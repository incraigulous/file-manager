/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 32);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue__);\n/**\n * GROUPS EVENT BUS\n * ////////////////\n *\n * Acts as an event bus to allow group components to communicate with each other using:\n *\n * bus.$emit('key', data)\n * - and -\n * bus.$on('key', callback)\n */\n\n\n\n/* harmony default export */ exports[\"a\"] = new __WEBPACK_IMPORTED_MODULE_0_vue___default.a();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9idXMuanM/NGVlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdST1VQUyBFVkVOVCBCVVNcbiAqIC8vLy8vLy8vLy8vLy8vLy9cbiAqXG4gKiBBY3RzIGFzIGFuIGV2ZW50IGJ1cyB0byBhbGxvdyBncm91cCBjb21wb25lbnRzIHRvIGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlciB1c2luZzpcbiAqXG4gKiBidXMuJGVtaXQoJ2tleScsIGRhdGEpXG4gKiAtIGFuZCAtXG4gKiBidXMuJG9uKCdrZXknLCBjYWxsYmFjaylcbiAqL1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcblxuZXhwb3J0IGRlZmF1bHQgbmV3IFZ1ZSgpXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGJ1cy5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports) {

eval("module.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanM/ZDRmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHJhd1NjcmlwdEV4cG9ydHMsXG4gIGNvbXBpbGVkVGVtcGxhdGUsXG4gIHNjb3BlSWQsXG4gIGNzc01vZHVsZXNcbikge1xuICB2YXIgZXNNb2R1bGVcbiAgdmFyIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyB8fCB7fVxuXG4gIC8vIEVTNiBtb2R1bGVzIGludGVyb3BcbiAgdmFyIHR5cGUgPSB0eXBlb2YgcmF3U2NyaXB0RXhwb3J0cy5kZWZhdWx0XG4gIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXNNb2R1bGUgPSByYXdTY3JpcHRFeHBvcnRzXG4gICAgc2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICB9XG5cbiAgLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcFxuICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nXG4gICAgPyBzY3JpcHRFeHBvcnRzLm9wdGlvbnNcbiAgICA6IHNjcmlwdEV4cG9ydHNcblxuICAvLyByZW5kZXIgZnVuY3Rpb25zXG4gIGlmIChjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBjb21waWxlZFRlbXBsYXRlLnJlbmRlclxuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWRUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9IHNjb3BlSWRcbiAgfVxuXG4gIC8vIGluamVjdCBjc3NNb2R1bGVzXG4gIGlmIChjc3NNb2R1bGVzKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gb3B0aW9ucy5jb21wdXRlZCB8fCAob3B0aW9ucy5jb21wdXRlZCA9IHt9KVxuICAgIE9iamVjdC5rZXlzKGNzc01vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG1vZHVsZSA9IGNzc01vZHVsZXNba2V5XVxuICAgICAgY29tcHV0ZWRba2V5XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZHVsZSB9XG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, global) {/*!\n * Vue.js v2.1.10\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n'use strict';\n\n/*  */\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction _toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove$1 (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind$1 (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\nfunction isPlainObject (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    return JSON.stringify(a) === JSON.stringify(b)\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * List of asset types that a component can own.\n   */\n  _assetTypes: [\n    'component',\n    'directive',\n    'filter'\n  ],\n\n  /**\n   * List of lifecycle hooks.\n   */\n  _lifecycleHooks: [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated'\n  ],\n\n  /**\n   * Max circular updates allowed in a scheduler flush cycle.\n   */\n  _maxUpdateCount: 100\n};\n\n/*  */\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  } else {\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) { return }\n        obj = obj[segments[i]];\n      }\n      return obj\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return /native code/.test(Ctor.toString())\n}\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) { cb.call(ctx); }\n      if (_resolve) { _resolve(ctx); }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\nvar warn = noop;\nvar formatComponentName;\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm) {\n    if (vm.$root === vm) {\n      return 'root instance'\n    }\n    var name = vm._isVue\n      ? vm.$options.name || vm.$options._componentTag\n      : vm.name;\n    return (\n      (name ? (\"component <\" + name + \">\") : \"anonymous component\") +\n      (vm._isVue && vm.$options.__file ? (\" at \" + (vm.$options.__file)) : '')\n    )\n  };\n\n  var formatLocation = function (str) {\n    if (str === 'anonymous component') {\n      str += \" - use the \\\"name\\\" option for better debugging messages.\";\n    }\n    return (\"\\n(found in \" + str + \")\")\n  };\n}\n\n/*  */\n\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid$1++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove$1(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stablize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set$1 (obj, key, val) {\n  if (Array.isArray(obj)) {\n    obj.length = Math.max(obj.length, key);\n    obj.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(obj, key)) {\n    obj[key] = val;\n    return\n  }\n  var ob = obj.__ob__;\n  if (obj._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return\n  }\n  if (!ob) {\n    obj[key] = val;\n    return\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (obj, key) {\n  var ob = obj.__ob__;\n  if (obj._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(obj, key)) {\n    return\n  }\n  delete obj[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set$1(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and param attributes are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nconfig._lifecycleHooks.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return parentVal }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return parentVal }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = typeof extendsFrom === 'function'\n      ? mergeOptions(parent, extendsFrom.options, vm)\n      : mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      var mixin = child.mixins[i];\n      if (mixin.prototype instanceof Vue$3) {\n        mixin = mixin.options;\n      }\n      parent = mergeOptions(parent, mixin, vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (isObject(def)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm[key] !== undefined) {\n    return vm[key]\n  }\n  // call factory function for non-Function types\n  return typeof def === 'function' && prop.type !== Function\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\n/**\n * Assert the type of a value\n */\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (expectedType === 'String') {\n    valid = typeof value === (expectedType = 'string');\n  } else if (expectedType === 'Number') {\n    valid = typeof value === (expectedType = 'number');\n  } else if (expectedType === 'Boolean') {\n    valid = typeof value === (expectedType = 'boolean');\n  } else if (expectedType === 'Function') {\n    valid = typeof value === (expectedType = 'function');\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match && match[1]\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n\n\nvar util = Object.freeze({\n\tdefineReactive: defineReactive$$1,\n\t_toString: _toString,\n\ttoNumber: toNumber,\n\tmakeMap: makeMap,\n\tisBuiltInTag: isBuiltInTag,\n\tremove: remove$1,\n\thasOwn: hasOwn,\n\tisPrimitive: isPrimitive,\n\tcached: cached,\n\tcamelize: camelize,\n\tcapitalize: capitalize,\n\thyphenate: hyphenate,\n\tbind: bind$1,\n\ttoArray: toArray,\n\textend: extend,\n\tisObject: isObject,\n\tisPlainObject: isPlainObject,\n\ttoObject: toObject,\n\tnoop: noop,\n\tno: no,\n\tidentity: identity,\n\tgenStaticKeys: genStaticKeys,\n\tlooseEqual: looseEqual,\n\tlooseIndexOf: looseIndexOf,\n\tisReserved: isReserved,\n\tdef: def,\n\tparsePath: parsePath,\n\thasProto: hasProto,\n\tinBrowser: inBrowser,\n\tUA: UA,\n\tisIE: isIE,\n\tisIE9: isIE9,\n\tisEdge: isEdge,\n\tisAndroid: isAndroid,\n\tisIOS: isIOS,\n\tisServerRendering: isServerRendering,\n\tdevtools: devtools,\n\tnextTick: nextTick,\n\tget _Set () { return _Set; },\n\tmergeOptions: mergeOptions,\n\tresolveAsset: resolveAsset,\n\tget warn () { return warn; },\n\tget formatComponentName () { return formatComponentName; },\n\tvalidateProp: validateProp\n});\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var res = new Array(vnodes.length);\n  for (var i = 0; i < vnodes.length; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };\nvar hooksToMerge = Object.keys(hooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (!Ctor) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (!Ctor.cid) {\n    if (Ctor.resolved) {\n      Ctor = Ctor.resolved;\n    } else {\n      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {\n        // it's ok to queue this on every render because\n        // $forceUpdate is buffered by the scheduler.\n        context.$forceUpdate();\n      });\n      if (!Ctor) {\n        // return nothing if this is indeed an async component\n        // wait for the callback to trigger parent update.\n        return\n      }\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // extract props\n  var propsData = extractProps(data, Ctor);\n\n  // functional component\n  if (Ctor.options.functional) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (Ctor.options.abstract) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (propOptions) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData);\n    }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    props: props,\n    data: data,\n    parent: context,\n    children: children,\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (inlineTemplate) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction init (\n  vnode,\n  hydrating,\n  parentElm,\n  refElm\n) {\n  if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n    var child = vnode.componentInstance = createComponentInstanceForVnode(\n      vnode,\n      activeInstance,\n      parentElm,\n      refElm\n    );\n    child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n  } else if (vnode.data.keepAlive) {\n    // kept-alive components, treat as a patch\n    var mountedNode = vnode; // work around flow\n    prepatch(mountedNode, mountedNode);\n  }\n}\n\nfunction prepatch (\n  oldVnode,\n  vnode\n) {\n  var options = vnode.componentOptions;\n  var child = vnode.componentInstance = oldVnode.componentInstance;\n  child._updateFromParent(\n    options.propsData, // updated props\n    options.listeners, // updated listeners\n    vnode, // new parent vnode\n    options.children // new children\n  );\n}\n\nfunction insert (vnode) {\n  if (!vnode.componentInstance._isMounted) {\n    vnode.componentInstance._isMounted = true;\n    callHook(vnode.componentInstance, 'mounted');\n  }\n  if (vnode.data.keepAlive) {\n    vnode.componentInstance._inactive = false;\n    callHook(vnode.componentInstance, 'activated');\n  }\n}\n\nfunction destroy$1 (vnode) {\n  if (!vnode.componentInstance._isDestroyed) {\n    if (!vnode.data.keepAlive) {\n      vnode.componentInstance.$destroy();\n    } else {\n      vnode.componentInstance._inactive = true;\n      callHook(vnode.componentInstance, 'deactivated');\n    }\n  }\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  cb\n) {\n  if (factory.requested) {\n    // pool callbacks\n    factory.pendingCallbacks.push(cb);\n  } else {\n    factory.requested = true;\n    var cbs = factory.pendingCallbacks = [cb];\n    var sync = true;\n\n    var resolve = function (res) {\n      if (isObject(res)) {\n        res = baseCtor.extend(res);\n      }\n      // cache resolved\n      factory.resolved = res;\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i](res);\n        }\n      }\n    };\n\n    var reject = function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n    };\n\n    var res = factory(resolve, reject);\n\n    // handle promise\n    if (res && typeof res.then === 'function' && !factory.resolved) {\n      res.then(resolve, reject);\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.resolved\n  }\n}\n\nfunction extractProps (data, Ctor) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (!propOptions) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  var domProps = data.domProps;\n  if (attrs || props || domProps) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey) ||\n      checkProp(res, domProps, key, altKey);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (hash) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = hooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook, key) {\n  key = key + hookKey;\n  var injectedHash = def.__injected || (def.__injected = {});\n  if (!injectedHash[key]) {\n    injectedHash[key] = true;\n    var oldHook = def[hookKey];\n    if (oldHook) {\n      def[hookKey] = function () {\n        oldHook.apply(this, arguments);\n        hook.apply(this, arguments);\n      };\n    } else {\n      def[hookKey] = hook;\n    }\n  }\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var once = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once,\n    capture: capture\n  }\n});\n\nfunction createEventHandle (fn) {\n  var handle = {\n    fn: fn,\n    invoker: function () {\n      var arguments$1 = arguments;\n\n      var fn = handle.fn;\n      if (Array.isArray(fn)) {\n        for (var i = 0; i < fn.length; i++) {\n          fn[i].apply(null, arguments$1);\n        }\n      } else {\n        fn.apply(null, arguments);\n      }\n    }\n  };\n  return handle\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (!cur) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (!old) {\n      if (!cur.invoker) {\n        cur = on[name] = createEventHandle(cur);\n      }\n      add(event.name, cur.invoker, event.once, event.capture);\n    } else if (cur !== old) {\n      old.fn = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (!on[name]) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name].invoker, event.capture);\n    }\n  }\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// nomralization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constrcuts that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (c == null || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (last && last.text) {\n        last.text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (c.text && last && last.text) {\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (c.tag && c.key == null && nestedIndex != null) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (data && data.__ob__) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n      typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (vnode) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (vnode.children) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (child.tag && !child.ns) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm.$vnode = null; // the placeholder node in parent tree\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$options._parentVnode;\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = {};\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    if (_parentVnode && _parentVnode.data.scopedSlots) {\n      vm.$scopedSlots = _parentVnode.data.scopedSlots;\n    }\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      /* istanbul ignore else */\n      if (config.errorHandler) {\n        config.errorHandler.call(null, e, vm);\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn((\"Error when rendering \" + (formatComponentName(vm)) + \":\"));\n        }\n        throw e\n      }\n      // return previous vnode to prevent render error causing blank component\n      vnode = vm._vnode;\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // toString for mustaches\n  Vue.prototype._s = _toString;\n  // convert text to vnode\n  Vue.prototype._v = createTextVNode;\n  // number conversion\n  Vue.prototype._n = toNumber;\n  // empty vnode\n  Vue.prototype._e = createEmptyVNode;\n  // loose equal\n  Vue.prototype._q = looseEqual;\n  // loose indexOf\n  Vue.prototype._i = looseIndexOf;\n\n  // render static tree by index\n  Vue.prototype._m = function renderStatic (\n    index,\n    isInFor\n  ) {\n    var tree = this._staticTrees[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree by doing a shallow clone.\n    if (tree && !isInFor) {\n      return Array.isArray(tree)\n        ? cloneVNodes(tree)\n        : cloneVNode(tree)\n    }\n    // otherwise, render a fresh tree.\n    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n    markStatic(tree, (\"__static__\" + index), false);\n    return tree\n  };\n\n  // mark node as static (v-once)\n  Vue.prototype._o = function markOnce (\n    tree,\n    index,\n    key\n  ) {\n    markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n    return tree\n  };\n\n  function markStatic (tree, key, isOnce) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode (node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n\n  // filter resolution helper\n  Vue.prototype._f = function resolveFilter (id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity\n  };\n\n  // render v-for\n  Vue.prototype._l = function renderList (\n    val,\n    render\n  ) {\n    var ret, i, l, keys, key;\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n    return ret\n  };\n\n  // renderSlot\n  Vue.prototype._t = function (\n    name,\n    fallback,\n    props,\n    bindObject\n  ) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    if (scopedSlotFn) { // scoped slot\n      props = props || {};\n      if (bindObject) {\n        extend(props, bindObject);\n      }\n      return scopedSlotFn(props) || fallback\n    } else {\n      var slotNodes = this.$slots[name];\n      // warn duplicate slot usage\n      if (slotNodes && process.env.NODE_ENV !== 'production') {\n        slotNodes._rendered && warn(\n          \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n          \"- this will likely cause render errors.\",\n          this\n        );\n        slotNodes._rendered = true;\n      }\n      return slotNodes || fallback\n    }\n  };\n\n  // apply v-bind object\n  Vue.prototype._b = function bindProps (\n    data,\n    tag,\n    value,\n    asProp\n  ) {\n    if (value) {\n      if (!isObject(value)) {\n        process.env.NODE_ENV !== 'production' && warn(\n          'v-bind without argument expects an Object or Array value',\n          this\n        );\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n        for (var key in value) {\n          if (key === 'class' || key === 'style') {\n            data[key] = value[key];\n          } else {\n            var type = data.attrs && data.attrs.type;\n            var hash = asProp || config.mustUseProp(tag, type, key)\n              ? data.domProps || (data.domProps = {})\n              : data.attrs || (data.attrs = {});\n            hash[key] = value[key];\n          }\n        }\n      }\n    }\n    return data\n  };\n\n  // check v-on keyCodes\n  Vue.prototype._k = function checkKeyCodes (\n    eventKeyCode,\n    key,\n    builtInAlias\n  ) {\n    var keyCodes = config.keyCodes[key] || builtInAlias;\n    if (Array.isArray(keyCodes)) {\n      return keyCodes.indexOf(eventKeyCode) === -1\n    } else {\n      return keyCodes !== eventKeyCode\n    }\n  };\n}\n\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  var name, child;\n  for (var i = 0, l = children.length; i < l; i++) {\n    child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n        child.data && (name = child.data.slot)) {\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore single whitespace\n  if (defaultSlot.length && !(\n    defaultSlot.length === 1 &&\n    (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)\n  )) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add$1 (event, fn, once) {\n  if (once) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$2 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add$1, remove$2, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);\n    // optimize hook:event cost by using a boolean flag marked at registration\n    // instead of a hash lookup\n    if (hookRE.test(event)) {\n      vm._hasHookEvent = true;\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._mount = function (\n    el,\n    hydrating\n  ) {\n    var vm = this;\n    vm.$el = el;\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      if (process.env.NODE_ENV !== 'production') {\n        /* istanbul ignore if */\n        if (vm.$options.template && vm.$options.template.charAt(0) !== '#') {\n          warn(\n            'You are using the runtime-only build of Vue where the template ' +\n            'option is not available. Either pre-compile the templates into ' +\n            'render functions, or use the compiler-included build.',\n            vm\n          );\n        } else {\n          warn(\n            'Failed to mount component: template or render function not defined.',\n            vm\n          );\n        }\n      }\n    }\n    callHook(vm, 'beforeMount');\n    vm._watcher = new Watcher(vm, function updateComponent () {\n      vm._update(vm._render(), hydrating);\n    }, noop);\n    hydrating = false;\n    // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n    return vm\n  };\n\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype._updateFromParent = function (\n    propsData,\n    listeners,\n    parentVnode,\n    renderChildren\n  ) {\n    var vm = this;\n    var hasChildren = !!(vm.$options._renderChildren || renderChildren);\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n    if (vm._vnode) { // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n    vm.$options._renderChildren = renderChildren;\n    // update props\n    if (propsData && vm.$options.props) {\n      observerState.shouldConvert = false;\n      if (process.env.NODE_ENV !== 'production') {\n        observerState.isSettingProps = true;\n      }\n      var propKeys = vm.$options._propKeys || [];\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        vm[key] = validateProp(key, vm.$options.props, propsData, vm);\n      }\n      observerState.shouldConvert = true;\n      if (process.env.NODE_ENV !== 'production') {\n        observerState.isSettingProps = false;\n      }\n      vm.$options.propsData = propsData;\n    }\n    // update listeners\n    if (listeners) {\n      var oldListeners = vm.$options._parentListeners;\n      vm.$options._parentListeners = listeners;\n      updateComponentListeners(vm, listeners, oldListeners);\n    }\n    // resolve slots + force update if has children\n    if (hasChildren) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove$1(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n  };\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      handlers[i].call(vm);\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar queue = [];\nvar has$1 = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  queue.length = 0;\n  has$1 = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id, vm;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has$1[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has$1[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > config._maxUpdateCount) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // call updated hooks\n  index = queue.length;\n  while (index--) {\n    watcher = queue[index];\n    vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n\n  resetSchedulerState();\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has$1[id] == null) {\n    has$1[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i >= 0 && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(Math.max(i, index) + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value = this.getter.call(this.vm, this.vm);\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          /* istanbul ignore else */\n          if (config.errorHandler) {\n            config.errorHandler.call(null, e, this.vm);\n          } else {\n            process.env.NODE_ENV !== 'production' && warn(\n              (\"Error in watcher \\\"\" + (this.expression) + \"\\\"\"),\n              this.vm\n            );\n            throw e\n          }\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove$1(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\n\nvar isReservedProp = { key: 1, ref: 1, slot: 1 };\n\nfunction initProps (vm, props) {\n  var propsData = vm.$options.propsData || {};\n  var keys = vm.$options._propKeys = Object.keys(props);\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( i ) {\n    var key = keys[i];\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      if (isReservedProp[key]) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(vm, key, validateProp(key, props, propsData, vm));\n    }\n  };\n\n  for (var i = 0; i < keys.length; i++) loop( i );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? data.call(vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else {\n      proxy(vm, keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nvar computedSharedDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction initComputed (vm, computed) {\n  for (var key in computed) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && key in vm) {\n      warn(\n        \"existing instance property \\\"\" + key + \"\\\" will be \" +\n        \"overwritten by a computed property with the same name.\",\n        vm\n      );\n    }\n    var userDef = computed[key];\n    if (typeof userDef === 'function') {\n      computedSharedDefinition.get = makeComputedGetter(userDef, vm);\n      computedSharedDefinition.set = noop;\n    } else {\n      computedSharedDefinition.get = userDef.get\n        ? userDef.cache !== false\n          ? makeComputedGetter(userDef.get, vm)\n          : bind$1(userDef.get, vm)\n        : noop;\n      computedSharedDefinition.set = userDef.set\n        ? bind$1(userDef.set, vm)\n        : noop;\n    }\n    Object.defineProperty(vm, key, computedSharedDefinition);\n  }\n}\n\nfunction makeComputedGetter (getter, owner) {\n  var watcher = new Watcher(owner, getter, noop, {\n    lazy: true\n  });\n  return function computedGetter () {\n    if (watcher.dirty) {\n      watcher.evaluate();\n    }\n    if (Dep.target) {\n      watcher.depend();\n    }\n    return watcher.value\n  }\n}\n\nfunction initMethods (vm, methods) {\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);\n    if (process.env.NODE_ENV !== 'production' && methods[key] == null) {\n      warn(\n        \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n        \"Did you reference the function correctly?\",\n        vm\n      );\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () {\n    return this._data\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n\n  Vue.prototype.$set = set$1;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\nfunction proxy (vm, key) {\n  if (!isReserved(key)) {\n    Object.defineProperty(vm, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter () {\n        return vm._data[key]\n      },\n      set: function proxySetter (val) {\n        vm._data[key] = val;\n      }\n    });\n  }\n}\n\n/*  */\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid++;\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initState(vm);\n    callHook(vm, 'created');\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = Ctor.super.options;\n    var cachedSuperOptions = Ctor.superOptions;\n    var extendOptions = Ctor.extendOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed\n      Ctor.superOptions = superOptions;\n      extendOptions.render = options.render;\n      extendOptions.staticRenderFns = options.staticRenderFns;\n      extendOptions._scopeId = options._scopeId;\n      options = Ctor.options = mergeOptions(superOptions, extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction Vue$3 (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue$3)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    config._assetTypes.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  config._assetTypes.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else {\n    return pattern.test(name)\n  }\n}\n\nfunction pruneCache (cache, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cachedNode);\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    if (!vnode.componentInstance._inactive) {\n      callHook(vnode.componentInstance, 'deactivated');\n    }\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n  Vue.util = util;\n  Vue.set = set$1;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  config._assetTypes.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nVue$3.version = '2.1.10';\n\n/*  */\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (childNode.componentInstance) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: child.class\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (staticClass || dynamicClass) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  var res = '';\n  if (!value) {\n    return res\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (value[i]) {\n        if ((stringified = stringifyClass(value[i]))) {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,' +\n  'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selector = el;\n    el = document.querySelector(el);\n    if (!el) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + selector\n      );\n      return document.createElement('div')\n    }\n  }\n  return el\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove$1(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks$1 = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction isUndef (s) {\n  return s == null\n}\n\nfunction isDef (s) {\n  return s != null\n}\n\nfunction sameVnode (vnode1, vnode2) {\n  return (\n    vnode1.key === vnode2.key &&\n    vnode1.tag === vnode2.tag &&\n    vnode1.isComment === vnode2.isComment &&\n    !vnode1.data === !vnode2.data\n  )\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks$1.length; ++i) {\n    cbs[hooks$1[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (parent) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        inPre--;\n      }\n    } else if (vnode.isComment) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isReactivated) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (vnode.data.pendingInsert) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref) {\n    if (parent) {\n      if (ref) {\n        nodeOps.insertBefore(parent, elm, ref);\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (i.create) { i.create(emptyNode, vnode); }\n      if (i.insert) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n    if (isDef(i = activeInstance) &&\n        i !== vnode.context &&\n        isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (rm || isDef(vnode.data)) {\n      var listeners = cbs.remove.length + 1;\n      if (!rm) {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      } else {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (vnode.isStatic &&\n        oldVnode.isStatic &&\n        vnode.key === oldVnode.key &&\n        (vnode.isCloned || vnode.isOnce)) {\n      vnode.elm = oldVnode.elm;\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    var hasData = isDef(data);\n    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (hasData && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (hasData) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (initial && vnode.parent) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !bailed) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (vnode.tag) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (!vnode) {\n      if (oldVnode) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (!oldVnode) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n            oldVnode.removeAttribute('server-rendered');\n            hydrating = true;\n          }\n          if (hydrating) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (vnode.parent) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (parentElm$1 !== null) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    }, 'dir-postpatch');\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (attrs.__ob__) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (attrs[key] == null) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (!data.staticClass && !data.class &&\n      (!oldData || (!oldData.staticClass && !oldData.class))) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (transitionClass) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar target$1;\n\nfunction add$2 (\n  event,\n  handler,\n  once,\n  capture\n) {\n  if (once) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      remove$3(event, handler, capture, _target);\n      arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n    };\n  }\n  target$1.addEventListener(event, handler, capture);\n}\n\nfunction remove$3 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (!oldVnode.data.on && !vnode.data.on) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  updateListeners(on, oldOn, add$2, remove$3, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (props.__ob__) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (props[key] == null) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = cur == null ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(vnode, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n  return document.activeElement !== elm && elm.value !== checkVal\n}\n\nfunction isInputChanged (vnode, newVal) {\n  var value = vnode.elm.value;\n  var modifiers = vnode.elm._vModifiers; // injected by v-model runtime\n  if ((modifiers && modifiers.number) || vnode.elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (modifiers && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    el.style[normalize(name)] = val;\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (!data.staticStyle && !data.style &&\n      !oldData.staticStyle && !oldData.style) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldVnode.data.staticStyle;\n  var oldStyleBinding = oldVnode.data.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  vnode.data.style = style.__ob__ ? extend({}, style) : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (newStyle[name] == null) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !cls.trim()) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = ' ' + el.getAttribute('class') + ' ';\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !cls.trim()) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = ' ' + el.getAttribute('class') + ' ';\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove$1(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (el._leaveCb) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (el._enterCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear ? appearClass : enterClass;\n  var activeClass = isAppear ? appearActiveClass : enterActiveClass;\n  var toClass = isAppear ? appearToClass : enterToClass;\n  var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;\n  var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;\n  var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;\n  var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl =\n    enterHook &&\n    // enterHook may be a bound method which exposes\n    // the length of original fn as _length\n    (enterHook._length || enterHook.length) > 1;\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n          pendingNode.tag === vnode.tag &&\n          pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    }, 'transition-insert');\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        whenTransitionEnds(el, type, cb);\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (el._enterCb) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (el._leaveCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl =\n    leave &&\n    // leave hook may be a bound method which exposes\n    // the length of original fn as _length\n    (leave._length || leave.length) > 1;\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          whenTransitionEnds(el, type, cb);\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    leaveClass: (name + \"-leave\"),\n    appearClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    leaveToClass: (name + \"-leave-to\"),\n    appearToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveActiveClass: (name + \"-leave-active\"),\n    appearActiveClass: (name + \"-enter-active\")\n  }\n});\n\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn();\n    }\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (!vnode.data.show) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove (vnode, rm) {\n    /* istanbul ignore else */\n    if (!vnode.data.show) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\nvar modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_-]*)?$/;\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model = {\n  inserted: function inserted (el, binding, vnode) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!modelableTagRE.test(vnode.tag)) {\n        warn(\n          \"v-model is not supported on element type: <\" + (vnode.tag) + \">. \" +\n          'If you are working with contenteditable, it\\'s recommended to ' +\n          'wrap a library dedicated for that purpose inside a custom component.',\n          vnode.context\n        );\n      }\n    }\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1].fn;\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  return /\\d-keep-alive$/.test(rawChild.tag)\n    ? h('keep-alive')\n    : null\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n        mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    var key = child.key = child.key == null\n      ? id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        }, key);\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave, key);\n        mergeVNodeHook(data, 'enterCancelled', performLeave, key);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n          delayedLeave = leave;\n        }, key);\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final disired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts\n            ? (opts.Ctor.options.name || opts.tag)\n            : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var f = document.body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      addTransitionClass(el, moveClass);\n      var info = getTransitionInfo(el);\n      removeTransitionClass(el, moveClass);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.isUnknownElement = isUnknownElement;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.mustUseProp = mustUseProp;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch$1 : noop;\n\n// wrap mount\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return this._mount(el, hydrating)\n};\n\nif (process.env.NODE_ENV !== 'production' &&\n    inBrowser && typeof console !== 'undefined') {\n  console[console.info ? 'info' : 'log'](\n    \"You are running Vue in development mode.\\n\" +\n    \"Make sure to turn on production mode when deploying for production.\\n\" +\n    \"See more tips at https://vuejs.org/guide/deployment.html\"\n  );\n}\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (\n      process.env.NODE_ENV !== 'production' &&\n      inBrowser && !isEdge && /Chrome\\/\\d+/.test(window.navigator.userAgent)\n    ) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar decoder;\n\nfunction decode (html) {\n  decoder = decoder || document.createElement('div');\n  decoder.innerHTML = html;\n  return decoder.textContent\n}\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr',\n  true\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source',\n  true\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track',\n  true\n);\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isScriptOrStyle = makeMap('script,style', true);\nvar reCache = {};\n\nvar ltRE = /&lt;/g;\nvar gtRE = /&gt;/g;\nvar nlRE = /&#10;/g;\nvar ampRE = /&amp;/g;\nvar quoteRE = /&quot;/g;\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  if (shouldDecodeNewlines) {\n    value = value.replace(nlRE, '\\n');\n  }\n  return value\n    .replace(ltRE, '<')\n    .replace(gtRE, '>')\n    .replace(ampRE, '&')\n    .replace(quoteRE, '\"')\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a script or style element\n    if (!lastTag || !isScriptOrStyle(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          continue\n        }\n      }\n\n      var text = (void 0), rest$1 = (void 0), next = (void 0);\n      if (textEnd > 0) {\n        rest$1 = html.slice(textEnd);\n        while (\n          !endTag.test(rest$1) &&\n          !startTagOpen.test(rest$1) &&\n          !comment.test(rest$1) &&\n          !conditionalComment.test(rest$1)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest$1.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest$1 = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var endTagLength = 0;\n      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest.length;\n      html = rest;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last && options.chars) {\n      options.chars(html);\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n      unarySlash = '';\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !/[\\w$]/.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue parser]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important\n) {\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\nvar bindRE = /^:|^v-bind:/;\nvar onRE = /^@|^v-on:/;\nvar argRE = /:(.*)$/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(decode);\n\n// configurable state\nvar warn$1;\nvar platformGetTagNamespace;\nvar platformMustUseProp;\nvar platformIsPreTag;\nvar preTransforms;\nvar transforms;\nvar postTransforms;\nvar delimiters;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$1 = options.warn || baseWarn;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformIsPreTag = options.isPreTag || no;\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n  parseHTML(template, {\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$1(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (process.env.NODE_ENV !== 'production' && !warned) {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warned = true;\n            warn$1(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes:\\n' + template\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warned = true;\n            warn$1(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements:\\n' + template\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (process.env.NODE_ENV !== 'production' && !warned) {\n          warned = true;\n          warn$1(\n            \"Component template should contain exactly one root element:\" +\n            \"\\n\\n\" + template + \"\\n\\n\" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || 'default';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ') {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      // check pre state\n      if (element.pre) {\n        inVPre = false;\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      }\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production' && !warned && text === template) {\n          warned = true;\n          warn$1(\n            'Component template requires a root element, rather than just text:\\n\\n' + template\n          );\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n          currentParent.tag === 'textarea' &&\n          currentParent.attrsMap.placeholder === text) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || children[children.length - 1].text !== ' ') {\n          currentParent.children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {\n      warn$1(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      process.env.NODE_ENV !== 'production' && warn$1(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$1(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once = getAndRemoveAttr(el, 'v-once');\n  if (once != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$1(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, arg, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n        }\n        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        if (argMatch && (arg = argMatch[1])) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$1(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE) {\n      warn$1('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n    }\n  }\n}\n\nfunction walkThroughConditionsBlocks (conditionBlocks, isInFor) {\n  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n    markStaticRoots(conditionBlocks[i].block, isInFor);\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: 'if($event.target !== $event.currentTarget)return;',\n  ctrl: 'if(!$event.ctrlKey)return;',\n  shift: 'if(!$event.shiftKey)return;',\n  alt: 'if(!$event.altKey)return;',\n  meta: 'if(!$event.metaKey)return;'\n};\n\nfunction genHandlers (events, native) {\n  var res = native ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, events[name])) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  } else if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  } else if (!handler.modifiers) {\n    return fnExpRE.test(handler.value) || simplePathRE.test(handler.value)\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\")\n  } else {\n    var code = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        code += modifierCode[key];\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code = genKeyFilter(keys) + code;\n    }\n    var handlerCode = simplePathRE.test(handler.value)\n      ? handler.value + '($event)'\n      : handler.value;\n    return 'function($event){' + code + handlerCode + '}'\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(\" + (keys.map(genFilterCode).join('&&')) + \")return;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction bind$2 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  bind: bind$2,\n  cloak: noop\n};\n\n/*  */\n\n// configurable state\nvar warn$2;\nvar transforms$1;\nvar dataGenFns;\nvar platformDirectives$1;\nvar isPlatformReservedTag$1;\nvar staticRenderFns;\nvar onceCount;\nvar currentOptions;\n\nfunction generate (\n  ast,\n  options\n) {\n  // save previous staticRenderFns so generate calls can be nested\n  var prevStaticRenderFns = staticRenderFns;\n  var currentStaticRenderFns = staticRenderFns = [];\n  var prevOnceCount = onceCount;\n  onceCount = 0;\n  currentOptions = options;\n  warn$2 = options.warn || baseWarn;\n  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  platformDirectives$1 = options.directives || {};\n  isPlatformReservedTag$1 = options.isReservedTag || no;\n  var code = ast ? genElement(ast) : '_c(\"div\")';\n  staticRenderFns = prevStaticRenderFns;\n  onceCount = prevOnceCount;\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: currentStaticRenderFns\n  }\n}\n\nfunction genElement (el) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el);\n    } else {\n      var data = el.plain ? undefined : genData(el);\n\n      var children = el.inlineTemplate ? null : genChildren(el, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < transforms$1.length; i++) {\n      code = transforms$1[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el) {\n  el.staticProcessed = true;\n  staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n  return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && warn$2(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el)\n    }\n    return (\"_o(\" + (genElement(el)) + \",\" + (onceCount++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el)\n  }\n}\n\nfunction genIf (el) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice())\n}\n\nfunction genIfConditions (conditions) {\n  if (!conditions.length) {\n    return '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return el.once ? genOnce(el) : genElement(el)\n  }\n}\n\nfunction genFor (el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genElement(el)) +\n    '})'\n}\n\nfunction genData (el) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < dataGenFns.length; i++) {\n    data += dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots)) + \",\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  return data\n}\n\nfunction genDirectives (el) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, warn$2);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (\n    el.children.length > 1 || ast.type !== 1\n  )) {\n    warn$2('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, currentOptions);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (slots) {\n  return (\"scopedSlots:{\" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + \"}\")\n}\n\nfunction genScopedSlot (key, el) {\n  return key + \":function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el) || 'void 0'\n      : genElement(el)) + \"}\"\n}\n\nfunction genChildren (el, checkSkip) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n        el$1.for &&\n        el$1.tag !== 'template' &&\n        el$1.tag !== 'slot') {\n      return genElement(el$1)\n    }\n    var normalizationType = getNormalizationType(children);\n    return (\"[\" + (children.map(genNode).join(',')) + \"]\" + (checkSkip\n        ? normalizationType ? (\",\" + normalizationType) : ''\n        : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (children) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction maybeComponent (el) {\n  return !isPlatformReservedTag$1(el.tag)\n}\n\nfunction genNode (node) {\n  if (node.type === 1) {\n    return genElement(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genSlot (el) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (componentName, el) {\n  var children = el.inlineTemplate ? null : genChildren(el, true);\n  return (\"_c(\" + componentName + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n/**\n * Compile a template.\n */\nfunction compile$1 (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n}\n\n/*  */\n\n// operators like typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"- invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"- avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + text\n      );\n    } else {\n      errors.push((\"- invalid expression: \" + text));\n    }\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData$1\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$2 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$2\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nvar warn$3;\n\nfunction model$1 (\n  el,\n  dir,\n  _warn\n) {\n  warn$3 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n  if (process.env.NODE_ENV !== 'production') {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$3(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n  }\n  if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else {\n    genDefaultModel(el, value, modifiers);\n  }\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  if (process.env.NODE_ENV !== 'production' &&\n    el.attrsMap.checked != null) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" checked>:\\n\" +\n      \"inline checked attributes will be ignored when using v-model. \" +\n      'Declare initial values in the component\\'s data option instead.'\n    );\n  }\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, 'click',\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + value + \"=$$c}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  if (process.env.NODE_ENV !== 'production' &&\n    el.attrsMap.checked != null) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" checked>:\\n\" +\n      \"inline checked attributes will be ignored when using v-model. \" +\n      'Declare initial values in the component\\'s data option instead.'\n    );\n  }\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, 'click', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (el.tag === 'input' && el.attrsMap.value) {\n      warn$3(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" value=\\\"\" + (el.attrsMap.value) + \"\\\">:\\n\" +\n        'inline value attributes will be ignored when using v-model. ' +\n        'Declare initial values in the component\\'s data option instead.'\n      );\n    }\n    if (el.tag === 'textarea' && el.children.length) {\n      warn$3(\n        \"<textarea v-model=\\\"\" + value + \"\\\">:\\n\" +\n        'inline content inside <textarea> will be ignored when using v-model. ' +\n        'Declare initial values in the component\\'s data option instead.'\n      );\n    }\n  }\n\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var event = lazy || (isIE && type === 'range') ? 'change' : 'input';\n  var needCompositionGuard = !lazy && type !== 'range';\n  var isNative = el.tag === 'input' || el.tag === 'textarea';\n\n  var valueExpression = isNative\n    ? (\"$event.target.value\" + (trim ? '.trim()' : ''))\n    : trim ? \"(typeof $event === 'string' ? $event.trim() : $event)\" : \"$event\";\n  valueExpression = number || type === 'number'\n    ? (\"_n(\" + valueExpression + \")\")\n    : valueExpression;\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (isNative && needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  // inputs with type=\"file\" are read only and setting the input's\n  // value will throw an error.\n  if (process.env.NODE_ENV !== 'production' &&\n      type === 'file') {\n    warn$3(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n      \"File inputs are read only. Use a v-on:change listener instead.\"\n    );\n  }\n\n  addProp(el, 'value', isNative ? (\"_s(\" + value + \")\") : (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number || type === 'number') {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    el.children.some(checkOptionWarning);\n  }\n\n  var number = modifiers && modifiers.number;\n  var assignment = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\" +\n    (el.attrsMap.multiple == null ? '[0]' : '');\n\n  var code = genAssignmentCode(value, assignment);\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction checkOptionWarning (option) {\n  if (option.type === 1 &&\n    option.tag === 'option' &&\n    option.attrsMap.selected != null) {\n    warn$3(\n      \"<select v-model=\\\"\" + (option.parent.attrsMap['v-model']) + \"\\\">:\\n\" +\n      'inline selected attributes on <option> will be ignored when using v-model. ' +\n      'Declare initial values in the component\\'s data option instead.'\n    );\n    return true\n  }\n  return false\n}\n\nfunction genAssignmentCode (value, assignment) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return \"var $$exp = \" + (modelRs.exp) + \", $$idx = \" + (modelRs.idx) + \";\" +\n      \"if (!Array.isArray($$exp)){\" +\n        value + \"=\" + assignment + \"}\" +\n      \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\"\n  }\n}\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model$1,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar cache = Object.create(null);\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  staticKeys: genStaticKeys(modules$1),\n  directives: directives$1,\n  isReservedTag: isReservedTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  getTagNamespace: getTagNamespace,\n  isPreTag: isPreTag\n};\n\nfunction compile$$1 (\n  template,\n  options\n) {\n  options = options\n    ? extend(extend({}, baseOptions), options)\n    : baseOptions;\n  return compile$1(template, options)\n}\n\nfunction compileToFunctions (\n  template,\n  options,\n  vm\n) {\n  var _warn = (options && options.warn) || warn;\n  // detect possible CSP restriction\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production') {\n    try {\n      new Function('return 1');\n    } catch (e) {\n      if (e.toString().match(/unsafe-eval|CSP/)) {\n        _warn(\n          'It seems you are using the standalone build of Vue.js in an ' +\n          'environment with Content Security Policy that prohibits unsafe-eval. ' +\n          'The template compiler cannot work in this environment. Consider ' +\n          'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n          'templates into render functions.'\n        );\n      }\n    }\n  }\n  var key = options && options.delimiters\n    ? String(options.delimiters) + template\n    : template;\n  if (cache[key]) {\n    return cache[key]\n  }\n  var res = {};\n  var compiled = compile$$1(template, options);\n  res.render = makeFunction(compiled.render);\n  var l = compiled.staticRenderFns.length;\n  res.staticRenderFns = new Array(l);\n  for (var i = 0; i < l; i++) {\n    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]);\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    if (res.render === noop || res.staticRenderFns.some(function (fn) { return fn === noop; })) {\n      _warn(\n        \"failed to compile template:\\n\\n\" + template + \"\\n\\n\" +\n        detectErrors(compiled.ast).join('\\n') +\n        '\\n\\n',\n        vm\n      );\n    }\n  }\n  return (cache[key] = res)\n}\n\nfunction makeFunction (code) {\n  try {\n    return new Function(code)\n  } catch (e) {\n    return noop\n  }\n}\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      var ref = compileToFunctions(template, {\n        warn: warn,\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\nmodule.exports = Vue$3;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19), __webpack_require__(3)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vdnVlL2Rpc3QvdnVlLmNvbW1vbi5qcz9lODgxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLmpzIHYyLjEuMTBcbiAqIChjKSAyMDE0LTIwMTcgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiAgKi9cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gX3RvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUkMSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gLyhbXi1dKShbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAqL1xuZnVuY3Rpb24gYmluZCQxIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIE9CSkVDVF9TVFJJTkcgPSAnW29iamVjdCBPYmplY3RdJztcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSBPQkpFQ1RfU1RSSU5HXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpXG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qICAqL1xuXG52YXIgY29uZmlnID0ge1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGFzc2V0IHR5cGVzIHRoYXQgYSBjb21wb25lbnQgY2FuIG93bi5cbiAgICovXG4gIF9hc3NldFR5cGVzOiBbXG4gICAgJ2NvbXBvbmVudCcsXG4gICAgJ2RpcmVjdGl2ZScsXG4gICAgJ2ZpbHRlcidcbiAgXSxcblxuICAvKipcbiAgICogTGlzdCBvZiBsaWZlY3ljbGUgaG9va3MuXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IFtcbiAgICAnYmVmb3JlQ3JlYXRlJyxcbiAgICAnY3JlYXRlZCcsXG4gICAgJ2JlZm9yZU1vdW50JyxcbiAgICAnbW91bnRlZCcsXG4gICAgJ2JlZm9yZVVwZGF0ZScsXG4gICAgJ3VwZGF0ZWQnLFxuICAgICdiZWZvcmVEZXN0cm95JyxcbiAgICAnZGVzdHJveWVkJyxcbiAgICAnYWN0aXZhdGVkJyxcbiAgICAnZGVhY3RpdmF0ZWQnXG4gIF0sXG5cbiAgLyoqXG4gICAqIE1heCBjaXJjdWxhciB1cGRhdGVzIGFsbG93ZWQgaW4gYSBzY2hlZHVsZXIgZmx1c2ggY3ljbGUuXG4gICAqL1xuICBfbWF4VXBkYXRlQ291bnQ6IDEwMFxufTtcblxuLyogICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfSBlbHNlIHtcbiAgICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG4vKiBnbG9iYWxzIE11dGF0aW9uT2JzZXJ2ZXIgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMDtcbnZhciBpc0lPUyA9IFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSk7XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbnZhciBfaXNTZXJ2ZXI7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbi8qKlxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuXG4gKi9cbnZhciBuZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIHRpbWVyRnVuYztcblxuICBmdW5jdGlvbiBuZXh0VGlja0hhbmRsZXIgKCkge1xuICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3BpZXNbaV0oKTtcbiAgICB9XG4gIH1cblxuICAvLyB0aGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuICAvLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbiAgLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4gIC8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4gIC8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbiAgLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdmFyIGxvZ0Vycm9yID0gZnVuY3Rpb24gKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IH07XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgcC50aGVuKG5leHRUaWNrSGFuZGxlcikuY2F0Y2gobG9nRXJyb3IpO1xuICAgICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4gICkpIHtcbiAgICAvLyB1c2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAgIC8vIGUuZy4gUGhhbnRvbUpTIElFMTEsIGlPUzcsIEFuZHJvaWQgNC40XG4gICAgdmFyIGNvdW50ZXIgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG5leHRUaWNrSGFuZGxlcik7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGZhbGxiYWNrIHRvIHNldFRpbWVvdXRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFRpbWVvdXQobmV4dFRpY2tIYW5kbGVyLCAwKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHF1ZXVlTmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgICB2YXIgX3Jlc29sdmU7XG4gICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNiKSB7IGNiLmNhbGwoY3R4KTsgfVxuICAgICAgaWYgKF9yZXNvbHZlKSB7IF9yZXNvbHZlKGN0eCk7IH1cbiAgICB9KTtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgICAgdGltZXJGdW5jKCk7XG4gICAgfVxuICAgIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pKCk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxudmFyIHdhcm4gPSBub29wO1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIFwiIFwiICsgKFxuICAgICAgICB2bSA/IGZvcm1hdExvY2F0aW9uKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAncm9vdCBpbnN0YW5jZSdcbiAgICB9XG4gICAgdmFyIG5hbWUgPSB2bS5faXNWdWVcbiAgICAgID8gdm0uJG9wdGlvbnMubmFtZSB8fCB2bS4kb3B0aW9ucy5fY29tcG9uZW50VGFnXG4gICAgICA6IHZtLm5hbWU7XG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiY29tcG9uZW50IDxcIiArIG5hbWUgKyBcIj5cIikgOiBcImFub255bW91cyBjb21wb25lbnRcIikgK1xuICAgICAgKHZtLl9pc1Z1ZSAmJiB2bS4kb3B0aW9ucy5fX2ZpbGUgPyAoXCIgYXQgXCIgKyAodm0uJG9wdGlvbnMuX19maWxlKSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIGZvcm1hdExvY2F0aW9uID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmIChzdHIgPT09ICdhbm9ueW1vdXMgY29tcG9uZW50Jykge1xuICAgICAgc3RyICs9IFwiIC0gdXNlIHRoZSBcXFwibmFtZVxcXCIgb3B0aW9uIGZvciBiZXR0ZXIgZGVidWdnaW5nIG1lc3NhZ2VzLlwiO1xuICAgIH1cbiAgICByZXR1cm4gKFwiXFxuKGZvdW5kIGluIFwiICsgc3RyICsgXCIpXCIpXG4gIH07XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQkMSA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCQxKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUkMSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxuLy8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gdGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvbmx5IG9uZVxuLy8gd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQgYXQgYW55IHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0IChfdGFyZ2V0KSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7IHRhcmdldFN0YWNrLnB1c2goRGVwLnRhcmdldCk7IH1cbiAgRGVwLnRhcmdldCA9IF90YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFjay5wb3AoKTtcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dXG4uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgLy8gYXZvaWQgbGVha2luZyBhcmd1bWVudHM6XG4gICAgLy8gaHR0cDovL2pzcGVyZi5jb20vY2xvc3VyZS13aXRoLWFyZ3VtZW50c1xuICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzJDFbaV07XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgd2hlbiBhIHJlYWN0aXZlIHByb3BlcnR5IGlzIHNldCwgdGhlIG5ldyB2YWx1ZSBpc1xuICogYWxzbyBjb252ZXJ0ZWQgdG8gYmVjb21lIHJlYWN0aXZlLiBIb3dldmVyIHdoZW4gcGFzc2luZyBkb3duIHByb3BzLFxuICogd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBjb252ZXJzaW9uIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZVxuICogdW5kZXIgYSBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmUuIENvbnZlcnRpbmcgaXQgd291bGQgZGVmZWF0IHRoZSBvcHRpbWl6YXRpb24uXG4gKi9cbnZhciBvYnNlcnZlclN0YXRlID0ge1xuICBzaG91bGRDb252ZXJ0OiB0cnVlLFxuICBpc1NldHRpbmdQcm9wczogZmFsc2Vcbn07XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvXG4gICAgICA/IHByb3RvQXVnbWVudFxuICAgICAgOiBjb3B5QXVnbWVudDtcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUkJDEgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXJcbikge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cbiAgdmFyIGNoaWxkT2IgPSBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCQxIChvYmosIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBvYmoubGVuZ3RoID0gTWF0aC5tYXgob2JqLmxlbmd0aCwga2V5KTtcbiAgICBvYmouc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGhhc093bihvYmosIGtleSkpIHtcbiAgICBvYmpba2V5XSA9IHZhbDtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSBvYmouX19vYl9fO1xuICBpZiAob2JqLl9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIG9ialtrZXldID0gdmFsO1xuICAgIHJldHVyblxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAob2JqLCBrZXkpIHtcbiAgdmFyIG9iID0gb2JqLl9fb2JfXztcbiAgaWYgKG9iai5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKG9iaiwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSBvYmpba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCQxKHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgY2hpbGRWYWwuY2FsbCh0aGlzKSxcbiAgICAgICAgcGFyZW50VmFsLmNhbGwodGhpcylcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyZW50VmFsIHx8IGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcGFyYW0gYXR0cmlidXRlcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWxcbn1cblxuY29uZmlnLl9saWZlY3ljbGVIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gICAgOiByZXNcbn1cblxuY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG59KTtcblxuLyoqXG4gKiBXYXRjaGVycy5cbiAqXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIHBhcmVudFZhbCB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBwYXJlbnRWYWwgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YXIgbG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaXNCdWlsdEluVGFnKGxvd2VyKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhsb3dlcikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAnaWQ6ICcgKyBrZXlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucykge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQpO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gdHlwZW9mIGV4dGVuZHNGcm9tID09PSAnZnVuY3Rpb24nXG4gICAgICA/IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLm9wdGlvbnMsIHZtKVxuICAgICAgOiBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbSwgdm0pO1xuICB9XG4gIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBtaXhpbiA9IGNoaWxkLm1peGluc1tpXTtcbiAgICAgIGlmIChtaXhpbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBWdWUkMykge1xuICAgICAgICBtaXhpbiA9IG1peGluLm9wdGlvbnM7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBtaXhpbiwgdm0pO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBoYW5kbGUgYm9vbGVhbiBwcm9wc1xuICBpZiAoaXNUeXBlKEJvb2xlYW4sIHByb3AudHlwZSkpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFpc1R5cGUoU3RyaW5nLCBwcm9wLnR5cGUpICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuICAgICAgdmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZENvbnZlcnQgPSBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQ7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBwcmV2U2hvdWxkQ29udmVydDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAoaXNPYmplY3QoZGVmKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdm1ba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIHByb3AudHlwZSAhPT0gRnVuY3Rpb25cbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyArXG4gICAgICAnIEV4cGVjdGVkICcgKyBleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpICtcbiAgICAgICcsIGdvdCAnICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkgKyAnLicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydCB0aGUgdHlwZSBvZiBhIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChleHBlY3RlZFR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IChleHBlY3RlZFR5cGUgPSAnc3RyaW5nJyk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnTnVtYmVyJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ251bWJlcicpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0Jvb2xlYW4nKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IChleHBlY3RlZFR5cGUgPSAnYm9vbGVhbicpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0Z1bmN0aW9uJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ2Z1bmN0aW9uJyk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXVxufVxuXG5mdW5jdGlvbiBpc1R5cGUgKHR5cGUsIGZuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmbikpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShmbikgPT09IGdldFR5cGUodHlwZSlcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZ2V0VHlwZShmbltpXSkgPT09IGdldFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5cblxudmFyIHV0aWwgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlJCQxLFxuXHRfdG9TdHJpbmc6IF90b1N0cmluZyxcblx0dG9OdW1iZXI6IHRvTnVtYmVyLFxuXHRtYWtlTWFwOiBtYWtlTWFwLFxuXHRpc0J1aWx0SW5UYWc6IGlzQnVpbHRJblRhZyxcblx0cmVtb3ZlOiByZW1vdmUkMSxcblx0aGFzT3duOiBoYXNPd24sXG5cdGlzUHJpbWl0aXZlOiBpc1ByaW1pdGl2ZSxcblx0Y2FjaGVkOiBjYWNoZWQsXG5cdGNhbWVsaXplOiBjYW1lbGl6ZSxcblx0Y2FwaXRhbGl6ZTogY2FwaXRhbGl6ZSxcblx0aHlwaGVuYXRlOiBoeXBoZW5hdGUsXG5cdGJpbmQ6IGJpbmQkMSxcblx0dG9BcnJheTogdG9BcnJheSxcblx0ZXh0ZW5kOiBleHRlbmQsXG5cdGlzT2JqZWN0OiBpc09iamVjdCxcblx0aXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcblx0dG9PYmplY3Q6IHRvT2JqZWN0LFxuXHRub29wOiBub29wLFxuXHRubzogbm8sXG5cdGlkZW50aXR5OiBpZGVudGl0eSxcblx0Z2VuU3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyxcblx0bG9vc2VFcXVhbDogbG9vc2VFcXVhbCxcblx0bG9vc2VJbmRleE9mOiBsb29zZUluZGV4T2YsXG5cdGlzUmVzZXJ2ZWQ6IGlzUmVzZXJ2ZWQsXG5cdGRlZjogZGVmLFxuXHRwYXJzZVBhdGg6IHBhcnNlUGF0aCxcblx0aGFzUHJvdG86IGhhc1Byb3RvLFxuXHRpbkJyb3dzZXI6IGluQnJvd3Nlcixcblx0VUE6IFVBLFxuXHRpc0lFOiBpc0lFLFxuXHRpc0lFOTogaXNJRTksXG5cdGlzRWRnZTogaXNFZGdlLFxuXHRpc0FuZHJvaWQ6IGlzQW5kcm9pZCxcblx0aXNJT1M6IGlzSU9TLFxuXHRpc1NlcnZlclJlbmRlcmluZzogaXNTZXJ2ZXJSZW5kZXJpbmcsXG5cdGRldnRvb2xzOiBkZXZ0b29scyxcblx0bmV4dFRpY2s6IG5leHRUaWNrLFxuXHRnZXQgX1NldCAoKSB7IHJldHVybiBfU2V0OyB9LFxuXHRtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcblx0cmVzb2x2ZUFzc2V0OiByZXNvbHZlQXNzZXQsXG5cdGdldCB3YXJuICgpIHsgcmV0dXJuIHdhcm47IH0sXG5cdGdldCBmb3JtYXRDb21wb25lbnROYW1lICgpIHsgcmV0dXJuIGZvcm1hdENvbXBvbmVudE5hbWU7IH0sXG5cdHZhbGlkYXRlUHJvcDogdmFsaWRhdGVQcm9wXG59KTtcblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgXCJyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0byBkZWNsYXJlIHJlYWN0aXZlIGRhdGEgXCIgK1xuICAgICAgXCJwcm9wZXJ0aWVzIGluIHRoZSBkYXRhIG9wdGlvbi5cIixcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgUHJveHkudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhJyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnNcbikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLmVsbSA9IGVsbTtcbiAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5mdW5jdGlvbmFsQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7fSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gJyc7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgIHZub2RlLnRhZyxcbiAgICB2bm9kZS5kYXRhLFxuICAgIHZub2RlLmNoaWxkcmVuLFxuICAgIHZub2RlLnRleHQsXG4gICAgdm5vZGUuZWxtLFxuICAgIHZub2RlLmNvbnRleHQsXG4gICAgdm5vZGUuY29tcG9uZW50T3B0aW9uc1xuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuZnVuY3Rpb24gY2xvbmVWTm9kZXMgKHZub2Rlcykge1xuICB2YXIgcmVzID0gbmV3IEFycmF5KHZub2Rlcy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgaG9va3MgPSB7IGluaXQ6IGluaXQsIHByZXBhdGNoOiBwcmVwYXRjaCwgaW5zZXJ0OiBpbnNlcnQsIGRlc3Ryb3k6IGRlc3Ryb3kkMSB9O1xudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmICghQ3Rvcikge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgaWYgKCFDdG9yLmNpZCkge1xuICAgIGlmIChDdG9yLnJlc29sdmVkKSB7XG4gICAgICBDdG9yID0gQ3Rvci5yZXNvbHZlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChDdG9yLCBiYXNlQ3RvciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBpdCdzIG9rIHRvIHF1ZXVlIHRoaXMgb24gZXZlcnkgcmVuZGVyIGJlY2F1c2VcbiAgICAgICAgLy8gJGZvcmNlVXBkYXRlIGlzIGJ1ZmZlcmVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gICAgICAgIGNvbnRleHQuJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIGlmICghQ3Rvcikge1xuICAgICAgICAvLyByZXR1cm4gbm90aGluZyBpZiB0aGlzIGlzIGluZGVlZCBhbiBhc3luYyBjb21wb25lbnRcbiAgICAgICAgLy8gd2FpdCBmb3IgdGhlIGNhbGxiYWNrIHRvIHRyaWdnZXIgcGFyZW50IHVwZGF0ZS5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHMoZGF0YSwgQ3Rvcik7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnNcbiAgICBkYXRhID0ge307XG4gIH1cblxuICAvLyBtZXJnZSBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIG1lcmdlSG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfVxuICApO1xuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW5cbikge1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAocHJvcE9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhKTtcbiAgICB9XG4gIH1cbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBfY29udGV4dCA9IE9iamVjdC5jcmVhdGUoY29udGV4dCk7XG4gIHZhciBoID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoX2NvbnRleHQsIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuICB2YXIgdm5vZGUgPSBDdG9yLm9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgaCwge1xuICAgIHByb3BzOiBwcm9wcyxcbiAgICBkYXRhOiBkYXRhLFxuICAgIHBhcmVudDogY29udGV4dCxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgc2xvdHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgY29udGV4dCk7IH1cbiAgfSk7XG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgdm5vZGUuZnVuY3Rpb25hbENvbnRleHQgPSBjb250ZXh0O1xuICAgIGlmIChkYXRhLnNsb3QpIHtcbiAgICAgICh2bm9kZS5kYXRhIHx8ICh2bm9kZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50LCAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbiAgcGFyZW50RWxtLFxuICByZWZFbG1cbikge1xuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIHByb3BzRGF0YTogdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YSxcbiAgICBfY29tcG9uZW50VGFnOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnLFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgX3BhcmVudExpc3RlbmVyczogdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycyxcbiAgICBfcmVuZGVyQ2hpbGRyZW46IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbixcbiAgICBfcGFyZW50RWxtOiBwYXJlbnRFbG0gfHwgbnVsbCxcbiAgICBfcmVmRWxtOiByZWZFbG0gfHwgbnVsbFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlQ29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIGluaXQgKFxuICB2bm9kZSxcbiAgaHlkcmF0aW5nLFxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgdm5vZGUsXG4gICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgIHBhcmVudEVsbSxcbiAgICAgIHJlZkVsbVxuICAgICk7XG4gICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgfSBlbHNlIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgcHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwYXRjaCAoXG4gIG9sZFZub2RlLFxuICB2bm9kZVxuKSB7XG4gIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgY2hpbGQuX3VwZGF0ZUZyb21QYXJlbnQoXG4gICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICk7XG59XG5cbmZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gIH1cbiAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2luYWN0aXZlID0gZmFsc2U7XG4gICAgY2FsbEhvb2sodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXN0cm95JDEgKHZub2RlKSB7XG4gIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2luYWN0aXZlID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLCAnZGVhY3RpdmF0ZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNiXG4pIHtcbiAgaWYgKGZhY3RvcnkucmVxdWVzdGVkKSB7XG4gICAgLy8gcG9vbCBjYWxsYmFja3NcbiAgICBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MucHVzaChjYik7XG4gIH0gZWxzZSB7XG4gICAgZmFjdG9yeS5yZXF1ZXN0ZWQgPSB0cnVlO1xuICAgIHZhciBjYnMgPSBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MgPSBbY2JdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcblxuICAgIHZhciByZXNvbHZlID0gZnVuY3Rpb24gKHJlcykge1xuICAgICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgICAgcmVzID0gYmFzZUN0b3IuZXh0ZW5kKHJlcyk7XG4gICAgICB9XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IHJlcztcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNic1tpXShyZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgLy8gaGFuZGxlIHByb21pc2VcbiAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJiAhZmFjdG9yeS5yZXNvbHZlZCkge1xuICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzIChkYXRhLCBDdG9yKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BPcHRpb25zKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICB2YXIgZG9tUHJvcHMgPSBkYXRhLmRvbVByb3BzO1xuICBpZiAoYXR0cnMgfHwgcHJvcHMgfHwgZG9tUHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGRvbVByb3BzLCBrZXksIGFsdEtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaGFzaCkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9va3MgKGRhdGEpIHtcbiAgaWYgKCFkYXRhLmhvb2spIHtcbiAgICBkYXRhLmhvb2sgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGZyb21QYXJlbnQgPSBkYXRhLmhvb2tba2V5XTtcbiAgICB2YXIgb3VycyA9IGhvb2tzW2tleV07XG4gICAgZGF0YS5ob29rW2tleV0gPSBmcm9tUGFyZW50ID8gbWVyZ2VIb29rJDEob3VycywgZnJvbVBhcmVudCkgOiBvdXJzO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9vayQxIChvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICBvbmUoYSwgYiwgYywgZCk7XG4gICAgdHdvKGEsIGIsIGMsIGQpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rLCBrZXkpIHtcbiAga2V5ID0ga2V5ICsgaG9va0tleTtcbiAgdmFyIGluamVjdGVkSGFzaCA9IGRlZi5fX2luamVjdGVkIHx8IChkZWYuX19pbmplY3RlZCA9IHt9KTtcbiAgaWYgKCFpbmplY3RlZEhhc2hba2V5XSkge1xuICAgIGluamVjdGVkSGFzaFtrZXldID0gdHJ1ZTtcbiAgICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcbiAgICBpZiAob2xkSG9vaykge1xuICAgICAgZGVmW2hvb2tLZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbGRIb29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZltob29rS2V5XSA9IGhvb2s7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIG9uY2UgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UsXG4gICAgY2FwdHVyZTogY2FwdHVyZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRXZlbnRIYW5kbGUgKGZuKSB7XG4gIHZhciBoYW5kbGUgPSB7XG4gICAgZm46IGZuLFxuICAgIGludm9rZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgICAgdmFyIGZuID0gaGFuZGxlLmZuO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZm4pKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBmbltpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGFuZGxlXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICBpZiAoIWN1cikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghb2xkKSB7XG4gICAgICBpZiAoIWN1ci5pbnZva2VyKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRXZlbnRIYW5kbGUoY3VyKTtcbiAgICAgIH1cbiAgICAgIGFkZChldmVudC5uYW1lLCBjdXIuaW52b2tlciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZuID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmICghb25bbmFtZV0pIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0uaW52b2tlciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9tcmFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJjdXRzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdDtcbiAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChjID09IG51bGwgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdCA9IHJlc1tyZXMubGVuZ3RoIC0gMV07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICByZXMucHVzaC5hcHBseShyZXMsIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcIl9cIiArIGkpKSk7XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGxhc3QgJiYgbGFzdC50ZXh0KSB7XG4gICAgICAgIGxhc3QudGV4dCArPSBTdHJpbmcoYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjLnRleHQgJiYgbGFzdCAmJiBsYXN0LnRleHQpIHtcbiAgICAgICAgcmVzW3Jlcy5sZW5ndGggLSAxXSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcbiAgICAgICAgaWYgKGMudGFnICYmIGMua2V5ID09IG51bGwgJiYgbmVzdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYyAmJiBjLmNvbXBvbmVudE9wdGlvbnM7IH0pWzBdXG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChhbHdheXNOb3JtYWxpemUpIHsgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFOyB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZVxuKSB7XG4gIGlmIChkYXRhICYmIGRhdGEuX19vYl9fKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKChDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKHZub2RlKSB7XG4gICAgaWYgKG5zKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZub2RlLmNoaWxkcmVuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNoaWxkLnRhZyAmJiAhY2hpbGQubnMpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uJHZub2RlID0gbnVsbDsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDtcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyh2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSB7fTtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBjbG9uZSBzbG90IG5vZGVzIG9uIHJlLXJlbmRlcnNcbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgdm0uJHNsb3RzW2tleV0gPSBjbG9uZVZOb2Rlcyh2bS4kc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF9wYXJlbnRWbm9kZSAmJiBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cykge1xuICAgICAgdm0uJHNjb3BlZFNsb3RzID0gX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHM7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRpY1JlbmRlckZucyAmJiAhdm0uX3N0YXRpY1RyZWVzKSB7XG4gICAgICB2bS5fc3RhdGljVHJlZXMgPSBbXTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICAgICAgY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGUsIHZtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybigoXCJFcnJvciB3aGVuIHJlbmRlcmluZyBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIjpcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcblxuICAvLyB0b1N0cmluZyBmb3IgbXVzdGFjaGVzXG4gIFZ1ZS5wcm90b3R5cGUuX3MgPSBfdG9TdHJpbmc7XG4gIC8vIGNvbnZlcnQgdGV4dCB0byB2bm9kZVxuICBWdWUucHJvdG90eXBlLl92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICAvLyBudW1iZXIgY29udmVyc2lvblxuICBWdWUucHJvdG90eXBlLl9uID0gdG9OdW1iZXI7XG4gIC8vIGVtcHR5IHZub2RlXG4gIFZ1ZS5wcm90b3R5cGUuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAvLyBsb29zZSBlcXVhbFxuICBWdWUucHJvdG90eXBlLl9xID0gbG9vc2VFcXVhbDtcbiAgLy8gbG9vc2UgaW5kZXhPZlxuICBWdWUucHJvdG90eXBlLl9pID0gbG9vc2VJbmRleE9mO1xuXG4gIC8vIHJlbmRlciBzdGF0aWMgdHJlZSBieSBpbmRleFxuICBWdWUucHJvdG90eXBlLl9tID0gZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgICBpbmRleCxcbiAgICBpc0luRm9yXG4gICkge1xuICAgIHZhciB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdO1xuICAgIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAgIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlIGJ5IGRvaW5nIGEgc2hhbGxvdyBjbG9uZS5cbiAgICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodHJlZSlcbiAgICAgICAgPyBjbG9uZVZOb2Rlcyh0cmVlKVxuICAgICAgICA6IGNsb25lVk5vZGUodHJlZSlcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICAgIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSk7XG4gICAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgICByZXR1cm4gdHJlZVxuICB9O1xuXG4gIC8vIG1hcmsgbm9kZSBhcyBzdGF0aWMgKHYtb25jZSlcbiAgVnVlLnByb3RvdHlwZS5fbyA9IGZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgICB0cmVlLFxuICAgIGluZGV4LFxuICAgIGtleVxuICApIHtcbiAgICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgICByZXR1cm4gdHJlZVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1hcmtTdGF0aWMgKHRyZWUsIGtleSwgaXNPbmNlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gICAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gICAgbm9kZS5rZXkgPSBrZXk7XG4gICAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG4gIH1cblxuICAvLyBmaWx0ZXIgcmVzb2x1dGlvbiBoZWxwZXJcbiAgVnVlLnByb3RvdHlwZS5fZiA9IGZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG4gICAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxuICB9O1xuXG4gIC8vIHJlbmRlciB2LWZvclxuICBWdWUucHJvdG90eXBlLl9sID0gZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gICAgdmFsLFxuICAgIHJlbmRlclxuICApIHtcbiAgICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfTtcblxuICAvLyByZW5kZXJTbG90XG4gIFZ1ZS5wcm90b3R5cGUuX3QgPSBmdW5jdGlvbiAoXG4gICAgbmFtZSxcbiAgICBmYWxsYmFjayxcbiAgICBwcm9wcyxcbiAgICBiaW5kT2JqZWN0XG4gICkge1xuICAgIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgICAgZXh0ZW5kKHByb3BzLCBiaW5kT2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAgIC8vIHdhcm4gZHVwbGljYXRlIHNsb3QgdXNhZ2VcbiAgICAgIGlmIChzbG90Tm9kZXMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkICYmIHdhcm4oXG4gICAgICAgICAgXCJEdXBsaWNhdGUgcHJlc2VuY2Ugb2Ygc2xvdCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGZvdW5kIGluIHRoZSBzYW1lIHJlbmRlciB0cmVlIFwiICtcbiAgICAgICAgICBcIi0gdGhpcyB3aWxsIGxpa2VseSBjYXVzZSByZW5kZXIgZXJyb3JzLlwiLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xvdE5vZGVzIHx8IGZhbGxiYWNrXG4gICAgfVxuICB9O1xuXG4gIC8vIGFwcGx5IHYtYmluZCBvYmplY3RcbiAgVnVlLnByb3RvdHlwZS5fYiA9IGZ1bmN0aW9uIGJpbmRQcm9wcyAoXG4gICAgZGF0YSxcbiAgICB0YWcsXG4gICAgdmFsdWUsXG4gICAgYXNQcm9wXG4gICkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgICB2YXIgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICB9O1xuXG4gIC8vIGNoZWNrIHYtb24ga2V5Q29kZXNcbiAgVnVlLnByb3RvdHlwZS5fayA9IGZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICAgIGV2ZW50S2V5Q29kZSxcbiAgICBrZXksXG4gICAgYnVpbHRJbkFsaWFzXG4gICkge1xuICAgIHZhciBrZXlDb2RlcyA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5BbGlhcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBrZXlDb2RlcyAhPT0gZXZlbnRLZXlDb2RlXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuICBjaGlsZHJlbixcbiAgY29udGV4dFxuKSB7XG4gIHZhciBzbG90cyA9IHt9O1xuICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHNsb3RzXG4gIH1cbiAgdmFyIGRlZmF1bHRTbG90ID0gW107XG4gIHZhciBuYW1lLCBjaGlsZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZnVuY3Rpb25hbENvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICAgIGNoaWxkLmRhdGEgJiYgKG5hbWUgPSBjaGlsZC5kYXRhLnNsb3QpKSB7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVmYXVsdFNsb3QucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzaW5nbGUgd2hpdGVzcGFjZVxuICBpZiAoZGVmYXVsdFNsb3QubGVuZ3RoICYmICEoXG4gICAgZGVmYXVsdFNsb3QubGVuZ3RoID09PSAxICYmXG4gICAgKGRlZmF1bHRTbG90WzBdLnRleHQgPT09ICcgJyB8fCBkZWZhdWx0U2xvdFswXS5pc0NvbW1lbnQpXG4gICkpIHtcbiAgICBzbG90cy5kZWZhdWx0ID0gZGVmYXVsdFNsb3Q7XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkJDEgKGV2ZW50LCBmbiwgb25jZSkge1xuICBpZiAob25jZSkge1xuICAgIHRhcmdldC4kb25jZShldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCQxLCByZW1vdmUkMiwgdm0pO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpczsodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgIHZhciBjYjtcbiAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY2IgPSBjYnNbaV07XG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBjYnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fbW91bnQgPSBmdW5jdGlvbiAoXG4gICAgZWwsXG4gICAgaHlkcmF0aW5nXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdm0uJGVsID0gZWw7XG4gICAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAgICdvcHRpb24gaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG4gICAgdm0uX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50ICgpIHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH0sIG5vb3ApO1xuICAgIGh5ZHJhdGluZyA9IGZhbHNlO1xuICAgIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gICAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl91cGRhdGVGcm9tUGFyZW50ID0gZnVuY3Rpb24gKFxuICAgIHByb3BzRGF0YSxcbiAgICBsaXN0ZW5lcnMsXG4gICAgcGFyZW50Vm5vZGUsXG4gICAgcmVuZGVyQ2hpbGRyZW5cbiAgKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgaGFzQ2hpbGRyZW4gPSAhISh2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgcmVuZGVyQ2hpbGRyZW4pO1xuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICAgIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG4gICAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICAgIH1cbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcbiAgICAvLyB1cGRhdGUgcHJvcHNcbiAgICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICAgIHZtW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgICB9XG4gICAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgb2JzZXJ2ZXJTdGF0ZS5pc1NldHRpbmdQcm9wcyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICAgIH1cbiAgICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG4gICAgfVxuICAgIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gICAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZSQxKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgaGFuZGxlcnNbaV0uY2FsbCh2bSk7XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGhhcyQxID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgcXVldWUubGVuZ3RoID0gMDtcbiAgaGFzJDEgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQsIHZtO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhcyQxW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzJDFbaWRdICE9IG51bGwpIHtcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IGNvbmZpZy5fbWF4VXBkYXRlQ291bnQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXG4gICAgICAgICAgICB3YXRjaGVyLnVzZXJcbiAgICAgICAgICAgICAgPyAoXCJpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKVxuICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3YXRjaGVyLnZtXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gY2FsbCB1cGRhdGVkIGhvb2tzXG4gIGluZGV4ID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cblxuICAvLyBkZXZ0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICB9XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhcyQxW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzJDFbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPj0gMCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKE1hdGgubWF4KGksIGluZGV4KSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnNcbikge1xuICB0aGlzLnZtID0gdm07XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgcHVzaFRhcmdldCh0aGlzKTtcbiAgdmFyIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh0aGlzLnZtLCB0aGlzLnZtKTtcbiAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICBpZiAodGhpcy5kZWVwKSB7XG4gICAgdHJhdmVyc2UodmFsdWUpO1xuICB9XG4gIHBvcFRhcmdldCgpO1xuICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzJDEuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgIHRoaXMuZGVlcFxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlLCB0aGlzLnZtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAgICAgICAoXCJFcnJvciBpbiB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpLFxuICAgICAgICAgICAgICB0aGlzLnZtXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhyb3cgZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMkMS5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUkMSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzJDEuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoKSB7IGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7IH1cbn1cblxudmFyIGlzUmVzZXJ2ZWRQcm9wID0geyBrZXk6IDEsIHJlZjogMSwgc2xvdDogMSB9O1xuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wcykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaXNSZXNlcnZlZFByb3Bba2V5XSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wcywgcHJvcHNEYXRhLCB2bSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIW9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgdmFsaWRhdGVQcm9wKGtleSwgcHJvcHMsIHByb3BzRGF0YSwgdm0pKTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSBsb29wKCBpICk7XG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXG4gICAgPyBkYXRhLmNhbGwodm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleXNbaV0pKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsgKGtleXNbaV0pICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJveHkodm0sIGtleXNbaV0pO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG52YXIgY29tcHV0ZWRTaGFyZWREZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBrZXkgaW4gdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiZXhpc3RpbmcgaW5zdGFuY2UgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdpbGwgYmUgXCIgK1xuICAgICAgICBcIm92ZXJ3cml0dGVuIGJ5IGEgY29tcHV0ZWQgcHJvcGVydHkgd2l0aCB0aGUgc2FtZSBuYW1lLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcHV0ZWRTaGFyZWREZWZpbml0aW9uLmdldCA9IG1ha2VDb21wdXRlZEdldHRlcih1c2VyRGVmLCB2bSk7XG4gICAgICBjb21wdXRlZFNoYXJlZERlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcHV0ZWRTaGFyZWREZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICAgID8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgICA/IG1ha2VDb21wdXRlZEdldHRlcih1c2VyRGVmLmdldCwgdm0pXG4gICAgICAgICAgOiBiaW5kJDEodXNlckRlZi5nZXQsIHZtKVxuICAgICAgICA6IG5vb3A7XG4gICAgICBjb21wdXRlZFNoYXJlZERlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgICAgPyBiaW5kJDEodXNlckRlZi5zZXQsIHZtKVxuICAgICAgICA6IG5vb3A7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2bSwga2V5LCBjb21wdXRlZFNoYXJlZERlZmluaXRpb24pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VDb21wdXRlZEdldHRlciAoZ2V0dGVyLCBvd25lcikge1xuICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKG93bmVyLCBnZXR0ZXIsIG5vb3AsIHtcbiAgICBsYXp5OiB0cnVlXG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgfVxuICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIHZtW2tleV0gPSBtZXRob2RzW2tleV0gPT0gbnVsbCA/IG5vb3AgOiBiaW5kJDEobWV0aG9kc1trZXldLCB2bSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbWV0aG9kc1trZXldID09IG51bGwpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyICh2bSwga2V5LCBoYW5kbGVyKSB7XG4gIHZhciBvcHRpb25zO1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICB2bS4kd2F0Y2goa2V5LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVxuICB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0JDE7XG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3h5ICh2bSwga2V5KSB7XG4gIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZtLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICAgICAgcmV0dXJuIHZtLl9kYXRhW2tleV1cbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICAgICAgdm0uX2RhdGFba2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkKys7XG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLnByb3BzRGF0YSA9IG9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgb3B0cy5fcGFyZW50RWxtID0gb3B0aW9ucy5fcGFyZW50RWxtO1xuICBvcHRzLl9yZWZFbG0gPSBvcHRpb25zLl9yZWZFbG07XG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyLm9wdGlvbnM7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIHZhciBleHRlbmRPcHRpb25zID0gQ3Rvci5leHRlbmRPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWRcbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgZXh0ZW5kT3B0aW9ucy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICAgIGV4dGVuZE9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gICAgICBleHRlbmRPcHRpb25zLl9zY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBleHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiBWdWUkMyAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSQzKSkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlJDMpO1xuc3RhdGVNaXhpbihWdWUkMyk7XG5ldmVudHNNaXhpbihWdWUkMyk7XG5saWZlY3ljbGVNaXhpbihWdWUkMyk7XG5yZW5kZXJNaXhpbihWdWUkMyk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIS9eW2EtekEtWl1bXFx3LV0qJC8udGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAgICAgJ2NhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYW5kIHRoZSBoeXBoZW4sICcgK1xuICAgICAgICAgICdhbmQgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGNvbmZpZy5pc1Jlc2VydmVkVGFnKGlkKSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICAgICAgICdpZDogJyArIGlkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHBdO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChjYWNoZSwgZmlsdGVyKSB7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZWROb2RlKTtcbiAgICAgICAgY2FjaGVba2V5XSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAodm5vZGUpIHtcbiAgaWYgKHZub2RlKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faW5hY3RpdmUpIHtcbiAgICAgIGNhbGxIb29rKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLCAnZGVhY3RpdmF0ZWQnKTtcbiAgICB9XG4gICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxufVxuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlc1xuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlW2tleV0pO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9LFxuICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgKFxuICAgICAgICAodGhpcy5pbmNsdWRlICYmICFtYXRjaGVzKHRoaXMuaW5jbHVkZSwgbmFtZSkpIHx8XG4gICAgICAgICh0aGlzLmV4Y2x1ZGUgJiYgbWF0Y2hlcyh0aGlzLmV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmICh0aGlzLmNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLmNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgIH1cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuICBWdWUudXRpbCA9IHV0aWw7XG4gIFZ1ZS5zZXQgPSBzZXQkMTtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlJDMpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuVnVlJDMudmVyc2lvbiA9ICcyLjEuMTAnO1xuXG4vKiAgKi9cblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCcpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZW5DbGFzc0Zyb21EYXRhKGRhdGEpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogY2hpbGQuY2xhc3NcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkNsYXNzRnJvbURhdGEgKGRhdGEpIHtcbiAgdmFyIGR5bmFtaWNDbGFzcyA9IGRhdGEuY2xhc3M7XG4gIHZhciBzdGF0aWNDbGFzcyA9IGRhdGEuc3RhdGljQ2xhc3M7XG4gIGlmIChzdGF0aWNDbGFzcyB8fCBkeW5hbWljQ2xhc3MpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiByZXNcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBzdHJpbmdpZmllZDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHZhbHVlW2ldKSB7XG4gICAgICAgIGlmICgoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpKSB7XG4gICAgICAgICAgcmVzICs9IHN0cmluZ2lmaWVkICsgJyAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlW2tleV0pIHsgcmVzICs9IGtleSArICcgJzsgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlJ1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLCcgK1xuICAnZm9udC1mYWNlLGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG52YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSBlbDtcbiAgICBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghZWwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBzZWxlY3RvclxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgfVxuICByZXR1cm4gZWxcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmICdtdWx0aXBsZScgaW4gdm5vZGUuZGF0YS5hdHRycykge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5vZGUsIGtleSwgdmFsKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbn1cblxuXG52YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG5cdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuXHRyZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG5cdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcblx0bmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuXHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cdHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICgha2V5KSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZSQxKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pICYmIHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAqXG5cbi8qXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAqL1xuXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG52YXIgaG9va3MkMSA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBpc1VuZGVmIChzKSB7XG4gIHJldHVybiBzID09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHMpIHtcbiAgcmV0dXJuIHMgIT0gbnVsbFxufVxuXG5mdW5jdGlvbiBzYW1lVm5vZGUgKHZub2RlMSwgdm5vZGUyKSB7XG4gIHJldHVybiAoXG4gICAgdm5vZGUxLmtleSA9PT0gdm5vZGUyLmtleSAmJlxuICAgIHZub2RlMS50YWcgPT09IHZub2RlMi50YWcgJiZcbiAgICB2bm9kZTEuaXNDb21tZW50ID09PSB2bm9kZTIuaXNDb21tZW50ICYmXG4gICAgIXZub2RlMS5kYXRhID09PSAhdm5vZGUyLmRhdGFcbiAgKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzJDEubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3MkMVtpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKG1vZHVsZXNbal1baG9va3MkMVtpXV0gIT09IHVuZGVmaW5lZCkgeyBjYnNbaG9va3MkMVtpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzJDFbaV1dKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpblByZSA9IDA7XG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIG5lc3RlZCkge1xuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGluUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICFpblByZSAmJlxuICAgICAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgICAgICEoY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiYgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5pbmRleE9mKHRhZykgPiAtMSkgJiZcbiAgICAgICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh0YWcpXG4gICAgICAgICkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBpblByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodm5vZGUuaXNDb21tZW50KSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLywgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNSZWFjdGl2YXRlZCkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZikge1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGkuY3JlYXRlKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaS5pbnNlcnQpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAocm0gfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoIXJtKSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxuICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIGVsbVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KSA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XSA6IG51bGw7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWVsbVRvTW92ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0l0IHNlZW1zIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5cyB0aGF0IGlzIGNhdXNpbmcgYW4gdXBkYXRlIGVycm9yLiAnICtcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtZVZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG5ld1N0YXJ0Vm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmICh2bm9kZS5pc1N0YXRpYyAmJlxuICAgICAgICBvbGRWbm9kZS5pc1N0YXRpYyAmJlxuICAgICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgICAodm5vZGUuaXNDbG9uZWQgfHwgdm5vZGUuaXNPbmNlKSkge1xuICAgICAgdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGhhc0RhdGEgPSBpc0RlZihkYXRhKTtcbiAgICBpZiAoaGFzRGF0YSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaGFzRGF0YSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGhhc0RhdGEpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGluaXRpYWwgJiYgdm5vZGUucGFyZW50KSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLHN0eWxlLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFiYWlsZWQpIHtcbiAgICAgICAgICAgICAgYmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8XG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgaWYgKCF2bm9kZSkge1xuICAgICAgaWYgKG9sZFZub2RlKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKCFvbGRWbm9kZSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKCdzZXJ2ZXItcmVuZGVyZWQnKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKCdzZXJ2ZXItcmVuZGVyZWQnKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoeWRyYXRpbmcpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0kMSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtJDEsXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHZub2RlLnBhcmVudCkge1xuICAgICAgICAgIC8vIGNvbXBvbmVudCByb290IGVsZW1lbnQgcmVwbGFjZWQuXG4gICAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBjYnMuY3JlYXRlW2ldKGVtcHR5Tm9kZSwgdm5vZGUucGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyZW50RWxtJDEgIT09IG51bGwpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtJDEsIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICByZXR1cm4gdm5vZGUuZWxtXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGNhbGxJbnNlcnQsICdkaXItaW5zZXJ0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9LCAnZGlyLXBvc3RwYXRjaCcpO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgfVxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoIW9sZFZub2RlLmRhdGEuYXR0cnMgJiYgIXZub2RlLmRhdGEuYXR0cnMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChhdHRycy5fX29iX18pIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFOSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGF0dHJzW2tleV0gPT0gbnVsbCkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBrZXkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdmYWxzZScgOiAndHJ1ZScpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmICghZGF0YS5zdGF0aWNDbGFzcyAmJiAhZGF0YS5jbGFzcyAmJlxuICAgICAgKCFvbGREYXRhIHx8ICghb2xkRGF0YS5zdGF0aWNDbGFzcyAmJiAhb2xkRGF0YS5jbGFzcykpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzKSB7XG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gIH1cblxuICAvLyBzZXQgdGhlIGNsYXNzXG4gIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICB9XG59XG5cbnZhciBrbGFzcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufTtcblxuLyogICovXG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gYWRkJDIgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgb25jZSxcbiAgY2FwdHVyZVxuKSB7XG4gIGlmIChvbmNlKSB7XG4gICAgdmFyIG9sZEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gICAgaGFuZGxlciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgcmVtb3ZlJDMoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IG9sZEhhbmRsZXIoZXYpXG4gICAgICAgIDogb2xkSGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQzIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmICghb2xkVm5vZGUuZGF0YS5vbiAmJiAhdm5vZGUuZGF0YS5vbikge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMiwgcmVtb3ZlJDMsIHZub2RlLmNvbnRleHQpO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmICghb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyAmJiAhdm5vZGUuZGF0YS5kb21Qcm9wcykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChwcm9wcy5fX29iX18pIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKHByb3BzW2tleV0gPT0gbnVsbCkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGN1ciA9PSBudWxsID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHZub2RlLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChcbiAgZWxtLFxuICB2bm9kZSxcbiAgY2hlY2tWYWxcbikge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICB2bm9kZS50YWcgPT09ICdvcHRpb24nIHx8XG4gICAgaXNEaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzSW5wdXRDaGFuZ2VkKHZub2RlLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNJbnB1dENoYW5nZWQgKHZub2RlLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gdm5vZGUuZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gdm5vZGUuZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcikgfHwgdm5vZGUuZWxtLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICB9XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnRyaW0pIHtcbiAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoY2hpbGROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgZWwuc3R5bGVbbm9ybWFsaXplKG5hbWUpXSA9IHZhbDtcbiAgfVxufTtcblxudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciB0ZXN0RWw7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHRlc3RFbCA9IHRlc3RFbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gdGVzdEVsLnN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIHVwcGVyID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIHVwcGVyO1xuICAgIGlmIChwcmVmaXhlZCBpbiB0ZXN0RWwuc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZFxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKCFkYXRhLnN0YXRpY1N0eWxlICYmICFkYXRhLnN0eWxlICYmXG4gICAgICAhb2xkRGF0YS5zdGF0aWNTdHlsZSAmJiAhb2xkRGF0YS5zdHlsZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGRWbm9kZS5kYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkVm5vZGUuZGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIHZub2RlLmRhdGEuc3R5bGUgPSBzdHlsZS5fX29iX18gPyBleHRlbmQoe30sIHN0eWxlKSA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAobmV3U3R5bGVbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhY2xzLnRyaW0oKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSAnICcgKyBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgKyAnICc7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIWNscy50cmltKCkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gJyAnICsgZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpICsgJyAnO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyLnRyaW0oKSk7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gIDogc2V0VGltZW91dDtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pKS5wdXNoKGNscyk7XG4gIGFkZENsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZSQxKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbmVEZWxheXMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uZURlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoZWwuX2xlYXZlQ2IpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbC5fZW50ZXJDYiB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gIH1cblxuICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciA/IGFwcGVhckNsYXNzIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgPyBhcHBlYXJBY3RpdmVDbGFzcyA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXIgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKSA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXIgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKSA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhciA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKSA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhciA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPVxuICAgIGVudGVySG9vayAmJlxuICAgIC8vIGVudGVySG9vayBtYXkgYmUgYSBib3VuZCBtZXRob2Qgd2hpY2ggZXhwb3Nlc1xuICAgIC8vIHRoZSBsZW5ndGggb2Ygb3JpZ2luYWwgZm4gYXMgX2xlbmd0aFxuICAgIChlbnRlckhvb2suX2xlbmd0aCB8fCBlbnRlckhvb2subGVuZ3RoKSA+IDE7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYikge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9LCAndHJhbnNpdGlvbi1pbnNlcnQnKTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChlbC5fZW50ZXJDYikge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwuX2xlYXZlQ2IgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPVxuICAgIGxlYXZlICYmXG4gICAgLy8gbGVhdmUgaG9vayBtYXkgYmUgYSBib3VuZCBtZXRob2Qgd2hpY2ggZXhwb3Nlc1xuICAgIC8vIHRoZSBsZW5ndGggb2Ygb3JpZ2luYWwgZm4gYXMgX2xlbmd0aFxuICAgIChsZWF2ZS5fbGVuZ3RoIHx8IGxlYXZlLmxlbmd0aCkgPiAxO1xuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpW3Zub2RlLmtleV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gIGlmICghZGVmJCQxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgYXBwZWFyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBhcHBlYXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpLFxuICAgIGFwcGVhckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKVxuICB9XG59KTtcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4oKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9O1xuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICBhdHRycyxcbiAga2xhc3MsXG4gIGV2ZW50cyxcbiAgZG9tUHJvcHMsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uXG5dO1xuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoJDEgPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxudmFyIG1vZGVsYWJsZVRhZ1JFID0gL15pbnB1dHxzZWxlY3R8dGV4dGFyZWF8dnVlLWNvbXBvbmVudC1bMC05XSsoLVswLTlhLXpBLVpfLV0qKT8kLztcblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBtb2RlbCA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFtb2RlbGFibGVUYWdSRS50ZXN0KHZub2RlLnRhZykpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiBlbGVtZW50IHR5cGU6IDxcIiArICh2bm9kZS50YWcpICsgXCI+LiBcIiArXG4gICAgICAgICAgJ0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgK1xuICAgICAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LicsXG4gICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgY2IoKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGVsLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgZWwub3B0aW9ucyk7IH0pXG4gICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGVsLm9wdGlvbnMpO1xuICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBvcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbnNbaV0pLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiAmJiAhaXNJRTkpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBtb2RlbCxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG4vLyBzdXBwb3J0cyB0cmFuc2l0aW9uIG1vZGUgKG91dC1pbiAvIGluLW91dClcblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmdcbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV0uZm47XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIHJldHVybiAvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZylcbiAgICA/IGgoJ2tlZXAtYWxpdmUnKVxuICAgIDogbnVsbFxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJykge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgdmFyIGtleSA9IGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9sZENoaWxkICYmIG9sZENoaWxkLmRhdGEgJiYgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkpIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZCAmJiAob2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0sIGtleSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlLCBrZXkpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUsIGtleSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7XG4gICAgICAgICAgZGVsYXllZExlYXZlID0gbGVhdmU7XG4gICAgICAgIH0sIGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXG4vLyBzdXBwb3J0cyBtb3ZlIHRyYW5zaXRpb25zIHVzaW5nIHRoZSBGTElQIHRlY2huaXF1ZS5cblxuLy8gQmVjYXVzZSB0aGUgdmRvbSdzIGNoaWxkcmVuIHVwZGF0ZSBhbGdvcml0aG0gaXMgXCJ1bnN0YWJsZVwiIC0gaS5lLlxuLy8gaXQgZG9lc24ndCBndWFyYW50ZWUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHJlbW92ZWQgZWxlbWVudHMsXG4vLyB3ZSBmb3JjZSB0cmFuc2l0aW9uLWdyb3VwIHRvIHVwZGF0ZSBpdHMgY2hpbGRyZW4gaW50byB0d28gcGFzc2VzOlxuLy8gaW4gdGhlIGZpcnN0IHBhc3MsIHdlIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQsXG4vLyB0cmlnZ2VyaW5nIHRoZWlyIGxlYXZpbmcgdHJhbnNpdGlvbjsgaW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBpbnNlcnQvbW92ZVxuLy8gaW50byB0aGUgZmluYWwgZGlzaXJlZCBzdGF0ZS4gVGhpcyB3YXkgaW4gdGhlIHNlY29uZCBwYXNzIHJlbW92ZWRcbi8vIG5vZGVzIHdpbGwgcmVtYWluIHdoZXJlIHRoZXkgc2hvdWxkIGJlLlxuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0c1xuICAgICAgICAgICAgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbiAgICAgICAgICAgIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICB2YXIgZiA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2hhc01vdmUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUkMy5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUkMy5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlJDMuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUkMy5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZSQzLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCQxIDogbm9vcDtcblxuLy8gd3JhcCBtb3VudFxuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gdGhpcy5fbW91bnQoZWwsIGh5ZHJhdGluZylcbn07XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICApO1xufVxuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlJDMpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBpbkJyb3dzZXIgJiYgIWlzRWRnZSAmJiAvQ2hyb21lXFwvXFxkKy8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICApIHtcbiAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbn0sIDApO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbmZ1bmN0aW9uIHNob3VsZERlY29kZSAoY29udGVudCwgZW5jb2RlZCkge1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgYT1cXFwiXCIgKyBjb250ZW50ICsgXCJcXFwiPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKGVuY29kZWQpID4gMFxufVxuXG4vLyAjMzY2M1xuLy8gSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gc2hvdWxkRGVjb2RlKCdcXG4nLCAnJiMxMDsnKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGRlY29kZXI7XG5cbmZ1bmN0aW9uIGRlY29kZSAoaHRtbCkge1xuICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxufVxuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicicsXG4gIHRydWVcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZScsXG4gIHRydWVcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaycsXG4gIHRydWVcbik7XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLyohXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgc2luZ2xlQXR0cklkZW50aWZpZXIgPSAvKFteXFxzXCInPD4vPV0rKS87XG52YXIgc2luZ2xlQXR0ckFzc2lnbiA9IC8oPzo9KS87XG52YXIgc2luZ2xlQXR0clZhbHVlcyA9IFtcbiAgLy8gYXR0ciB2YWx1ZSBkb3VibGUgcXVvdGVzXG4gIC9cIihbXlwiXSopXCIrLy5zb3VyY2UsXG4gIC8vIGF0dHIgdmFsdWUsIHNpbmdsZSBxdW90ZXNcbiAgLycoW14nXSopJysvLnNvdXJjZSxcbiAgLy8gYXR0ciB2YWx1ZSwgbm8gcXVvdGVzXG4gIC8oW15cXHNcIic9PD5gXSspLy5zb3VyY2Vcbl07XG52YXIgYXR0cmlidXRlID0gbmV3IFJlZ0V4cChcbiAgJ15cXFxccyonICsgc2luZ2xlQXR0cklkZW50aWZpZXIuc291cmNlICtcbiAgJyg/OlxcXFxzKignICsgc2luZ2xlQXR0ckFzc2lnbi5zb3VyY2UgKyAnKScgK1xuICAnXFxcXHMqKD86JyArIHNpbmdsZUF0dHJWYWx1ZXMuam9pbignfCcpICsgJykpPydcbik7XG5cbi8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcbnZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcbnZhciBxbmFtZUNhcHR1cmUgPSAnKCg/OicgKyBuY25hbWUgKyAnXFxcXDopPycgKyBuY25hbWUgKyAnKSc7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgnXjwnICsgcW5hbWVDYXB0dXJlKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgnXjxcXFxcLycgKyBxbmFtZUNhcHR1cmUgKyAnW14+XSo+Jyk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xudmFyIGNvbW1lbnQgPSAvXjwhLS0vO1xudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG52YXIgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGZhbHNlO1xuJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtLCBnKSB7XG4gIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBnID09PSAnJztcbn0pO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbnZhciBpc1NjcmlwdE9yU3R5bGUgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUnLCB0cnVlKTtcbnZhciByZUNhY2hlID0ge307XG5cbnZhciBsdFJFID0gLyZsdDsvZztcbnZhciBndFJFID0gLyZndDsvZztcbnZhciBubFJFID0gLyYjMTA7L2c7XG52YXIgYW1wUkUgPSAvJmFtcDsvZztcbnZhciBxdW90ZVJFID0gLyZxdW90Oy9nO1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgaWYgKHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKG5sUkUsICdcXG4nKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbiAgICAucmVwbGFjZShsdFJFLCAnPCcpXG4gICAgLnJlcGxhY2UoZ3RSRSwgJz4nKVxuICAgIC5yZXBsYWNlKGFtcFJFLCAnJicpXG4gICAgLnJlcGxhY2UocXVvdGVSRSwgJ1wiJylcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0LCBsYXN0VGFnO1xuICB3aGlsZSAoaHRtbCkge1xuICAgIGxhc3QgPSBodG1sO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBzY3JpcHQgb3Igc3R5bGUgZWxlbWVudFxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNTY3JpcHRPclN0eWxlKGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xuXG4gICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9jdHlwZTpcbiAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcbiAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmQgdGFnOlxuICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgIHZhciBjdXJJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgdGFnOlxuICAgICAgICB2YXIgc3RhcnRUYWdNYXRjaCA9IHBhcnNlU3RhcnRUYWcoKTtcbiAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QkMSA9ICh2b2lkIDApLCBuZXh0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAodGV4dEVuZCA+IDApIHtcbiAgICAgICAgcmVzdCQxID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICFlbmRUYWcudGVzdChyZXN0JDEpICYmXG4gICAgICAgICAgIXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QkMSkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QkMSkgJiZcbiAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdCQxKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxuICAgICAgICAgIG5leHQgPSByZXN0JDEuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QkMSA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgICBhZHZhbmNlKHRleHRFbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dEVuZCA8IDApIHtcbiAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICAgIGh0bWwgPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciBlbmRUYWdMZW5ndGggPSAwO1xuICAgICAgdmFyIHJlc3QgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKHN0YWNrZWRUYWcgIT09ICdzY3JpcHQnICYmIHN0YWNrZWRUYWcgIT09ICdzdHlsZScgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCEtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QubGVuZ3RoO1xuICAgICAgaHRtbCA9IHJlc3Q7XG4gICAgICBwYXJzZUVuZFRhZyhzdGFja2VkVGFnLCBpbmRleCAtIGVuZFRhZ0xlbmd0aCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChodG1sID09PSBsYXN0ICYmIG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMoaHRtbCk7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICBwYXJzZUVuZFRhZygpO1xuXG4gIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICBpbmRleCArPSBuO1xuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xuICAgIHZhciBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHZhciBtYXRjaCA9IHtcbiAgICAgICAgdGFnTmFtZTogc3RhcnRbMV0sXG4gICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgc3RhcnQ6IGluZGV4XG4gICAgICB9O1xuICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgdmFyIGVuZCwgYXR0cjtcbiAgICAgIHdoaWxlICghKGVuZCA9IGh0bWwubWF0Y2goc3RhcnRUYWdDbG9zZSkpICYmIChhdHRyID0gaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWcodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8IHRhZ05hbWUgPT09ICdodG1sJyAmJiBsYXN0VGFnID09PSAnaGVhZCcgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgLy8gaGFja2lzaCB3b3JrIGFyb3VuZCBGRiBidWcgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MzY5Nzc4XG4gICAgICBpZiAoSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiAmJiBhcmdzWzBdLmluZGV4T2YoJ1wiXCInKSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKGFyZ3NbM10gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzNdOyB9XG4gICAgICAgIGlmIChhcmdzWzRdID09PSAnJykgeyBkZWxldGUgYXJnc1s0XTsgfVxuICAgICAgICBpZiAoYXJnc1s1XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNV07IH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNcbiAgICAgICAgKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycyB9KTtcbiAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xuICAgICAgdW5hcnlTbGFzaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbmRUYWcgKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBzdGFydCA9IGluZGV4OyB9XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7IGVuZCA9IGluZGV4OyB9XG5cbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXG4gICAgICBwb3MgPSAwO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XG4gIHZhciBpblNpbmdsZSA9IGZhbHNlO1xuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgdmFyIGluUmVnZXggPSBmYWxzZTtcbiAgdmFyIGN1cmx5ID0gMDtcbiAgdmFyIHNxdWFyZSA9IDA7XG4gIHZhciBwYXJlbiA9IDA7XG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSB7IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3QyAmJlxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG4gICAgKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXG4gICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgIHZhciBwID0gKHZvaWQgMCk7XG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgIGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcCB8fCAhL1tcXHckXS8udGVzdChwKSkge1xuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICAgIChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gIH1cblxuICBpZiAoZmlsdGVycykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcmVzc2lvblxufVxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XG4gIGlmIChpIDwgMCkge1xuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIGZpbHRlciArIFwiXFxcIikoXCIgKyBleHAgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIsXCIgKyBhcmdzKVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleDtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCkpKTtcbiAgfVxuICByZXR1cm4gdG9rZW5zLmpvaW4oJysnKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZykge1xuICBjb25zb2xlLmVycm9yKChcIltWdWUgcGFyc2VyXTogXCIgKyBtc2cpKTtcbn1cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gIGVsLFxuICBuYW1lLFxuICByYXdOYW1lLFxuICB2YWx1ZSxcbiAgYXJnLFxuICBtb2RpZmllcnNcbikge1xuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHJhd05hbWU6IHJhd05hbWUsIHZhbHVlOiB2YWx1ZSwgYXJnOiBhcmcsIG1vZGlmaWVyczogbW9kaWZpZXJzIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudFxuKSB7XG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICBuYW1lID0gJyEnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbiAgfVxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5vbmNlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgIG5hbWUgPSAnficgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBvbmNlXG4gIH1cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gIH1cbiAgdmFyIG5ld0hhbmRsZXIgPSB7IHZhbHVlOiB2YWx1ZSwgbW9kaWZpZXJzOiBtb2RpZmllcnMgfTtcbiAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIGdldFN0YXRpY1xuKSB7XG4gIHZhciBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICB2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChlbCwgbmFtZSkge1xuICB2YXIgdmFsO1xuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG52YXIgbGVuO1xudmFyIHN0cjtcbnZhciBjaHI7XG52YXIgaW5kZXgkMTtcbnZhciBleHByZXNzaW9uUG9zO1xudmFyIGV4cHJlc3Npb25FbmRQb3M7XG5cbi8qKlxuICogcGFyc2UgZGlyZWN0aXZlIG1vZGVsIHRvIGRvIHRoZSBhcnJheSB1cGRhdGUgdHJhbnNmb3JtLiBhW2lkeF0gPSB2YWwgPT4gJCRhLnNwbGljZSgkJGlkeCwgMSwgdmFsKVxuICpcbiAqIGZvciBsb29wIHBvc3NpYmxlIGNhc2VzOlxuICpcbiAqIC0gdGVzdFxuICogLSB0ZXN0W2lkeF1cbiAqIC0gdGVzdFt0ZXN0MVtpZHhdXVxuICogLSB0ZXN0W1wiYVwiXVtpZHhdXG4gKiAtIHh4eC50ZXN0W2FbYV0udGVzdDFbaWR4XV1cbiAqIC0gdGVzdC54eHguYVtcImFzYVwiXVt0ZXN0MVtpZHhdXVxuICpcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgc3RyID0gdmFsO1xuICBsZW4gPSBzdHIubGVuZ3RoO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwOiB2YWwsXG4gICAgICBpZHg6IG51bGxcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcbiAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwOiB2YWwuc3Vic3RyaW5nKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGlkeDogdmFsLnN1YnN0cmluZyhleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICB2YXIgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cbiAgICBpZiAoY2hyID09PSAweDVEKSB7IGluQnJhY2tldC0tOyB9XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gIHZhciBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJSRSA9IC9edi18XkB8XjovO1xudmFyIGZvckFsaWFzUkUgPSAvKC4qPylcXHMrKD86aW58b2YpXFxzKyguKikvO1xudmFyIGZvckl0ZXJhdG9yUkUgPSAvXFwoKFxce1tefV0qXFx9fFteLF0qKSwoW14sXSopKD86LChbXixdKikpP1xcKS87XG52YXIgYmluZFJFID0gL146fF52LWJpbmQ6LztcbnZhciBvblJFID0gL15AfF52LW9uOi87XG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBtb2RpZmllclJFID0gL1xcLlteLl0rL2c7XG5cbnZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGRlY29kZSk7XG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMTtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcbnZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcHJlVHJhbnNmb3JtcztcbnZhciB0cmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIGRlbGltaXRlcnM7XG5cbi8qKlxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB3YXJuJDEgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICB0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG4gIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIHRhZzogdGFnLFxuICAgICAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgICAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICAgICAgcGFyZW50OiBjdXJyZW50UGFyZW50LFxuICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgIH07XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMShcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xuXG4gICAgICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gICAgICAgIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xuICAgICAgICBlbGVtZW50LnBsYWluID0gIWVsZW1lbnQua2V5ICYmICFhdHRycy5sZW5ndGg7XG5cbiAgICAgICAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc1Nsb3QoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgIHRyYW5zZm9ybXNbaSQxXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhd2FybmVkKSB7XG4gICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2RlczpcXG4nICsgdGVtcGxhdGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xuICAgICAgICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50czpcXG4nICsgdGVtcGxhdGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF3YXJuZWQpIHtcbiAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudDpcIiArXG4gICAgICAgICAgICBcIlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgICBcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgICAgICAgY3VycmVudFBhcmVudC5wbGFpbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciBuYW1lID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdkZWZhdWx0JzsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9XG4gICAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgcG9zdFRyYW5zZm9ybXNbaSQyXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQgKCkge1xuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICB2YXIgbGFzdE5vZGUgPSBlbGVtZW50LmNoaWxkcmVuW2VsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdE5vZGUgJiYgbGFzdE5vZGUudHlwZSA9PT0gMyAmJiBsYXN0Tm9kZS50ZXh0ID09PSAnICcpIHtcbiAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICBpblByZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhd2FybmVkICYmIHRleHQgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQ6XFxuXFxuJyArIHRlbXBsYXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICB0ZXh0ID0gaW5QcmUgfHwgdGV4dC50cmltKClcbiAgICAgICAgPyBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpXG4gICAgICAgIC8vIG9ubHkgcHJlc2VydmUgd2hpdGVzcGFjZSBpZiBpdHMgbm90IHJpZ2h0IGFmdGVyIGEgc3RhcnRpbmcgdGFnXG4gICAgICAgIDogcHJlc2VydmVXaGl0ZXNwYWNlICYmIGNoaWxkcmVuLmxlbmd0aCA/ICcgJyA6ICcnO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb247XG4gICAgICAgIGlmICghaW5WUHJlICYmIHRleHQgIT09ICcgJyAmJiAoZXhwcmVzc2lvbiA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIHZhciBsID0gZWwuYXR0cnNMaXN0Lmxlbmd0aDtcbiAgaWYgKGwpIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGVsLmF0dHJzTGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoZWwuYXR0cnNMaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHdhcm4kMShcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGVsLmtleSA9IGV4cDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xuICB2YXIgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcbiAgaWYgKHJlZikge1xuICAgIGVsLnJlZiA9IHJlZjtcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XG4gIHZhciBleHA7XG4gIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gICAgaWYgKCFpbk1hdGNoKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMShcbiAgICAgICAgKFwiSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiBcIiArIGV4cClcbiAgICAgICk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZWwuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gICAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCk7XG4gICAgdmFyIGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgICAgZWwuYWxpYXMgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIGVsLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbM10pIHtcbiAgICAgICAgZWwuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFszXS50cmltKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmFsaWFzID0gYWxpYXM7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJyk7XG4gIGlmIChleHApIHtcbiAgICBlbC5pZiA9IGV4cDtcbiAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xuICAgICAgZXhwOiBleHAsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgIGVsLmVsc2UgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xuICAgIGlmIChlbHNlaWYpIHtcbiAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xuICB2YXIgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQxKFxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXG4gICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIlxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcbiAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gIH1cbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XG4gIHZhciBvbmNlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xuICBpZiAob25jZSAhPSBudWxsKSB7XG4gICAgZWwub25jZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3QgKGVsKSB7XG4gIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwua2V5KSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXG4gICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICAgIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgICBlbC5zbG90VGFyZ2V0ID0gc2xvdFRhcmdldCA9PT0gJ1wiXCInID8gJ1wiZGVmYXVsdFwiJyA6IHNsb3RUYXJnZXQ7XG4gICAgfVxuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIGVsLnNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICB2YXIgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMsIGlzUHJvcDtcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lKTtcbiAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcbiAgICAgICAgaXNQcm9wID0gZmFsc2U7XG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3ApIHtcbiAgICAgICAgICAgIGlzUHJvcCA9IHRydWU7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJvcCB8fCBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICBpZiAoYXJnTWF0Y2ggJiYgKGFyZyA9IGFyZ01hdGNoWzFdKSkge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSkge1xuICAgICAgd2FybiQxKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcgKGVsKSB7XG4gIHJldHVybiAoXG4gICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgKGVsLnRhZyA9PT0gJ3NjcmlwdCcgJiYgKFxuICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcbiAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgKSlcbiAgKVxufVxuXG52YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcbnZhciBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgcmVzLnB1c2goYXR0cik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgdmFyIF9lbCA9IGVsO1xuICB3aGlsZSAoX2VsKSB7XG4gICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcbiAgICAgICAgXCJ3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBcIiArXG4gICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBpc1N0YXRpY0tleTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljKHJvb3QpO1xuICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuICByZXR1cm4gbWFrZU1hcChcbiAgICAndHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycycgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyhjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIHdhbGtUaHJvdWdoQ29uZGl0aW9uc0Jsb2Nrcyhub2RlLmlmQ29uZGl0aW9ucywgaXNJbkZvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhbGtUaHJvdWdoQ29uZGl0aW9uc0Jsb2NrcyAoY29uZGl0aW9uQmxvY2tzLCBpc0luRm9yKSB7XG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBjb25kaXRpb25CbG9ja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBtYXJrU3RhdGljUm9vdHMoY29uZGl0aW9uQmxvY2tzW2ldLmJsb2NrLCBpc0luRm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyAobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAyKSB7IC8vIGV4cHJlc3Npb25cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAzKSB7IC8vIHRleHRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiAhIShub2RlLnByZSB8fCAoXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcbiAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgIWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXG4gICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XG4gIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobm9kZS5mb3IpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxudmFyIGZuRXhwUkUgPSAvXlxccyooW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqXFwoLztcbnZhciBzaW1wbGVQYXRoUkUgPSAvXlxccypbQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXXxcXFtcIi4qP1wiXXxcXFtcXGQrXXxcXFtbQS1aYS16XyRdW1xcdyRdKl0pKlxccyokLztcblxuLy8ga2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG52YXIgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiAnaWYoJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXQpcmV0dXJuOycsXG4gIGN0cmw6ICdpZighJGV2ZW50LmN0cmxLZXkpcmV0dXJuOycsXG4gIHNoaWZ0OiAnaWYoISRldmVudC5zaGlmdEtleSlyZXR1cm47JyxcbiAgYWx0OiAnaWYoISRldmVudC5hbHRLZXkpcmV0dXJuOycsXG4gIG1ldGE6ICdpZighJGV2ZW50Lm1ldGFLZXkpcmV0dXJuOydcbn07XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXJzIChldmVudHMsIG5hdGl2ZSkge1xuICB2YXIgcmVzID0gbmF0aXZlID8gJ25hdGl2ZU9uOnsnIDogJ29uOnsnO1xuICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgIHJlcyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyAoZ2VuSGFuZGxlcihuYW1lLCBldmVudHNbbmFtZV0pKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ30nXG59XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXIgKFxuICBuYW1lLFxuICBoYW5kbGVyXG4pIHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcbiAgfSBlbHNlIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICByZXR1cm4gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpIHx8IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpXG4gICAgICA/IGhhbmRsZXIudmFsdWVcbiAgICAgIDogKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIChoYW5kbGVyLnZhbHVlKSArIFwifVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBjb2RlID0gJyc7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICBjb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgY29kZSA9IGdlbktleUZpbHRlcihrZXlzKSArIGNvZGU7XG4gICAgfVxuICAgIHZhciBoYW5kbGVyQ29kZSA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpXG4gICAgICA/IGhhbmRsZXIudmFsdWUgKyAnKCRldmVudCknXG4gICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgcmV0dXJuICdmdW5jdGlvbigkZXZlbnQpeycgKyBjb2RlICsgaGFuZGxlckNvZGUgKyAnfSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgcmV0dXJuIChcImlmKFwiICsgKGtleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJykpICsgXCIpcmV0dXJuO1wiKVxufVxuXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcbiAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIChcIiRldmVudC5rZXlDb2RlIT09XCIgKyBrZXlWYWwpXG4gIH1cbiAgdmFyIGFsaWFzID0ga2V5Q29kZXNba2V5XTtcbiAgcmV0dXJuIChcIl9rKCRldmVudC5rZXlDb2RlLFwiICsgKEpTT04uc3RyaW5naWZ5KGtleSkpICsgKGFsaWFzID8gJywnICsgSlNPTi5zdHJpbmdpZnkoYWxpYXMpIDogJycpICsgXCIpXCIpXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDIgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBiaW5kOiBiaW5kJDIsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIHRyYW5zZm9ybXMkMTtcbnZhciBkYXRhR2VuRm5zO1xudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyQxO1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxO1xudmFyIHN0YXRpY1JlbmRlckZucztcbnZhciBvbmNlQ291bnQ7XG52YXIgY3VycmVudE9wdGlvbnM7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgYXN0LFxuICBvcHRpb25zXG4pIHtcbiAgLy8gc2F2ZSBwcmV2aW91cyBzdGF0aWNSZW5kZXJGbnMgc28gZ2VuZXJhdGUgY2FsbHMgY2FuIGJlIG5lc3RlZFxuICB2YXIgcHJldlN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcbiAgdmFyIGN1cnJlbnRTdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnMgPSBbXTtcbiAgdmFyIHByZXZPbmNlQ291bnQgPSBvbmNlQ291bnQ7XG4gIG9uY2VDb3VudCA9IDA7XG4gIGN1cnJlbnRPcHRpb25zID0gb3B0aW9ucztcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB0cmFuc2Zvcm1zJDEgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICBwbGF0Zm9ybURpcmVjdGl2ZXMkMSA9IG9wdGlvbnMuZGlyZWN0aXZlcyB8fCB7fTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDEgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QpIDogJ19jKFwiZGl2XCIpJztcbiAgc3RhdGljUmVuZGVyRm5zID0gcHJldlN0YXRpY1JlbmRlckZucztcbiAgb25jZUNvdW50ID0gcHJldk9uY2VDb3VudDtcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGN1cnJlbnRTdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCkge1xuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbClcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbk9uY2UoZWwpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsKVxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbClcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQpIHtcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwpIHx8ICd2b2lkIDAnXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICByZXR1cm4gZ2VuU2xvdChlbClcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkYXRhID0gZWwucGxhaW4gPyB1bmRlZmluZWQgOiBnZW5EYXRhKGVsKTtcblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHRydWUpO1xuICAgICAgY29kZSA9IFwiX2MoJ1wiICsgKGVsLnRhZykgKyBcIidcIiArIChkYXRhID8gKFwiLFwiICsgZGF0YSkgOiAnJykgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMkMS5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHRyYW5zZm9ybXMkMVtpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwpIHtcbiAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCkpICsgXCJ9XCIpKTtcbiAgcmV0dXJuIChcIl9tKFwiICsgKHN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxKSArIChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbn1cblxuLy8gdi1vbmNlXG5mdW5jdGlvbiBnZW5PbmNlIChlbCkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbClcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgIFwidi1vbmNlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHYtZm9yIHRoYXQgaXMga2V5ZWQuIFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwpXG4gICAgfVxuICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsKSkgKyBcIixcIiArIChvbmNlQ291bnQrKykgKyAoa2V5ID8gKFwiLFwiICsga2V5KSA6IFwiXCIpICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JZiAoZWwpIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChjb25kaXRpb25zKSB7XG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJ19lKCknXG4gIH1cblxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiAoXCIoXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcIik/XCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSArIFwiOlwiICsgKGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zKSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGVsLm9uY2UgPyBnZW5PbmNlKGVsKSA6IGdlbkVsZW1lbnQoZWwpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChlbCkge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArIChnZW5FbGVtZW50KGVsKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsKTtcbiAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cbiAgLy8ga2V5XG4gIGlmIChlbC5rZXkpIHtcbiAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gXCJyZWY6XCIgKyAoZWwucmVmKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5yZWZJbkZvcikge1xuICAgIGRhdGEgKz0gXCJyZWZJbkZvcjp0cnVlLFwiO1xuICB9XG4gIC8vIHByZVxuICBpZiAoZWwucHJlKSB7XG4gICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IFwiYXR0cnM6e1wiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczp7XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBldmVudCBoYW5kbGVyc1xuICBpZiAoZWwuZXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzKSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlKSkgKyBcIixcIjtcbiAgfVxuICAvLyBzbG90IHRhcmdldFxuICBpZiAoZWwuc2xvdFRhcmdldCkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLnNjb3BlZFNsb3RzKSkgKyBcIixcIjtcbiAgfVxuICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwpO1xuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwpIHtcbiAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgdmFyIGdlbiA9IHBsYXRmb3JtRGlyZWN0aXZlcyQxW2Rpci5uYW1lXSB8fCBiYXNlRGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgd2FybiQyKTtcbiAgICB9XG4gICAgaWYgKG5lZWRSdW50aW1lKSB7XG4gICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHJlcyArPSBcIntuYW1lOlxcXCJcIiArIChkaXIubmFtZSkgKyBcIlxcXCIscmF3TmFtZTpcXFwiXCIgKyAoZGlyLnJhd05hbWUpICsgXCJcXFwiXCIgKyAoZGlyLnZhbHVlID8gKFwiLHZhbHVlOihcIiArIChkaXIudmFsdWUpICsgXCIpLGV4cHJlc3Npb246XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKSkpIDogJycpICsgKGRpci5hcmcgPyAoXCIsYXJnOlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzUnVudGltZSkge1xuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ10nXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSW5saW5lVGVtcGxhdGUgKGVsKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgYXN0LnR5cGUgIT09IDFcbiAgKSkge1xuICAgIHdhcm4kMignSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyk7XG4gIH1cbiAgaWYgKGFzdC50eXBlID09PSAxKSB7XG4gICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgY3VycmVudE9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKHNsb3RzKSB7XG4gIHJldHVybiAoXCJzY29wZWRTbG90czp7XCIgKyAoT2JqZWN0LmtleXMoc2xvdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KGtleSwgc2xvdHNba2V5XSk7IH0pLmpvaW4oJywnKSkgKyBcIn1cIilcbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoa2V5LCBlbCkge1xuICByZXR1cm4ga2V5ICsgXCI6ZnVuY3Rpb24oXCIgKyAoU3RyaW5nKGVsLmF0dHJzTWFwLnNjb3BlKSkgKyBcIil7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgPyBnZW5DaGlsZHJlbihlbCkgfHwgJ3ZvaWQgMCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCkpICsgXCJ9XCJcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKGVsLCBjaGVja1NraXApIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgZWwkMS5mb3IgJiZcbiAgICAgICAgZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgICAgZWwkMS50YWcgIT09ICdzbG90Jykge1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwkMSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4pO1xuICAgIHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGdlbk5vZGUpLmpvaW4oJywnKSkgKyBcIl1cIiArIChjaGVja1NraXBcbiAgICAgICAgPyBub3JtYWxpemF0aW9uVHlwZSA/IChcIixcIiArIG5vcm1hbGl6YXRpb25UeXBlKSA6ICcnXG4gICAgICAgIDogJycpKVxuICB9XG59XG5cbi8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cbi8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXG4vLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoY2hpbGRyZW4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIG1heWJlQ29tcG9uZW50IChlbCkge1xuICByZXR1cm4gIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxKGVsLnRhZylcbn1cblxuZnVuY3Rpb24gZ2VuTm9kZSAobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblRleHQgKHRleHQpIHtcbiAgcmV0dXJuIChcIl92KFwiICsgKHRleHQudHlwZSA9PT0gMlxuICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcbiAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2xvdCAoZWwpIHtcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwpO1xuICB2YXIgcmVzID0gXCJfdChcIiArIHNsb3ROYW1lICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpO1xuICB2YXIgYXR0cnMgPSBlbC5hdHRycyAmJiAoXCJ7XCIgKyAoZWwuYXR0cnMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiAoKGNhbWVsaXplKGEubmFtZSkpICsgXCI6XCIgKyAoYS52YWx1ZSkpOyB9KS5qb2luKCcsJykpICsgXCJ9XCIpO1xuICB2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcbiAgaWYgKChhdHRycyB8fCBiaW5kJCQxKSAmJiAhY2hpbGRyZW4pIHtcbiAgICByZXMgKz0gXCIsbnVsbFwiO1xuICB9XG4gIGlmIChhdHRycykge1xuICAgIHJlcyArPSBcIixcIiArIGF0dHJzO1xuICB9XG4gIGlmIChiaW5kJCQxKSB7XG4gICAgcmVzICs9IChhdHRycyA/ICcnIDogJyxudWxsJykgKyBcIixcIiArIGJpbmQkJDE7XG4gIH1cbiAgcmV0dXJuIHJlcyArICcpJ1xufVxuXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQgKGNvbXBvbmVudE5hbWUsIGVsKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCB0cnVlKTtcbiAgcmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEoZWwpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICByZXMgKz0gXCJcXFwiXCIgKyAocHJvcC5uYW1lKSArIFwiXFxcIjpcIiArICh0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSkpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbn1cblxuLy8gIzM4OTUsICM0MjY4XG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcbiAgcmV0dXJuIHRleHRcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jylcbn1cblxuLyogICovXG5cbi8qKlxuICogQ29tcGlsZSBhIHRlbXBsYXRlLlxuICovXG5mdW5jdGlvbiBjb21waWxlJDEgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuLyogICovXG5cbi8vIG9wZXJhdG9ycyBsaWtlIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuLy8gY2hlY2sgdmFsaWQgaWRlbnRpZmllciBmb3Igdi1mb3JcbnZhciBpZGVudFJFID0gL1tBLVphLXpfJF1bXFx3JF0qLztcbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbnZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCkge1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmIChhc3QpIHtcbiAgICBjaGVja05vZGUoYXN0LCBlcnJvcnMpO1xuICB9XG4gIHJldHVybiBlcnJvcnNcbn1cblxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCBlcnJvcnMpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIGVycm9ycyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgZXJyb3JzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKGlkZW50LCB0eXBlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycgJiYgIWlkZW50UkUudGVzdChpZGVudCkpIHtcbiAgICBlcnJvcnMucHVzaCgoXCItIGludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyB0ZXh0KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIGVycm9ycykge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgIFwiLSBhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyB0ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcnMucHVzaCgoXCItIGludmFsaWQgZXhwcmVzc2lvbjogXCIgKyB0ZXh0KSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRpY0NsYXNzKSB7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiY2xhc3M9XFxcIlwiICsgc3RhdGljQ2xhc3MgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBrbGFzcyQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMlxufTtcblxudmFyIG1vZHVsZXMkMSA9IFtcbiAga2xhc3MkMSxcbiAgc3R5bGUkMVxuXTtcblxuLyogICovXG5cbnZhciB3YXJuJDM7XG5cbmZ1bmN0aW9uIG1vZGVsJDEgKFxuICBlbCxcbiAgZGlyLFxuICBfd2FyblxuKSB7XG4gIHdhcm4kMyA9IF93YXJuO1xuICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xuICB2YXIgdGFnID0gZWwudGFnO1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGR5bmFtaWNUeXBlID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiBkeW5hbWljVHlwZSkge1xuICAgICAgd2FybiQzKFxuICAgICAgICBcIjxpbnB1dCA6dHlwZT1cXFwiXCIgKyBkeW5hbWljVHlwZSArIFwiXFxcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjpcXG5cIiArXG4gICAgICAgIFwidi1tb2RlbCBkb2VzIG5vdCBzdXBwb3J0IGR5bmFtaWMgaW5wdXQgdHlwZXMuIFVzZSB2LWlmIGJyYW5jaGVzIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfVxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBlbC5hdHRyc01hcC5jaGVja2VkICE9IG51bGwpIHtcbiAgICB3YXJuJDMoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiBjaGVja2VkPjpcXG5cIiArXG4gICAgICBcImlubGluZSBjaGVja2VkIGF0dHJpYnV0ZXMgd2lsbCBiZSBpZ25vcmVkIHdoZW4gdXNpbmcgdi1tb2RlbC4gXCIgK1xuICAgICAgJ0RlY2xhcmUgaW5pdGlhbCB2YWx1ZXMgaW4gdGhlIGNvbXBvbmVudFxcJ3MgZGF0YSBvcHRpb24gaW5zdGVhZC4nXG4gICAgKTtcbiAgfVxuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcbiAgICAgIFwiP19pKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKT4tMVwiICsgKFxuICAgICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgICA/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxuICAgICAgICAgIDogKFwiOl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIilcIilcbiAgICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NsaWNrJyxcbiAgICBcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgXCJ2YXIgJCR2PVwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFwiLFwiICtcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgXCJpZigkJGMpeyQkaTwwJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5jb25jYXQoJCR2KSl9XCIgK1xuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgdmFsdWUgKyBcIj0kJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKSl9XCIgK1xuICAgIFwifWVsc2V7XCIgKyB2YWx1ZSArIFwiPSQkY31cIixcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgZWwuYXR0cnNNYXAuY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgd2FybiQzKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgY2hlY2tlZD46XFxuXCIgK1xuICAgICAgXCJpbmxpbmUgY2hlY2tlZCBhdHRyaWJ1dGVzIHdpbGwgYmUgaWdub3JlZCB3aGVuIHVzaW5nIHYtbW9kZWwuIFwiICtcbiAgICAgICdEZWNsYXJlIGluaXRpYWwgdmFsdWVzIGluIHRoZSBjb21wb25lbnRcXCdzIGRhdGEgb3B0aW9uIGluc3RlYWQuJ1xuICAgICk7XG4gIH1cbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gKFwiX24oXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NsaWNrJywgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ2lucHV0JyAmJiBlbC5hdHRyc01hcC52YWx1ZSkge1xuICAgICAgd2FybiQzKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB2YWx1ZT1cXFwiXCIgKyAoZWwuYXR0cnNNYXAudmFsdWUpICsgXCJcXFwiPjpcXG5cIiArXG4gICAgICAgICdpbmxpbmUgdmFsdWUgYXR0cmlidXRlcyB3aWxsIGJlIGlnbm9yZWQgd2hlbiB1c2luZyB2LW1vZGVsLiAnICtcbiAgICAgICAgJ0RlY2xhcmUgaW5pdGlhbCB2YWx1ZXMgaW4gdGhlIGNvbXBvbmVudFxcJ3MgZGF0YSBvcHRpb24gaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZWwudGFnID09PSAndGV4dGFyZWEnICYmIGVsLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgd2FybiQzKFxuICAgICAgICBcIjx0ZXh0YXJlYSB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjpcXG5cIiArXG4gICAgICAgICdpbmxpbmUgY29udGVudCBpbnNpZGUgPHRleHRhcmVhPiB3aWxsIGJlIGlnbm9yZWQgd2hlbiB1c2luZyB2LW1vZGVsLiAnICtcbiAgICAgICAgJ0RlY2xhcmUgaW5pdGlhbCB2YWx1ZXMgaW4gdGhlIGNvbXBvbmVudFxcJ3MgZGF0YSBvcHRpb24gaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBldmVudCA9IGxhenkgfHwgKGlzSUUgJiYgdHlwZSA9PT0gJ3JhbmdlJykgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBpc05hdGl2ZSA9IGVsLnRhZyA9PT0gJ2lucHV0JyB8fCBlbC50YWcgPT09ICd0ZXh0YXJlYSc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9IGlzTmF0aXZlXG4gICAgPyAoXCIkZXZlbnQudGFyZ2V0LnZhbHVlXCIgKyAodHJpbSA/ICcudHJpbSgpJyA6ICcnKSlcbiAgICA6IHRyaW0gPyBcIih0eXBlb2YgJGV2ZW50ID09PSAnc3RyaW5nJyA/ICRldmVudC50cmltKCkgOiAkZXZlbnQpXCIgOiBcIiRldmVudFwiO1xuICB2YWx1ZUV4cHJlc3Npb24gPSBudW1iZXIgfHwgdHlwZSA9PT0gJ251bWJlcidcbiAgICA/IChcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCIpXG4gICAgOiB2YWx1ZUV4cHJlc3Npb247XG5cbiAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcbiAgaWYgKGlzTmF0aXZlICYmIG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgY29kZSA9IFwiaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuO1wiICsgY29kZTtcbiAgfVxuXG4gIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAvLyB2YWx1ZSB3aWxsIHRocm93IGFuIGVycm9yLlxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgd2FybiQzKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgdHlwZT1cXFwiZmlsZVxcXCI+OlxcblwiICtcbiAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIlxuICAgICk7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCBpc05hdGl2ZSA/IChcIl9zKFwiICsgdmFsdWUgKyBcIilcIikgOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyIHx8IHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5TZWxlY3QgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZWwuY2hpbGRyZW4uc29tZShjaGVja09wdGlvbldhcm5pbmcpO1xuICB9XG5cbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgYXNzaWdubWVudCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICBcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xuICAgIFwiLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXFxcIl92YWx1ZVxcXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiICtcbiAgICAoZWwuYXR0cnNNYXAubXVsdGlwbGUgPT0gbnVsbCA/ICdbMF0nIDogJycpO1xuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrT3B0aW9uV2FybmluZyAob3B0aW9uKSB7XG4gIGlmIChvcHRpb24udHlwZSA9PT0gMSAmJlxuICAgIG9wdGlvbi50YWcgPT09ICdvcHRpb24nICYmXG4gICAgb3B0aW9uLmF0dHJzTWFwLnNlbGVjdGVkICE9IG51bGwpIHtcbiAgICB3YXJuJDMoXG4gICAgICBcIjxzZWxlY3Qgdi1tb2RlbD1cXFwiXCIgKyAob3B0aW9uLnBhcmVudC5hdHRyc01hcFsndi1tb2RlbCddKSArIFwiXFxcIj46XFxuXCIgK1xuICAgICAgJ2lubGluZSBzZWxlY3RlZCBhdHRyaWJ1dGVzIG9uIDxvcHRpb24+IHdpbGwgYmUgaWdub3JlZCB3aGVuIHVzaW5nIHYtbW9kZWwuICcgK1xuICAgICAgJ0RlY2xhcmUgaW5pdGlhbCB2YWx1ZXMgaW4gdGhlIGNvbXBvbmVudFxcJ3MgZGF0YSBvcHRpb24gaW5zdGVhZC4nXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAodmFsdWUsIGFzc2lnbm1lbnQpIHtcbiAgdmFyIG1vZGVsUnMgPSBwYXJzZU1vZGVsKHZhbHVlKTtcbiAgaWYgKG1vZGVsUnMuaWR4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJ2YXIgJCRleHAgPSBcIiArIChtb2RlbFJzLmV4cCkgKyBcIiwgJCRpZHggPSBcIiArIChtb2RlbFJzLmlkeCkgKyBcIjtcIiArXG4gICAgICBcImlmICghQXJyYXkuaXNBcnJheSgkJGV4cCkpe1wiICtcbiAgICAgICAgdmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQgKyBcIn1cIiArXG4gICAgICBcImVsc2V7JCRleHAuc3BsaWNlKCQkaWR4LCAxLCBcIiArIGFzc2lnbm1lbnQgKyBcIil9XCJcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICdpbm5lckhUTUwnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbDogbW9kZWwkMSxcbiAgdGV4dDogdGV4dCxcbiAgaHRtbDogaHRtbFxufTtcblxuLyogICovXG5cbnZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbnZhciBiYXNlT3B0aW9ucyA9IHtcbiAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxuICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSksXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxuICBnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcbiAgaXNQcmVUYWc6IGlzUHJlVGFnXG59O1xuXG5mdW5jdGlvbiBjb21waWxlJCQxIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICBvcHRpb25zID0gb3B0aW9uc1xuICAgID8gZXh0ZW5kKGV4dGVuZCh7fSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKVxuICAgIDogYmFzZU9wdGlvbnM7XG4gIHJldHVybiBjb21waWxlJDEodGVtcGxhdGUsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zLFxuICB2bVxuKSB7XG4gIHZhciBfd2FybiA9IChvcHRpb25zICYmIG9wdGlvbnMud2FybikgfHwgd2FybjtcbiAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgIF93YXJuKFxuICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIga2V5ID0gb3B0aW9ucyAmJiBvcHRpb25zLmRlbGltaXRlcnNcbiAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICA6IHRlbXBsYXRlO1xuICBpZiAoY2FjaGVba2V5XSkge1xuICAgIHJldHVybiBjYWNoZVtrZXldXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgY29tcGlsZWQgPSBjb21waWxlJCQxKHRlbXBsYXRlLCBvcHRpb25zKTtcbiAgcmVzLnJlbmRlciA9IG1ha2VGdW5jdGlvbihjb21waWxlZC5yZW5kZXIpO1xuICB2YXIgbCA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5sZW5ndGg7XG4gIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBuZXcgQXJyYXkobCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgcmVzLnN0YXRpY1JlbmRlckZuc1tpXSA9IG1ha2VGdW5jdGlvbihjb21waWxlZC5zdGF0aWNSZW5kZXJGbnNbaV0pO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHJlcy5yZW5kZXIgPT09IG5vb3AgfHwgcmVzLnN0YXRpY1JlbmRlckZucy5zb21lKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4gPT09IG5vb3A7IH0pKSB7XG4gICAgICBfd2FybihcbiAgICAgICAgXCJmYWlsZWQgdG8gY29tcGlsZSB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QpLmpvaW4oJ1xcbicpICtcbiAgICAgICAgJ1xcblxcbicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG59XG5cbmZ1bmN0aW9uIG1ha2VGdW5jdGlvbiAoY29kZSkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBub29wXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBpZFRvVGVtcGxhdGUgPSBjYWNoZWQoZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBlbCA9IHF1ZXJ5KGlkKTtcbiAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxufSk7XG5cbnZhciBtb3VudCA9IFZ1ZSQzLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICB2YXIgcmVmID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XG4gICAgICAgIHdhcm46IHdhcm4sXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlcjtcbiAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgfVxufVxuXG5WdWUkMy5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZ1ZSQzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS9kaXN0L3Z1ZS5jb21tb24uanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 3 */
/***/ function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/MzY5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = __webpack_require__(8)\nvar ieee754 = __webpack_require__(17)\nvar isArray = __webpack_require__(18)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer, __webpack_require__(3)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vYnVmZmVyL2luZGV4LmpzPzFhNTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1ZmZlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

eval("var Factory = __webpack_require__(20).Factory;\nvar Chance = __webpack_require__(14)\nvar chance = new Chance();\n\nmodule.exports = new Factory()\n    .sequence('id')\n    .attrs({\n        prefix: function () { return chance.word() + '/' + chance.word(); }, //Trailing slashes will be stripped\n        preview_url: function () { return chance.url({extensions: ['gif', 'jpg', 'png', 'mov', 'doc', 'pdf']}); },\n        name: function () { return /[^/]*$/.exec(chance.url({extensions: ['gif', 'jpg', 'png', 'mov', 'doc', 'pdf']}))[0]; },\n        size: function () { return chance.integer({min: 1, max: 99999999}); },\n        mime: function () { return chance.pickone(['audio/aac', 'application/x-abiword', 'application/octet-stream', 'text/csv', 'image/gif']); }\n    })\n    .attr('location', ['prefix', 'name'], function (prefix, name) {\n        return prefix + '/' + name;\n    });//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9mYWN0b3JpZXMvZmlsZS5qcz84YjZlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBGYWN0b3J5ID0gcmVxdWlyZSgncm9zaWUnKS5GYWN0b3J5O1xudmFyIENoYW5jZSA9IHJlcXVpcmUoJ2NoYW5jZScpXG52YXIgY2hhbmNlID0gbmV3IENoYW5jZSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBGYWN0b3J5KClcbiAgICAuc2VxdWVuY2UoJ2lkJylcbiAgICAuYXR0cnMoe1xuICAgICAgICBwcmVmaXg6ICgpID0+IGNoYW5jZS53b3JkKCkgKyAnLycgKyBjaGFuY2Uud29yZCgpLCAvL1RyYWlsaW5nIHNsYXNoZXMgd2lsbCBiZSBzdHJpcHBlZFxuICAgICAgICBwcmV2aWV3X3VybDogKCkgPT4gY2hhbmNlLnVybCh7ZXh0ZW5zaW9uczogWydnaWYnLCAnanBnJywgJ3BuZycsICdtb3YnLCAnZG9jJywgJ3BkZiddfSksXG4gICAgICAgIG5hbWU6ICgpID0+IC9bXi9dKiQvLmV4ZWMoY2hhbmNlLnVybCh7ZXh0ZW5zaW9uczogWydnaWYnLCAnanBnJywgJ3BuZycsICdtb3YnLCAnZG9jJywgJ3BkZiddfSkpWzBdLFxuICAgICAgICBzaXplOiAoKSA9PiBjaGFuY2UuaW50ZWdlcih7bWluOiAxLCBtYXg6IDk5OTk5OTk5fSksXG4gICAgICAgIG1pbWU6ICgpID0+IGNoYW5jZS5waWNrb25lKFsnYXVkaW8vYWFjJywgJ2FwcGxpY2F0aW9uL3gtYWJpd29yZCcsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLCAndGV4dC9jc3YnLCAnaW1hZ2UvZ2lmJ10pXG4gICAgfSlcbiAgICAuYXR0cignbG9jYXRpb24nLCBbJ3ByZWZpeCcsICduYW1lJ10sIChwcmVmaXgsIG5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICcvJyArIG5hbWU7XG4gICAgfSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGZhY3Rvcmllcy9maWxlLmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bus__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_main_vue__ = __webpack_require__(23);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__components_main_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vue__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vue_paginate__ = __webpack_require__(31);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vue_paginate___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_vue_paginate__);\n\n\n\n\n\n__WEBPACK_IMPORTED_MODULE_2_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_3_vue_paginate___default.a)\n\n/* harmony default export */ exports[\"a\"] = __WEBPACK_IMPORTED_MODULE_1__components_main_vue___default.a;\n/* unused harmony reexport bus */\n/* unused harmony reexport manager */\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9tYWluLmpzPzdhOTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGJ1cyBmcm9tICcuL2J1cydcbmltcG9ydCBtYW5hZ2VyIGZyb20gJy4vY29tcG9uZW50cy9tYWluLnZ1ZSdcbmltcG9ydCBWdWUgZnJvbSAndnVlJ1xuaW1wb3J0IFZ1ZVBhZ2luYXRlIGZyb20gJ3Z1ZS1wYWdpbmF0ZSdcblxuVnVlLnVzZShWdWVQYWdpbmF0ZSlcblxuZXhwb3J0IGRlZmF1bHQgbWFuYWdlcjtcbmV4cG9ydCB7YnVzLCBtYW5hZ2VyfTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbWFpbi5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony default export */ exports[\"a\"] = function (name, url) {\n    if (!url) {\n        url = window.location.href;\n    }\n    name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n    var regex = new RegExp(\"[?&]\" + name + \"(=([^&#]*)|&|#|$)\"),\n        results = regex.exec(url);\n    if (!results) return null;\n    if (!results[2]) return '';\n    return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy91dGlsaXRpZXMvZ2V0UGFyYW0uanM/YWI1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAobmFtZSwgdXJsKSB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgICAgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgfVxuICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tcXFtcXF1dL2csIFwiXFxcXCQmXCIpO1xuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoXCJbPyZdXCIgKyBuYW1lICsgXCIoPShbXiYjXSopfCZ8I3wkKVwiKSxcbiAgICAgICAgcmVzdWx0cyA9IHJlZ2V4LmV4ZWModXJsKTtcbiAgICBpZiAoIXJlc3VsdHMpIHJldHVybiBudWxsO1xuICAgIGlmICghcmVzdWx0c1syXSkgcmV0dXJuICcnO1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1syXS5yZXBsYWNlKC9cXCsvZywgXCIgXCIpKTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gdXRpbGl0aWVzL2dldFBhcmFtLmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 8 */
/***/ function(module, exports) {

"use strict";
eval("'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vYmFzZTY0LWpzL2luZGV4LmpzPzJhZGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jhc2U2NC1qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("//\n//\n//\n//\n//\n//\n\n/* harmony default export */ exports[\"default\"] = {\n    props: ['file']\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jb21wb25lbnRzL2ZpbGUudnVlP2ZhY2UiXSwic291cmNlc0NvbnRlbnQiOlsiLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IFsnZmlsZSddXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gY29tcG9uZW50cy9maWxlLnZ1ZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bus__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__file_vue__ = __webpack_require__(21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__file_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__file_vue__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n/* harmony default export */ exports[\"default\"] = {\n    components: {file: __WEBPACK_IMPORTED_MODULE_1__file_vue___default.a},\n    props: {\n        files: {\n            type: Array,\n            default: []\n        },\n        limit: {\n            type: Number,\n            default: 10\n        }\n    },\n    data: function data() {\n        return {\n            search: '',\n            paginate: ['filtered']\n        }\n    },\n    computed: {\n        filtered: function filtered() {\n            var this$1 = this;\n\n            if (!this.search) return this.files;\n            return this.files.filter(function (file) {\n                return ((file.location.toLowerCase().indexOf(this$1.search.toLowerCase()) !== -1)\n                    || (file.mime.toLowerCase().indexOf(this$1.search.toLowerCase()) !== -1)\n                    || (file.name.toLowerCase().indexOf(this$1.search.toLowerCase()) !== -1))\n            })\n        }\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vY29tcG9uZW50cy9maWxlcy52dWU/NzdlMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuaW1wb3J0IGV2ZW50cyBmcm9tICcuLi9idXMnXG5pbXBvcnQgZmlsZSBmcm9tICcuL2ZpbGUudnVlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgY29tcG9uZW50czoge2ZpbGV9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGZpbGVzOiB7XG4gICAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIGxpbWl0OiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxMFxuICAgICAgICB9XG4gICAgfSxcbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VhcmNoOiAnJyxcbiAgICAgICAgICAgIHBhZ2luYXRlOiBbJ2ZpbHRlcmVkJ11cbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgZmlsdGVyZWQoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VhcmNoKSByZXR1cm4gdGhpcy5maWxlcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVzLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKGZpbGUubG9jYXRpb24udG9Mb3dlckNhc2UoKS5pbmRleE9mKHRoaXMuc2VhcmNoLnRvTG93ZXJDYXNlKCkpICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgfHwgKGZpbGUubWltZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YodGhpcy5zZWFyY2gudG9Mb3dlckNhc2UoKSkgIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICB8fCAoZmlsZS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0aGlzLnNlYXJjaC50b0xvd2VyQ2FzZSgpKSAhPT0gLTEpKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjb21wb25lbnRzL2ZpbGVzLnZ1ZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bus__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__modal_vue__ = __webpack_require__(24);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__modal_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__modal_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__uploader_vue__ = __webpack_require__(25);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__uploader_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__uploader_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__files_vue__ = __webpack_require__(22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__files_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__files_vue__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n/* harmony default export */ exports[\"default\"] = {\n    components: {modal: __WEBPACK_IMPORTED_MODULE_1__modal_vue___default.a, uploader: __WEBPACK_IMPORTED_MODULE_2__uploader_vue___default.a, files: __WEBPACK_IMPORTED_MODULE_3__files_vue___default.a},\n    props: ['files'],\n    data: function data() {\n        return {\n            active: false\n        }\n    },\n    created: function created()  {\n        __WEBPACK_IMPORTED_MODULE_0__bus__[\"a\" /* default */].$on('manager:show', this.show.bind(this))\n        __WEBPACK_IMPORTED_MODULE_0__bus__[\"a\" /* default */].$on('manager:hide', this.hide.bind(this))\n        __WEBPACK_IMPORTED_MODULE_0__bus__[\"a\" /* default */].$on('manager:toggle', this.toggle.bind(this))\n    },\n    mounted: function mounted() {\n        this.$refs.modal.$on('modal:close', this.hide.bind(this))\n    },\n    methods: {\n        show: function show() {\n            this.active = true;\n            __WEBPACK_IMPORTED_MODULE_0__bus__[\"a\" /* default */].$emit('manager:shown', this)\n        },\n        hide: function hide() {\n            this.active = false;\n            __WEBPACK_IMPORTED_MODULE_0__bus__[\"a\" /* default */].$emit('manager:hidden', this)\n        },\n        toggle: function toggle() {\n            if (this.active) {\n                this.hide()\n            } else {\n                this.show()\n            }\n        }\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vY29tcG9uZW50cy9tYWluLnZ1ZT9lOWJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmltcG9ydCBldmVudHMgZnJvbSAnLi4vYnVzJ1xuaW1wb3J0IG1vZGFsIGZyb20gJy4vbW9kYWwudnVlJ1xuaW1wb3J0IHVwbG9hZGVyIGZyb20gJy4vdXBsb2FkZXIudnVlJ1xuaW1wb3J0IGZpbGVzIGZyb20gJy4vZmlsZXMudnVlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgY29tcG9uZW50czoge21vZGFsLCB1cGxvYWRlciwgZmlsZXN9LFxuICAgIHByb3BzOiBbJ2ZpbGVzJ10sXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjdGl2ZTogZmFsc2VcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlZCgpICB7XG4gICAgICAgIGV2ZW50cy4kb24oJ21hbmFnZXI6c2hvdycsIHRoaXMuc2hvdy5iaW5kKHRoaXMpKVxuICAgICAgICBldmVudHMuJG9uKCdtYW5hZ2VyOmhpZGUnLCB0aGlzLmhpZGUuYmluZCh0aGlzKSlcbiAgICAgICAgZXZlbnRzLiRvbignbWFuYWdlcjp0b2dnbGUnLCB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpKVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy4kcmVmcy5tb2RhbC4kb24oJ21vZGFsOmNsb3NlJywgdGhpcy5oaWRlLmJpbmQodGhpcykpXG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBldmVudHMuJGVtaXQoJ21hbmFnZXI6c2hvd24nLCB0aGlzKVxuICAgICAgICB9LFxuICAgICAgICBoaWRlKCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGV2ZW50cy4kZW1pdCgnbWFuYWdlcjpoaWRkZW4nLCB0aGlzKVxuICAgICAgICB9LFxuICAgICAgICB0b2dnbGUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3coKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGNvbXBvbmVudHMvbWFpbi52dWUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bus__ = __webpack_require__(0);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n/* harmony default export */ exports[\"default\"] = {\n    props: ['active'],\n    methods: {\n        close: function close() {\n            this.$emit('modal:close', this)\n        }\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vY29tcG9uZW50cy9tb2RhbC52dWU/YzQyOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5pbXBvcnQgZXZlbnRzIGZyb20gJy4uL2J1cydcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIHByb3BzOiBbJ2FjdGl2ZSddLFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdtb2RhbDpjbG9zZScsIHRoaXMpXG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gY29tcG9uZW50cy9tb2RhbC52dWUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_fine_uploader_lib_s3__ = __webpack_require__(15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_fine_uploader_lib_s3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_fine_uploader_lib_s3__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n/* harmony default export */ exports[\"default\"] = {\n    mounted: function mounted() {\n        var uploader = new __WEBPACK_IMPORTED_MODULE_0_fine_uploader_lib_s3___default.a.s3.FineUploader({\n            element: this.$refs.uploader\n        })\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vY29tcG9uZW50cy91cGxvYWRlci52dWU/OGE3MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuaW1wb3J0IGZpbmUgZnJvbSAnZmluZS11cGxvYWRlci9saWIvczMnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBtb3VudGVkKCkge1xuICAgICAgICBsZXQgdXBsb2FkZXIgPSBuZXcgZmluZS5zMy5GaW5lVXBsb2FkZXIoe1xuICAgICAgICAgICAgZWxlbWVudDogdGhpcy4kcmVmcy51cGxvYWRlclxuICAgICAgICB9KVxuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjb21wb25lbnRzL3VwbG9hZGVyLnZ1ZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//  Chance.js 1.0.4\n//  http://chancejs.com\n//  (c) 2013 Victor Quinn\n//  Chance may be freely distributed or modified under the MIT license.\n\n(function () {\n\n    // Constants\n    var MAX_INT = 9007199254740992;\n    var MIN_INT = -MAX_INT;\n    var NUMBERS = '0123456789';\n    var CHARS_LOWER = 'abcdefghijklmnopqrstuvwxyz';\n    var CHARS_UPPER = CHARS_LOWER.toUpperCase();\n    var HEX_POOL  = NUMBERS + \"abcdef\";\n\n    // Cached array helpers\n    var slice = Array.prototype.slice;\n\n    // Constructor\n    function Chance (seed) {\n        if (!(this instanceof Chance)) {\n            return seed == null ? new Chance() : new Chance(seed);\n        }\n\n        // if user has provided a function, use that as the generator\n        if (typeof seed === 'function') {\n            this.random = seed;\n            return this;\n        }\n\n        if (arguments.length) {\n            // set a starting value of zero so we can add to it\n            this.seed = 0;\n        }\n\n        // otherwise, leave this.seed blank so that MT will receive a blank\n\n        for (var i = 0; i < arguments.length; i++) {\n            var seedling = 0;\n            if (Object.prototype.toString.call(arguments[i]) === '[object String]') {\n                for (var j = 0; j < arguments[i].length; j++) {\n                    // create a numeric hash for each argument, add to seedling\n                    var hash = 0;\n                    for (var k = 0; k < arguments[i].length; k++) {\n                        hash = arguments[i].charCodeAt(k) + (hash << 6) + (hash << 16) - hash;\n                    }\n                    seedling += hash;\n                }\n            } else {\n                seedling = arguments[i];\n            }\n            this.seed += (arguments.length - i) * seedling;\n        }\n\n        // If no generator function was provided, use our MT\n        this.mt = this.mersenne_twister(this.seed);\n        this.bimd5 = this.blueimp_md5();\n        this.random = function () {\n            return this.mt.random(this.seed);\n        };\n\n        return this;\n    }\n\n    Chance.prototype.VERSION = \"1.0.4\";\n\n    // Random helper functions\n    function initOptions(options, defaults) {\n        options || (options = {});\n\n        if (defaults) {\n            for (var i in defaults) {\n                if (typeof options[i] === 'undefined') {\n                    options[i] = defaults[i];\n                }\n            }\n        }\n\n        return options;\n    }\n\n    function testRange(test, errorMessage) {\n        if (test) {\n            throw new RangeError(errorMessage);\n        }\n    }\n\n    /**\n     * Encode the input string with Base64.\n     */\n    var base64 = function() {\n        throw new Error('No Base64 encoder available.');\n    };\n\n    // Select proper Base64 encoder.\n    (function determineBase64Encoder() {\n        if (typeof btoa === 'function') {\n            base64 = btoa;\n        } else if (typeof Buffer === 'function') {\n            base64 = function(input) {\n                return new Buffer(input).toString('base64');\n            };\n        }\n    })();\n\n    // -- Basics --\n\n    /**\n     *  Return a random bool, either true or false\n     *\n     *  @param {Object} [options={ likelihood: 50 }] alter the likelihood of\n     *    receiving a true or false value back.\n     *  @throws {RangeError} if the likelihood is out of bounds\n     *  @returns {Bool} either true or false\n     */\n    Chance.prototype.bool = function (options) {\n        // likelihood of success (true)\n        options = initOptions(options, {likelihood : 50});\n\n        // Note, we could get some minor perf optimizations by checking range\n        // prior to initializing defaults, but that makes code a bit messier\n        // and the check more complicated as we have to check existence of\n        // the object then existence of the key before checking constraints.\n        // Since the options initialization should be minor computationally,\n        // decision made for code cleanliness intentionally. This is mentioned\n        // here as it's the first occurrence, will not be mentioned again.\n        testRange(\n            options.likelihood < 0 || options.likelihood > 100,\n            \"Chance: Likelihood accepts values from 0 to 100.\"\n        );\n\n        return this.random() * 100 < options.likelihood;\n    };\n\n    /**\n     *  Return a random character.\n     *\n     *  @param {Object} [options={}] can specify a character pool, only alpha,\n     *    only symbols, and casing (lower or upper)\n     *  @returns {String} a single random character\n     *  @throws {RangeError} Can only specify alpha or symbols, not both\n     */\n    Chance.prototype.character = function (options) {\n        options = initOptions(options);\n        testRange(\n            options.alpha && options.symbols,\n            \"Chance: Cannot specify both alpha and symbols.\"\n        );\n\n        var symbols = \"!@#$%^&*()[]\",\n            letters, pool;\n\n        if (options.casing === 'lower') {\n            letters = CHARS_LOWER;\n        } else if (options.casing === 'upper') {\n            letters = CHARS_UPPER;\n        } else {\n            letters = CHARS_LOWER + CHARS_UPPER;\n        }\n\n        if (options.pool) {\n            pool = options.pool;\n        } else if (options.alpha) {\n            pool = letters;\n        } else if (options.symbols) {\n            pool = symbols;\n        } else {\n            pool = letters + NUMBERS + symbols;\n        }\n\n        return pool.charAt(this.natural({max: (pool.length - 1)}));\n    };\n\n    // Note, wanted to use \"float\" or \"double\" but those are both JS reserved words.\n\n    // Note, fixed means N OR LESS digits after the decimal. This because\n    // It could be 14.9000 but in JavaScript, when this is cast as a number,\n    // the trailing zeroes are dropped. Left to the consumer if trailing zeroes are\n    // needed\n    /**\n     *  Return a random floating point number\n     *\n     *  @param {Object} [options={}] can specify a fixed precision, min, max\n     *  @returns {Number} a single floating point number\n     *  @throws {RangeError} Can only specify fixed or precision, not both. Also\n     *    min cannot be greater than max\n     */\n    Chance.prototype.floating = function (options) {\n        options = initOptions(options, {fixed : 4});\n        testRange(\n            options.fixed && options.precision,\n            \"Chance: Cannot specify both fixed and precision.\"\n        );\n\n        var num;\n        var fixed = Math.pow(10, options.fixed);\n\n        var max = MAX_INT / fixed;\n        var min = -max;\n\n        testRange(\n            options.min && options.fixed && options.min < min,\n            \"Chance: Min specified is out of range with fixed. Min should be, at least, \" + min\n        );\n        testRange(\n            options.max && options.fixed && options.max > max,\n            \"Chance: Max specified is out of range with fixed. Max should be, at most, \" + max\n        );\n\n        options = initOptions(options, { min : min, max : max });\n\n        // Todo - Make this work!\n        // options.precision = (typeof options.precision !== \"undefined\") ? options.precision : false;\n\n        num = this.integer({min: options.min * fixed, max: options.max * fixed});\n        var num_fixed = (num / fixed).toFixed(options.fixed);\n\n        return parseFloat(num_fixed);\n    };\n\n    /**\n     *  Return a random integer\n     *\n     *  NOTE the max and min are INCLUDED in the range. So:\n     *  chance.integer({min: 1, max: 3});\n     *  would return either 1, 2, or 3.\n     *\n     *  @param {Object} [options={}] can specify a min and/or max\n     *  @returns {Number} a single random integer number\n     *  @throws {RangeError} min cannot be greater than max\n     */\n    Chance.prototype.integer = function (options) {\n        // 9007199254740992 (2^53) is the max integer number in JavaScript\n        // See: http://vq.io/132sa2j\n        options = initOptions(options, {min: MIN_INT, max: MAX_INT});\n        testRange(options.min > options.max, \"Chance: Min cannot be greater than Max.\");\n\n        return Math.floor(this.random() * (options.max - options.min + 1) + options.min);\n    };\n\n    /**\n     *  Return a random natural\n     *\n     *  NOTE the max and min are INCLUDED in the range. So:\n     *  chance.natural({min: 1, max: 3});\n     *  would return either 1, 2, or 3.\n     *\n     *  @param {Object} [options={}] can specify a min and/or max\n     *  @returns {Number} a single random integer number\n     *  @throws {RangeError} min cannot be greater than max\n     */\n    Chance.prototype.natural = function (options) {\n        options = initOptions(options, {min: 0, max: MAX_INT});\n        testRange(options.min < 0, \"Chance: Min cannot be less than zero.\");\n        return this.integer(options);\n    };\n\n    /**\n     *  Return a random string\n     *\n     *  @param {Object} [options={}] can specify a length\n     *  @returns {String} a string of random length\n     *  @throws {RangeError} length cannot be less than zero\n     */\n    Chance.prototype.string = function (options) {\n        options = initOptions(options, { length: this.natural({min: 5, max: 20}) });\n        testRange(options.length < 0, \"Chance: Length cannot be less than zero.\");\n        var length = options.length,\n            text = this.n(this.character, length, options);\n\n        return text.join(\"\");\n    };\n\n    // -- End Basics --\n\n    // -- Helpers --\n\n    Chance.prototype.capitalize = function (word) {\n        return word.charAt(0).toUpperCase() + word.substr(1);\n    };\n\n    Chance.prototype.mixin = function (obj) {\n        for (var func_name in obj) {\n            Chance.prototype[func_name] = obj[func_name];\n        }\n        return this;\n    };\n\n    /**\n     *  Given a function that generates something random and a number of items to generate,\n     *    return an array of items where none repeat.\n     *\n     *  @param {Function} fn the function that generates something random\n     *  @param {Number} num number of terms to generate\n     *  @param {Object} options any options to pass on to the generator function\n     *  @returns {Array} an array of length `num` with every item generated by `fn` and unique\n     *\n     *  There can be more parameters after these. All additional parameters are provided to the given function\n     */\n    Chance.prototype.unique = function(fn, num, options) {\n        testRange(\n            typeof fn !== \"function\",\n            \"Chance: The first argument must be a function.\"\n        );\n\n        var comparator = function(arr, val) { return arr.indexOf(val) !== -1; };\n\n        if (options) {\n            comparator = options.comparator || comparator;\n        }\n\n        var arr = [], count = 0, result, MAX_DUPLICATES = num * 50, params = slice.call(arguments, 2);\n\n        while (arr.length < num) {\n            var clonedParams = JSON.parse(JSON.stringify(params));\n            result = fn.apply(this, clonedParams);\n            if (!comparator(arr, result)) {\n                arr.push(result);\n                // reset count when unique found\n                count = 0;\n            }\n\n            if (++count > MAX_DUPLICATES) {\n                throw new RangeError(\"Chance: num is likely too large for sample set\");\n            }\n        }\n        return arr;\n    };\n\n    /**\n     *  Gives an array of n random terms\n     *\n     *  @param {Function} fn the function that generates something random\n     *  @param {Number} n number of terms to generate\n     *  @returns {Array} an array of length `n` with items generated by `fn`\n     *\n     *  There can be more parameters after these. All additional parameters are provided to the given function\n     */\n    Chance.prototype.n = function(fn, n) {\n        testRange(\n            typeof fn !== \"function\",\n            \"Chance: The first argument must be a function.\"\n        );\n\n        if (typeof n === 'undefined') {\n            n = 1;\n        }\n        var i = n, arr = [], params = slice.call(arguments, 2);\n\n        // Providing a negative count should result in a noop.\n        i = Math.max( 0, i );\n\n        for (null; i--; null) {\n            arr.push(fn.apply(this, params));\n        }\n\n        return arr;\n    };\n\n    // H/T to SO for this one: http://vq.io/OtUrZ5\n    Chance.prototype.pad = function (number, width, pad) {\n        // Default pad to 0 if none provided\n        pad = pad || '0';\n        // Convert number to a string\n        number = number + '';\n        return number.length >= width ? number : new Array(width - number.length + 1).join(pad) + number;\n    };\n\n    // DEPRECATED on 2015-10-01\n    Chance.prototype.pick = function (arr, count) {\n        if (arr.length === 0) {\n            throw new RangeError(\"Chance: Cannot pick() from an empty array\");\n        }\n        if (!count || count === 1) {\n            return arr[this.natural({max: arr.length - 1})];\n        } else {\n            return this.shuffle(arr).slice(0, count);\n        }\n    };\n\n    // Given an array, returns a single random element\n    Chance.prototype.pickone = function (arr) {\n        if (arr.length === 0) {\n          throw new RangeError(\"Chance: Cannot pickone() from an empty array\");\n        }\n        return arr[this.natural({max: arr.length - 1})];\n    };\n\n    // Given an array, returns a random set with 'count' elements\n    Chance.prototype.pickset = function (arr, count) {\n        if (count === 0) {\n            return [];\n        }\n        if (arr.length === 0) {\n            throw new RangeError(\"Chance: Cannot pickset() from an empty array\");\n        }\n        if (count < 0) {\n            throw new RangeError(\"Chance: count must be positive number\");\n        }\n        if (!count || count === 1) {\n            return [ this.pickone(arr) ];\n        } else {\n            return this.shuffle(arr).slice(0, count);\n        }\n    };\n\n    Chance.prototype.shuffle = function (arr) {\n        var old_array = arr.slice(0),\n            new_array = [],\n            j = 0,\n            length = Number(old_array.length);\n\n        for (var i = 0; i < length; i++) {\n            // Pick a random index from the array\n            j = this.natural({max: old_array.length - 1});\n            // Add it to the new array\n            new_array[i] = old_array[j];\n            // Remove that element from the original array\n            old_array.splice(j, 1);\n        }\n\n        return new_array;\n    };\n\n    // Returns a single item from an array with relative weighting of odds\n    Chance.prototype.weighted = function (arr, weights, trim) {\n        if (arr.length !== weights.length) {\n            throw new RangeError(\"Chance: length of array and weights must match\");\n        }\n\n        // scan weights array and sum valid entries\n        var sum = 0;\n        var val;\n        for (var weightIndex = 0; weightIndex < weights.length; ++weightIndex) {\n            val = weights[weightIndex];\n            if (val > 0) {\n                sum += val;\n            }\n        }\n\n        if (sum === 0) {\n            throw new RangeError(\"Chance: no valid entries in array weights\");\n        }\n\n        // select a value within range\n        var selected = this.random() * sum;\n\n        // find array entry corresponding to selected value\n        var total = 0;\n        var lastGoodIdx = -1;\n        var chosenIdx;\n        for (weightIndex = 0; weightIndex < weights.length; ++weightIndex) {\n            val = weights[weightIndex];\n            total += val;\n            if (val > 0) {\n                if (selected <= total) {\n                    chosenIdx = weightIndex;\n                    break;\n                }\n                lastGoodIdx = weightIndex;\n            }\n\n            // handle any possible rounding error comparison to ensure something is picked\n            if (weightIndex === (weights.length - 1)) {\n                chosenIdx = lastGoodIdx;\n            }\n        }\n\n        var chosen = arr[chosenIdx];\n        trim = (typeof trim === 'undefined') ? false : trim;\n        if (trim) {\n            arr.splice(chosenIdx, 1);\n            weights.splice(chosenIdx, 1);\n        }\n\n        return chosen;\n    };\n\n    // -- End Helpers --\n\n    // -- Text --\n\n    Chance.prototype.paragraph = function (options) {\n        options = initOptions(options);\n\n        var sentences = options.sentences || this.natural({min: 3, max: 7}),\n            sentence_array = this.n(this.sentence, sentences);\n\n        return sentence_array.join(' ');\n    };\n\n    // Could get smarter about this than generating random words and\n    // chaining them together. Such as: http://vq.io/1a5ceOh\n    Chance.prototype.sentence = function (options) {\n        options = initOptions(options);\n\n        var words = options.words || this.natural({min: 12, max: 18}),\n            punctuation = options.punctuation,\n            text, word_array = this.n(this.word, words);\n\n        text = word_array.join(' ');\n\n        // Capitalize first letter of sentence\n        text = this.capitalize(text);\n\n        // Make sure punctuation has a usable value\n        if (punctuation !== false && !/^[\\.\\?;!:]$/.test(punctuation)) {\n            punctuation = '.';\n        }\n\n        // Add punctuation mark\n        if (punctuation) {\n            text += punctuation;\n        }\n\n        return text;\n    };\n\n    Chance.prototype.syllable = function (options) {\n        options = initOptions(options);\n\n        var length = options.length || this.natural({min: 2, max: 3}),\n            consonants = 'bcdfghjklmnprstvwz', // consonants except hard to speak ones\n            vowels = 'aeiou', // vowels\n            all = consonants + vowels, // all\n            text = '',\n            chr;\n\n        // I'm sure there's a more elegant way to do this, but this works\n        // decently well.\n        for (var i = 0; i < length; i++) {\n            if (i === 0) {\n                // First character can be anything\n                chr = this.character({pool: all});\n            } else if (consonants.indexOf(chr) === -1) {\n                // Last character was a vowel, now we want a consonant\n                chr = this.character({pool: consonants});\n            } else {\n                // Last character was a consonant, now we want a vowel\n                chr = this.character({pool: vowels});\n            }\n\n            text += chr;\n        }\n\n        if (options.capitalize) {\n            text = this.capitalize(text);\n        }\n\n        return text;\n    };\n\n    Chance.prototype.word = function (options) {\n        options = initOptions(options);\n\n        testRange(\n            options.syllables && options.length,\n            \"Chance: Cannot specify both syllables AND length.\"\n        );\n\n        var syllables = options.syllables || this.natural({min: 1, max: 3}),\n            text = '';\n\n        if (options.length) {\n            // Either bound word by length\n            do {\n                text += this.syllable();\n            } while (text.length < options.length);\n            text = text.substring(0, options.length);\n        } else {\n            // Or by number of syllables\n            for (var i = 0; i < syllables; i++) {\n                text += this.syllable();\n            }\n        }\n\n        if (options.capitalize) {\n            text = this.capitalize(text);\n        }\n\n        return text;\n    };\n\n    // -- End Text --\n\n    // -- Person --\n\n    Chance.prototype.age = function (options) {\n        options = initOptions(options);\n        var ageRange;\n\n        switch (options.type) {\n            case 'child':\n                ageRange = {min: 0, max: 12};\n                break;\n            case 'teen':\n                ageRange = {min: 13, max: 19};\n                break;\n            case 'adult':\n                ageRange = {min: 18, max: 65};\n                break;\n            case 'senior':\n                ageRange = {min: 65, max: 100};\n                break;\n            case 'all':\n                ageRange = {min: 0, max: 100};\n                break;\n            default:\n                ageRange = {min: 18, max: 65};\n                break;\n        }\n\n        return this.natural(ageRange);\n    };\n\n    Chance.prototype.birthday = function (options) {\n        var age = this.age(options);\n        var currentYear = new Date().getFullYear();\n\n        if (options && options.type) {\n            var min = new Date();\n            var max = new Date();\n            min.setFullYear(currentYear - age - 1);\n            max.setFullYear(currentYear - age);\n\n            options = initOptions(options, {\n                min: min,\n                max: max\n            });\n        } else {\n            options = initOptions(options, {\n                year: currentYear - age\n            });\n        }\n\n        return this.date(options);\n    };\n\n    // CPF; ID to identify taxpayers in Brazil\n    Chance.prototype.cpf = function (options) {\n        options = initOptions(options, {\n            formatted: true\n        });\n\n        var n = this.n(this.natural, 9, { max: 9 });\n        var d1 = n[8]*2+n[7]*3+n[6]*4+n[5]*5+n[4]*6+n[3]*7+n[2]*8+n[1]*9+n[0]*10;\n        d1 = 11 - (d1 % 11);\n        if (d1>=10) {\n            d1 = 0;\n        }\n        var d2 = d1*2+n[8]*3+n[7]*4+n[6]*5+n[5]*6+n[4]*7+n[3]*8+n[2]*9+n[1]*10+n[0]*11;\n        d2 = 11 - (d2 % 11);\n        if (d2>=10) {\n            d2 = 0;\n        }\n        var cpf = ''+n[0]+n[1]+n[2]+'.'+n[3]+n[4]+n[5]+'.'+n[6]+n[7]+n[8]+'-'+d1+d2;\n        return options.formatted ? cpf : cpf.replace(/\\D/g,'');\n    };\n\n    // CNPJ: ID to identify companies in Brazil\n    Chance.prototype.cnpj = function (options) {\n        options = initOptions(options, {\n            formatted: true\n        });\n\n        var n = this.n(this.natural, 12, { max: 12 });\n        var d1 = n[11]*2+n[10]*3+n[9]*4+n[8]*5+n[7]*6+n[6]*7+n[5]*8+n[4]*9+n[3]*2+n[2]*3+n[1]*4+n[0]*5;\n        d1 = 11 - (d1 % 11);\n        if (d1<2) {\n            d1 = 0;\n        }\n        var d2 = d1*2+n[11]*3+n[10]*4+n[9]*5+n[8]*6+n[7]*7+n[6]*8+n[5]*9+n[4]*2+n[3]*3+n[2]*4+n[1]*5+n[0]*6;\n        d2 = 11 - (d2 % 11);\n        if (d2<2) {\n            d2 = 0;\n        }\n        var cnpj = ''+n[0]+n[1]+'.'+n[2]+n[3]+n[4]+'.'+n[5]+n[6]+n[7]+'/'+n[8]+n[9]+n[10]+n[11]+'-'+d1+d2;\n        return options.formatted ? cnpj : cnpj.replace(/\\D/g,'');\n    };\n\n    Chance.prototype.first = function (options) {\n        options = initOptions(options, {gender: this.gender(), nationality: 'en'});\n        return this.pick(this.get(\"firstNames\")[options.gender.toLowerCase()][options.nationality.toLowerCase()]);\n    };\n\n    Chance.prototype.gender = function (options) {\n        options = initOptions(options, {extraGenders: []});\n        return this.pick(['Male', 'Female'].concat(options.extraGenders));\n    };\n\n    Chance.prototype.last = function (options) {\n        options = initOptions(options, {nationality: 'en'});\n        return this.pick(this.get(\"lastNames\")[options.nationality.toLowerCase()]);\n    };\n\n    Chance.prototype.israelId=function(){\n        var x=this.string({pool: '0123456789',length:8});\n        var y=0;\n        for (var i=0;i<x.length;i++){\n            var thisDigit=  x[i] *  (i/2===parseInt(i/2) ? 1 : 2);\n            thisDigit=this.pad(thisDigit,2).toString();\n            thisDigit=parseInt(thisDigit[0]) + parseInt(thisDigit[1]);\n            y=y+thisDigit;\n        }\n        x=x+(10-parseInt(y.toString().slice(-1))).toString().slice(-1);\n        return x;\n    };\n\n    Chance.prototype.mrz = function (options) {\n        var checkDigit = function (input) {\n            var alpha = \"<ABCDEFGHIJKLMNOPQRSTUVWXYXZ\".split(''),\n                multipliers = [ 7, 3, 1 ],\n                runningTotal = 0;\n\n            if (typeof input !== 'string') {\n                input = input.toString();\n            }\n\n            input.split('').forEach(function(character, idx) {\n                var pos = alpha.indexOf(character);\n\n                if(pos !== -1) {\n                    character = pos === 0 ? 0 : pos + 9;\n                } else {\n                    character = parseInt(character, 10);\n                }\n                character *= multipliers[idx % multipliers.length];\n                runningTotal += character;\n            });\n            return runningTotal % 10;\n        };\n        var generate = function (opts) {\n            var pad = function (length) {\n                return new Array(length + 1).join('<');\n            };\n            var number = [ 'P<',\n                           opts.issuer,\n                           opts.last.toUpperCase(),\n                           '<<',\n                           opts.first.toUpperCase(),\n                           pad(39 - (opts.last.length + opts.first.length + 2)),\n                           opts.passportNumber,\n                           checkDigit(opts.passportNumber),\n                           opts.nationality,\n                           opts.dob,\n                           checkDigit(opts.dob),\n                           opts.gender,\n                           opts.expiry,\n                           checkDigit(opts.expiry),\n                           pad(14),\n                           checkDigit(pad(14)) ].join('');\n\n            return number +\n                (checkDigit(number.substr(44, 10) +\n                            number.substr(57, 7) +\n                            number.substr(65, 7)));\n        };\n\n        var that = this;\n\n        options = initOptions(options, {\n            first: this.first(),\n            last: this.last(),\n            passportNumber: this.integer({min: 100000000, max: 999999999}),\n            dob: (function () {\n                var date = that.birthday({type: 'adult'});\n                return [date.getFullYear().toString().substr(2),\n                        that.pad(date.getMonth() + 1, 2),\n                        that.pad(date.getDate(), 2)].join('');\n            }()),\n            expiry: (function () {\n                var date = new Date();\n                return [(date.getFullYear() + 5).toString().substr(2),\n                        that.pad(date.getMonth() + 1, 2),\n                        that.pad(date.getDate(), 2)].join('');\n            }()),\n            gender: this.gender() === 'Female' ? 'F': 'M',\n            issuer: 'GBR',\n            nationality: 'GBR'\n        });\n        return generate (options);\n    };\n\n    Chance.prototype.name = function (options) {\n        options = initOptions(options);\n\n        var first = this.first(options),\n            last = this.last(options),\n            name;\n\n        if (options.middle) {\n            name = first + ' ' + this.first(options) + ' ' + last;\n        } else if (options.middle_initial) {\n            name = first + ' ' + this.character({alpha: true, casing: 'upper'}) + '. ' + last;\n        } else {\n            name = first + ' ' + last;\n        }\n\n        if (options.prefix) {\n            name = this.prefix(options) + ' ' + name;\n        }\n\n        if (options.suffix) {\n            name = name + ' ' + this.suffix(options);\n        }\n\n        return name;\n    };\n\n    // Return the list of available name prefixes based on supplied gender.\n    // @todo introduce internationalization\n    Chance.prototype.name_prefixes = function (gender) {\n        gender = gender || \"all\";\n        gender = gender.toLowerCase();\n\n        var prefixes = [\n            { name: 'Doctor', abbreviation: 'Dr.' }\n        ];\n\n        if (gender === \"male\" || gender === \"all\") {\n            prefixes.push({ name: 'Mister', abbreviation: 'Mr.' });\n        }\n\n        if (gender === \"female\" || gender === \"all\") {\n            prefixes.push({ name: 'Miss', abbreviation: 'Miss' });\n            prefixes.push({ name: 'Misses', abbreviation: 'Mrs.' });\n        }\n\n        return prefixes;\n    };\n\n    // Alias for name_prefix\n    Chance.prototype.prefix = function (options) {\n        return this.name_prefix(options);\n    };\n\n    Chance.prototype.name_prefix = function (options) {\n        options = initOptions(options, { gender: \"all\" });\n        return options.full ?\n            this.pick(this.name_prefixes(options.gender)).name :\n            this.pick(this.name_prefixes(options.gender)).abbreviation;\n    };\n    //Hungarian ID number\n    Chance.prototype.HIDN= function(){\n     //Hungarian ID nuber structure: XXXXXXYY (X=number,Y=Capital Latin letter)\n      var idn_pool=\"0123456789\";\n      var idn_chrs=\"ABCDEFGHIJKLMNOPQRSTUVWXYXZ\";\n      var idn=\"\";\n        idn+=this.string({pool:idn_pool,length:6});\n        idn+=this.string({pool:idn_chrs,length:2});\n        return idn;\n    };\n\n\n    Chance.prototype.ssn = function (options) {\n        options = initOptions(options, {ssnFour: false, dashes: true});\n        var ssn_pool = \"1234567890\",\n            ssn,\n            dash = options.dashes ? '-' : '';\n\n        if(!options.ssnFour) {\n            ssn = this.string({pool: ssn_pool, length: 3}) + dash +\n            this.string({pool: ssn_pool, length: 2}) + dash +\n            this.string({pool: ssn_pool, length: 4});\n        } else {\n            ssn = this.string({pool: ssn_pool, length: 4});\n        }\n        return ssn;\n    };\n\n    // Return the list of available name suffixes\n    // @todo introduce internationalization\n    Chance.prototype.name_suffixes = function () {\n        var suffixes = [\n            { name: 'Doctor of Osteopathic Medicine', abbreviation: 'D.O.' },\n            { name: 'Doctor of Philosophy', abbreviation: 'Ph.D.' },\n            { name: 'Esquire', abbreviation: 'Esq.' },\n            { name: 'Junior', abbreviation: 'Jr.' },\n            { name: 'Juris Doctor', abbreviation: 'J.D.' },\n            { name: 'Master of Arts', abbreviation: 'M.A.' },\n            { name: 'Master of Business Administration', abbreviation: 'M.B.A.' },\n            { name: 'Master of Science', abbreviation: 'M.S.' },\n            { name: 'Medical Doctor', abbreviation: 'M.D.' },\n            { name: 'Senior', abbreviation: 'Sr.' },\n            { name: 'The Third', abbreviation: 'III' },\n            { name: 'The Fourth', abbreviation: 'IV' },\n            { name: 'Bachelor of Engineering', abbreviation: 'B.E' },\n            { name: 'Bachelor of Technology', abbreviation: 'B.TECH' }\n        ];\n        return suffixes;\n    };\n\n    // Alias for name_suffix\n    Chance.prototype.suffix = function (options) {\n        return this.name_suffix(options);\n    };\n\n    Chance.prototype.name_suffix = function (options) {\n        options = initOptions(options);\n        return options.full ?\n            this.pick(this.name_suffixes()).name :\n            this.pick(this.name_suffixes()).abbreviation;\n    };\n\n    Chance.prototype.nationalities = function () {\n        return this.get(\"nationalities\");\n    };\n\n    // Generate random nationality based on json list\n    Chance.prototype.nationality = function () {\n        var nationality = this.pick(this.nationalities());\n        return nationality.name;\n    };\n\n    // -- End Person --\n\n    // -- Mobile --\n    // Android GCM Registration ID\n    Chance.prototype.android_id = function () {\n        return \"APA91\" + this.string({ pool: \"0123456789abcefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_\", length: 178 });\n    };\n\n    // Apple Push Token\n    Chance.prototype.apple_token = function () {\n        return this.string({ pool: \"abcdef1234567890\", length: 64 });\n    };\n\n    // Windows Phone 8 ANID2\n    Chance.prototype.wp8_anid2 = function () {\n        return base64( this.hash( { length : 32 } ) );\n    };\n\n    // Windows Phone 7 ANID\n    Chance.prototype.wp7_anid = function () {\n        return 'A=' + this.guid().replace(/-/g, '').toUpperCase() + '&E=' + this.hash({ length:3 }) + '&W=' + this.integer({ min:0, max:9 });\n    };\n\n    // BlackBerry Device PIN\n    Chance.prototype.bb_pin = function () {\n        return this.hash({ length: 8 });\n    };\n\n    // -- End Mobile --\n\n    // -- Web --\n    Chance.prototype.avatar = function (options) {\n        var url = null;\n        var URL_BASE = '//www.gravatar.com/avatar/';\n        var PROTOCOLS = {\n            http: 'http',\n            https: 'https'\n        };\n        var FILE_TYPES = {\n            bmp: 'bmp',\n            gif: 'gif',\n            jpg: 'jpg',\n            png: 'png'\n        };\n        var FALLBACKS = {\n            '404': '404', // Return 404 if not found\n            mm: 'mm', // Mystery man\n            identicon: 'identicon', // Geometric pattern based on hash\n            monsterid: 'monsterid', // A generated monster icon\n            wavatar: 'wavatar', // A generated face\n            retro: 'retro', // 8-bit icon\n            blank: 'blank' // A transparent png\n        };\n        var RATINGS = {\n            g: 'g',\n            pg: 'pg',\n            r: 'r',\n            x: 'x'\n        };\n        var opts = {\n            protocol: null,\n            email: null,\n            fileExtension: null,\n            size: null,\n            fallback: null,\n            rating: null\n        };\n\n        if (!options) {\n            // Set to a random email\n            opts.email = this.email();\n            options = {};\n        }\n        else if (typeof options === 'string') {\n            opts.email = options;\n            options = {};\n        }\n        else if (typeof options !== 'object') {\n            return null;\n        }\n        else if (options.constructor === 'Array') {\n            return null;\n        }\n\n        opts = initOptions(options, opts);\n\n        if (!opts.email) {\n            // Set to a random email\n            opts.email = this.email();\n        }\n\n        // Safe checking for params\n        opts.protocol = PROTOCOLS[opts.protocol] ? opts.protocol + ':' : '';\n        opts.size = parseInt(opts.size, 0) ? opts.size : '';\n        opts.rating = RATINGS[opts.rating] ? opts.rating : '';\n        opts.fallback = FALLBACKS[opts.fallback] ? opts.fallback : '';\n        opts.fileExtension = FILE_TYPES[opts.fileExtension] ? opts.fileExtension : '';\n\n        url =\n            opts.protocol +\n            URL_BASE +\n            this.bimd5.md5(opts.email) +\n            (opts.fileExtension ? '.' + opts.fileExtension : '') +\n            (opts.size || opts.rating || opts.fallback ? '?' : '') +\n            (opts.size ? '&s=' + opts.size.toString() : '') +\n            (opts.rating ? '&r=' + opts.rating : '') +\n            (opts.fallback ? '&d=' + opts.fallback : '')\n            ;\n\n        return url;\n    };\n\n    /**\n     * #Description:\n     * ===============================================\n     * Generate random color value base on color type:\n     * -> hex\n     * -> rgb\n     * -> rgba\n     * -> 0x\n     * -> named color\n     *\n     * #Examples:\n     * ===============================================\n     * * Geerate random hex color\n     * chance.color() => '#79c157' / 'rgb(110,52,164)' / '0x67ae0b' / '#e2e2e2' / '#29CFA7'\n     *\n     * * Generate Hex based color value\n     * chance.color({format: 'hex'})    => '#d67118'\n     *\n     * * Generate simple rgb value\n     * chance.color({format: 'rgb'})    => 'rgb(110,52,164)'\n     *\n     * * Generate Ox based color value\n     * chance.color({format: '0x'})     => '0x67ae0b'\n     *\n     * * Generate graiscale based value\n     * chance.color({grayscale: true})  => '#e2e2e2'\n     *\n     * * Return valide color name\n     * chance.color({format: 'name'})   => 'red'\n     *\n     * * Make color uppercase\n     * chance.color({casing: 'upper'})  => '#29CFA7'\n     *\n     * @param  [object] options\n     * @return [string] color value\n     */\n    Chance.prototype.color = function (options) {\n\n        function gray(value, delimiter) {\n            return [value, value, value].join(delimiter || '');\n        }\n\n        function rgb(hasAlpha) {\n\n            var rgbValue    = (hasAlpha)    ? 'rgba' : 'rgb';\n            var alphaChanal = (hasAlpha)    ? (',' + this.floating({min:0, max:1})) : \"\";\n            var colorValue  = (isGrayscale) ? (gray(this.natural({max: 255}), ',')) : (this.natural({max: 255}) + ',' + this.natural({max: 255}) + ',' + this.natural({max: 255}));\n\n            return rgbValue + '(' + colorValue + alphaChanal + ')';\n        }\n\n        function hex(start, end, withHash) {\n\n            var simbol = (withHash) ? \"#\" : \"\";\n            var expression  = (isGrayscale ? gray(this.hash({length: start})) : this.hash({length: end}));\n            return simbol + expression;\n        }\n\n        options = initOptions(options, {\n            format: this.pick(['hex', 'shorthex', 'rgb', 'rgba', '0x', 'name']),\n            grayscale: false,\n            casing: 'lower'\n        });\n\n        var isGrayscale = options.grayscale;\n        var colorValue;\n\n        if (options.format === 'hex') {\n            colorValue =  hex.call(this, 2, 6, true);\n        }\n        else if (options.format === 'shorthex') {\n            colorValue = hex.call(this, 1, 3, true);\n        }\n        else if (options.format === 'rgb') {\n            colorValue = rgb.call(this, false);\n        }\n        else if (options.format === 'rgba') {\n            colorValue = rgb.call(this, true);\n        }\n        else if (options.format === '0x') {\n            colorValue = '0x' + hex.call(this, 2, 6);\n        }\n        else if(options.format === 'name') {\n            return this.pick(this.get(\"colorNames\"));\n        }\n        else {\n            throw new RangeError('Invalid format provided. Please provide one of \"hex\", \"shorthex\", \"rgb\", \"rgba\", \"0x\" or \"name\".');\n        }\n\n        if (options.casing === 'upper' ) {\n            colorValue = colorValue.toUpperCase();\n        }\n\n        return colorValue;\n    };\n\n    Chance.prototype.domain = function (options) {\n        options = initOptions(options);\n        return this.word() + '.' + (options.tld || this.tld());\n    };\n\n    Chance.prototype.email = function (options) {\n        options = initOptions(options);\n        return this.word({length: options.length}) + '@' + (options.domain || this.domain());\n    };\n\n    Chance.prototype.fbid = function () {\n        return parseInt('10000' + this.natural({max: 100000000000}), 10);\n    };\n\n    Chance.prototype.google_analytics = function () {\n        var account = this.pad(this.natural({max: 999999}), 6);\n        var property = this.pad(this.natural({max: 99}), 2);\n\n        return 'UA-' + account + '-' + property;\n    };\n\n    Chance.prototype.hashtag = function () {\n        return '#' + this.word();\n    };\n\n    Chance.prototype.ip = function () {\n        // Todo: This could return some reserved IPs. See http://vq.io/137dgYy\n        // this should probably be updated to account for that rare as it may be\n        return this.natural({min: 1, max: 254}) + '.' +\n               this.natural({max: 255}) + '.' +\n               this.natural({max: 255}) + '.' +\n               this.natural({min: 1, max: 254});\n    };\n\n    Chance.prototype.ipv6 = function () {\n        var ip_addr = this.n(this.hash, 8, {length: 4});\n\n        return ip_addr.join(\":\");\n    };\n\n    Chance.prototype.klout = function () {\n        return this.natural({min: 1, max: 99});\n    };\n\n    Chance.prototype.semver = function (options) {\n        options = initOptions(options, { include_prerelease: true });\n\n        var range = this.pickone([\"^\", \"~\", \"<\", \">\", \"<=\", \">=\", \"=\"]);\n        if (options.range) {\n            range = options.range;\n        }\n\n        var prerelease = \"\";\n        if (options.include_prerelease) {\n            prerelease = this.weighted([\"\", \"-dev\", \"-beta\", \"-alpha\"], [50, 10, 5, 1]);\n        }\n        return range + this.rpg('3d10').join('.') + prerelease;\n    };\n\n    Chance.prototype.tlds = function () {\n        return ['com', 'org', 'edu', 'gov', 'co.uk', 'net', 'io', 'ac', 'ad', 'ae', 'af', 'ag', 'ai', 'al', 'am', 'an', 'ao', 'aq', 'ar', 'as', 'at', 'au', 'aw', 'ax', 'az', 'ba', 'bb', 'bd', 'be', 'bf', 'bg', 'bh', 'bi', 'bj', 'bm', 'bn', 'bo', 'bq', 'br', 'bs', 'bt', 'bv', 'bw', 'by', 'bz', 'ca', 'cc', 'cd', 'cf', 'cg', 'ch', 'ci', 'ck', 'cl', 'cm', 'cn', 'co', 'cr', 'cu', 'cv', 'cw', 'cx', 'cy', 'cz', 'de', 'dj', 'dk', 'dm', 'do', 'dz', 'ec', 'ee', 'eg', 'eh', 'er', 'es', 'et', 'eu', 'fi', 'fj', 'fk', 'fm', 'fo', 'fr', 'ga', 'gb', 'gd', 'ge', 'gf', 'gg', 'gh', 'gi', 'gl', 'gm', 'gn', 'gp', 'gq', 'gr', 'gs', 'gt', 'gu', 'gw', 'gy', 'hk', 'hm', 'hn', 'hr', 'ht', 'hu', 'id', 'ie', 'il', 'im', 'in', 'io', 'iq', 'ir', 'is', 'it', 'je', 'jm', 'jo', 'jp', 'ke', 'kg', 'kh', 'ki', 'km', 'kn', 'kp', 'kr', 'kw', 'ky', 'kz', 'la', 'lb', 'lc', 'li', 'lk', 'lr', 'ls', 'lt', 'lu', 'lv', 'ly', 'ma', 'mc', 'md', 'me', 'mg', 'mh', 'mk', 'ml', 'mm', 'mn', 'mo', 'mp', 'mq', 'mr', 'ms', 'mt', 'mu', 'mv', 'mw', 'mx', 'my', 'mz', 'na', 'nc', 'ne', 'nf', 'ng', 'ni', 'nl', 'no', 'np', 'nr', 'nu', 'nz', 'om', 'pa', 'pe', 'pf', 'pg', 'ph', 'pk', 'pl', 'pm', 'pn', 'pr', 'ps', 'pt', 'pw', 'py', 'qa', 're', 'ro', 'rs', 'ru', 'rw', 'sa', 'sb', 'sc', 'sd', 'se', 'sg', 'sh', 'si', 'sj', 'sk', 'sl', 'sm', 'sn', 'so', 'sr', 'ss', 'st', 'su', 'sv', 'sx', 'sy', 'sz', 'tc', 'td', 'tf', 'tg', 'th', 'tj', 'tk', 'tl', 'tm', 'tn', 'to', 'tp', 'tr', 'tt', 'tv', 'tw', 'tz', 'ua', 'ug', 'uk', 'us', 'uy', 'uz', 'va', 'vc', 've', 'vg', 'vi', 'vn', 'vu', 'wf', 'ws', 'ye', 'yt', 'za', 'zm', 'zw'];\n    };\n\n    Chance.prototype.tld = function () {\n        return this.pick(this.tlds());\n    };\n\n    Chance.prototype.twitter = function () {\n        return '@' + this.word();\n    };\n\n    Chance.prototype.url = function (options) {\n        options = initOptions(options, { protocol: \"http\", domain: this.domain(options), domain_prefix: \"\", path: this.word(), extensions: []});\n\n        var extension = options.extensions.length > 0 ? \".\" + this.pick(options.extensions) : \"\";\n        var domain = options.domain_prefix ? options.domain_prefix + \".\" + options.domain : options.domain;\n\n        return options.protocol + \"://\" + domain + \"/\" + options.path + extension;\n    };\n\n    // -- End Web --\n\n    // -- Location --\n\n    Chance.prototype.address = function (options) {\n        options = initOptions(options);\n        return this.natural({min: 5, max: 2000}) + ' ' + this.street(options);\n    };\n\n    Chance.prototype.altitude = function (options) {\n        options = initOptions(options, {fixed: 5, min: 0, max: 8848});\n        return this.floating({\n            min: options.min,\n            max: options.max,\n            fixed: options.fixed\n        });\n    };\n\n    Chance.prototype.areacode = function (options) {\n        options = initOptions(options, {parens : true});\n        // Don't want area codes to start with 1, or have a 9 as the second digit\n        var areacode = this.natural({min: 2, max: 9}).toString() +\n                this.natural({min: 0, max: 8}).toString() +\n                this.natural({min: 0, max: 9}).toString();\n\n        return options.parens ? '(' + areacode + ')' : areacode;\n    };\n\n    Chance.prototype.city = function () {\n        return this.capitalize(this.word({syllables: 3}));\n    };\n\n    Chance.prototype.coordinates = function (options) {\n        return this.latitude(options) + ', ' + this.longitude(options);\n    };\n\n    Chance.prototype.countries = function () {\n        return this.get(\"countries\");\n    };\n\n    Chance.prototype.country = function (options) {\n        options = initOptions(options);\n        var country = this.pick(this.countries());\n        return options.full ? country.name : country.abbreviation;\n    };\n\n    Chance.prototype.depth = function (options) {\n        options = initOptions(options, {fixed: 5, min: -10994, max: 0});\n        return this.floating({\n            min: options.min,\n            max: options.max,\n            fixed: options.fixed\n        });\n    };\n\n    Chance.prototype.geohash = function (options) {\n        options = initOptions(options, { length: 7 });\n        return this.string({ length: options.length, pool: '0123456789bcdefghjkmnpqrstuvwxyz' });\n    };\n\n    Chance.prototype.geojson = function (options) {\n        return this.latitude(options) + ', ' + this.longitude(options) + ', ' + this.altitude(options);\n    };\n\n    Chance.prototype.latitude = function (options) {\n        options = initOptions(options, {fixed: 5, min: -90, max: 90});\n        return this.floating({min: options.min, max: options.max, fixed: options.fixed});\n    };\n\n    Chance.prototype.longitude = function (options) {\n        options = initOptions(options, {fixed: 5, min: -180, max: 180});\n        return this.floating({min: options.min, max: options.max, fixed: options.fixed});\n    };\n\n    Chance.prototype.phone = function (options) {\n        var self = this,\n            numPick,\n            ukNum = function (parts) {\n                var section = [];\n                //fills the section part of the phone number with random numbers.\n                parts.sections.forEach(function(n) {\n                    section.push(self.string({ pool: '0123456789', length: n}));\n                });\n                return parts.area + section.join(' ');\n            };\n        options = initOptions(options, {\n            formatted: true,\n            country: 'us',\n            mobile: false\n        });\n        if (!options.formatted) {\n            options.parens = false;\n        }\n        var phone;\n        switch (options.country) {\n            case 'fr':\n                if (!options.mobile) {\n                    numPick = this.pick([\n                        // Valid zone and dpartement codes.\n                        '01' + this.pick(['30', '34', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '53', '55', '56', '58', '60', '64', '69', '70', '72', '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83']) + self.string({ pool: '0123456789', length: 6}),\n                        '02' + this.pick(['14', '18', '22', '23', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '40', '41', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '56', '57', '61', '62', '69', '72', '76', '77', '78', '85', '90', '96', '97', '98', '99']) + self.string({ pool: '0123456789', length: 6}),\n                        '03' + this.pick(['10', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '39', '44', '45', '51', '52', '54', '55', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90']) + self.string({ pool: '0123456789', length: 6}),\n                        '04' + this.pick(['11', '13', '15', '20', '22', '26', '27', '30', '32', '34', '37', '42', '43', '44', '50', '56', '57', '63', '66', '67', '68', '69', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '88', '89', '90', '91', '92', '93', '94', '95', '97', '98']) + self.string({ pool: '0123456789', length: 6}),\n                        '05' + this.pick(['08', '16', '17', '19', '24', '31', '32', '33', '34', '35', '40', '45', '46', '47', '49', '53', '55', '56', '57', '58', '59', '61', '62', '63', '64', '65', '67', '79', '81', '82', '86', '87', '90', '94']) + self.string({ pool: '0123456789', length: 6}),\n                        '09' + self.string({ pool: '0123456789', length: 8}),\n                    ]);\n                    phone = options.formatted ? numPick.match(/../g).join(' ') : numPick;\n                } else {\n                    numPick = this.pick(['06', '07']) + self.string({ pool: '0123456789', length: 8});\n                    phone = options.formatted ? numPick.match(/../g).join(' ') : numPick;\n                }\n                break;\n            case 'uk':\n                if (!options.mobile) {\n                    numPick = this.pick([\n                        //valid area codes of major cities/counties followed by random numbers in required format.\n                        { area: '01' + this.character({ pool: '234569' }) + '1 ', sections: [3,4] },\n                        { area: '020 ' + this.character({ pool: '378' }), sections: [3,4] },\n                        { area: '023 ' + this.character({ pool: '89' }), sections: [3,4] },\n                        { area: '024 7', sections: [3,4] },\n                        { area: '028 ' + this.pick(['25','28','37','71','82','90','92','95']), sections: [2,4] },\n                        { area: '012' + this.pick(['04','08','54','76','97','98']) + ' ', sections: [6] },\n                        { area: '013' + this.pick(['63','64','84','86']) + ' ', sections: [6] },\n                        { area: '014' + this.pick(['04','20','60','61','80','88']) + ' ', sections: [6] },\n                        { area: '015' + this.pick(['24','27','62','66']) + ' ', sections: [6] },\n                        { area: '016' + this.pick(['06','29','35','47','59','95']) + ' ', sections: [6] },\n                        { area: '017' + this.pick(['26','44','50','68']) + ' ', sections: [6] },\n                        { area: '018' + this.pick(['27','37','84','97']) + ' ', sections: [6] },\n                        { area: '019' + this.pick(['00','05','35','46','49','63','95']) + ' ', sections: [6] }\n                    ]);\n                    phone = options.formatted ? ukNum(numPick) : ukNum(numPick).replace(' ', '', 'g');\n                } else {\n                    numPick = this.pick([\n                        { area: '07' + this.pick(['4','5','7','8','9']), sections: [2,6] },\n                        { area: '07624 ', sections: [6] }\n                    ]);\n                    phone = options.formatted ? ukNum(numPick) : ukNum(numPick).replace(' ', '');\n                }\n                break;\n            case 'us':\n                var areacode = this.areacode(options).toString();\n                var exchange = this.natural({ min: 2, max: 9 }).toString() +\n                    this.natural({ min: 0, max: 9 }).toString() +\n                    this.natural({ min: 0, max: 9 }).toString();\n                var subscriber = this.natural({ min: 1000, max: 9999 }).toString(); // this could be random [0-9]{4}\n                phone = options.formatted ? areacode + ' ' + exchange + '-' + subscriber : areacode + exchange + subscriber;\n        }\n        return phone;\n    };\n\n    Chance.prototype.postal = function () {\n        // Postal District\n        var pd = this.character({pool: \"XVTSRPNKLMHJGECBA\"});\n        // Forward Sortation Area (FSA)\n        var fsa = pd + this.natural({max: 9}) + this.character({alpha: true, casing: \"upper\"});\n        // Local Delivery Unut (LDU)\n        var ldu = this.natural({max: 9}) + this.character({alpha: true, casing: \"upper\"}) + this.natural({max: 9});\n\n        return fsa + \" \" + ldu;\n    };\n\n    Chance.prototype.counties = function (options) {\n        options = initOptions(options, { country: 'uk' });\n        return this.get(\"counties\")[options.country.toLowerCase()];\n    };\n\n    Chance.prototype.county = function (options) {\n        return this.pick(this.counties(options)).name;\n    };\n\n    Chance.prototype.provinces = function (options) {\n        options = initOptions(options, { country: 'ca' });\n        return this.get(\"provinces\")[options.country.toLowerCase()];\n    };\n\n    Chance.prototype.province = function (options) {\n        return (options && options.full) ?\n            this.pick(this.provinces(options)).name :\n            this.pick(this.provinces(options)).abbreviation;\n    };\n\n    Chance.prototype.state = function (options) {\n        return (options && options.full) ?\n            this.pick(this.states(options)).name :\n            this.pick(this.states(options)).abbreviation;\n    };\n\n    Chance.prototype.states = function (options) {\n        options = initOptions(options, { country: 'us', us_states_and_dc: true } );\n\n        var states;\n\n        switch (options.country.toLowerCase()) {\n            case 'us':\n                var us_states_and_dc = this.get(\"us_states_and_dc\"),\n                    territories = this.get(\"territories\"),\n                    armed_forces = this.get(\"armed_forces\");\n\n                states = [];\n\n                if (options.us_states_and_dc) {\n                    states = states.concat(us_states_and_dc);\n                }\n                if (options.territories) {\n                    states = states.concat(territories);\n                }\n                if (options.armed_forces) {\n                    states = states.concat(armed_forces);\n                }\n                break;\n            case 'it':\n                states = this.get(\"country_regions\")[options.country.toLowerCase()];\n                break;\n            case 'uk':\n                states = this.get(\"counties\")[options.country.toLowerCase()];\n                break;\n        }\n\n        return states;\n    };\n\n    Chance.prototype.street = function (options) {\n        options = initOptions(options, { country: 'us', syllables: 2 });\n        var     street;\n\n        switch (options.country.toLowerCase()) {\n            case 'us':\n                street = this.word({ syllables: options.syllables });\n                street = this.capitalize(street);\n                street += ' ';\n                street += options.short_suffix ?\n                    this.street_suffix(options).abbreviation :\n                    this.street_suffix(options).name;\n                break;\n            case 'it':\n                street = this.word({ syllables: options.syllables });\n                street = this.capitalize(street);\n                street = (options.short_suffix ?\n                    this.street_suffix(options).abbreviation :\n                    this.street_suffix(options).name) + \" \" + street;\n                break;\n        }\n        return street;\n    };\n\n    Chance.prototype.street_suffix = function (options) {\n        options = initOptions(options, { country: 'us' });\n        return this.pick(this.street_suffixes(options));\n    };\n\n    Chance.prototype.street_suffixes = function (options) {\n        options = initOptions(options, { country: 'us' });\n        // These are the most common suffixes.\n        return this.get(\"street_suffixes\")[options.country.toLowerCase()];\n    };\n\n    // Note: only returning US zip codes, internationalization will be a whole\n    // other beast to tackle at some point.\n    Chance.prototype.zip = function (options) {\n        var zip = this.n(this.natural, 5, {max: 9});\n\n        if (options && options.plusfour === true) {\n            zip.push('-');\n            zip = zip.concat(this.n(this.natural, 4, {max: 9}));\n        }\n\n        return zip.join(\"\");\n    };\n\n    // -- End Location --\n\n    // -- Time\n\n    Chance.prototype.ampm = function () {\n        return this.bool() ? 'am' : 'pm';\n    };\n\n    Chance.prototype.date = function (options) {\n        var date_string, date;\n\n        // If interval is specified we ignore preset\n        if(options && (options.min || options.max)) {\n            options = initOptions(options, {\n                american: true,\n                string: false\n            });\n            var min = typeof options.min !== \"undefined\" ? options.min.getTime() : 1;\n            // 100,000,000 days measured relative to midnight at the beginning of 01 January, 1970 UTC. http://es5.github.io/#x15.9.1.1\n            var max = typeof options.max !== \"undefined\" ? options.max.getTime() : 8640000000000000;\n\n            date = new Date(this.integer({min: min, max: max}));\n        } else {\n            var m = this.month({raw: true});\n            var daysInMonth = m.days;\n\n            if(options && options.month) {\n                // Mod 12 to allow months outside range of 0-11 (not encouraged, but also not prevented).\n                daysInMonth = this.get('months')[((options.month % 12) + 12) % 12].days;\n            }\n\n            options = initOptions(options, {\n                year: parseInt(this.year(), 10),\n                // Necessary to subtract 1 because Date() 0-indexes month but not day or year\n                // for some reason.\n                month: m.numeric - 1,\n                day: this.natural({min: 1, max: daysInMonth}),\n                hour: this.hour({twentyfour: true}),\n                minute: this.minute(),\n                second: this.second(),\n                millisecond: this.millisecond(),\n                american: true,\n                string: false\n            });\n\n            date = new Date(options.year, options.month, options.day, options.hour, options.minute, options.second, options.millisecond);\n        }\n\n        if (options.american) {\n            // Adding 1 to the month is necessary because Date() 0-indexes\n            // months but not day for some odd reason.\n            date_string = (date.getMonth() + 1) + '/' + date.getDate() + '/' + date.getFullYear();\n        } else {\n            date_string = date.getDate() + '/' + (date.getMonth() + 1) + '/' + date.getFullYear();\n        }\n\n        return options.string ? date_string : date;\n    };\n\n    Chance.prototype.hammertime = function (options) {\n        return this.date(options).getTime();\n    };\n\n    Chance.prototype.hour = function (options) {\n        options = initOptions(options, {\n            min: options && options.twentyfour ? 0 : 1,\n            max: options && options.twentyfour ? 23 : 12\n        });\n\n        testRange(options.min < 0, \"Chance: Min cannot be less than 0.\");\n        testRange(options.twentyfour && options.max > 23, \"Chance: Max cannot be greater than 23 for twentyfour option.\");\n        testRange(!options.twentyfour && options.max > 12, \"Chance: Max cannot be greater than 12.\");\n        testRange(options.min > options.max, \"Chance: Min cannot be greater than Max.\");\n\n        return this.natural({min: options.min, max: options.max});\n    };\n\n    Chance.prototype.millisecond = function () {\n        return this.natural({max: 999});\n    };\n\n    Chance.prototype.minute = Chance.prototype.second = function (options) {\n        options = initOptions(options, {min: 0, max: 59});\n\n        testRange(options.min < 0, \"Chance: Min cannot be less than 0.\");\n        testRange(options.max > 59, \"Chance: Max cannot be greater than 59.\");\n        testRange(options.min > options.max, \"Chance: Min cannot be greater than Max.\");\n\n        return this.natural({min: options.min, max: options.max});\n    };\n\n    Chance.prototype.month = function (options) {\n        options = initOptions(options, {min: 1, max: 12});\n\n        testRange(options.min < 1, \"Chance: Min cannot be less than 1.\");\n        testRange(options.max > 12, \"Chance: Max cannot be greater than 12.\");\n        testRange(options.min > options.max, \"Chance: Min cannot be greater than Max.\");\n\n        var month = this.pick(this.months().slice(options.min - 1, options.max));\n        return options.raw ? month : month.name;\n    };\n\n    Chance.prototype.months = function () {\n        return this.get(\"months\");\n    };\n\n    Chance.prototype.second = function () {\n        return this.natural({max: 59});\n    };\n\n    Chance.prototype.timestamp = function () {\n        return this.natural({min: 1, max: parseInt(new Date().getTime() / 1000, 10)});\n    };\n\n    Chance.prototype.weekday = function (options) {\n        options = initOptions(options, {weekday_only: false});\n        var weekdays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"];\n        if (!options.weekday_only) {\n            weekdays.push(\"Saturday\");\n            weekdays.push(\"Sunday\");\n        }\n        return this.pickone(weekdays);\n    };\n\n    Chance.prototype.year = function (options) {\n        // Default to current year as min if none specified\n        options = initOptions(options, {min: new Date().getFullYear()});\n\n        // Default to one century after current year as max if none specified\n        options.max = (typeof options.max !== \"undefined\") ? options.max : options.min + 100;\n\n        return this.natural(options).toString();\n    };\n\n    // -- End Time\n\n    // -- Finance --\n\n    Chance.prototype.cc = function (options) {\n        options = initOptions(options);\n\n        var type, number, to_generate;\n\n        type = (options.type) ?\n                    this.cc_type({ name: options.type, raw: true }) :\n                    this.cc_type({ raw: true });\n\n        number = type.prefix.split(\"\");\n        to_generate = type.length - type.prefix.length - 1;\n\n        // Generates n - 1 digits\n        number = number.concat(this.n(this.integer, to_generate, {min: 0, max: 9}));\n\n        // Generates the last digit according to Luhn algorithm\n        number.push(this.luhn_calculate(number.join(\"\")));\n\n        return number.join(\"\");\n    };\n\n    Chance.prototype.cc_types = function () {\n        // http://en.wikipedia.org/wiki/Bank_card_number#Issuer_identification_number_.28IIN.29\n        return this.get(\"cc_types\");\n    };\n\n    Chance.prototype.cc_type = function (options) {\n        options = initOptions(options);\n        var types = this.cc_types(),\n            type = null;\n\n        if (options.name) {\n            for (var i = 0; i < types.length; i++) {\n                // Accept either name or short_name to specify card type\n                if (types[i].name === options.name || types[i].short_name === options.name) {\n                    type = types[i];\n                    break;\n                }\n            }\n            if (type === null) {\n                throw new RangeError(\"Credit card type '\" + options.name + \"'' is not supported\");\n            }\n        } else {\n            type = this.pick(types);\n        }\n\n        return options.raw ? type : type.name;\n    };\n\n    //return all world currency by ISO 4217\n    Chance.prototype.currency_types = function () {\n        return this.get(\"currency_types\");\n    };\n\n    //return random world currency by ISO 4217\n    Chance.prototype.currency = function () {\n        return this.pick(this.currency_types());\n    };\n\n    //return all timezones availabel\n    Chance.prototype.timezones = function () {\n        return this.get(\"timezones\");\n    };\n\n    //return random timezone\n    Chance.prototype.timezone = function () {\n        return this.pick(this.timezones());\n    };\n\n    //Return random correct currency exchange pair (e.g. EUR/USD) or array of currency code\n    Chance.prototype.currency_pair = function (returnAsString) {\n        var currencies = this.unique(this.currency, 2, {\n            comparator: function(arr, val) {\n\n                return arr.reduce(function(acc, item) {\n                    // If a match has been found, short circuit check and just return\n                    return acc || (item.code === val.code);\n                }, false);\n            }\n        });\n\n        if (returnAsString) {\n            return currencies[0].code + '/' + currencies[1].code;\n        } else {\n            return currencies;\n        }\n    };\n\n    Chance.prototype.dollar = function (options) {\n        // By default, a somewhat more sane max for dollar than all available numbers\n        options = initOptions(options, {max : 10000, min : 0});\n\n        var dollar = this.floating({min: options.min, max: options.max, fixed: 2}).toString(),\n            cents = dollar.split('.')[1];\n\n        if (cents === undefined) {\n            dollar += '.00';\n        } else if (cents.length < 2) {\n            dollar = dollar + '0';\n        }\n\n        if (dollar < 0) {\n            return '-$' + dollar.replace('-', '');\n        } else {\n            return '$' + dollar;\n        }\n    };\n\n    Chance.prototype.euro = function (options) {\n        return Number(this.dollar(options).replace(\"$\", \"\")).toLocaleString() + \"\";\n    };\n\n    Chance.prototype.exp = function (options) {\n        options = initOptions(options);\n        var exp = {};\n\n        exp.year = this.exp_year();\n\n        // If the year is this year, need to ensure month is greater than the\n        // current month or this expiration will not be valid\n        if (exp.year === (new Date().getFullYear()).toString()) {\n            exp.month = this.exp_month({future: true});\n        } else {\n            exp.month = this.exp_month();\n        }\n\n        return options.raw ? exp : exp.month + '/' + exp.year;\n    };\n\n    Chance.prototype.exp_month = function (options) {\n        options = initOptions(options);\n        var month, month_int,\n            // Date object months are 0 indexed\n            curMonth = new Date().getMonth() + 1;\n\n        if (options.future && (curMonth !== 12)) {\n            do {\n                month = this.month({raw: true}).numeric;\n                month_int = parseInt(month, 10);\n            } while (month_int <= curMonth);\n        } else {\n            month = this.month({raw: true}).numeric;\n        }\n\n        return month;\n    };\n\n    Chance.prototype.exp_year = function () {\n        var curMonth = new Date().getMonth() + 1,\n            curYear = new Date().getFullYear();\n\n        return this.year({min: ((curMonth === 12) ? (curYear + 1) : curYear), max: (curYear + 10)});\n    };\n\n    Chance.prototype.vat = function (options) {\n        options = initOptions(options, { country: 'it' });\n        switch (options.country.toLowerCase()) {\n            case 'it':\n                return this.it_vat();\n        }\n    };\n\n    // -- End Finance\n\n    // -- Regional\n\n    Chance.prototype.it_vat = function () {\n        var it_vat = this.natural({min: 1, max: 1800000});\n\n        it_vat = this.pad(it_vat, 7) + this.pad(this.pick(this.provinces({ country: 'it' })).code, 3);\n        return it_vat + this.luhn_calculate(it_vat);\n    };\n\n    /*\n     * this generator is written following the official algorithm\n     * all data can be passed explicitely or randomized by calling chance.cf() without options\n     * the code does not check that the input data is valid (it goes beyond the scope of the generator)\n     *\n     * @param  [Object] options = { first: first name,\n     *                              last: last name,\n     *                              gender: female|male,\n                                    birthday: JavaScript date object,\n                                    city: string(4), 1 letter + 3 numbers\n                                   }\n     * @return [string] codice fiscale\n     *\n    */\n    Chance.prototype.cf = function (options) {\n        options = options || {};\n        var gender = !!options.gender ? options.gender : this.gender(),\n            first = !!options.first ? options.first : this.first( { gender: gender, nationality: 'it'} ),\n            last = !!options.last ? options.last : this.last( { nationality: 'it'} ),\n            birthday = !!options.birthday ? options.birthday : this.birthday(),\n            city = !!options.city ? options.city : this.pickone(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'L', 'M', 'Z']) + this.pad(this.natural({max:999}), 3),\n            cf = [],\n            name_generator = function(name, isLast) {\n                var temp,\n                    return_value = [];\n\n                if (name.length < 3) {\n                    return_value = name.split(\"\").concat(\"XXX\".split(\"\")).splice(0,3);\n                }\n                else {\n                    temp = name.toUpperCase().split('').map(function(c){\n                        return (\"BCDFGHJKLMNPRSTVWZ\".indexOf(c) !== -1) ? c : undefined;\n                    }).join('');\n                    if (temp.length > 3) {\n                        if (isLast) {\n                            temp = temp.substr(0,3);\n                        } else {\n                            temp = temp[0] + temp.substr(2,2);\n                        }\n                    }\n                    if (temp.length < 3) {\n                        return_value = temp;\n                        temp = name.toUpperCase().split('').map(function(c){\n                            return (\"AEIOU\".indexOf(c) !== -1) ? c : undefined;\n                        }).join('').substr(0, 3 - return_value.length);\n                    }\n                    return_value = return_value + temp;\n                }\n\n                return return_value;\n            },\n            date_generator = function(birthday, gender, that) {\n                var lettermonths = ['A', 'B', 'C', 'D', 'E', 'H', 'L', 'M', 'P', 'R', 'S', 'T'];\n\n                return  birthday.getFullYear().toString().substr(2) +\n                        lettermonths[birthday.getMonth()] +\n                        that.pad(birthday.getDate() + ((gender.toLowerCase() === \"female\") ? 40 : 0), 2);\n            },\n            checkdigit_generator = function(cf) {\n                var range1 = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n                    range2 = \"ABCDEFGHIJABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n                    evens  = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n                    odds   = \"BAKPLCQDREVOSFTGUHMINJWZYX\",\n                    digit  = 0;\n\n\n                for(var i = 0; i < 15; i++) {\n                    if (i % 2 !== 0) {\n                        digit += evens.indexOf(range2[range1.indexOf(cf[i])]);\n                    }\n                    else {\n                        digit +=  odds.indexOf(range2[range1.indexOf(cf[i])]);\n                    }\n                }\n                return evens[digit % 26];\n            };\n\n        cf = cf.concat(name_generator(last, true), name_generator(first), date_generator(birthday, gender, this), city.toUpperCase().split(\"\")).join(\"\");\n        cf += checkdigit_generator(cf.toUpperCase(), this);\n\n        return cf.toUpperCase();\n    };\n\n    Chance.prototype.pl_pesel = function () {\n        var number = this.natural({min: 1, max: 9999999999});\n        var arr = this.pad(number, 10).split('');\n        for (var i = 0; i < arr.length; i++) {\n            arr[i] = parseInt(arr[i]);\n        }\n\n        var controlNumber = (1 * arr[0] + 3 * arr[1] + 7 * arr[2] + 9 * arr[3] + 1 * arr[4] + 3 * arr[5] + 7 * arr[6] + 9 * arr[7] + 1 * arr[8] + 3 * arr[9]) % 10;\n        if(controlNumber !== 0) {\n            controlNumber = 10 - controlNumber;\n        }\n\n        return arr.join('') + controlNumber;\n    };\n\n    Chance.prototype.pl_nip = function () {\n        var number = this.natural({min: 1, max: 999999999});\n        var arr = this.pad(number, 9).split('');\n        for (var i = 0; i < arr.length; i++) {\n            arr[i] = parseInt(arr[i]);\n        }\n\n        var controlNumber = (6 * arr[0] + 5 * arr[1] + 7 * arr[2] + 2 * arr[3] + 3 * arr[4] + 4 * arr[5] + 5 * arr[6] + 6 * arr[7] + 7 * arr[8]) % 11;\n        if(controlNumber === 10) {\n            return this.pl_nip();\n        }\n\n        return arr.join('') + controlNumber;\n    };\n\n    Chance.prototype.pl_regon = function () {\n        var number = this.natural({min: 1, max: 99999999});\n        var arr = this.pad(number, 8).split('');\n        for (var i = 0; i < arr.length; i++) {\n            arr[i] = parseInt(arr[i]);\n        }\n\n        var controlNumber = (8 * arr[0] + 9 * arr[1] + 2 * arr[2] + 3 * arr[3] + 4 * arr[4] + 5 * arr[5] + 6 * arr[6] + 7 * arr[7]) % 11;\n        if(controlNumber === 10) {\n            controlNumber = 0;\n        }\n\n        return arr.join('') + controlNumber;\n    };\n\n    // -- End Regional\n\n    // -- Miscellaneous --\n\n    // Dice - For all the board game geeks out there, myself included ;)\n    function diceFn (range) {\n        return function () {\n            return this.natural(range);\n        };\n    }\n    Chance.prototype.d4 = diceFn({min: 1, max: 4});\n    Chance.prototype.d6 = diceFn({min: 1, max: 6});\n    Chance.prototype.d8 = diceFn({min: 1, max: 8});\n    Chance.prototype.d10 = diceFn({min: 1, max: 10});\n    Chance.prototype.d12 = diceFn({min: 1, max: 12});\n    Chance.prototype.d20 = diceFn({min: 1, max: 20});\n    Chance.prototype.d30 = diceFn({min: 1, max: 30});\n    Chance.prototype.d100 = diceFn({min: 1, max: 100});\n\n    Chance.prototype.rpg = function (thrown, options) {\n        options = initOptions(options);\n        if (!thrown) {\n            throw new RangeError(\"A type of die roll must be included\");\n        } else {\n            var bits = thrown.toLowerCase().split(\"d\"),\n                rolls = [];\n\n            if (bits.length !== 2 || !parseInt(bits[0], 10) || !parseInt(bits[1], 10)) {\n                throw new Error(\"Invalid format provided. Please provide #d# where the first # is the number of dice to roll, the second # is the max of each die\");\n            }\n            for (var i = bits[0]; i > 0; i--) {\n                rolls[i - 1] = this.natural({min: 1, max: bits[1]});\n            }\n            return (typeof options.sum !== 'undefined' && options.sum) ? rolls.reduce(function (p, c) { return p + c; }) : rolls;\n        }\n    };\n\n    // Guid\n    Chance.prototype.guid = function (options) {\n        options = initOptions(options, { version: 5 });\n\n        var guid_pool = \"abcdef1234567890\",\n            variant_pool = \"ab89\",\n            guid = this.string({ pool: guid_pool, length: 8 }) + '-' +\n                   this.string({ pool: guid_pool, length: 4 }) + '-' +\n                   // The Version\n                   options.version +\n                   this.string({ pool: guid_pool, length: 3 }) + '-' +\n                   // The Variant\n                   this.string({ pool: variant_pool, length: 1 }) +\n                   this.string({ pool: guid_pool, length: 3 }) + '-' +\n                   this.string({ pool: guid_pool, length: 12 });\n        return guid;\n    };\n\n    // Hash\n    Chance.prototype.hash = function (options) {\n        options = initOptions(options, {length : 40, casing: 'lower'});\n        var pool = options.casing === 'upper' ? HEX_POOL.toUpperCase() : HEX_POOL;\n        return this.string({pool: pool, length: options.length});\n    };\n\n    Chance.prototype.luhn_check = function (num) {\n        var str = num.toString();\n        var checkDigit = +str.substring(str.length - 1);\n        return checkDigit === this.luhn_calculate(+str.substring(0, str.length - 1));\n    };\n\n    Chance.prototype.luhn_calculate = function (num) {\n        var digits = num.toString().split(\"\").reverse();\n        var sum = 0;\n        var digit;\n\n        for (var i = 0, l = digits.length; l > i; ++i) {\n            digit = +digits[i];\n            if (i % 2 === 0) {\n                digit *= 2;\n                if (digit > 9) {\n                    digit -= 9;\n                }\n            }\n            sum += digit;\n        }\n        return (sum * 9) % 10;\n    };\n\n    // MD5 Hash\n    Chance.prototype.md5 = function(options) {\n        var opts = { str: '', key: null, raw: false };\n\n        if (!options) {\n            opts.str = this.string();\n            options = {};\n        }\n        else if (typeof options === 'string') {\n            opts.str = options;\n            options = {};\n        }\n        else if (typeof options !== 'object') {\n            return null;\n        }\n        else if(options.constructor === 'Array') {\n            return null;\n        }\n\n        opts = initOptions(options, opts);\n\n        if(!opts.str){\n            throw new Error('A parameter is required to return an md5 hash.');\n        }\n\n        return this.bimd5.md5(opts.str, opts.key, opts.raw);\n    };\n\n    /**\n     * #Description:\n     * =====================================================\n     * Generate random file name with extention\n     *\n     * The argument provide extention type\n     * -> raster\n     * -> vector\n     * -> 3d\n     * -> document\n     *\n     * If noting is provided the function return random file name with random\n     * extention type of any kind\n     *\n     * The user can validate the file name length range\n     * If noting provided the generated file name is radom\n     *\n     * #Extention Pool :\n     * * Currently the supported extentions are\n     *  -> some of the most popular raster image extentions\n     *  -> some of the most popular vector image extentions\n     *  -> some of the most popular 3d image extentions\n     *  -> some of the most popular document extentions\n     *\n     * #Examples :\n     * =====================================================\n     *\n     * Return random file name with random extention. The file extention\n     * is provided by a predifined collection of extentions. More abouth the extention\n     * pool can be fond in #Extention Pool section\n     *\n     * chance.file()\n     * => dsfsdhjf.xml\n     *\n     * In order to generate a file name with sspecific length, specify the\n     * length property and integer value. The extention is going to be random\n     *\n     * chance.file({length : 10})\n     * => asrtineqos.pdf\n     *\n     * In order to geerate file with extention form some of the predifined groups\n     * of the extention pool just specify the extenton pool category in fileType property\n     *\n     * chance.file({fileType : 'raster'})\n     * => dshgssds.psd\n     *\n     * You can provide specific extention for your files\n     * chance.file({extention : 'html'})\n     * => djfsd.html\n     *\n     * Or you could pass custom collection of extentons bt array or by object\n     * chance.file({extentions : [...]})\n     * => dhgsdsd.psd\n     *\n     * chance.file({extentions : { key : [...], key : [...]}})\n     * => djsfksdjsd.xml\n     *\n     * @param  [collection] options\n     * @return [string]\n     *\n     */\n    Chance.prototype.file = function(options) {\n\n        var fileOptions = options || {};\n        var poolCollectionKey = \"fileExtension\";\n        var typeRange   = Object.keys(this.get(\"fileExtension\"));//['raster', 'vector', '3d', 'document'];\n        var fileName;\n        var fileExtention;\n\n        // Generate random file name\n        fileName = this.word({length : fileOptions.length});\n\n        // Generate file by specific extention provided by the user\n        if(fileOptions.extention) {\n\n            fileExtention = fileOptions.extention;\n            return (fileName + '.' + fileExtention);\n        }\n\n        // Generate file by specific axtention collection\n        if(fileOptions.extentions) {\n\n            if(Array.isArray(fileOptions.extentions)) {\n\n                fileExtention = this.pickone(fileOptions.extentions);\n                return (fileName + '.' + fileExtention);\n            }\n            else if(fileOptions.extentions.constructor === Object) {\n\n                var extentionObjectCollection = fileOptions.extentions;\n                var keys = Object.keys(extentionObjectCollection);\n\n                fileExtention = this.pickone(extentionObjectCollection[this.pickone(keys)]);\n                return (fileName + '.' + fileExtention);\n            }\n\n            throw new Error(\"Expect collection of type Array or Object to be passed as an argument \");\n        }\n\n        // Generate file extention based on specific file type\n        if(fileOptions.fileType) {\n\n            var fileType = fileOptions.fileType;\n            if(typeRange.indexOf(fileType) !== -1) {\n\n                fileExtention = this.pickone(this.get(poolCollectionKey)[fileType]);\n                return (fileName + '.' + fileExtention);\n            }\n\n            throw new Error(\"Expect file type value to be 'raster', 'vector', '3d' or 'document' \");\n        }\n\n        // Generate random file name if no extenton options are passed\n        fileExtention = this.pickone(this.get(poolCollectionKey)[this.pickone(typeRange)]);\n        return (fileName + '.' + fileExtention);\n    };\n\n    var data = {\n\n        firstNames: {\n            \"male\": {\n                \"en\": [\"James\", \"John\", \"Robert\", \"Michael\", \"William\", \"David\", \"Richard\", \"Joseph\", \"Charles\", \"Thomas\", \"Christopher\", \"Daniel\", \"Matthew\", \"George\", \"Donald\", \"Anthony\", \"Paul\", \"Mark\", \"Edward\", \"Steven\", \"Kenneth\", \"Andrew\", \"Brian\", \"Joshua\", \"Kevin\", \"Ronald\", \"Timothy\", \"Jason\", \"Jeffrey\", \"Frank\", \"Gary\", \"Ryan\", \"Nicholas\", \"Eric\", \"Stephen\", \"Jacob\", \"Larry\", \"Jonathan\", \"Scott\", \"Raymond\", \"Justin\", \"Brandon\", \"Gregory\", \"Samuel\", \"Benjamin\", \"Patrick\", \"Jack\", \"Henry\", \"Walter\", \"Dennis\", \"Jerry\", \"Alexander\", \"Peter\", \"Tyler\", \"Douglas\", \"Harold\", \"Aaron\", \"Jose\", \"Adam\", \"Arthur\", \"Zachary\", \"Carl\", \"Nathan\", \"Albert\", \"Kyle\", \"Lawrence\", \"Joe\", \"Willie\", \"Gerald\", \"Roger\", \"Keith\", \"Jeremy\", \"Terry\", \"Harry\", \"Ralph\", \"Sean\", \"Jesse\", \"Roy\", \"Louis\", \"Billy\", \"Austin\", \"Bruce\", \"Eugene\", \"Christian\", \"Bryan\", \"Wayne\", \"Russell\", \"Howard\", \"Fred\", \"Ethan\", \"Jordan\", \"Philip\", \"Alan\", \"Juan\", \"Randy\", \"Vincent\", \"Bobby\", \"Dylan\", \"Johnny\", \"Phillip\", \"Victor\", \"Clarence\", \"Ernest\", \"Martin\", \"Craig\", \"Stanley\", \"Shawn\", \"Travis\", \"Bradley\", \"Leonard\", \"Earl\", \"Gabriel\", \"Jimmy\", \"Francis\", \"Todd\", \"Noah\", \"Danny\", \"Dale\", \"Cody\", \"Carlos\", \"Allen\", \"Frederick\", \"Logan\", \"Curtis\", \"Alex\", \"Joel\", \"Luis\", \"Norman\", \"Marvin\", \"Glenn\", \"Tony\", \"Nathaniel\", \"Rodney\", \"Melvin\", \"Alfred\", \"Steve\", \"Cameron\", \"Chad\", \"Edwin\", \"Caleb\", \"Evan\", \"Antonio\", \"Lee\", \"Herbert\", \"Jeffery\", \"Isaac\", \"Derek\", \"Ricky\", \"Marcus\", \"Theodore\", \"Elijah\", \"Luke\", \"Jesus\", \"Eddie\", \"Troy\", \"Mike\", \"Dustin\", \"Ray\", \"Adrian\", \"Bernard\", \"Leroy\", \"Angel\", \"Randall\", \"Wesley\", \"Ian\", \"Jared\", \"Mason\", \"Hunter\", \"Calvin\", \"Oscar\", \"Clifford\", \"Jay\", \"Shane\", \"Ronnie\", \"Barry\", \"Lucas\", \"Corey\", \"Manuel\", \"Leo\", \"Tommy\", \"Warren\", \"Jackson\", \"Isaiah\", \"Connor\", \"Don\", \"Dean\", \"Jon\", \"Julian\", \"Miguel\", \"Bill\", \"Lloyd\", \"Charlie\", \"Mitchell\", \"Leon\", \"Jerome\", \"Darrell\", \"Jeremiah\", \"Alvin\", \"Brett\", \"Seth\", \"Floyd\", \"Jim\", \"Blake\", \"Micheal\", \"Gordon\", \"Trevor\", \"Lewis\", \"Erik\", \"Edgar\", \"Vernon\", \"Devin\", \"Gavin\", \"Jayden\", \"Chris\", \"Clyde\", \"Tom\", \"Derrick\", \"Mario\", \"Brent\", \"Marc\", \"Herman\", \"Chase\", \"Dominic\", \"Ricardo\", \"Franklin\", \"Maurice\", \"Max\", \"Aiden\", \"Owen\", \"Lester\", \"Gilbert\", \"Elmer\", \"Gene\", \"Francisco\", \"Glen\", \"Cory\", \"Garrett\", \"Clayton\", \"Sam\", \"Jorge\", \"Chester\", \"Alejandro\", \"Jeff\", \"Harvey\", \"Milton\", \"Cole\", \"Ivan\", \"Andre\", \"Duane\", \"Landon\"],\n                // Data taken from http://www.dati.gov.it/dataset/comune-di-firenze_0163\n                \"it\": [\"Adolfo\", \"Alberto\", \"Aldo\", \"Alessandro\", \"Alessio\", \"Alfredo\", \"Alvaro\", \"Andrea\", \"Angelo\", \"Angiolo\", \"Antonino\", \"Antonio\", \"Attilio\", \"Benito\", \"Bernardo\", \"Bruno\", \"Carlo\", \"Cesare\", \"Christian\", \"Claudio\", \"Corrado\", \"Cosimo\", \"Cristian\", \"Cristiano\", \"Daniele\", \"Dario\", \"David\", \"Davide\", \"Diego\", \"Dino\", \"Domenico\", \"Duccio\", \"Edoardo\", \"Elia\", \"Elio\", \"Emanuele\", \"Emiliano\", \"Emilio\", \"Enrico\", \"Enzo\", \"Ettore\", \"Fabio\", \"Fabrizio\", \"Federico\", \"Ferdinando\", \"Fernando\", \"Filippo\", \"Francesco\", \"Franco\", \"Gabriele\", \"Giacomo\", \"Giampaolo\", \"Giampiero\", \"Giancarlo\", \"Gianfranco\", \"Gianluca\", \"Gianmarco\", \"Gianni\", \"Gino\", \"Giorgio\", \"Giovanni\", \"Giuliano\", \"Giulio\", \"Giuseppe\", \"Graziano\", \"Gregorio\", \"Guido\", \"Iacopo\", \"Jacopo\", \"Lapo\", \"Leonardo\", \"Lorenzo\", \"Luca\", \"Luciano\", \"Luigi\", \"Manuel\", \"Marcello\", \"Marco\", \"Marino\", \"Mario\", \"Massimiliano\", \"Massimo\", \"Matteo\", \"Mattia\", \"Maurizio\", \"Mauro\", \"Michele\", \"Mirko\", \"Mohamed\", \"Nello\", \"Neri\", \"Niccol\", \"Nicola\", \"Osvaldo\", \"Otello\", \"Paolo\", \"Pier Luigi\", \"Piero\", \"Pietro\", \"Raffaele\", \"Remo\", \"Renato\", \"Renzo\", \"Riccardo\", \"Roberto\", \"Rolando\", \"Romano\", \"Salvatore\", \"Samuele\", \"Sandro\", \"Sergio\", \"Silvano\", \"Simone\", \"Stefano\", \"Thomas\", \"Tommaso\", \"Ubaldo\", \"Ugo\", \"Umberto\", \"Valerio\", \"Valter\", \"Vasco\", \"Vincenzo\", \"Vittorio\"]\n            },\n            \"female\": {\n                \"en\": [\"Mary\", \"Emma\", \"Elizabeth\", \"Minnie\", \"Margaret\", \"Ida\", \"Alice\", \"Bertha\", \"Sarah\", \"Annie\", \"Clara\", \"Ella\", \"Florence\", \"Cora\", \"Martha\", \"Laura\", \"Nellie\", \"Grace\", \"Carrie\", \"Maude\", \"Mabel\", \"Bessie\", \"Jennie\", \"Gertrude\", \"Julia\", \"Hattie\", \"Edith\", \"Mattie\", \"Rose\", \"Catherine\", \"Lillian\", \"Ada\", \"Lillie\", \"Helen\", \"Jessie\", \"Louise\", \"Ethel\", \"Lula\", \"Myrtle\", \"Eva\", \"Frances\", \"Lena\", \"Lucy\", \"Edna\", \"Maggie\", \"Pearl\", \"Daisy\", \"Fannie\", \"Josephine\", \"Dora\", \"Rosa\", \"Katherine\", \"Agnes\", \"Marie\", \"Nora\", \"May\", \"Mamie\", \"Blanche\", \"Stella\", \"Ellen\", \"Nancy\", \"Effie\", \"Sallie\", \"Nettie\", \"Della\", \"Lizzie\", \"Flora\", \"Susie\", \"Maud\", \"Mae\", \"Etta\", \"Harriet\", \"Sadie\", \"Caroline\", \"Katie\", \"Lydia\", \"Elsie\", \"Kate\", \"Susan\", \"Mollie\", \"Alma\", \"Addie\", \"Georgia\", \"Eliza\", \"Lulu\", \"Nannie\", \"Lottie\", \"Amanda\", \"Belle\", \"Charlotte\", \"Rebecca\", \"Ruth\", \"Viola\", \"Olive\", \"Amelia\", \"Hannah\", \"Jane\", \"Virginia\", \"Emily\", \"Matilda\", \"Irene\", \"Kathryn\", \"Esther\", \"Willie\", \"Henrietta\", \"Ollie\", \"Amy\", \"Rachel\", \"Sara\", \"Estella\", \"Theresa\", \"Augusta\", \"Ora\", \"Pauline\", \"Josie\", \"Lola\", \"Sophia\", \"Leona\", \"Anne\", \"Mildred\", \"Ann\", \"Beulah\", \"Callie\", \"Lou\", \"Delia\", \"Eleanor\", \"Barbara\", \"Iva\", \"Louisa\", \"Maria\", \"Mayme\", \"Evelyn\", \"Estelle\", \"Nina\", \"Betty\", \"Marion\", \"Bettie\", \"Dorothy\", \"Luella\", \"Inez\", \"Lela\", \"Rosie\", \"Allie\", \"Millie\", \"Janie\", \"Cornelia\", \"Victoria\", \"Ruby\", \"Winifred\", \"Alta\", \"Celia\", \"Christine\", \"Beatrice\", \"Birdie\", \"Harriett\", \"Mable\", \"Myra\", \"Sophie\", \"Tillie\", \"Isabel\", \"Sylvia\", \"Carolyn\", \"Isabelle\", \"Leila\", \"Sally\", \"Ina\", \"Essie\", \"Bertie\", \"Nell\", \"Alberta\", \"Katharine\", \"Lora\", \"Rena\", \"Mina\", \"Rhoda\", \"Mathilda\", \"Abbie\", \"Eula\", \"Dollie\", \"Hettie\", \"Eunice\", \"Fanny\", \"Ola\", \"Lenora\", \"Adelaide\", \"Christina\", \"Lelia\", \"Nelle\", \"Sue\", \"Johanna\", \"Lilly\", \"Lucinda\", \"Minerva\", \"Lettie\", \"Roxie\", \"Cynthia\", \"Helena\", \"Hilda\", \"Hulda\", \"Bernice\", \"Genevieve\", \"Jean\", \"Cordelia\", \"Marian\", \"Francis\", \"Jeanette\", \"Adeline\", \"Gussie\", \"Leah\", \"Lois\", \"Lura\", \"Mittie\", \"Hallie\", \"Isabella\", \"Olga\", \"Phoebe\", \"Teresa\", \"Hester\", \"Lida\", \"Lina\", \"Winnie\", \"Claudia\", \"Marguerite\", \"Vera\", \"Cecelia\", \"Bess\", \"Emilie\", \"John\", \"Rosetta\", \"Verna\", \"Myrtie\", \"Cecilia\", \"Elva\", \"Olivia\", \"Ophelia\", \"Georgie\", \"Elnora\", \"Violet\", \"Adele\", \"Lily\", \"Linnie\", \"Loretta\", \"Madge\", \"Polly\", \"Virgie\", \"Eugenia\", \"Lucile\", \"Lucille\", \"Mabelle\", \"Rosalie\"],\n                // Data taken from http://www.dati.gov.it/dataset/comune-di-firenze_0162\n                \"it\": [\"Ada\", \"Adriana\", \"Alessandra\", \"Alessia\", \"Alice\", \"Angela\", \"Anna\", \"Anna Maria\", \"Annalisa\", \"Annita\", \"Annunziata\", \"Antonella\", \"Arianna\", \"Asia\", \"Assunta\", \"Aurora\", \"Barbara\", \"Beatrice\", \"Benedetta\", \"Bianca\", \"Bruna\", \"Camilla\", \"Carla\", \"Carlotta\", \"Carmela\", \"Carolina\", \"Caterina\", \"Catia\", \"Cecilia\", \"Chiara\", \"Cinzia\", \"Clara\", \"Claudia\", \"Costanza\", \"Cristina\", \"Daniela\", \"Debora\", \"Diletta\", \"Dina\", \"Donatella\", \"Elena\", \"Eleonora\", \"Elisa\", \"Elisabetta\", \"Emanuela\", \"Emma\", \"Eva\", \"Federica\", \"Fernanda\", \"Fiorella\", \"Fiorenza\", \"Flora\", \"Franca\", \"Francesca\", \"Gabriella\", \"Gaia\", \"Gemma\", \"Giada\", \"Gianna\", \"Gina\", \"Ginevra\", \"Giorgia\", \"Giovanna\", \"Giulia\", \"Giuliana\", \"Giuseppa\", \"Giuseppina\", \"Grazia\", \"Graziella\", \"Greta\", \"Ida\", \"Ilaria\", \"Ines\", \"Iolanda\", \"Irene\", \"Irma\", \"Isabella\", \"Jessica\", \"Laura\", \"Leda\", \"Letizia\", \"Licia\", \"Lidia\", \"Liliana\", \"Lina\", \"Linda\", \"Lisa\", \"Livia\", \"Loretta\", \"Luana\", \"Lucia\", \"Luciana\", \"Lucrezia\", \"Luisa\", \"Manuela\", \"Mara\", \"Marcella\", \"Margherita\", \"Maria\", \"Maria Cristina\", \"Maria Grazia\", \"Maria Luisa\", \"Maria Pia\", \"Maria Teresa\", \"Marina\", \"Marisa\", \"Marta\", \"Martina\", \"Marzia\", \"Matilde\", \"Melissa\", \"Michela\", \"Milena\", \"Mirella\", \"Monica\", \"Natalina\", \"Nella\", \"Nicoletta\", \"Noemi\", \"Olga\", \"Paola\", \"Patrizia\", \"Piera\", \"Pierina\", \"Raffaella\", \"Rebecca\", \"Renata\", \"Rina\", \"Rita\", \"Roberta\", \"Rosa\", \"Rosanna\", \"Rossana\", \"Rossella\", \"Sabrina\", \"Sandra\", \"Sara\", \"Serena\", \"Silvana\", \"Silvia\", \"Simona\", \"Simonetta\", \"Sofia\", \"Sonia\", \"Stefania\", \"Susanna\", \"Teresa\", \"Tina\", \"Tiziana\", \"Tosca\", \"Valentina\", \"Valeria\", \"Vanda\", \"Vanessa\", \"Vanna\", \"Vera\", \"Veronica\", \"Vilma\", \"Viola\", \"Virginia\", \"Vittoria\"]\n            }\n        },\n\n        lastNames: {\n            \"en\": ['Smith', 'Johnson', 'Williams', 'Jones', 'Brown', 'Davis', 'Miller', 'Wilson', 'Moore', 'Taylor', 'Anderson', 'Thomas', 'Jackson', 'White', 'Harris', 'Martin', 'Thompson', 'Garcia', 'Martinez', 'Robinson', 'Clark', 'Rodriguez', 'Lewis', 'Lee', 'Walker', 'Hall', 'Allen', 'Young', 'Hernandez', 'King', 'Wright', 'Lopez', 'Hill', 'Scott', 'Green', 'Adams', 'Baker', 'Gonzalez', 'Nelson', 'Carter', 'Mitchell', 'Perez', 'Roberts', 'Turner', 'Phillips', 'Campbell', 'Parker', 'Evans', 'Edwards', 'Collins', 'Stewart', 'Sanchez', 'Morris', 'Rogers', 'Reed', 'Cook', 'Morgan', 'Bell', 'Murphy', 'Bailey', 'Rivera', 'Cooper', 'Richardson', 'Cox', 'Howard', 'Ward', 'Torres', 'Peterson', 'Gray', 'Ramirez', 'James', 'Watson', 'Brooks', 'Kelly', 'Sanders', 'Price', 'Bennett', 'Wood', 'Barnes', 'Ross', 'Henderson', 'Coleman', 'Jenkins', 'Perry', 'Powell', 'Long', 'Patterson', 'Hughes', 'Flores', 'Washington', 'Butler', 'Simmons', 'Foster', 'Gonzales', 'Bryant', 'Alexander', 'Russell', 'Griffin', 'Diaz', 'Hayes', 'Myers', 'Ford', 'Hamilton', 'Graham', 'Sullivan', 'Wallace', 'Woods', 'Cole', 'West', 'Jordan', 'Owens', 'Reynolds', 'Fisher', 'Ellis', 'Harrison', 'Gibson', 'McDonald', 'Cruz', 'Marshall', 'Ortiz', 'Gomez', 'Murray', 'Freeman', 'Wells', 'Webb', 'Simpson', 'Stevens', 'Tucker', 'Porter', 'Hunter', 'Hicks', 'Crawford', 'Henry', 'Boyd', 'Mason', 'Morales', 'Kennedy', 'Warren', 'Dixon', 'Ramos', 'Reyes', 'Burns', 'Gordon', 'Shaw', 'Holmes', 'Rice', 'Robertson', 'Hunt', 'Black', 'Daniels', 'Palmer', 'Mills', 'Nichols', 'Grant', 'Knight', 'Ferguson', 'Rose', 'Stone', 'Hawkins', 'Dunn', 'Perkins', 'Hudson', 'Spencer', 'Gardner', 'Stephens', 'Payne', 'Pierce', 'Berry', 'Matthews', 'Arnold', 'Wagner', 'Willis', 'Ray', 'Watkins', 'Olson', 'Carroll', 'Duncan', 'Snyder', 'Hart', 'Cunningham', 'Bradley', 'Lane', 'Andrews', 'Ruiz', 'Harper', 'Fox', 'Riley', 'Armstrong', 'Carpenter', 'Weaver', 'Greene', 'Lawrence', 'Elliott', 'Chavez', 'Sims', 'Austin', 'Peters', 'Kelley', 'Franklin', 'Lawson', 'Fields', 'Gutierrez', 'Ryan', 'Schmidt', 'Carr', 'Vasquez', 'Castillo', 'Wheeler', 'Chapman', 'Oliver', 'Montgomery', 'Richards', 'Williamson', 'Johnston', 'Banks', 'Meyer', 'Bishop', 'McCoy', 'Howell', 'Alvarez', 'Morrison', 'Hansen', 'Fernandez', 'Garza', 'Harvey', 'Little', 'Burton', 'Stanley', 'Nguyen', 'George', 'Jacobs', 'Reid', 'Kim', 'Fuller', 'Lynch', 'Dean', 'Gilbert', 'Garrett', 'Romero', 'Welch', 'Larson', 'Frazier', 'Burke', 'Hanson', 'Day', 'Mendoza', 'Moreno', 'Bowman', 'Medina', 'Fowler', 'Brewer', 'Hoffman', 'Carlson', 'Silva', 'Pearson', 'Holland', 'Douglas', 'Fleming', 'Jensen', 'Vargas', 'Byrd', 'Davidson', 'Hopkins', 'May', 'Terry', 'Herrera', 'Wade', 'Soto', 'Walters', 'Curtis', 'Neal', 'Caldwell', 'Lowe', 'Jennings', 'Barnett', 'Graves', 'Jimenez', 'Horton', 'Shelton', 'Barrett', 'Obrien', 'Castro', 'Sutton', 'Gregory', 'McKinney', 'Lucas', 'Miles', 'Craig', 'Rodriquez', 'Chambers', 'Holt', 'Lambert', 'Fletcher', 'Watts', 'Bates', 'Hale', 'Rhodes', 'Pena', 'Beck', 'Newman', 'Haynes', 'McDaniel', 'Mendez', 'Bush', 'Vaughn', 'Parks', 'Dawson', 'Santiago', 'Norris', 'Hardy', 'Love', 'Steele', 'Curry', 'Powers', 'Schultz', 'Barker', 'Guzman', 'Page', 'Munoz', 'Ball', 'Keller', 'Chandler', 'Weber', 'Leonard', 'Walsh', 'Lyons', 'Ramsey', 'Wolfe', 'Schneider', 'Mullins', 'Benson', 'Sharp', 'Bowen', 'Daniel', 'Barber', 'Cummings', 'Hines', 'Baldwin', 'Griffith', 'Valdez', 'Hubbard', 'Salazar', 'Reeves', 'Warner', 'Stevenson', 'Burgess', 'Santos', 'Tate', 'Cross', 'Garner', 'Mann', 'Mack', 'Moss', 'Thornton', 'Dennis', 'McGee', 'Farmer', 'Delgado', 'Aguilar', 'Vega', 'Glover', 'Manning', 'Cohen', 'Harmon', 'Rodgers', 'Robbins', 'Newton', 'Todd', 'Blair', 'Higgins', 'Ingram', 'Reese', 'Cannon', 'Strickland', 'Townsend', 'Potter', 'Goodwin', 'Walton', 'Rowe', 'Hampton', 'Ortega', 'Patton', 'Swanson', 'Joseph', 'Francis', 'Goodman', 'Maldonado', 'Yates', 'Becker', 'Erickson', 'Hodges', 'Rios', 'Conner', 'Adkins', 'Webster', 'Norman', 'Malone', 'Hammond', 'Flowers', 'Cobb', 'Moody', 'Quinn', 'Blake', 'Maxwell', 'Pope', 'Floyd', 'Osborne', 'Paul', 'McCarthy', 'Guerrero', 'Lindsey', 'Estrada', 'Sandoval', 'Gibbs', 'Tyler', 'Gross', 'Fitzgerald', 'Stokes', 'Doyle', 'Sherman', 'Saunders', 'Wise', 'Colon', 'Gill', 'Alvarado', 'Greer', 'Padilla', 'Simon', 'Waters', 'Nunez', 'Ballard', 'Schwartz', 'McBride', 'Houston', 'Christensen', 'Klein', 'Pratt', 'Briggs', 'Parsons', 'McLaughlin', 'Zimmerman', 'French', 'Buchanan', 'Moran', 'Copeland', 'Roy', 'Pittman', 'Brady', 'McCormick', 'Holloway', 'Brock', 'Poole', 'Frank', 'Logan', 'Owen', 'Bass', 'Marsh', 'Drake', 'Wong', 'Jefferson', 'Park', 'Morton', 'Abbott', 'Sparks', 'Patrick', 'Norton', 'Huff', 'Clayton', 'Massey', 'Lloyd', 'Figueroa', 'Carson', 'Bowers', 'Roberson', 'Barton', 'Tran', 'Lamb', 'Harrington', 'Casey', 'Boone', 'Cortez', 'Clarke', 'Mathis', 'Singleton', 'Wilkins', 'Cain', 'Bryan', 'Underwood', 'Hogan', 'McKenzie', 'Collier', 'Luna', 'Phelps', 'McGuire', 'Allison', 'Bridges', 'Wilkerson', 'Nash', 'Summers', 'Atkins'],\n                // Data taken from http://www.dati.gov.it/dataset/comune-di-firenze_0164 (first 1000)\n            \"it\": [\"Acciai\", \"Aglietti\", \"Agostini\", \"Agresti\", \"Ahmed\", \"Aiazzi\", \"Albanese\", \"Alberti\", \"Alessi\", \"Alfani\", \"Alinari\", \"Alterini\", \"Amato\", \"Ammannati\", \"Ancillotti\", \"Andrei\", \"Andreini\", \"Andreoni\", \"Angeli\", \"Anichini\", \"Antonelli\", \"Antonini\", \"Arena\", \"Ariani\", \"Arnetoli\", \"Arrighi\", \"Baccani\", \"Baccetti\", \"Bacci\", \"Bacherini\", \"Badii\", \"Baggiani\", \"Baglioni\", \"Bagni\", \"Bagnoli\", \"Baldassini\", \"Baldi\", \"Baldini\", \"Ballerini\", \"Balli\", \"Ballini\", \"Balloni\", \"Bambi\", \"Banchi\", \"Bandinelli\", \"Bandini\", \"Bani\", \"Barbetti\", \"Barbieri\", \"Barchielli\", \"Bardazzi\", \"Bardelli\", \"Bardi\", \"Barducci\", \"Bargellini\", \"Bargiacchi\", \"Barni\", \"Baroncelli\", \"Baroncini\", \"Barone\", \"Baroni\", \"Baronti\", \"Bartalesi\", \"Bartoletti\", \"Bartoli\", \"Bartolini\", \"Bartoloni\", \"Bartolozzi\", \"Basagni\", \"Basile\", \"Bassi\", \"Batacchi\", \"Battaglia\", \"Battaglini\", \"Bausi\", \"Becagli\", \"Becattini\", \"Becchi\", \"Becucci\", \"Bellandi\", \"Bellesi\", \"Belli\", \"Bellini\", \"Bellucci\", \"Bencini\", \"Benedetti\", \"Benelli\", \"Beni\", \"Benini\", \"Bensi\", \"Benucci\", \"Benvenuti\", \"Berlincioni\", \"Bernacchioni\", \"Bernardi\", \"Bernardini\", \"Berni\", \"Bernini\", \"Bertelli\", \"Berti\", \"Bertini\", \"Bessi\", \"Betti\", \"Bettini\", \"Biagi\", \"Biagini\", \"Biagioni\", \"Biagiotti\", \"Biancalani\", \"Bianchi\", \"Bianchini\", \"Bianco\", \"Biffoli\", \"Bigazzi\", \"Bigi\", \"Biliotti\", \"Billi\", \"Binazzi\", \"Bindi\", \"Bini\", \"Biondi\", \"Bizzarri\", \"Bocci\", \"Bogani\", \"Bolognesi\", \"Bonaiuti\", \"Bonanni\", \"Bonciani\", \"Boncinelli\", \"Bondi\", \"Bonechi\", \"Bongini\", \"Boni\", \"Bonini\", \"Borchi\", \"Boretti\", \"Borghi\", \"Borghini\", \"Borgioli\", \"Borri\", \"Borselli\", \"Boschi\", \"Bottai\", \"Bracci\", \"Braccini\", \"Brandi\", \"Braschi\", \"Bravi\", \"Brazzini\", \"Breschi\", \"Brilli\", \"Brizzi\", \"Brogelli\", \"Brogi\", \"Brogioni\", \"Brunelli\", \"Brunetti\", \"Bruni\", \"Bruno\", \"Brunori\", \"Bruschi\", \"Bucci\", \"Bucciarelli\", \"Buccioni\", \"Bucelli\", \"Bulli\", \"Burberi\", \"Burchi\", \"Burgassi\", \"Burroni\", \"Bussotti\", \"Buti\", \"Caciolli\", \"Caiani\", \"Calabrese\", \"Calamai\", \"Calamandrei\", \"Caldini\", \"Calo'\", \"Calonaci\", \"Calosi\", \"Calvelli\", \"Cambi\", \"Camiciottoli\", \"Cammelli\", \"Cammilli\", \"Campolmi\", \"Cantini\", \"Capanni\", \"Capecchi\", \"Caponi\", \"Cappelletti\", \"Cappelli\", \"Cappellini\", \"Cappugi\", \"Capretti\", \"Caputo\", \"Carbone\", \"Carboni\", \"Cardini\", \"Carlesi\", \"Carletti\", \"Carli\", \"Caroti\", \"Carotti\", \"Carrai\", \"Carraresi\", \"Carta\", \"Caruso\", \"Casalini\", \"Casati\", \"Caselli\", \"Casini\", \"Castagnoli\", \"Castellani\", \"Castelli\", \"Castellucci\", \"Catalano\", \"Catarzi\", \"Catelani\", \"Cavaciocchi\", \"Cavallaro\", \"Cavallini\", \"Cavicchi\", \"Cavini\", \"Ceccarelli\", \"Ceccatelli\", \"Ceccherelli\", \"Ceccherini\", \"Cecchi\", \"Cecchini\", \"Cecconi\", \"Cei\", \"Cellai\", \"Celli\", \"Cellini\", \"Cencetti\", \"Ceni\", \"Cenni\", \"Cerbai\", \"Cesari\", \"Ceseri\", \"Checcacci\", \"Checchi\", \"Checcucci\", \"Cheli\", \"Chellini\", \"Chen\", \"Cheng\", \"Cherici\", \"Cherubini\", \"Chiaramonti\", \"Chiarantini\", \"Chiarelli\", \"Chiari\", \"Chiarini\", \"Chiarugi\", \"Chiavacci\", \"Chiesi\", \"Chimenti\", \"Chini\", \"Chirici\", \"Chiti\", \"Ciabatti\", \"Ciampi\", \"Cianchi\", \"Cianfanelli\", \"Cianferoni\", \"Ciani\", \"Ciapetti\", \"Ciappi\", \"Ciardi\", \"Ciatti\", \"Cicali\", \"Ciccone\", \"Cinelli\", \"Cini\", \"Ciobanu\", \"Ciolli\", \"Cioni\", \"Cipriani\", \"Cirillo\", \"Cirri\", \"Ciucchi\", \"Ciuffi\", \"Ciulli\", \"Ciullini\", \"Clemente\", \"Cocchi\", \"Cognome\", \"Coli\", \"Collini\", \"Colombo\", \"Colzi\", \"Comparini\", \"Conforti\", \"Consigli\", \"Conte\", \"Conti\", \"Contini\", \"Coppini\", \"Coppola\", \"Corsi\", \"Corsini\", \"Corti\", \"Cortini\", \"Cosi\", \"Costa\", \"Costantini\", \"Costantino\", \"Cozzi\", \"Cresci\", \"Crescioli\", \"Cresti\", \"Crini\", \"Curradi\", \"D'Agostino\", \"D'Alessandro\", \"D'Amico\", \"D'Angelo\", \"Daddi\", \"Dainelli\", \"Dallai\", \"Danti\", \"Davitti\", \"De Angelis\", \"De Luca\", \"De Marco\", \"De Rosa\", \"De Santis\", \"De Simone\", \"De Vita\", \"Degl'Innocenti\", \"Degli Innocenti\", \"Dei\", \"Del Lungo\", \"Del Re\", \"Di Marco\", \"Di Stefano\", \"Dini\", \"Diop\", \"Dobre\", \"Dolfi\", \"Donati\", \"Dondoli\", \"Dong\", \"Donnini\", \"Ducci\", \"Dumitru\", \"Ermini\", \"Esposito\", \"Evangelisti\", \"Fabbri\", \"Fabbrini\", \"Fabbrizzi\", \"Fabbroni\", \"Fabbrucci\", \"Fabiani\", \"Facchini\", \"Faggi\", \"Fagioli\", \"Failli\", \"Faini\", \"Falciani\", \"Falcini\", \"Falcone\", \"Fallani\", \"Falorni\", \"Falsini\", \"Falugiani\", \"Fancelli\", \"Fanelli\", \"Fanetti\", \"Fanfani\", \"Fani\", \"Fantappie'\", \"Fantechi\", \"Fanti\", \"Fantini\", \"Fantoni\", \"Farina\", \"Fattori\", \"Favilli\", \"Fedi\", \"Fei\", \"Ferrante\", \"Ferrara\", \"Ferrari\", \"Ferraro\", \"Ferretti\", \"Ferri\", \"Ferrini\", \"Ferroni\", \"Fiaschi\", \"Fibbi\", \"Fiesoli\", \"Filippi\", \"Filippini\", \"Fini\", \"Fioravanti\", \"Fiore\", \"Fiorentini\", \"Fiorini\", \"Fissi\", \"Focardi\", \"Foggi\", \"Fontana\", \"Fontanelli\", \"Fontani\", \"Forconi\", \"Formigli\", \"Forte\", \"Forti\", \"Fortini\", \"Fossati\", \"Fossi\", \"Francalanci\", \"Franceschi\", \"Franceschini\", \"Franchi\", \"Franchini\", \"Franci\", \"Francini\", \"Francioni\", \"Franco\", \"Frassineti\", \"Frati\", \"Fratini\", \"Frilli\", \"Frizzi\", \"Frosali\", \"Frosini\", \"Frullini\", \"Fusco\", \"Fusi\", \"Gabbrielli\", \"Gabellini\", \"Gagliardi\", \"Galanti\", \"Galardi\", \"Galeotti\", \"Galletti\", \"Galli\", \"Gallo\", \"Gallori\", \"Gambacciani\", \"Gargani\", \"Garofalo\", \"Garuglieri\", \"Gashi\", \"Gasperini\", \"Gatti\", \"Gelli\", \"Gensini\", \"Gentile\", \"Gentili\", \"Geri\", \"Gerini\", \"Gheri\", \"Ghini\", \"Giachetti\", \"Giachi\", \"Giacomelli\", \"Gianassi\", \"Giani\", \"Giannelli\", \"Giannetti\", \"Gianni\", \"Giannini\", \"Giannoni\", \"Giannotti\", \"Giannozzi\", \"Gigli\", \"Giordano\", \"Giorgetti\", \"Giorgi\", \"Giovacchini\", \"Giovannelli\", \"Giovannetti\", \"Giovannini\", \"Giovannoni\", \"Giuliani\", \"Giunti\", \"Giuntini\", \"Giusti\", \"Gonnelli\", \"Goretti\", \"Gori\", \"Gradi\", \"Gramigni\", \"Grassi\", \"Grasso\", \"Graziani\", \"Grazzini\", \"Greco\", \"Grifoni\", \"Grillo\", \"Grimaldi\", \"Grossi\", \"Gualtieri\", \"Guarducci\", \"Guarino\", \"Guarnieri\", \"Guasti\", \"Guerra\", \"Guerri\", \"Guerrini\", \"Guidi\", \"Guidotti\", \"He\", \"Hoxha\", \"Hu\", \"Huang\", \"Iandelli\", \"Ignesti\", \"Innocenti\", \"Jin\", \"La Rosa\", \"Lai\", \"Landi\", \"Landini\", \"Lanini\", \"Lapi\", \"Lapini\", \"Lari\", \"Lascialfari\", \"Lastrucci\", \"Latini\", \"Lazzeri\", \"Lazzerini\", \"Lelli\", \"Lenzi\", \"Leonardi\", \"Leoncini\", \"Leone\", \"Leoni\", \"Lepri\", \"Li\", \"Liao\", \"Lin\", \"Linari\", \"Lippi\", \"Lisi\", \"Livi\", \"Lombardi\", \"Lombardini\", \"Lombardo\", \"Longo\", \"Lopez\", \"Lorenzi\", \"Lorenzini\", \"Lorini\", \"Lotti\", \"Lu\", \"Lucchesi\", \"Lucherini\", \"Lunghi\", \"Lupi\", \"Madiai\", \"Maestrini\", \"Maffei\", \"Maggi\", \"Maggini\", \"Magherini\", \"Magini\", \"Magnani\", \"Magnelli\", \"Magni\", \"Magnolfi\", \"Magrini\", \"Malavolti\", \"Malevolti\", \"Manca\", \"Mancini\", \"Manetti\", \"Manfredi\", \"Mangani\", \"Mannelli\", \"Manni\", \"Mannini\", \"Mannucci\", \"Manuelli\", \"Manzini\", \"Marcelli\", \"Marchese\", \"Marchetti\", \"Marchi\", \"Marchiani\", \"Marchionni\", \"Marconi\", \"Marcucci\", \"Margheri\", \"Mari\", \"Mariani\", \"Marilli\", \"Marinai\", \"Marinari\", \"Marinelli\", \"Marini\", \"Marino\", \"Mariotti\", \"Marsili\", \"Martelli\", \"Martinelli\", \"Martini\", \"Martino\", \"Marzi\", \"Masi\", \"Masini\", \"Masoni\", \"Massai\", \"Materassi\", \"Mattei\", \"Matteini\", \"Matteucci\", \"Matteuzzi\", \"Mattioli\", \"Mattolini\", \"Matucci\", \"Mauro\", \"Mazzanti\", \"Mazzei\", \"Mazzetti\", \"Mazzi\", \"Mazzini\", \"Mazzocchi\", \"Mazzoli\", \"Mazzoni\", \"Mazzuoli\", \"Meacci\", \"Mecocci\", \"Meini\", \"Melani\", \"Mele\", \"Meli\", \"Mengoni\", \"Menichetti\", \"Meoni\", \"Merlini\", \"Messeri\", \"Messina\", \"Meucci\", \"Miccinesi\", \"Miceli\", \"Micheli\", \"Michelini\", \"Michelozzi\", \"Migliori\", \"Migliorini\", \"Milani\", \"Miniati\", \"Misuri\", \"Monaco\", \"Montagnani\", \"Montagni\", \"Montanari\", \"Montelatici\", \"Monti\", \"Montigiani\", \"Montini\", \"Morandi\", \"Morandini\", \"Morelli\", \"Moretti\", \"Morganti\", \"Mori\", \"Morini\", \"Moroni\", \"Morozzi\", \"Mugnai\", \"Mugnaini\", \"Mustafa\", \"Naldi\", \"Naldini\", \"Nannelli\", \"Nanni\", \"Nannini\", \"Nannucci\", \"Nardi\", \"Nardini\", \"Nardoni\", \"Natali\", \"Ndiaye\", \"Nencetti\", \"Nencini\", \"Nencioni\", \"Neri\", \"Nesi\", \"Nesti\", \"Niccolai\", \"Niccoli\", \"Niccolini\", \"Nigi\", \"Nistri\", \"Nocentini\", \"Noferini\", \"Novelli\", \"Nucci\", \"Nuti\", \"Nutini\", \"Oliva\", \"Olivieri\", \"Olmi\", \"Orlandi\", \"Orlandini\", \"Orlando\", \"Orsini\", \"Ortolani\", \"Ottanelli\", \"Pacciani\", \"Pace\", \"Paci\", \"Pacini\", \"Pagani\", \"Pagano\", \"Paggetti\", \"Pagliai\", \"Pagni\", \"Pagnini\", \"Paladini\", \"Palagi\", \"Palchetti\", \"Palloni\", \"Palmieri\", \"Palumbo\", \"Pampaloni\", \"Pancani\", \"Pandolfi\", \"Pandolfini\", \"Panerai\", \"Panichi\", \"Paoletti\", \"Paoli\", \"Paolini\", \"Papi\", \"Papini\", \"Papucci\", \"Parenti\", \"Parigi\", \"Parisi\", \"Parri\", \"Parrini\", \"Pasquini\", \"Passeri\", \"Pecchioli\", \"Pecorini\", \"Pellegrini\", \"Pepi\", \"Perini\", \"Perrone\", \"Peruzzi\", \"Pesci\", \"Pestelli\", \"Petri\", \"Petrini\", \"Petrucci\", \"Pettini\", \"Pezzati\", \"Pezzatini\", \"Piani\", \"Piazza\", \"Piazzesi\", \"Piazzini\", \"Piccardi\", \"Picchi\", \"Piccini\", \"Piccioli\", \"Pieraccini\", \"Pieraccioni\", \"Pieralli\", \"Pierattini\", \"Pieri\", \"Pierini\", \"Pieroni\", \"Pietrini\", \"Pini\", \"Pinna\", \"Pinto\", \"Pinzani\", \"Pinzauti\", \"Piras\", \"Pisani\", \"Pistolesi\", \"Poggesi\", \"Poggi\", \"Poggiali\", \"Poggiolini\", \"Poli\", \"Pollastri\", \"Porciani\", \"Pozzi\", \"Pratellesi\", \"Pratesi\", \"Prosperi\", \"Pruneti\", \"Pucci\", \"Puccini\", \"Puccioni\", \"Pugi\", \"Pugliese\", \"Puliti\", \"Querci\", \"Quercioli\", \"Raddi\", \"Radu\", \"Raffaelli\", \"Ragazzini\", \"Ranfagni\", \"Ranieri\", \"Rastrelli\", \"Raugei\", \"Raveggi\", \"Renai\", \"Renzi\", \"Rettori\", \"Ricci\", \"Ricciardi\", \"Ridi\", \"Ridolfi\", \"Rigacci\", \"Righi\", \"Righini\", \"Rinaldi\", \"Risaliti\", \"Ristori\", \"Rizzo\", \"Rocchi\", \"Rocchini\", \"Rogai\", \"Romagnoli\", \"Romanelli\", \"Romani\", \"Romano\", \"Romei\", \"Romeo\", \"Romiti\", \"Romoli\", \"Romolini\", \"Rontini\", \"Rosati\", \"Roselli\", \"Rosi\", \"Rossetti\", \"Rossi\", \"Rossini\", \"Rovai\", \"Ruggeri\", \"Ruggiero\", \"Russo\", \"Sabatini\", \"Saccardi\", \"Sacchetti\", \"Sacchi\", \"Sacco\", \"Salerno\", \"Salimbeni\", \"Salucci\", \"Salvadori\", \"Salvestrini\", \"Salvi\", \"Salvini\", \"Sanesi\", \"Sani\", \"Sanna\", \"Santi\", \"Santini\", \"Santoni\", \"Santoro\", \"Santucci\", \"Sardi\", \"Sarri\", \"Sarti\", \"Sassi\", \"Sbolci\", \"Scali\", \"Scarpelli\", \"Scarselli\", \"Scopetani\", \"Secci\", \"Selvi\", \"Senatori\", \"Senesi\", \"Serafini\", \"Sereni\", \"Serra\", \"Sestini\", \"Sguanci\", \"Sieni\", \"Signorini\", \"Silvestri\", \"Simoncini\", \"Simonetti\", \"Simoni\", \"Singh\", \"Sodi\", \"Soldi\", \"Somigli\", \"Sorbi\", \"Sorelli\", \"Sorrentino\", \"Sottili\", \"Spina\", \"Spinelli\", \"Staccioli\", \"Staderini\", \"Stefanelli\", \"Stefani\", \"Stefanini\", \"Stella\", \"Susini\", \"Tacchi\", \"Tacconi\", \"Taddei\", \"Tagliaferri\", \"Tamburini\", \"Tanganelli\", \"Tani\", \"Tanini\", \"Tapinassi\", \"Tarchi\", \"Tarchiani\", \"Targioni\", \"Tassi\", \"Tassini\", \"Tempesti\", \"Terzani\", \"Tesi\", \"Testa\", \"Testi\", \"Tilli\", \"Tinti\", \"Tirinnanzi\", \"Toccafondi\", \"Tofanari\", \"Tofani\", \"Tognaccini\", \"Tonelli\", \"Tonini\", \"Torelli\", \"Torrini\", \"Tosi\", \"Toti\", \"Tozzi\", \"Trambusti\", \"Trapani\", \"Tucci\", \"Turchi\", \"Ugolini\", \"Ulivi\", \"Valente\", \"Valenti\", \"Valentini\", \"Vangelisti\", \"Vanni\", \"Vannini\", \"Vannoni\", \"Vannozzi\", \"Vannucchi\", \"Vannucci\", \"Ventura\", \"Venturi\", \"Venturini\", \"Vestri\", \"Vettori\", \"Vichi\", \"Viciani\", \"Vieri\", \"Vigiani\", \"Vignoli\", \"Vignolini\", \"Vignozzi\", \"Villani\", \"Vinci\", \"Visani\", \"Vitale\", \"Vitali\", \"Viti\", \"Viviani\", \"Vivoli\", \"Volpe\", \"Volpi\", \"Wang\", \"Wu\", \"Xu\", \"Yang\", \"Ye\", \"Zagli\", \"Zani\", \"Zanieri\", \"Zanobini\", \"Zecchi\", \"Zetti\", \"Zhang\", \"Zheng\", \"Zhou\", \"Zhu\", \"Zingoni\", \"Zini\", \"Zoppi\"]\n        },\n\n        // Data taken from https://github.com/umpirsky/country-list/blob/master/data/en_US/country.json\n        countries: [{\"name\":\"Afghanistan\",\"abbreviation\":\"AF\"},{\"name\":\"land Islands\",\"abbreviation\":\"AX\"},{\"name\":\"Albania\",\"abbreviation\":\"AL\"},{\"name\":\"Algeria\",\"abbreviation\":\"DZ\"},{\"name\":\"American Samoa\",\"abbreviation\":\"AS\"},{\"name\":\"Andorra\",\"abbreviation\":\"AD\"},{\"name\":\"Angola\",\"abbreviation\":\"AO\"},{\"name\":\"Anguilla\",\"abbreviation\":\"AI\"},{\"name\":\"Antarctica\",\"abbreviation\":\"AQ\"},{\"name\":\"Antigua & Barbuda\",\"abbreviation\":\"AG\"},{\"name\":\"Argentina\",\"abbreviation\":\"AR\"},{\"name\":\"Armenia\",\"abbreviation\":\"AM\"},{\"name\":\"Aruba\",\"abbreviation\":\"AW\"},{\"name\":\"Ascension Island\",\"abbreviation\":\"AC\"},{\"name\":\"Australia\",\"abbreviation\":\"AU\"},{\"name\":\"Austria\",\"abbreviation\":\"AT\"},{\"name\":\"Azerbaijan\",\"abbreviation\":\"AZ\"},{\"name\":\"Bahamas\",\"abbreviation\":\"BS\"},{\"name\":\"Bahrain\",\"abbreviation\":\"BH\"},{\"name\":\"Bangladesh\",\"abbreviation\":\"BD\"},{\"name\":\"Barbados\",\"abbreviation\":\"BB\"},{\"name\":\"Belarus\",\"abbreviation\":\"BY\"},{\"name\":\"Belgium\",\"abbreviation\":\"BE\"},{\"name\":\"Belize\",\"abbreviation\":\"BZ\"},{\"name\":\"Benin\",\"abbreviation\":\"BJ\"},{\"name\":\"Bermuda\",\"abbreviation\":\"BM\"},{\"name\":\"Bhutan\",\"abbreviation\":\"BT\"},{\"name\":\"Bolivia\",\"abbreviation\":\"BO\"},{\"name\":\"Bosnia & Herzegovina\",\"abbreviation\":\"BA\"},{\"name\":\"Botswana\",\"abbreviation\":\"BW\"},{\"name\":\"Brazil\",\"abbreviation\":\"BR\"},{\"name\":\"British Indian Ocean Territory\",\"abbreviation\":\"IO\"},{\"name\":\"British Virgin Islands\",\"abbreviation\":\"VG\"},{\"name\":\"Brunei\",\"abbreviation\":\"BN\"},{\"name\":\"Bulgaria\",\"abbreviation\":\"BG\"},{\"name\":\"Burkina Faso\",\"abbreviation\":\"BF\"},{\"name\":\"Burundi\",\"abbreviation\":\"BI\"},{\"name\":\"Cambodia\",\"abbreviation\":\"KH\"},{\"name\":\"Cameroon\",\"abbreviation\":\"CM\"},{\"name\":\"Canada\",\"abbreviation\":\"CA\"},{\"name\":\"Canary Islands\",\"abbreviation\":\"IC\"},{\"name\":\"Cape Verde\",\"abbreviation\":\"CV\"},{\"name\":\"Caribbean Netherlands\",\"abbreviation\":\"BQ\"},{\"name\":\"Cayman Islands\",\"abbreviation\":\"KY\"},{\"name\":\"Central African Republic\",\"abbreviation\":\"CF\"},{\"name\":\"Ceuta & Melilla\",\"abbreviation\":\"EA\"},{\"name\":\"Chad\",\"abbreviation\":\"TD\"},{\"name\":\"Chile\",\"abbreviation\":\"CL\"},{\"name\":\"China\",\"abbreviation\":\"CN\"},{\"name\":\"Christmas Island\",\"abbreviation\":\"CX\"},{\"name\":\"Cocos (Keeling) Islands\",\"abbreviation\":\"CC\"},{\"name\":\"Colombia\",\"abbreviation\":\"CO\"},{\"name\":\"Comoros\",\"abbreviation\":\"KM\"},{\"name\":\"Congo - Brazzaville\",\"abbreviation\":\"CG\"},{\"name\":\"Congo - Kinshasa\",\"abbreviation\":\"CD\"},{\"name\":\"Cook Islands\",\"abbreviation\":\"CK\"},{\"name\":\"Costa Rica\",\"abbreviation\":\"CR\"},{\"name\":\"Cte d'Ivoire\",\"abbreviation\":\"CI\"},{\"name\":\"Croatia\",\"abbreviation\":\"HR\"},{\"name\":\"Cuba\",\"abbreviation\":\"CU\"},{\"name\":\"Curaao\",\"abbreviation\":\"CW\"},{\"name\":\"Cyprus\",\"abbreviation\":\"CY\"},{\"name\":\"Czech Republic\",\"abbreviation\":\"CZ\"},{\"name\":\"Denmark\",\"abbreviation\":\"DK\"},{\"name\":\"Diego Garcia\",\"abbreviation\":\"DG\"},{\"name\":\"Djibouti\",\"abbreviation\":\"DJ\"},{\"name\":\"Dominica\",\"abbreviation\":\"DM\"},{\"name\":\"Dominican Republic\",\"abbreviation\":\"DO\"},{\"name\":\"Ecuador\",\"abbreviation\":\"EC\"},{\"name\":\"Egypt\",\"abbreviation\":\"EG\"},{\"name\":\"El Salvador\",\"abbreviation\":\"SV\"},{\"name\":\"Equatorial Guinea\",\"abbreviation\":\"GQ\"},{\"name\":\"Eritrea\",\"abbreviation\":\"ER\"},{\"name\":\"Estonia\",\"abbreviation\":\"EE\"},{\"name\":\"Ethiopia\",\"abbreviation\":\"ET\"},{\"name\":\"Falkland Islands\",\"abbreviation\":\"FK\"},{\"name\":\"Faroe Islands\",\"abbreviation\":\"FO\"},{\"name\":\"Fiji\",\"abbreviation\":\"FJ\"},{\"name\":\"Finland\",\"abbreviation\":\"FI\"},{\"name\":\"France\",\"abbreviation\":\"FR\"},{\"name\":\"French Guiana\",\"abbreviation\":\"GF\"},{\"name\":\"French Polynesia\",\"abbreviation\":\"PF\"},{\"name\":\"French Southern Territories\",\"abbreviation\":\"TF\"},{\"name\":\"Gabon\",\"abbreviation\":\"GA\"},{\"name\":\"Gambia\",\"abbreviation\":\"GM\"},{\"name\":\"Georgia\",\"abbreviation\":\"GE\"},{\"name\":\"Germany\",\"abbreviation\":\"DE\"},{\"name\":\"Ghana\",\"abbreviation\":\"GH\"},{\"name\":\"Gibraltar\",\"abbreviation\":\"GI\"},{\"name\":\"Greece\",\"abbreviation\":\"GR\"},{\"name\":\"Greenland\",\"abbreviation\":\"GL\"},{\"name\":\"Grenada\",\"abbreviation\":\"GD\"},{\"name\":\"Guadeloupe\",\"abbreviation\":\"GP\"},{\"name\":\"Guam\",\"abbreviation\":\"GU\"},{\"name\":\"Guatemala\",\"abbreviation\":\"GT\"},{\"name\":\"Guernsey\",\"abbreviation\":\"GG\"},{\"name\":\"Guinea\",\"abbreviation\":\"GN\"},{\"name\":\"Guinea-Bissau\",\"abbreviation\":\"GW\"},{\"name\":\"Guyana\",\"abbreviation\":\"GY\"},{\"name\":\"Haiti\",\"abbreviation\":\"HT\"},{\"name\":\"Honduras\",\"abbreviation\":\"HN\"},{\"name\":\"Hong Kong SAR China\",\"abbreviation\":\"HK\"},{\"name\":\"Hungary\",\"abbreviation\":\"HU\"},{\"name\":\"Iceland\",\"abbreviation\":\"IS\"},{\"name\":\"India\",\"abbreviation\":\"IN\"},{\"name\":\"Indonesia\",\"abbreviation\":\"ID\"},{\"name\":\"Iran\",\"abbreviation\":\"IR\"},{\"name\":\"Iraq\",\"abbreviation\":\"IQ\"},{\"name\":\"Ireland\",\"abbreviation\":\"IE\"},{\"name\":\"Isle of Man\",\"abbreviation\":\"IM\"},{\"name\":\"Israel\",\"abbreviation\":\"IL\"},{\"name\":\"Italy\",\"abbreviation\":\"IT\"},{\"name\":\"Jamaica\",\"abbreviation\":\"JM\"},{\"name\":\"Japan\",\"abbreviation\":\"JP\"},{\"name\":\"Jersey\",\"abbreviation\":\"JE\"},{\"name\":\"Jordan\",\"abbreviation\":\"JO\"},{\"name\":\"Kazakhstan\",\"abbreviation\":\"KZ\"},{\"name\":\"Kenya\",\"abbreviation\":\"KE\"},{\"name\":\"Kiribati\",\"abbreviation\":\"KI\"},{\"name\":\"Kosovo\",\"abbreviation\":\"XK\"},{\"name\":\"Kuwait\",\"abbreviation\":\"KW\"},{\"name\":\"Kyrgyzstan\",\"abbreviation\":\"KG\"},{\"name\":\"Laos\",\"abbreviation\":\"LA\"},{\"name\":\"Latvia\",\"abbreviation\":\"LV\"},{\"name\":\"Lebanon\",\"abbreviation\":\"LB\"},{\"name\":\"Lesotho\",\"abbreviation\":\"LS\"},{\"name\":\"Liberia\",\"abbreviation\":\"LR\"},{\"name\":\"Libya\",\"abbreviation\":\"LY\"},{\"name\":\"Liechtenstein\",\"abbreviation\":\"LI\"},{\"name\":\"Lithuania\",\"abbreviation\":\"LT\"},{\"name\":\"Luxembourg\",\"abbreviation\":\"LU\"},{\"name\":\"Macau SAR China\",\"abbreviation\":\"MO\"},{\"name\":\"Macedonia\",\"abbreviation\":\"MK\"},{\"name\":\"Madagascar\",\"abbreviation\":\"MG\"},{\"name\":\"Malawi\",\"abbreviation\":\"MW\"},{\"name\":\"Malaysia\",\"abbreviation\":\"MY\"},{\"name\":\"Maldives\",\"abbreviation\":\"MV\"},{\"name\":\"Mali\",\"abbreviation\":\"ML\"},{\"name\":\"Malta\",\"abbreviation\":\"MT\"},{\"name\":\"Marshall Islands\",\"abbreviation\":\"MH\"},{\"name\":\"Martinique\",\"abbreviation\":\"MQ\"},{\"name\":\"Mauritania\",\"abbreviation\":\"MR\"},{\"name\":\"Mauritius\",\"abbreviation\":\"MU\"},{\"name\":\"Mayotte\",\"abbreviation\":\"YT\"},{\"name\":\"Mexico\",\"abbreviation\":\"MX\"},{\"name\":\"Micronesia\",\"abbreviation\":\"FM\"},{\"name\":\"Moldova\",\"abbreviation\":\"MD\"},{\"name\":\"Monaco\",\"abbreviation\":\"MC\"},{\"name\":\"Mongolia\",\"abbreviation\":\"MN\"},{\"name\":\"Montenegro\",\"abbreviation\":\"ME\"},{\"name\":\"Montserrat\",\"abbreviation\":\"MS\"},{\"name\":\"Morocco\",\"abbreviation\":\"MA\"},{\"name\":\"Mozambique\",\"abbreviation\":\"MZ\"},{\"name\":\"Myanmar (Burma)\",\"abbreviation\":\"MM\"},{\"name\":\"Namibia\",\"abbreviation\":\"NA\"},{\"name\":\"Nauru\",\"abbreviation\":\"NR\"},{\"name\":\"Nepal\",\"abbreviation\":\"NP\"},{\"name\":\"Netherlands\",\"abbreviation\":\"NL\"},{\"name\":\"New Caledonia\",\"abbreviation\":\"NC\"},{\"name\":\"New Zealand\",\"abbreviation\":\"NZ\"},{\"name\":\"Nicaragua\",\"abbreviation\":\"NI\"},{\"name\":\"Niger\",\"abbreviation\":\"NE\"},{\"name\":\"Nigeria\",\"abbreviation\":\"NG\"},{\"name\":\"Niue\",\"abbreviation\":\"NU\"},{\"name\":\"Norfolk Island\",\"abbreviation\":\"NF\"},{\"name\":\"North Korea\",\"abbreviation\":\"KP\"},{\"name\":\"Northern Mariana Islands\",\"abbreviation\":\"MP\"},{\"name\":\"Norway\",\"abbreviation\":\"NO\"},{\"name\":\"Oman\",\"abbreviation\":\"OM\"},{\"name\":\"Pakistan\",\"abbreviation\":\"PK\"},{\"name\":\"Palau\",\"abbreviation\":\"PW\"},{\"name\":\"Palestinian Territories\",\"abbreviation\":\"PS\"},{\"name\":\"Panama\",\"abbreviation\":\"PA\"},{\"name\":\"Papua New Guinea\",\"abbreviation\":\"PG\"},{\"name\":\"Paraguay\",\"abbreviation\":\"PY\"},{\"name\":\"Peru\",\"abbreviation\":\"PE\"},{\"name\":\"Philippines\",\"abbreviation\":\"PH\"},{\"name\":\"Pitcairn Islands\",\"abbreviation\":\"PN\"},{\"name\":\"Poland\",\"abbreviation\":\"PL\"},{\"name\":\"Portugal\",\"abbreviation\":\"PT\"},{\"name\":\"Puerto Rico\",\"abbreviation\":\"PR\"},{\"name\":\"Qatar\",\"abbreviation\":\"QA\"},{\"name\":\"Runion\",\"abbreviation\":\"RE\"},{\"name\":\"Romania\",\"abbreviation\":\"RO\"},{\"name\":\"Russia\",\"abbreviation\":\"RU\"},{\"name\":\"Rwanda\",\"abbreviation\":\"RW\"},{\"name\":\"Samoa\",\"abbreviation\":\"WS\"},{\"name\":\"San Marino\",\"abbreviation\":\"SM\"},{\"name\":\"So Tom and Prncipe\",\"abbreviation\":\"ST\"},{\"name\":\"Saudi Arabia\",\"abbreviation\":\"SA\"},{\"name\":\"Senegal\",\"abbreviation\":\"SN\"},{\"name\":\"Serbia\",\"abbreviation\":\"RS\"},{\"name\":\"Seychelles\",\"abbreviation\":\"SC\"},{\"name\":\"Sierra Leone\",\"abbreviation\":\"SL\"},{\"name\":\"Singapore\",\"abbreviation\":\"SG\"},{\"name\":\"Sint Maarten\",\"abbreviation\":\"SX\"},{\"name\":\"Slovakia\",\"abbreviation\":\"SK\"},{\"name\":\"Slovenia\",\"abbreviation\":\"SI\"},{\"name\":\"Solomon Islands\",\"abbreviation\":\"SB\"},{\"name\":\"Somalia\",\"abbreviation\":\"SO\"},{\"name\":\"South Africa\",\"abbreviation\":\"ZA\"},{\"name\":\"South Georgia & South Sandwich Islands\",\"abbreviation\":\"GS\"},{\"name\":\"South Korea\",\"abbreviation\":\"KR\"},{\"name\":\"South Sudan\",\"abbreviation\":\"SS\"},{\"name\":\"Spain\",\"abbreviation\":\"ES\"},{\"name\":\"Sri Lanka\",\"abbreviation\":\"LK\"},{\"name\":\"St. Barthlemy\",\"abbreviation\":\"BL\"},{\"name\":\"St. Helena\",\"abbreviation\":\"SH\"},{\"name\":\"St. Kitts & Nevis\",\"abbreviation\":\"KN\"},{\"name\":\"St. Lucia\",\"abbreviation\":\"LC\"},{\"name\":\"St. Martin\",\"abbreviation\":\"MF\"},{\"name\":\"St. Pierre & Miquelon\",\"abbreviation\":\"PM\"},{\"name\":\"St. Vincent & Grenadines\",\"abbreviation\":\"VC\"},{\"name\":\"Sudan\",\"abbreviation\":\"SD\"},{\"name\":\"Suriname\",\"abbreviation\":\"SR\"},{\"name\":\"Svalbard & Jan Mayen\",\"abbreviation\":\"SJ\"},{\"name\":\"Swaziland\",\"abbreviation\":\"SZ\"},{\"name\":\"Sweden\",\"abbreviation\":\"SE\"},{\"name\":\"Switzerland\",\"abbreviation\":\"CH\"},{\"name\":\"Syria\",\"abbreviation\":\"SY\"},{\"name\":\"Taiwan\",\"abbreviation\":\"TW\"},{\"name\":\"Tajikistan\",\"abbreviation\":\"TJ\"},{\"name\":\"Tanzania\",\"abbreviation\":\"TZ\"},{\"name\":\"Thailand\",\"abbreviation\":\"TH\"},{\"name\":\"Timor-Leste\",\"abbreviation\":\"TL\"},{\"name\":\"Togo\",\"abbreviation\":\"TG\"},{\"name\":\"Tokelau\",\"abbreviation\":\"TK\"},{\"name\":\"Tonga\",\"abbreviation\":\"TO\"},{\"name\":\"Trinidad & Tobago\",\"abbreviation\":\"TT\"},{\"name\":\"Tristan da Cunha\",\"abbreviation\":\"TA\"},{\"name\":\"Tunisia\",\"abbreviation\":\"TN\"},{\"name\":\"Turkey\",\"abbreviation\":\"TR\"},{\"name\":\"Turkmenistan\",\"abbreviation\":\"TM\"},{\"name\":\"Turks & Caicos Islands\",\"abbreviation\":\"TC\"},{\"name\":\"Tuvalu\",\"abbreviation\":\"TV\"},{\"name\":\"U.S. Outlying Islands\",\"abbreviation\":\"UM\"},{\"name\":\"U.S. Virgin Islands\",\"abbreviation\":\"VI\"},{\"name\":\"Uganda\",\"abbreviation\":\"UG\"},{\"name\":\"Ukraine\",\"abbreviation\":\"UA\"},{\"name\":\"United Arab Emirates\",\"abbreviation\":\"AE\"},{\"name\":\"United Kingdom\",\"abbreviation\":\"GB\"},{\"name\":\"United States\",\"abbreviation\":\"US\"},{\"name\":\"Uruguay\",\"abbreviation\":\"UY\"},{\"name\":\"Uzbekistan\",\"abbreviation\":\"UZ\"},{\"name\":\"Vanuatu\",\"abbreviation\":\"VU\"},{\"name\":\"Vatican City\",\"abbreviation\":\"VA\"},{\"name\":\"Venezuela\",\"abbreviation\":\"VE\"},{\"name\":\"Vietnam\",\"abbreviation\":\"VN\"},{\"name\":\"Wallis & Futuna\",\"abbreviation\":\"WF\"},{\"name\":\"Western Sahara\",\"abbreviation\":\"EH\"},{\"name\":\"Yemen\",\"abbreviation\":\"YE\"},{\"name\":\"Zambia\",\"abbreviation\":\"ZM\"},{\"name\":\"Zimbabwe\",\"abbreviation\":\"ZW\"}],\n\n\t\tcounties: {\n            // Data taken from http://www.downloadexcelfiles.com/gb_en/download-excel-file-list-counties-uk\n            \"uk\": [\n                {name: 'Bath and North East Somerset'},\n                {name: 'Bedford'},\n                {name: 'Blackburn with Darwen'},\n                {name: 'Blackpool'},\n                {name: 'Bournemouth'},\n                {name: 'Bracknell Forest'},\n                {name: 'Brighton & Hove'},\n                {name: 'Bristol'},\n                {name: 'Buckinghamshire'},\n                {name: 'Cambridgeshire'},\n                {name: 'Central Bedfordshire'},\n                {name: 'Cheshire East'},\n                {name: 'Cheshire West and Chester'},\n                {name: 'Cornwall'},\n                {name: 'County Durham'},\n                {name: 'Cumbria'},\n                {name: 'Darlington'},\n                {name: 'Derby'},\n                {name: 'Derbyshire'},\n                {name: 'Devon'},\n                {name: 'Dorset'},\n                {name: 'East Riding of Yorkshire'},\n                {name: 'East Sussex'},\n                {name: 'Essex'},\n                {name: 'Gloucestershire'},\n                {name: 'Greater London'},\n                {name: 'Greater Manchester'},\n                {name: 'Halton'},\n                {name: 'Hampshire'},\n                {name: 'Hartlepool'},\n                {name: 'Herefordshire'},\n                {name: 'Hertfordshire'},\n                {name: 'Hull'},\n                {name: 'Isle of Wight'},\n                {name: 'Isles of Scilly'},\n                {name: 'Kent'},\n                {name: 'Lancashire'},\n                {name: 'Leicester'},\n                {name: 'Leicestershire'},\n                {name: 'Lincolnshire'},\n                {name: 'Luton'},\n                {name: 'Medway'},\n                {name: 'Merseyside'},\n                {name: 'Middlesbrough'},\n                {name: 'Milton Keynes'},\n                {name: 'Norfolk'},\n                {name: 'North East Lincolnshire'},\n                {name: 'North Lincolnshire'},\n                {name: 'North Somerset'},\n                {name: 'North Yorkshire'},\n                {name: 'Northamptonshire'},\n                {name: 'Northumberland'},\n                {name: 'Nottingham'},\n                {name: 'Nottinghamshire'},\n                {name: 'Oxfordshire'},\n                {name: 'Peterborough'},\n                {name: 'Plymouth'},\n                {name: 'Poole'},\n                {name: 'Portsmouth'},\n                {name: 'Reading'},\n                {name: 'Redcar and Cleveland'},\n                {name: 'Rutland'},\n                {name: 'Shropshire'},\n                {name: 'Slough'},\n                {name: 'Somerset'},\n                {name: 'South Gloucestershire'},\n                {name: 'South Yorkshire'},\n                {name: 'Southampton'},\n                {name: 'Southend-on-Sea'},\n                {name: 'Staffordshire'},\n                {name: 'Stockton-on-Tees'},\n                {name: 'Stoke-on-Trent'},\n                {name: 'Suffolk'},\n                {name: 'Surrey'},\n                {name: 'Swindon'},\n                {name: 'Telford and Wrekin'},\n                {name: 'Thurrock'},\n                {name: 'Torbay'},\n                {name: 'Tyne and Wear'},\n                {name: 'Warrington'},\n                {name: 'Warwickshire'},\n                {name: 'West Berkshire'},\n                {name: 'West Midlands'},\n                {name: 'West Sussex'},\n                {name: 'West Yorkshire'},\n                {name: 'Wiltshire'},\n                {name: 'Windsor and Maidenhead'},\n                {name: 'Wokingham'},\n                {name: 'Worcestershire'},\n                {name: 'York'}]\n\t\t\t\t},\n        provinces: {\n            \"ca\": [\n                {name: 'Alberta', abbreviation: 'AB'},\n                {name: 'British Columbia', abbreviation: 'BC'},\n                {name: 'Manitoba', abbreviation: 'MB'},\n                {name: 'New Brunswick', abbreviation: 'NB'},\n                {name: 'Newfoundland and Labrador', abbreviation: 'NL'},\n                {name: 'Nova Scotia', abbreviation: 'NS'},\n                {name: 'Ontario', abbreviation: 'ON'},\n                {name: 'Prince Edward Island', abbreviation: 'PE'},\n                {name: 'Quebec', abbreviation: 'QC'},\n                {name: 'Saskatchewan', abbreviation: 'SK'},\n\n                // The case could be made that the following are not actually provinces\n                // since they are technically considered \"territories\" however they all\n                // look the same on an envelope!\n                {name: 'Northwest Territories', abbreviation: 'NT'},\n                {name: 'Nunavut', abbreviation: 'NU'},\n                {name: 'Yukon', abbreviation: 'YT'}\n            ],\n            \"it\": [\n                { name: \"Agrigento\", abbreviation: \"AG\", code: 84 },\n                { name: \"Alessandria\", abbreviation: \"AL\", code: 6 },\n                { name: \"Ancona\", abbreviation: \"AN\", code: 42 },\n                { name: \"Aosta\", abbreviation: \"AO\", code: 7 },\n                { name: \"L'Aquila\", abbreviation: \"AQ\", code: 66 },\n                { name: \"Arezzo\", abbreviation: \"AR\", code: 51 },\n                { name: \"Ascoli-Piceno\", abbreviation: \"AP\", code: 44 },\n                { name: \"Asti\", abbreviation: \"AT\", code: 5 },\n                { name: \"Avellino\", abbreviation: \"AV\", code: 64 },\n                { name: \"Bari\", abbreviation: \"BA\", code: 72 },\n                { name: \"Barletta-Andria-Trani\", abbreviation: \"BT\", code: 72 },\n                { name: \"Belluno\", abbreviation: \"BL\", code: 25 },\n                { name: \"Benevento\", abbreviation: \"BN\", code: 62 },\n                { name: \"Bergamo\", abbreviation: \"BG\", code: 16 },\n                { name: \"Biella\", abbreviation: \"BI\", code: 96 },\n                { name: \"Bologna\", abbreviation: \"BO\", code: 37 },\n                { name: \"Bolzano\", abbreviation: \"BZ\", code: 21 },\n                { name: \"Brescia\", abbreviation: \"BS\", code: 17 },\n                { name: \"Brindisi\", abbreviation: \"BR\", code: 74 },\n                { name: \"Cagliari\", abbreviation: \"CA\", code: 92 },\n                { name: \"Caltanissetta\", abbreviation: \"CL\", code: 85 },\n                { name: \"Campobasso\", abbreviation: \"CB\", code: 70 },\n                { name: \"Carbonia Iglesias\", abbreviation: \"CI\", code: 70 },\n                { name: \"Caserta\", abbreviation: \"CE\", code: 61 },\n                { name: \"Catania\", abbreviation: \"CT\", code: 87 },\n                { name: \"Catanzaro\", abbreviation: \"CZ\", code: 79 },\n                { name: \"Chieti\", abbreviation: \"CH\", code: 69 },\n                { name: \"Como\", abbreviation: \"CO\", code: 13 },\n                { name: \"Cosenza\", abbreviation: \"CS\", code: 78 },\n                { name: \"Cremona\", abbreviation: \"CR\", code: 19 },\n                { name: \"Crotone\", abbreviation: \"KR\", code: 101 },\n                { name: \"Cuneo\", abbreviation: \"CN\", code: 4 },\n                { name: \"Enna\", abbreviation: \"EN\", code: 86 },\n                { name: \"Fermo\", abbreviation: \"FM\", code: 86 },\n                { name: \"Ferrara\", abbreviation: \"FE\", code: 38 },\n                { name: \"Firenze\", abbreviation: \"FI\", code: 48 },\n                { name: \"Foggia\", abbreviation: \"FG\", code: 71 },\n                { name: \"Forli-Cesena\", abbreviation: \"FC\", code: 71 },\n                { name: \"Frosinone\", abbreviation: \"FR\", code: 60 },\n                { name: \"Genova\", abbreviation: \"GE\", code: 10 },\n                { name: \"Gorizia\", abbreviation: \"GO\", code: 31 },\n                { name: \"Grosseto\", abbreviation: \"GR\", code: 53 },\n                { name: \"Imperia\", abbreviation: \"IM\", code: 8 },\n                { name: \"Isernia\", abbreviation: \"IS\", code: 94 },\n                { name: \"La-Spezia\", abbreviation: \"SP\", code: 66 },\n                { name: \"Latina\", abbreviation: \"LT\", code: 59 },\n                { name: \"Lecce\", abbreviation: \"LE\", code: 75 },\n                { name: \"Lecco\", abbreviation: \"LC\", code: 97 },\n                { name: \"Livorno\", abbreviation: \"LI\", code: 49 },\n                { name: \"Lodi\", abbreviation: \"LO\", code: 98 },\n                { name: \"Lucca\", abbreviation: \"LU\", code: 46 },\n                { name: \"Macerata\", abbreviation: \"MC\", code: 43 },\n                { name: \"Mantova\", abbreviation: \"MN\", code: 20 },\n                { name: \"Massa-Carrara\", abbreviation: \"MS\", code: 45 },\n                { name: \"Matera\", abbreviation: \"MT\", code: 77 },\n                { name: \"Medio Campidano\", abbreviation: \"VS\", code: 77 },\n                { name: \"Messina\", abbreviation: \"ME\", code: 83 },\n                { name: \"Milano\", abbreviation: \"MI\", code: 15 },\n                { name: \"Modena\", abbreviation: \"MO\", code: 36 },\n                { name: \"Monza-Brianza\", abbreviation: \"MB\", code: 36 },\n                { name: \"Napoli\", abbreviation: \"NA\", code: 63 },\n                { name: \"Novara\", abbreviation: \"NO\", code: 3 },\n                { name: \"Nuoro\", abbreviation: \"NU\", code: 91 },\n                { name: \"Ogliastra\", abbreviation: \"OG\", code: 91 },\n                { name: \"Olbia Tempio\", abbreviation: \"OT\", code: 91 },\n                { name: \"Oristano\", abbreviation: \"OR\", code: 95 },\n                { name: \"Padova\", abbreviation: \"PD\", code: 28 },\n                { name: \"Palermo\", abbreviation: \"PA\", code: 82 },\n                { name: \"Parma\", abbreviation: \"PR\", code: 34 },\n                { name: \"Pavia\", abbreviation: \"PV\", code: 18 },\n                { name: \"Perugia\", abbreviation: \"PG\", code: 54 },\n                { name: \"Pesaro-Urbino\", abbreviation: \"PU\", code: 41 },\n                { name: \"Pescara\", abbreviation: \"PE\", code: 68 },\n                { name: \"Piacenza\", abbreviation: \"PC\", code: 33 },\n                { name: \"Pisa\", abbreviation: \"PI\", code: 50 },\n                { name: \"Pistoia\", abbreviation: \"PT\", code: 47 },\n                { name: \"Pordenone\", abbreviation: \"PN\", code: 93 },\n                { name: \"Potenza\", abbreviation: \"PZ\", code: 76 },\n                { name: \"Prato\", abbreviation: \"PO\", code: 100 },\n                { name: \"Ragusa\", abbreviation: \"RG\", code: 88 },\n                { name: \"Ravenna\", abbreviation: \"RA\", code: 39 },\n                { name: \"Reggio-Calabria\", abbreviation: \"RC\", code: 35 },\n                { name: \"Reggio-Emilia\", abbreviation: \"RE\", code: 35 },\n                { name: \"Rieti\", abbreviation: \"RI\", code: 57 },\n                { name: \"Rimini\", abbreviation: \"RN\", code: 99 },\n                { name: \"Roma\", abbreviation: \"Roma\", code: 58 },\n                { name: \"Rovigo\", abbreviation: \"RO\", code: 29 },\n                { name: \"Salerno\", abbreviation: \"SA\", code: 65 },\n                { name: \"Sassari\", abbreviation: \"SS\", code: 90 },\n                { name: \"Savona\", abbreviation: \"SV\", code: 9 },\n                { name: \"Siena\", abbreviation: \"SI\", code: 52 },\n                { name: \"Siracusa\", abbreviation: \"SR\", code: 89 },\n                { name: \"Sondrio\", abbreviation: \"SO\", code: 14 },\n                { name: \"Taranto\", abbreviation: \"TA\", code: 73 },\n                { name: \"Teramo\", abbreviation: \"TE\", code: 67 },\n                { name: \"Terni\", abbreviation: \"TR\", code: 55 },\n                { name: \"Torino\", abbreviation: \"TO\", code: 1 },\n                { name: \"Trapani\", abbreviation: \"TP\", code: 81 },\n                { name: \"Trento\", abbreviation: \"TN\", code: 22 },\n                { name: \"Treviso\", abbreviation: \"TV\", code: 26 },\n                { name: \"Trieste\", abbreviation: \"TS\", code: 32 },\n                { name: \"Udine\", abbreviation: \"UD\", code: 30 },\n                { name: \"Varese\", abbreviation: \"VA\", code: 12 },\n                { name: \"Venezia\", abbreviation: \"VE\", code: 27 },\n                { name: \"Verbania\", abbreviation: \"VB\", code: 27 },\n                { name: \"Vercelli\", abbreviation: \"VC\", code: 2 },\n                { name: \"Verona\", abbreviation: \"VR\", code: 23 },\n                { name: \"Vibo-Valentia\", abbreviation: \"VV\", code: 102 },\n                { name: \"Vicenza\", abbreviation: \"VI\", code: 24 },\n                { name: \"Viterbo\", abbreviation: \"VT\", code: 56 }\n            ]\n        },\n\n            // from: https://github.com/samsargent/Useful-Autocomplete-Data/blob/master/data/nationalities.json\n        nationalities: [\n           {name: 'Afghan'},\n           {name: 'Albanian'},\n           {name: 'Algerian'},\n           {name: 'American'},\n           {name: 'Andorran'},\n           {name: 'Angolan'},\n           {name: 'Antiguans'},\n           {name: 'Argentinean'},\n           {name: 'Armenian'},\n           {name: 'Australian'},\n           {name: 'Austrian'},\n           {name: 'Azerbaijani'},\n           {name: 'Bahami'},\n           {name: 'Bahraini'},\n           {name: 'Bangladeshi'},\n           {name: 'Barbadian'},\n           {name: 'Barbudans'},\n           {name: 'Batswana'},\n           {name: 'Belarusian'},\n           {name: 'Belgian'},\n           {name: 'Belizean'},\n           {name: 'Beninese'},\n           {name: 'Bhutanese'},\n           {name: 'Bolivian'},\n           {name: 'Bosnian'},\n           {name: 'Brazilian'},\n           {name: 'British'},\n           {name: 'Bruneian'},\n           {name: 'Bulgarian'},\n           {name: 'Burkinabe'},\n           {name: 'Burmese'},\n           {name: 'Burundian'},\n           {name: 'Cambodian'},\n           {name: 'Cameroonian'},\n           {name: 'Canadian'},\n           {name: 'Cape Verdean'},\n           {name: 'Central African'},\n           {name: 'Chadian'},\n           {name: 'Chilean'},\n           {name: 'Chinese'},\n           {name: 'Colombian'},\n           {name: 'Comoran'},\n           {name: 'Congolese'},\n           {name: 'Costa Rican'},\n           {name: 'Croatian'},\n           {name: 'Cuban'},\n           {name: 'Cypriot'},\n           {name: 'Czech'},\n           {name: 'Danish'},\n           {name: 'Djibouti'},\n           {name: 'Dominican'},\n           {name: 'Dutch'},\n           {name: 'East Timorese'},\n           {name: 'Ecuadorean'},\n           {name: 'Egyptian'},\n           {name: 'Emirian'},\n           {name: 'Equatorial Guinean'},\n           {name: 'Eritrean'},\n           {name: 'Estonian'},\n           {name: 'Ethiopian'},\n           {name: 'Fijian'},\n           {name: 'Filipino'},\n           {name: 'Finnish'},\n           {name: 'French'},\n           {name: 'Gabonese'},\n           {name: 'Gambian'},\n           {name: 'Georgian'},\n           {name: 'German'},\n           {name: 'Ghanaian'},\n           {name: 'Greek'},\n           {name: 'Grenadian'},\n           {name: 'Guatemalan'},\n           {name: 'Guinea-Bissauan'},\n           {name: 'Guinean'},\n           {name: 'Guyanese'},\n           {name: 'Haitian'},\n           {name: 'Herzegovinian'},\n           {name: 'Honduran'},\n           {name: 'Hungarian'},\n           {name: 'I-Kiribati'},\n           {name: 'Icelander'},\n           {name: 'Indian'},\n           {name: 'Indonesian'},\n           {name: 'Iranian'},\n           {name: 'Iraqi'},\n           {name: 'Irish'},\n           {name: 'Israeli'},\n           {name: 'Italian'},\n           {name: 'Ivorian'},\n           {name: 'Jamaican'},\n           {name: 'Japanese'},\n           {name: 'Jordanian'},\n           {name: 'Kazakhstani'},\n           {name: 'Kenyan'},\n           {name: 'Kittian and Nevisian'},\n           {name: 'Kuwaiti'},\n           {name: 'Kyrgyz'},\n           {name: 'Laotian'},\n           {name: 'Latvian'},\n           {name: 'Lebanese'},\n           {name: 'Liberian'},\n           {name: 'Libyan'},\n           {name: 'Liechtensteiner'},\n           {name: 'Lithuanian'},\n           {name: 'Luxembourger'},\n           {name: 'Macedonian'},\n           {name: 'Malagasy'},\n           {name: 'Malawian'},\n           {name: 'Malaysian'},\n           {name: 'Maldivan'},\n           {name: 'Malian'},\n           {name: 'Maltese'},\n           {name: 'Marshallese'},\n           {name: 'Mauritanian'},\n           {name: 'Mauritian'},\n           {name: 'Mexican'},\n           {name: 'Micronesian'},\n           {name: 'Moldovan'},\n           {name: 'Monacan'},\n           {name: 'Mongolian'},\n           {name: 'Moroccan'},\n           {name: 'Mosotho'},\n           {name: 'Motswana'},\n           {name: 'Mozambican'},\n           {name: 'Namibian'},\n           {name: 'Nauruan'},\n           {name: 'Nepalese'},\n           {name: 'New Zealander'},\n           {name: 'Nicaraguan'},\n           {name: 'Nigerian'},\n           {name: 'Nigerien'},\n           {name: 'North Korean'},\n           {name: 'Northern Irish'},\n           {name: 'Norwegian'},\n           {name: 'Omani'},\n           {name: 'Pakistani'},\n           {name: 'Palauan'},\n           {name: 'Panamanian'},\n           {name: 'Papua New Guinean'},\n           {name: 'Paraguayan'},\n           {name: 'Peruvian'},\n           {name: 'Polish'},\n           {name: 'Portuguese'},\n           {name: 'Qatari'},\n           {name: 'Romani'},\n           {name: 'Russian'},\n           {name: 'Rwandan'},\n           {name: 'Saint Lucian'},\n           {name: 'Salvadoran'},\n           {name: 'Samoan'},\n           {name: 'San Marinese'},\n           {name: 'Sao Tomean'},\n           {name: 'Saudi'},\n           {name: 'Scottish'},\n           {name: 'Senegalese'},\n           {name: 'Serbian'},\n           {name: 'Seychellois'},\n           {name: 'Sierra Leonean'},\n           {name: 'Singaporean'},\n           {name: 'Slovakian'},\n           {name: 'Slovenian'},\n           {name: 'Solomon Islander'},\n           {name: 'Somali'},\n           {name: 'South African'},\n           {name: 'South Korean'},\n           {name: 'Spanish'},\n           {name: 'Sri Lankan'},\n           {name: 'Sudanese'},\n           {name: 'Surinamer'},\n           {name: 'Swazi'},\n           {name: 'Swedish'},\n           {name: 'Swiss'},\n           {name: 'Syrian'},\n           {name: 'Taiwanese'},\n           {name: 'Tajik'},\n           {name: 'Tanzanian'},\n           {name: 'Thai'},\n           {name: 'Togolese'},\n           {name: 'Tongan'},\n           {name: 'Trinidadian or Tobagonian'},\n           {name: 'Tunisian'},\n           {name: 'Turkish'},\n           {name: 'Tuvaluan'},\n           {name: 'Ugandan'},\n           {name: 'Ukrainian'},\n           {name: 'Uruguaya'},\n           {name: 'Uzbekistani'},\n           {name: 'Venezuela'},\n           {name: 'Vietnamese'},\n           {name: 'Wels'},\n           {name: 'Yemenit'},\n           {name: 'Zambia'},\n           {name: 'Zimbabwe'},\n        ],\n\n        us_states_and_dc: [\n            {name: 'Alabama', abbreviation: 'AL'},\n            {name: 'Alaska', abbreviation: 'AK'},\n            {name: 'Arizona', abbreviation: 'AZ'},\n            {name: 'Arkansas', abbreviation: 'AR'},\n            {name: 'California', abbreviation: 'CA'},\n            {name: 'Colorado', abbreviation: 'CO'},\n            {name: 'Connecticut', abbreviation: 'CT'},\n            {name: 'Delaware', abbreviation: 'DE'},\n            {name: 'District of Columbia', abbreviation: 'DC'},\n            {name: 'Florida', abbreviation: 'FL'},\n            {name: 'Georgia', abbreviation: 'GA'},\n            {name: 'Hawaii', abbreviation: 'HI'},\n            {name: 'Idaho', abbreviation: 'ID'},\n            {name: 'Illinois', abbreviation: 'IL'},\n            {name: 'Indiana', abbreviation: 'IN'},\n            {name: 'Iowa', abbreviation: 'IA'},\n            {name: 'Kansas', abbreviation: 'KS'},\n            {name: 'Kentucky', abbreviation: 'KY'},\n            {name: 'Louisiana', abbreviation: 'LA'},\n            {name: 'Maine', abbreviation: 'ME'},\n            {name: 'Maryland', abbreviation: 'MD'},\n            {name: 'Massachusetts', abbreviation: 'MA'},\n            {name: 'Michigan', abbreviation: 'MI'},\n            {name: 'Minnesota', abbreviation: 'MN'},\n            {name: 'Mississippi', abbreviation: 'MS'},\n            {name: 'Missouri', abbreviation: 'MO'},\n            {name: 'Montana', abbreviation: 'MT'},\n            {name: 'Nebraska', abbreviation: 'NE'},\n            {name: 'Nevada', abbreviation: 'NV'},\n            {name: 'New Hampshire', abbreviation: 'NH'},\n            {name: 'New Jersey', abbreviation: 'NJ'},\n            {name: 'New Mexico', abbreviation: 'NM'},\n            {name: 'New York', abbreviation: 'NY'},\n            {name: 'North Carolina', abbreviation: 'NC'},\n            {name: 'North Dakota', abbreviation: 'ND'},\n            {name: 'Ohio', abbreviation: 'OH'},\n            {name: 'Oklahoma', abbreviation: 'OK'},\n            {name: 'Oregon', abbreviation: 'OR'},\n            {name: 'Pennsylvania', abbreviation: 'PA'},\n            {name: 'Rhode Island', abbreviation: 'RI'},\n            {name: 'South Carolina', abbreviation: 'SC'},\n            {name: 'South Dakota', abbreviation: 'SD'},\n            {name: 'Tennessee', abbreviation: 'TN'},\n            {name: 'Texas', abbreviation: 'TX'},\n            {name: 'Utah', abbreviation: 'UT'},\n            {name: 'Vermont', abbreviation: 'VT'},\n            {name: 'Virginia', abbreviation: 'VA'},\n            {name: 'Washington', abbreviation: 'WA'},\n            {name: 'West Virginia', abbreviation: 'WV'},\n            {name: 'Wisconsin', abbreviation: 'WI'},\n            {name: 'Wyoming', abbreviation: 'WY'}\n        ],\n\n        territories: [\n            {name: 'American Samoa', abbreviation: 'AS'},\n            {name: 'Federated States of Micronesia', abbreviation: 'FM'},\n            {name: 'Guam', abbreviation: 'GU'},\n            {name: 'Marshall Islands', abbreviation: 'MH'},\n            {name: 'Northern Mariana Islands', abbreviation: 'MP'},\n            {name: 'Puerto Rico', abbreviation: 'PR'},\n            {name: 'Virgin Islands, U.S.', abbreviation: 'VI'}\n        ],\n\n        armed_forces: [\n            {name: 'Armed Forces Europe', abbreviation: 'AE'},\n            {name: 'Armed Forces Pacific', abbreviation: 'AP'},\n            {name: 'Armed Forces the Americas', abbreviation: 'AA'}\n        ],\n\n        country_regions: {\n            it: [\n                { name: \"Valle d'Aosta\", abbreviation: \"VDA\" },\n                { name: \"Piemonte\", abbreviation: \"PIE\" },\n                { name: \"Lombardia\", abbreviation: \"LOM\" },\n                { name: \"Veneto\", abbreviation: \"VEN\" },\n                { name: \"Trentino Alto Adige\", abbreviation: \"TAA\" },\n                { name: \"Friuli Venezia Giulia\", abbreviation: \"FVG\" },\n                { name: \"Liguria\", abbreviation: \"LIG\" },\n                { name: \"Emilia Romagna\", abbreviation: \"EMR\" },\n                { name: \"Toscana\", abbreviation: \"TOS\" },\n                { name: \"Umbria\", abbreviation: \"UMB\" },\n                { name: \"Marche\", abbreviation: \"MAR\" },\n                { name: \"Abruzzo\", abbreviation: \"ABR\" },\n                { name: \"Lazio\", abbreviation: \"LAZ\" },\n                { name: \"Campania\", abbreviation: \"CAM\" },\n                { name: \"Puglia\", abbreviation: \"PUG\" },\n                { name: \"Basilicata\", abbreviation: \"BAS\" },\n                { name: \"Molise\", abbreviation: \"MOL\" },\n                { name: \"Calabria\", abbreviation: \"CAL\" },\n                { name: \"Sicilia\", abbreviation: \"SIC\" },\n                { name: \"Sardegna\", abbreviation: \"SAR\" }\n            ]\n        },\n\n        street_suffixes: {\n            'us': [\n                {name: 'Avenue', abbreviation: 'Ave'},\n                {name: 'Boulevard', abbreviation: 'Blvd'},\n                {name: 'Center', abbreviation: 'Ctr'},\n                {name: 'Circle', abbreviation: 'Cir'},\n                {name: 'Court', abbreviation: 'Ct'},\n                {name: 'Drive', abbreviation: 'Dr'},\n                {name: 'Extension', abbreviation: 'Ext'},\n                {name: 'Glen', abbreviation: 'Gln'},\n                {name: 'Grove', abbreviation: 'Grv'},\n                {name: 'Heights', abbreviation: 'Hts'},\n                {name: 'Highway', abbreviation: 'Hwy'},\n                {name: 'Junction', abbreviation: 'Jct'},\n                {name: 'Key', abbreviation: 'Key'},\n                {name: 'Lane', abbreviation: 'Ln'},\n                {name: 'Loop', abbreviation: 'Loop'},\n                {name: 'Manor', abbreviation: 'Mnr'},\n                {name: 'Mill', abbreviation: 'Mill'},\n                {name: 'Park', abbreviation: 'Park'},\n                {name: 'Parkway', abbreviation: 'Pkwy'},\n                {name: 'Pass', abbreviation: 'Pass'},\n                {name: 'Path', abbreviation: 'Path'},\n                {name: 'Pike', abbreviation: 'Pike'},\n                {name: 'Place', abbreviation: 'Pl'},\n                {name: 'Plaza', abbreviation: 'Plz'},\n                {name: 'Point', abbreviation: 'Pt'},\n                {name: 'Ridge', abbreviation: 'Rdg'},\n                {name: 'River', abbreviation: 'Riv'},\n                {name: 'Road', abbreviation: 'Rd'},\n                {name: 'Square', abbreviation: 'Sq'},\n                {name: 'Street', abbreviation: 'St'},\n                {name: 'Terrace', abbreviation: 'Ter'},\n                {name: 'Trail', abbreviation: 'Trl'},\n                {name: 'Turnpike', abbreviation: 'Tpke'},\n                {name: 'View', abbreviation: 'Vw'},\n                {name: 'Way', abbreviation: 'Way'}\n            ],\n            'it': [\n                { name: 'Accesso', abbreviation: 'Acc.' },\n                { name: 'Alzaia', abbreviation: 'Alz.' },\n                { name: 'Arco', abbreviation: 'Arco' },\n                { name: 'Archivolto', abbreviation: 'Acv.' },\n                { name: 'Arena', abbreviation: 'Arena' },\n                { name: 'Argine', abbreviation: 'Argine' },\n                { name: 'Bacino', abbreviation: 'Bacino' },\n                { name: 'Banchi', abbreviation: 'Banchi' },\n                { name: 'Banchina', abbreviation: 'Ban.' },\n                { name: 'Bastioni', abbreviation: 'Bas.' },\n                { name: 'Belvedere', abbreviation: 'Belv.' },\n                { name: 'Borgata', abbreviation: 'B.ta' },\n                { name: 'Borgo', abbreviation: 'B.go' },\n                { name: 'Calata', abbreviation: 'Cal.' },\n                { name: 'Calle', abbreviation: 'Calle' },\n                { name: 'Campiello', abbreviation: 'Cam.' },\n                { name: 'Campo', abbreviation: 'Cam.' },\n                { name: 'Canale', abbreviation: 'Can.' },\n                { name: 'Carraia', abbreviation: 'Carr.' },\n                { name: 'Cascina', abbreviation: 'Cascina' },\n                { name: 'Case sparse', abbreviation: 'c.s.' },\n                { name: 'Cavalcavia', abbreviation: 'Cv.' },\n                { name: 'Circonvallazione', abbreviation: 'Cv.' },\n                { name: 'Complanare', abbreviation: 'C.re' },\n                { name: 'Contrada', abbreviation: 'C.da' },\n                { name: 'Corso', abbreviation: 'C.so' },\n                { name: 'Corte', abbreviation: 'C.te' },\n                { name: 'Cortile', abbreviation: 'C.le' },\n                { name: 'Diramazione', abbreviation: 'Dir.' },\n                { name: 'Fondaco', abbreviation: 'F.co' },\n                { name: 'Fondamenta', abbreviation: 'F.ta' },\n                { name: 'Fondo', abbreviation: 'F.do' },\n                { name: 'Frazione', abbreviation: 'Fr.' },\n                { name: 'Isola', abbreviation: 'Is.' },\n                { name: 'Largo', abbreviation: 'L.go' },\n                { name: 'Litoranea', abbreviation: 'Lit.' },\n                { name: 'Lungolago', abbreviation: 'L.go lago' },\n                { name: 'Lungo Po', abbreviation: 'l.go Po' },\n                { name: 'Molo', abbreviation: 'Molo' },\n                { name: 'Mura', abbreviation: 'Mura' },\n                { name: 'Passaggio privato', abbreviation: 'pass. priv.' },\n                { name: 'Passeggiata', abbreviation: 'Pass.' },\n                { name: 'Piazza', abbreviation: 'P.zza' },\n                { name: 'Piazzale', abbreviation: 'P.le' },\n                { name: 'Ponte', abbreviation: 'P.te' },\n                { name: 'Portico', abbreviation: 'P.co' },\n                { name: 'Rampa', abbreviation: 'Rampa' },\n                { name: 'Regione', abbreviation: 'Reg.' },\n                { name: 'Rione', abbreviation: 'R.ne' },\n                { name: 'Rio', abbreviation: 'Rio' },\n                { name: 'Ripa', abbreviation: 'Ripa' },\n                { name: 'Riva', abbreviation: 'Riva' },\n                { name: 'Rond', abbreviation: 'Rond' },\n                { name: 'Rotonda', abbreviation: 'Rot.' },\n                { name: 'Sagrato', abbreviation: 'Sagr.' },\n                { name: 'Salita', abbreviation: 'Sal.' },\n                { name: 'Scalinata', abbreviation: 'Scal.' },\n                { name: 'Scalone', abbreviation: 'Scal.' },\n                { name: 'Slargo', abbreviation: 'Sl.' },\n                { name: 'Sottoportico', abbreviation: 'Sott.' },\n                { name: 'Strada', abbreviation: 'Str.' },\n                { name: 'Stradale', abbreviation: 'Str.le' },\n                { name: 'Strettoia', abbreviation: 'Strett.' },\n                { name: 'Traversa', abbreviation: 'Trav.' },\n                { name: 'Via', abbreviation: 'V.' },\n                { name: 'Viale', abbreviation: 'V.le' },\n                { name: 'Vicinale', abbreviation: 'Vic.le' },\n                { name: 'Vicolo', abbreviation: 'Vic.' }\n            ]\n        },\n\n        months: [\n            {name: 'January', short_name: 'Jan', numeric: '01', days: 31},\n            // Not messing with leap years...\n            {name: 'February', short_name: 'Feb', numeric: '02', days: 28},\n            {name: 'March', short_name: 'Mar', numeric: '03', days: 31},\n            {name: 'April', short_name: 'Apr', numeric: '04', days: 30},\n            {name: 'May', short_name: 'May', numeric: '05', days: 31},\n            {name: 'June', short_name: 'Jun', numeric: '06', days: 30},\n            {name: 'July', short_name: 'Jul', numeric: '07', days: 31},\n            {name: 'August', short_name: 'Aug', numeric: '08', days: 31},\n            {name: 'September', short_name: 'Sep', numeric: '09', days: 30},\n            {name: 'October', short_name: 'Oct', numeric: '10', days: 31},\n            {name: 'November', short_name: 'Nov', numeric: '11', days: 30},\n            {name: 'December', short_name: 'Dec', numeric: '12', days: 31}\n        ],\n\n        // http://en.wikipedia.org/wiki/Bank_card_number#Issuer_identification_number_.28IIN.29\n        cc_types: [\n            {name: \"American Express\", short_name: 'amex', prefix: '34', length: 15},\n            {name: \"Bankcard\", short_name: 'bankcard', prefix: '5610', length: 16},\n            {name: \"China UnionPay\", short_name: 'chinaunion', prefix: '62', length: 16},\n            {name: \"Diners Club Carte Blanche\", short_name: 'dccarte', prefix: '300', length: 14},\n            {name: \"Diners Club enRoute\", short_name: 'dcenroute', prefix: '2014', length: 15},\n            {name: \"Diners Club International\", short_name: 'dcintl', prefix: '36', length: 14},\n            {name: \"Diners Club United States & Canada\", short_name: 'dcusc', prefix: '54', length: 16},\n            {name: \"Discover Card\", short_name: 'discover', prefix: '6011', length: 16},\n            {name: \"InstaPayment\", short_name: 'instapay', prefix: '637', length: 16},\n            {name: \"JCB\", short_name: 'jcb', prefix: '3528', length: 16},\n            {name: \"Laser\", short_name: 'laser', prefix: '6304', length: 16},\n            {name: \"Maestro\", short_name: 'maestro', prefix: '5018', length: 16},\n            {name: \"Mastercard\", short_name: 'mc', prefix: '51', length: 16},\n            {name: \"Solo\", short_name: 'solo', prefix: '6334', length: 16},\n            {name: \"Switch\", short_name: 'switch', prefix: '4903', length: 16},\n            {name: \"Visa\", short_name: 'visa', prefix: '4', length: 16},\n            {name: \"Visa Electron\", short_name: 'electron', prefix: '4026', length: 16}\n        ],\n\n        //return all world currency by ISO 4217\n        currency_types: [\n            {'code' : 'AED', 'name' : 'United Arab Emirates Dirham'},\n            {'code' : 'AFN', 'name' : 'Afghanistan Afghani'},\n            {'code' : 'ALL', 'name' : 'Albania Lek'},\n            {'code' : 'AMD', 'name' : 'Armenia Dram'},\n            {'code' : 'ANG', 'name' : 'Netherlands Antilles Guilder'},\n            {'code' : 'AOA', 'name' : 'Angola Kwanza'},\n            {'code' : 'ARS', 'name' : 'Argentina Peso'},\n            {'code' : 'AUD', 'name' : 'Australia Dollar'},\n            {'code' : 'AWG', 'name' : 'Aruba Guilder'},\n            {'code' : 'AZN', 'name' : 'Azerbaijan New Manat'},\n            {'code' : 'BAM', 'name' : 'Bosnia and Herzegovina Convertible Marka'},\n            {'code' : 'BBD', 'name' : 'Barbados Dollar'},\n            {'code' : 'BDT', 'name' : 'Bangladesh Taka'},\n            {'code' : 'BGN', 'name' : 'Bulgaria Lev'},\n            {'code' : 'BHD', 'name' : 'Bahrain Dinar'},\n            {'code' : 'BIF', 'name' : 'Burundi Franc'},\n            {'code' : 'BMD', 'name' : 'Bermuda Dollar'},\n            {'code' : 'BND', 'name' : 'Brunei Darussalam Dollar'},\n            {'code' : 'BOB', 'name' : 'Bolivia Boliviano'},\n            {'code' : 'BRL', 'name' : 'Brazil Real'},\n            {'code' : 'BSD', 'name' : 'Bahamas Dollar'},\n            {'code' : 'BTN', 'name' : 'Bhutan Ngultrum'},\n            {'code' : 'BWP', 'name' : 'Botswana Pula'},\n            {'code' : 'BYR', 'name' : 'Belarus Ruble'},\n            {'code' : 'BZD', 'name' : 'Belize Dollar'},\n            {'code' : 'CAD', 'name' : 'Canada Dollar'},\n            {'code' : 'CDF', 'name' : 'Congo/Kinshasa Franc'},\n            {'code' : 'CHF', 'name' : 'Switzerland Franc'},\n            {'code' : 'CLP', 'name' : 'Chile Peso'},\n            {'code' : 'CNY', 'name' : 'China Yuan Renminbi'},\n            {'code' : 'COP', 'name' : 'Colombia Peso'},\n            {'code' : 'CRC', 'name' : 'Costa Rica Colon'},\n            {'code' : 'CUC', 'name' : 'Cuba Convertible Peso'},\n            {'code' : 'CUP', 'name' : 'Cuba Peso'},\n            {'code' : 'CVE', 'name' : 'Cape Verde Escudo'},\n            {'code' : 'CZK', 'name' : 'Czech Republic Koruna'},\n            {'code' : 'DJF', 'name' : 'Djibouti Franc'},\n            {'code' : 'DKK', 'name' : 'Denmark Krone'},\n            {'code' : 'DOP', 'name' : 'Dominican Republic Peso'},\n            {'code' : 'DZD', 'name' : 'Algeria Dinar'},\n            {'code' : 'EGP', 'name' : 'Egypt Pound'},\n            {'code' : 'ERN', 'name' : 'Eritrea Nakfa'},\n            {'code' : 'ETB', 'name' : 'Ethiopia Birr'},\n            {'code' : 'EUR', 'name' : 'Euro Member Countries'},\n            {'code' : 'FJD', 'name' : 'Fiji Dollar'},\n            {'code' : 'FKP', 'name' : 'Falkland Islands (Malvinas) Pound'},\n            {'code' : 'GBP', 'name' : 'United Kingdom Pound'},\n            {'code' : 'GEL', 'name' : 'Georgia Lari'},\n            {'code' : 'GGP', 'name' : 'Guernsey Pound'},\n            {'code' : 'GHS', 'name' : 'Ghana Cedi'},\n            {'code' : 'GIP', 'name' : 'Gibraltar Pound'},\n            {'code' : 'GMD', 'name' : 'Gambia Dalasi'},\n            {'code' : 'GNF', 'name' : 'Guinea Franc'},\n            {'code' : 'GTQ', 'name' : 'Guatemala Quetzal'},\n            {'code' : 'GYD', 'name' : 'Guyana Dollar'},\n            {'code' : 'HKD', 'name' : 'Hong Kong Dollar'},\n            {'code' : 'HNL', 'name' : 'Honduras Lempira'},\n            {'code' : 'HRK', 'name' : 'Croatia Kuna'},\n            {'code' : 'HTG', 'name' : 'Haiti Gourde'},\n            {'code' : 'HUF', 'name' : 'Hungary Forint'},\n            {'code' : 'IDR', 'name' : 'Indonesia Rupiah'},\n            {'code' : 'ILS', 'name' : 'Israel Shekel'},\n            {'code' : 'IMP', 'name' : 'Isle of Man Pound'},\n            {'code' : 'INR', 'name' : 'India Rupee'},\n            {'code' : 'IQD', 'name' : 'Iraq Dinar'},\n            {'code' : 'IRR', 'name' : 'Iran Rial'},\n            {'code' : 'ISK', 'name' : 'Iceland Krona'},\n            {'code' : 'JEP', 'name' : 'Jersey Pound'},\n            {'code' : 'JMD', 'name' : 'Jamaica Dollar'},\n            {'code' : 'JOD', 'name' : 'Jordan Dinar'},\n            {'code' : 'JPY', 'name' : 'Japan Yen'},\n            {'code' : 'KES', 'name' : 'Kenya Shilling'},\n            {'code' : 'KGS', 'name' : 'Kyrgyzstan Som'},\n            {'code' : 'KHR', 'name' : 'Cambodia Riel'},\n            {'code' : 'KMF', 'name' : 'Comoros Franc'},\n            {'code' : 'KPW', 'name' : 'Korea (North) Won'},\n            {'code' : 'KRW', 'name' : 'Korea (South) Won'},\n            {'code' : 'KWD', 'name' : 'Kuwait Dinar'},\n            {'code' : 'KYD', 'name' : 'Cayman Islands Dollar'},\n            {'code' : 'KZT', 'name' : 'Kazakhstan Tenge'},\n            {'code' : 'LAK', 'name' : 'Laos Kip'},\n            {'code' : 'LBP', 'name' : 'Lebanon Pound'},\n            {'code' : 'LKR', 'name' : 'Sri Lanka Rupee'},\n            {'code' : 'LRD', 'name' : 'Liberia Dollar'},\n            {'code' : 'LSL', 'name' : 'Lesotho Loti'},\n            {'code' : 'LTL', 'name' : 'Lithuania Litas'},\n            {'code' : 'LYD', 'name' : 'Libya Dinar'},\n            {'code' : 'MAD', 'name' : 'Morocco Dirham'},\n            {'code' : 'MDL', 'name' : 'Moldova Leu'},\n            {'code' : 'MGA', 'name' : 'Madagascar Ariary'},\n            {'code' : 'MKD', 'name' : 'Macedonia Denar'},\n            {'code' : 'MMK', 'name' : 'Myanmar (Burma) Kyat'},\n            {'code' : 'MNT', 'name' : 'Mongolia Tughrik'},\n            {'code' : 'MOP', 'name' : 'Macau Pataca'},\n            {'code' : 'MRO', 'name' : 'Mauritania Ouguiya'},\n            {'code' : 'MUR', 'name' : 'Mauritius Rupee'},\n            {'code' : 'MVR', 'name' : 'Maldives (Maldive Islands) Rufiyaa'},\n            {'code' : 'MWK', 'name' : 'Malawi Kwacha'},\n            {'code' : 'MXN', 'name' : 'Mexico Peso'},\n            {'code' : 'MYR', 'name' : 'Malaysia Ringgit'},\n            {'code' : 'MZN', 'name' : 'Mozambique Metical'},\n            {'code' : 'NAD', 'name' : 'Namibia Dollar'},\n            {'code' : 'NGN', 'name' : 'Nigeria Naira'},\n            {'code' : 'NIO', 'name' : 'Nicaragua Cordoba'},\n            {'code' : 'NOK', 'name' : 'Norway Krone'},\n            {'code' : 'NPR', 'name' : 'Nepal Rupee'},\n            {'code' : 'NZD', 'name' : 'New Zealand Dollar'},\n            {'code' : 'OMR', 'name' : 'Oman Rial'},\n            {'code' : 'PAB', 'name' : 'Panama Balboa'},\n            {'code' : 'PEN', 'name' : 'Peru Nuevo Sol'},\n            {'code' : 'PGK', 'name' : 'Papua New Guinea Kina'},\n            {'code' : 'PHP', 'name' : 'Philippines Peso'},\n            {'code' : 'PKR', 'name' : 'Pakistan Rupee'},\n            {'code' : 'PLN', 'name' : 'Poland Zloty'},\n            {'code' : 'PYG', 'name' : 'Paraguay Guarani'},\n            {'code' : 'QAR', 'name' : 'Qatar Riyal'},\n            {'code' : 'RON', 'name' : 'Romania New Leu'},\n            {'code' : 'RSD', 'name' : 'Serbia Dinar'},\n            {'code' : 'RUB', 'name' : 'Russia Ruble'},\n            {'code' : 'RWF', 'name' : 'Rwanda Franc'},\n            {'code' : 'SAR', 'name' : 'Saudi Arabia Riyal'},\n            {'code' : 'SBD', 'name' : 'Solomon Islands Dollar'},\n            {'code' : 'SCR', 'name' : 'Seychelles Rupee'},\n            {'code' : 'SDG', 'name' : 'Sudan Pound'},\n            {'code' : 'SEK', 'name' : 'Sweden Krona'},\n            {'code' : 'SGD', 'name' : 'Singapore Dollar'},\n            {'code' : 'SHP', 'name' : 'Saint Helena Pound'},\n            {'code' : 'SLL', 'name' : 'Sierra Leone Leone'},\n            {'code' : 'SOS', 'name' : 'Somalia Shilling'},\n            {'code' : 'SPL', 'name' : 'Seborga Luigino'},\n            {'code' : 'SRD', 'name' : 'Suriname Dollar'},\n            {'code' : 'STD', 'name' : 'So Tom and Prncipe Dobra'},\n            {'code' : 'SVC', 'name' : 'El Salvador Colon'},\n            {'code' : 'SYP', 'name' : 'Syria Pound'},\n            {'code' : 'SZL', 'name' : 'Swaziland Lilangeni'},\n            {'code' : 'THB', 'name' : 'Thailand Baht'},\n            {'code' : 'TJS', 'name' : 'Tajikistan Somoni'},\n            {'code' : 'TMT', 'name' : 'Turkmenistan Manat'},\n            {'code' : 'TND', 'name' : 'Tunisia Dinar'},\n            {'code' : 'TOP', 'name' : 'Tonga Pa\\'anga'},\n            {'code' : 'TRY', 'name' : 'Turkey Lira'},\n            {'code' : 'TTD', 'name' : 'Trinidad and Tobago Dollar'},\n            {'code' : 'TVD', 'name' : 'Tuvalu Dollar'},\n            {'code' : 'TWD', 'name' : 'Taiwan New Dollar'},\n            {'code' : 'TZS', 'name' : 'Tanzania Shilling'},\n            {'code' : 'UAH', 'name' : 'Ukraine Hryvnia'},\n            {'code' : 'UGX', 'name' : 'Uganda Shilling'},\n            {'code' : 'USD', 'name' : 'United States Dollar'},\n            {'code' : 'UYU', 'name' : 'Uruguay Peso'},\n            {'code' : 'UZS', 'name' : 'Uzbekistan Som'},\n            {'code' : 'VEF', 'name' : 'Venezuela Bolivar'},\n            {'code' : 'VND', 'name' : 'Viet Nam Dong'},\n            {'code' : 'VUV', 'name' : 'Vanuatu Vatu'},\n            {'code' : 'WST', 'name' : 'Samoa Tala'},\n            {'code' : 'XAF', 'name' : 'Communaut Financire Africaine (BEAC) CFA Franc BEAC'},\n            {'code' : 'XCD', 'name' : 'East Caribbean Dollar'},\n            {'code' : 'XDR', 'name' : 'International Monetary Fund (IMF) Special Drawing Rights'},\n            {'code' : 'XOF', 'name' : 'Communaut Financire Africaine (BCEAO) Franc'},\n            {'code' : 'XPF', 'name' : 'Comptoirs Franais du Pacifique (CFP) Franc'},\n            {'code' : 'YER', 'name' : 'Yemen Rial'},\n            {'code' : 'ZAR', 'name' : 'South Africa Rand'},\n            {'code' : 'ZMW', 'name' : 'Zambia Kwacha'},\n            {'code' : 'ZWD', 'name' : 'Zimbabwe Dollar'}\n        ],\n\n        // return the names of all valide colors\n        colorNames : [  \"AliceBlue\", \"Black\", \"Navy\", \"DarkBlue\", \"MediumBlue\", \"Blue\", \"DarkGreen\", \"Green\", \"Teal\", \"DarkCyan\", \"DeepSkyBlue\", \"DarkTurquoise\", \"MediumSpringGreen\", \"Lime\", \"SpringGreen\",\n            \"Aqua\", \"Cyan\", \"MidnightBlue\", \"DodgerBlue\", \"LightSeaGreen\", \"ForestGreen\", \"SeaGreen\", \"DarkSlateGray\", \"LimeGreen\", \"MediumSeaGreen\", \"Turquoise\", \"RoyalBlue\", \"SteelBlue\", \"DarkSlateBlue\", \"MediumTurquoise\",\n            \"Indigo\", \"DarkOliveGreen\", \"CadetBlue\", \"CornflowerBlue\", \"RebeccaPurple\", \"MediumAquaMarine\", \"DimGray\", \"SlateBlue\", \"OliveDrab\", \"SlateGray\", \"LightSlateGray\", \"MediumSlateBlue\", \"LawnGreen\", \"Chartreuse\",\n            \"Aquamarine\", \"Maroon\", \"Purple\", \"Olive\", \"Gray\", \"SkyBlue\", \"LightSkyBlue\", \"BlueViolet\", \"DarkRed\", \"DarkMagenta\", \"SaddleBrown\", \"Ivory\", \"White\",\n            \"DarkSeaGreen\", \"LightGreen\", \"MediumPurple\", \"DarkViolet\", \"PaleGreen\", \"DarkOrchid\", \"YellowGreen\", \"Sienna\", \"Brown\", \"DarkGray\", \"LightBlue\", \"GreenYellow\", \"PaleTurquoise\", \"LightSteelBlue\", \"PowderBlue\",\n            \"FireBrick\", \"DarkGoldenRod\", \"MediumOrchid\", \"RosyBrown\", \"DarkKhaki\", \"Silver\", \"MediumVioletRed\", \"IndianRed\", \"Peru\", \"Chocolate\", \"Tan\", \"LightGray\", \"Thistle\", \"Orchid\", \"GoldenRod\", \"PaleVioletRed\",\n            \"Crimson\", \"Gainsboro\", \"Plum\", \"BurlyWood\", \"LightCyan\", \"Lavender\", \"DarkSalmon\", \"Violet\", \"PaleGoldenRod\", \"LightCoral\", \"Khaki\", \"AliceBlue\", \"HoneyDew\", \"Azure\", \"SandyBrown\", \"Wheat\", \"Beige\", \"WhiteSmoke\",\n            \"MintCream\", \"GhostWhite\", \"Salmon\", \"AntiqueWhite\", \"Linen\", \"LightGoldenRodYellow\", \"OldLace\", \"Red\", \"Fuchsia\", \"Magenta\", \"DeepPink\", \"OrangeRed\", \"Tomato\", \"HotPink\", \"Coral\", \"DarkOrange\", \"LightSalmon\", \"Orange\",\n            \"LightPink\", \"Pink\", \"Gold\", \"PeachPuff\", \"NavajoWhite\", \"Moccasin\", \"Bisque\", \"MistyRose\", \"BlanchedAlmond\", \"PapayaWhip\", \"LavenderBlush\", \"SeaShell\", \"Cornsilk\", \"LemonChiffon\", \"FloralWhite\", \"Snow\", \"Yellow\", \"LightYellow\"\n        ],\n\n        fileExtension : {\n            \"raster\"    : [\"bmp\", \"gif\", \"gpl\", \"ico\", \"jpeg\", \"psd\", \"png\", \"psp\", \"raw\", \"tiff\"],\n            \"vector\"    : [\"3dv\", \"amf\", \"awg\", \"ai\", \"cgm\", \"cdr\", \"cmx\", \"dxf\", \"e2d\", \"egt\", \"eps\", \"fs\", \"odg\", \"svg\", \"xar\"],\n            \"3d\"        : [\"3dmf\", \"3dm\", \"3mf\", \"3ds\", \"an8\", \"aoi\", \"blend\", \"cal3d\", \"cob\", \"ctm\", \"iob\", \"jas\", \"max\", \"mb\", \"mdx\", \"obj\", \"x\", \"x3d\"],\n            \"document\"  : [\"doc\", \"docx\", \"dot\", \"html\", \"xml\", \"odt\", \"odm\", \"ott\", \"csv\", \"rtf\", \"tex\", \"xhtml\", \"xps\"]\n        },\n\n        // Data taken from https://github.com/dmfilipenko/timezones.json/blob/master/timezones.json\n        timezones: [\n                  {\n                    \"name\": \"Dateline Standard Time\",\n                    \"abbr\": \"DST\",\n                    \"offset\": -12,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-12:00) International Date Line West\",\n                    \"utc\": [\n                      \"Etc/GMT+12\"\n                    ]\n                  },\n                  {\n                    \"name\": \"UTC-11\",\n                    \"abbr\": \"U\",\n                    \"offset\": -11,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-11:00) Coordinated Universal Time-11\",\n                    \"utc\": [\n                      \"Etc/GMT+11\",\n                      \"Pacific/Midway\",\n                      \"Pacific/Niue\",\n                      \"Pacific/Pago_Pago\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Hawaiian Standard Time\",\n                    \"abbr\": \"HST\",\n                    \"offset\": -10,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-10:00) Hawaii\",\n                    \"utc\": [\n                      \"Etc/GMT+10\",\n                      \"Pacific/Honolulu\",\n                      \"Pacific/Johnston\",\n                      \"Pacific/Rarotonga\",\n                      \"Pacific/Tahiti\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Alaskan Standard Time\",\n                    \"abbr\": \"AKDT\",\n                    \"offset\": -8,\n                    \"isdst\": true,\n                    \"text\": \"(UTC-09:00) Alaska\",\n                    \"utc\": [\n                      \"America/Anchorage\",\n                      \"America/Juneau\",\n                      \"America/Nome\",\n                      \"America/Sitka\",\n                      \"America/Yakutat\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Pacific Standard Time (Mexico)\",\n                    \"abbr\": \"PDT\",\n                    \"offset\": -7,\n                    \"isdst\": true,\n                    \"text\": \"(UTC-08:00) Baja California\",\n                    \"utc\": [\n                      \"America/Santa_Isabel\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Pacific Standard Time\",\n                    \"abbr\": \"PDT\",\n                    \"offset\": -7,\n                    \"isdst\": true,\n                    \"text\": \"(UTC-08:00) Pacific Time (US & Canada)\",\n                    \"utc\": [\n                      \"America/Dawson\",\n                      \"America/Los_Angeles\",\n                      \"America/Tijuana\",\n                      \"America/Vancouver\",\n                      \"America/Whitehorse\",\n                      \"PST8PDT\"\n                    ]\n                  },\n                  {\n                    \"name\": \"US Mountain Standard Time\",\n                    \"abbr\": \"UMST\",\n                    \"offset\": -7,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-07:00) Arizona\",\n                    \"utc\": [\n                      \"America/Creston\",\n                      \"America/Dawson_Creek\",\n                      \"America/Hermosillo\",\n                      \"America/Phoenix\",\n                      \"Etc/GMT+7\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Mountain Standard Time (Mexico)\",\n                    \"abbr\": \"MDT\",\n                    \"offset\": -6,\n                    \"isdst\": true,\n                    \"text\": \"(UTC-07:00) Chihuahua, La Paz, Mazatlan\",\n                    \"utc\": [\n                      \"America/Chihuahua\",\n                      \"America/Mazatlan\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Mountain Standard Time\",\n                    \"abbr\": \"MDT\",\n                    \"offset\": -6,\n                    \"isdst\": true,\n                    \"text\": \"(UTC-07:00) Mountain Time (US & Canada)\",\n                    \"utc\": [\n                      \"America/Boise\",\n                      \"America/Cambridge_Bay\",\n                      \"America/Denver\",\n                      \"America/Edmonton\",\n                      \"America/Inuvik\",\n                      \"America/Ojinaga\",\n                      \"America/Yellowknife\",\n                      \"MST7MDT\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Central America Standard Time\",\n                    \"abbr\": \"CAST\",\n                    \"offset\": -6,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-06:00) Central America\",\n                    \"utc\": [\n                      \"America/Belize\",\n                      \"America/Costa_Rica\",\n                      \"America/El_Salvador\",\n                      \"America/Guatemala\",\n                      \"America/Managua\",\n                      \"America/Tegucigalpa\",\n                      \"Etc/GMT+6\",\n                      \"Pacific/Galapagos\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Central Standard Time\",\n                    \"abbr\": \"CDT\",\n                    \"offset\": -5,\n                    \"isdst\": true,\n                    \"text\": \"(UTC-06:00) Central Time (US & Canada)\",\n                    \"utc\": [\n                      \"America/Chicago\",\n                      \"America/Indiana/Knox\",\n                      \"America/Indiana/Tell_City\",\n                      \"America/Matamoros\",\n                      \"America/Menominee\",\n                      \"America/North_Dakota/Beulah\",\n                      \"America/North_Dakota/Center\",\n                      \"America/North_Dakota/New_Salem\",\n                      \"America/Rainy_River\",\n                      \"America/Rankin_Inlet\",\n                      \"America/Resolute\",\n                      \"America/Winnipeg\",\n                      \"CST6CDT\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Central Standard Time (Mexico)\",\n                    \"abbr\": \"CDT\",\n                    \"offset\": -5,\n                    \"isdst\": true,\n                    \"text\": \"(UTC-06:00) Guadalajara, Mexico City, Monterrey\",\n                    \"utc\": [\n                      \"America/Bahia_Banderas\",\n                      \"America/Cancun\",\n                      \"America/Merida\",\n                      \"America/Mexico_City\",\n                      \"America/Monterrey\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Canada Central Standard Time\",\n                    \"abbr\": \"CCST\",\n                    \"offset\": -6,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-06:00) Saskatchewan\",\n                    \"utc\": [\n                      \"America/Regina\",\n                      \"America/Swift_Current\"\n                    ]\n                  },\n                  {\n                    \"name\": \"SA Pacific Standard Time\",\n                    \"abbr\": \"SPST\",\n                    \"offset\": -5,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-05:00) Bogota, Lima, Quito\",\n                    \"utc\": [\n                      \"America/Bogota\",\n                      \"America/Cayman\",\n                      \"America/Coral_Harbour\",\n                      \"America/Eirunepe\",\n                      \"America/Guayaquil\",\n                      \"America/Jamaica\",\n                      \"America/Lima\",\n                      \"America/Panama\",\n                      \"America/Rio_Branco\",\n                      \"Etc/GMT+5\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Eastern Standard Time\",\n                    \"abbr\": \"EDT\",\n                    \"offset\": -4,\n                    \"isdst\": true,\n                    \"text\": \"(UTC-05:00) Eastern Time (US & Canada)\",\n                    \"utc\": [\n                      \"America/Detroit\",\n                      \"America/Havana\",\n                      \"America/Indiana/Petersburg\",\n                      \"America/Indiana/Vincennes\",\n                      \"America/Indiana/Winamac\",\n                      \"America/Iqaluit\",\n                      \"America/Kentucky/Monticello\",\n                      \"America/Louisville\",\n                      \"America/Montreal\",\n                      \"America/Nassau\",\n                      \"America/New_York\",\n                      \"America/Nipigon\",\n                      \"America/Pangnirtung\",\n                      \"America/Port-au-Prince\",\n                      \"America/Thunder_Bay\",\n                      \"America/Toronto\",\n                      \"EST5EDT\"\n                    ]\n                  },\n                  {\n                    \"name\": \"US Eastern Standard Time\",\n                    \"abbr\": \"UEDT\",\n                    \"offset\": -4,\n                    \"isdst\": true,\n                    \"text\": \"(UTC-05:00) Indiana (East)\",\n                    \"utc\": [\n                      \"America/Indiana/Marengo\",\n                      \"America/Indiana/Vevay\",\n                      \"America/Indianapolis\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Venezuela Standard Time\",\n                    \"abbr\": \"VST\",\n                    \"offset\": -4.5,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-04:30) Caracas\",\n                    \"utc\": [\n                      \"America/Caracas\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Paraguay Standard Time\",\n                    \"abbr\": \"PST\",\n                    \"offset\": -4,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-04:00) Asuncion\",\n                    \"utc\": [\n                      \"America/Asuncion\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Atlantic Standard Time\",\n                    \"abbr\": \"ADT\",\n                    \"offset\": -3,\n                    \"isdst\": true,\n                    \"text\": \"(UTC-04:00) Atlantic Time (Canada)\",\n                    \"utc\": [\n                      \"America/Glace_Bay\",\n                      \"America/Goose_Bay\",\n                      \"America/Halifax\",\n                      \"America/Moncton\",\n                      \"America/Thule\",\n                      \"Atlantic/Bermuda\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Central Brazilian Standard Time\",\n                    \"abbr\": \"CBST\",\n                    \"offset\": -4,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-04:00) Cuiaba\",\n                    \"utc\": [\n                      \"America/Campo_Grande\",\n                      \"America/Cuiaba\"\n                    ]\n                  },\n                  {\n                    \"name\": \"SA Western Standard Time\",\n                    \"abbr\": \"SWST\",\n                    \"offset\": -4,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-04:00) Georgetown, La Paz, Manaus, San Juan\",\n                    \"utc\": [\n                      \"America/Anguilla\",\n                      \"America/Antigua\",\n                      \"America/Aruba\",\n                      \"America/Barbados\",\n                      \"America/Blanc-Sablon\",\n                      \"America/Boa_Vista\",\n                      \"America/Curacao\",\n                      \"America/Dominica\",\n                      \"America/Grand_Turk\",\n                      \"America/Grenada\",\n                      \"America/Guadeloupe\",\n                      \"America/Guyana\",\n                      \"America/Kralendijk\",\n                      \"America/La_Paz\",\n                      \"America/Lower_Princes\",\n                      \"America/Manaus\",\n                      \"America/Marigot\",\n                      \"America/Martinique\",\n                      \"America/Montserrat\",\n                      \"America/Port_of_Spain\",\n                      \"America/Porto_Velho\",\n                      \"America/Puerto_Rico\",\n                      \"America/Santo_Domingo\",\n                      \"America/St_Barthelemy\",\n                      \"America/St_Kitts\",\n                      \"America/St_Lucia\",\n                      \"America/St_Thomas\",\n                      \"America/St_Vincent\",\n                      \"America/Tortola\",\n                      \"Etc/GMT+4\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Pacific SA Standard Time\",\n                    \"abbr\": \"PSST\",\n                    \"offset\": -4,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-04:00) Santiago\",\n                    \"utc\": [\n                      \"America/Santiago\",\n                      \"Antarctica/Palmer\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Newfoundland Standard Time\",\n                    \"abbr\": \"NDT\",\n                    \"offset\": -2.5,\n                    \"isdst\": true,\n                    \"text\": \"(UTC-03:30) Newfoundland\",\n                    \"utc\": [\n                      \"America/St_Johns\"\n                    ]\n                  },\n                  {\n                    \"name\": \"E. South America Standard Time\",\n                    \"abbr\": \"ESAST\",\n                    \"offset\": -3,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-03:00) Brasilia\",\n                    \"utc\": [\n                      \"America/Sao_Paulo\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Argentina Standard Time\",\n                    \"abbr\": \"AST\",\n                    \"offset\": -3,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-03:00) Buenos Aires\",\n                    \"utc\": [\n                      \"America/Argentina/La_Rioja\",\n                      \"America/Argentina/Rio_Gallegos\",\n                      \"America/Argentina/Salta\",\n                      \"America/Argentina/San_Juan\",\n                      \"America/Argentina/San_Luis\",\n                      \"America/Argentina/Tucuman\",\n                      \"America/Argentina/Ushuaia\",\n                      \"America/Buenos_Aires\",\n                      \"America/Catamarca\",\n                      \"America/Cordoba\",\n                      \"America/Jujuy\",\n                      \"America/Mendoza\"\n                    ]\n                  },\n                  {\n                    \"name\": \"SA Eastern Standard Time\",\n                    \"abbr\": \"SEST\",\n                    \"offset\": -3,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-03:00) Cayenne, Fortaleza\",\n                    \"utc\": [\n                      \"America/Araguaina\",\n                      \"America/Belem\",\n                      \"America/Cayenne\",\n                      \"America/Fortaleza\",\n                      \"America/Maceio\",\n                      \"America/Paramaribo\",\n                      \"America/Recife\",\n                      \"America/Santarem\",\n                      \"Antarctica/Rothera\",\n                      \"Atlantic/Stanley\",\n                      \"Etc/GMT+3\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Greenland Standard Time\",\n                    \"abbr\": \"GDT\",\n                    \"offset\": -2,\n                    \"isdst\": true,\n                    \"text\": \"(UTC-03:00) Greenland\",\n                    \"utc\": [\n                      \"America/Godthab\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Montevideo Standard Time\",\n                    \"abbr\": \"MST\",\n                    \"offset\": -3,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-03:00) Montevideo\",\n                    \"utc\": [\n                      \"America/Montevideo\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Bahia Standard Time\",\n                    \"abbr\": \"BST\",\n                    \"offset\": -3,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-03:00) Salvador\",\n                    \"utc\": [\n                      \"America/Bahia\"\n                    ]\n                  },\n                  {\n                    \"name\": \"UTC-02\",\n                    \"abbr\": \"U\",\n                    \"offset\": -2,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-02:00) Coordinated Universal Time-02\",\n                    \"utc\": [\n                      \"America/Noronha\",\n                      \"Atlantic/South_Georgia\",\n                      \"Etc/GMT+2\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Mid-Atlantic Standard Time\",\n                    \"abbr\": \"MDT\",\n                    \"offset\": -1,\n                    \"isdst\": true,\n                    \"text\": \"(UTC-02:00) Mid-Atlantic - Old\"\n                  },\n                  {\n                    \"name\": \"Azores Standard Time\",\n                    \"abbr\": \"ADT\",\n                    \"offset\": 0,\n                    \"isdst\": true,\n                    \"text\": \"(UTC-01:00) Azores\",\n                    \"utc\": [\n                      \"America/Scoresbysund\",\n                      \"Atlantic/Azores\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Cape Verde Standard Time\",\n                    \"abbr\": \"CVST\",\n                    \"offset\": -1,\n                    \"isdst\": false,\n                    \"text\": \"(UTC-01:00) Cape Verde Is.\",\n                    \"utc\": [\n                      \"Atlantic/Cape_Verde\",\n                      \"Etc/GMT+1\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Morocco Standard Time\",\n                    \"abbr\": \"MDT\",\n                    \"offset\": 1,\n                    \"isdst\": true,\n                    \"text\": \"(UTC) Casablanca\",\n                    \"utc\": [\n                      \"Africa/Casablanca\",\n                      \"Africa/El_Aaiun\"\n                    ]\n                  },\n                  {\n                    \"name\": \"UTC\",\n                    \"abbr\": \"CUT\",\n                    \"offset\": 0,\n                    \"isdst\": false,\n                    \"text\": \"(UTC) Coordinated Universal Time\",\n                    \"utc\": [\n                      \"America/Danmarkshavn\",\n                      \"Etc/GMT\"\n                    ]\n                  },\n                  {\n                    \"name\": \"GMT Standard Time\",\n                    \"abbr\": \"GDT\",\n                    \"offset\": 1,\n                    \"isdst\": true,\n                    \"text\": \"(UTC) Dublin, Edinburgh, Lisbon, London\",\n                    \"utc\": [\n                      \"Atlantic/Canary\",\n                      \"Atlantic/Faeroe\",\n                      \"Atlantic/Madeira\",\n                      \"Europe/Dublin\",\n                      \"Europe/Guernsey\",\n                      \"Europe/Isle_of_Man\",\n                      \"Europe/Jersey\",\n                      \"Europe/Lisbon\",\n                      \"Europe/London\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Greenwich Standard Time\",\n                    \"abbr\": \"GST\",\n                    \"offset\": 0,\n                    \"isdst\": false,\n                    \"text\": \"(UTC) Monrovia, Reykjavik\",\n                    \"utc\": [\n                      \"Africa/Abidjan\",\n                      \"Africa/Accra\",\n                      \"Africa/Bamako\",\n                      \"Africa/Banjul\",\n                      \"Africa/Bissau\",\n                      \"Africa/Conakry\",\n                      \"Africa/Dakar\",\n                      \"Africa/Freetown\",\n                      \"Africa/Lome\",\n                      \"Africa/Monrovia\",\n                      \"Africa/Nouakchott\",\n                      \"Africa/Ouagadougou\",\n                      \"Africa/Sao_Tome\",\n                      \"Atlantic/Reykjavik\",\n                      \"Atlantic/St_Helena\"\n                    ]\n                  },\n                  {\n                    \"name\": \"W. Europe Standard Time\",\n                    \"abbr\": \"WEDT\",\n                    \"offset\": 2,\n                    \"isdst\": true,\n                    \"text\": \"(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna\",\n                    \"utc\": [\n                      \"Arctic/Longyearbyen\",\n                      \"Europe/Amsterdam\",\n                      \"Europe/Andorra\",\n                      \"Europe/Berlin\",\n                      \"Europe/Busingen\",\n                      \"Europe/Gibraltar\",\n                      \"Europe/Luxembourg\",\n                      \"Europe/Malta\",\n                      \"Europe/Monaco\",\n                      \"Europe/Oslo\",\n                      \"Europe/Rome\",\n                      \"Europe/San_Marino\",\n                      \"Europe/Stockholm\",\n                      \"Europe/Vaduz\",\n                      \"Europe/Vatican\",\n                      \"Europe/Vienna\",\n                      \"Europe/Zurich\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Central Europe Standard Time\",\n                    \"abbr\": \"CEDT\",\n                    \"offset\": 2,\n                    \"isdst\": true,\n                    \"text\": \"(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague\",\n                    \"utc\": [\n                      \"Europe/Belgrade\",\n                      \"Europe/Bratislava\",\n                      \"Europe/Budapest\",\n                      \"Europe/Ljubljana\",\n                      \"Europe/Podgorica\",\n                      \"Europe/Prague\",\n                      \"Europe/Tirane\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Romance Standard Time\",\n                    \"abbr\": \"RDT\",\n                    \"offset\": 2,\n                    \"isdst\": true,\n                    \"text\": \"(UTC+01:00) Brussels, Copenhagen, Madrid, Paris\",\n                    \"utc\": [\n                      \"Africa/Ceuta\",\n                      \"Europe/Brussels\",\n                      \"Europe/Copenhagen\",\n                      \"Europe/Madrid\",\n                      \"Europe/Paris\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Central European Standard Time\",\n                    \"abbr\": \"CEDT\",\n                    \"offset\": 2,\n                    \"isdst\": true,\n                    \"text\": \"(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb\",\n                    \"utc\": [\n                      \"Europe/Sarajevo\",\n                      \"Europe/Skopje\",\n                      \"Europe/Warsaw\",\n                      \"Europe/Zagreb\"\n                    ]\n                  },\n                  {\n                    \"name\": \"W. Central Africa Standard Time\",\n                    \"abbr\": \"WCAST\",\n                    \"offset\": 1,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+01:00) West Central Africa\",\n                    \"utc\": [\n                      \"Africa/Algiers\",\n                      \"Africa/Bangui\",\n                      \"Africa/Brazzaville\",\n                      \"Africa/Douala\",\n                      \"Africa/Kinshasa\",\n                      \"Africa/Lagos\",\n                      \"Africa/Libreville\",\n                      \"Africa/Luanda\",\n                      \"Africa/Malabo\",\n                      \"Africa/Ndjamena\",\n                      \"Africa/Niamey\",\n                      \"Africa/Porto-Novo\",\n                      \"Africa/Tunis\",\n                      \"Etc/GMT-1\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Namibia Standard Time\",\n                    \"abbr\": \"NST\",\n                    \"offset\": 1,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+01:00) Windhoek\",\n                    \"utc\": [\n                      \"Africa/Windhoek\"\n                    ]\n                  },\n                  {\n                    \"name\": \"GTB Standard Time\",\n                    \"abbr\": \"GDT\",\n                    \"offset\": 3,\n                    \"isdst\": true,\n                    \"text\": \"(UTC+02:00) Athens, Bucharest\",\n                    \"utc\": [\n                      \"Asia/Nicosia\",\n                      \"Europe/Athens\",\n                      \"Europe/Bucharest\",\n                      \"Europe/Chisinau\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Middle East Standard Time\",\n                    \"abbr\": \"MEDT\",\n                    \"offset\": 3,\n                    \"isdst\": true,\n                    \"text\": \"(UTC+02:00) Beirut\",\n                    \"utc\": [\n                      \"Asia/Beirut\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Egypt Standard Time\",\n                    \"abbr\": \"EST\",\n                    \"offset\": 2,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+02:00) Cairo\",\n                    \"utc\": [\n                      \"Africa/Cairo\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Syria Standard Time\",\n                    \"abbr\": \"SDT\",\n                    \"offset\": 3,\n                    \"isdst\": true,\n                    \"text\": \"(UTC+02:00) Damascus\",\n                    \"utc\": [\n                      \"Asia/Damascus\"\n                    ]\n                  },\n                  {\n                    \"name\": \"E. Europe Standard Time\",\n                    \"abbr\": \"EEDT\",\n                    \"offset\": 3,\n                    \"isdst\": true,\n                    \"text\": \"(UTC+02:00) E. Europe\"\n                  },\n                  {\n                    \"name\": \"South Africa Standard Time\",\n                    \"abbr\": \"SAST\",\n                    \"offset\": 2,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+02:00) Harare, Pretoria\",\n                    \"utc\": [\n                      \"Africa/Blantyre\",\n                      \"Africa/Bujumbura\",\n                      \"Africa/Gaborone\",\n                      \"Africa/Harare\",\n                      \"Africa/Johannesburg\",\n                      \"Africa/Kigali\",\n                      \"Africa/Lubumbashi\",\n                      \"Africa/Lusaka\",\n                      \"Africa/Maputo\",\n                      \"Africa/Maseru\",\n                      \"Africa/Mbabane\",\n                      \"Etc/GMT-2\"\n                    ]\n                  },\n                  {\n                    \"name\": \"FLE Standard Time\",\n                    \"abbr\": \"FDT\",\n                    \"offset\": 3,\n                    \"isdst\": true,\n                    \"text\": \"(UTC+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius\",\n                    \"utc\": [\n                      \"Europe/Helsinki\",\n                      \"Europe/Kiev\",\n                      \"Europe/Mariehamn\",\n                      \"Europe/Riga\",\n                      \"Europe/Sofia\",\n                      \"Europe/Tallinn\",\n                      \"Europe/Uzhgorod\",\n                      \"Europe/Vilnius\",\n                      \"Europe/Zaporozhye\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Turkey Standard Time\",\n                    \"abbr\": \"TDT\",\n                    \"offset\": 3,\n                    \"isdst\": true,\n                    \"text\": \"(UTC+02:00) Istanbul\",\n                    \"utc\": [\n                      \"Europe/Istanbul\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Israel Standard Time\",\n                    \"abbr\": \"JDT\",\n                    \"offset\": 3,\n                    \"isdst\": true,\n                    \"text\": \"(UTC+02:00) Jerusalem\",\n                    \"utc\": [\n                      \"Asia/Jerusalem\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Libya Standard Time\",\n                    \"abbr\": \"LST\",\n                    \"offset\": 2,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+02:00) Tripoli\",\n                    \"utc\": [\n                      \"Africa/Tripoli\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Jordan Standard Time\",\n                    \"abbr\": \"JST\",\n                    \"offset\": 3,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+03:00) Amman\",\n                    \"utc\": [\n                      \"Asia/Amman\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Arabic Standard Time\",\n                    \"abbr\": \"AST\",\n                    \"offset\": 3,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+03:00) Baghdad\",\n                    \"utc\": [\n                      \"Asia/Baghdad\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Kaliningrad Standard Time\",\n                    \"abbr\": \"KST\",\n                    \"offset\": 3,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+03:00) Kaliningrad, Minsk\",\n                    \"utc\": [\n                      \"Europe/Kaliningrad\",\n                      \"Europe/Minsk\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Arab Standard Time\",\n                    \"abbr\": \"AST\",\n                    \"offset\": 3,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+03:00) Kuwait, Riyadh\",\n                    \"utc\": [\n                      \"Asia/Aden\",\n                      \"Asia/Bahrain\",\n                      \"Asia/Kuwait\",\n                      \"Asia/Qatar\",\n                      \"Asia/Riyadh\"\n                    ]\n                  },\n                  {\n                    \"name\": \"E. Africa Standard Time\",\n                    \"abbr\": \"EAST\",\n                    \"offset\": 3,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+03:00) Nairobi\",\n                    \"utc\": [\n                      \"Africa/Addis_Ababa\",\n                      \"Africa/Asmera\",\n                      \"Africa/Dar_es_Salaam\",\n                      \"Africa/Djibouti\",\n                      \"Africa/Juba\",\n                      \"Africa/Kampala\",\n                      \"Africa/Khartoum\",\n                      \"Africa/Mogadishu\",\n                      \"Africa/Nairobi\",\n                      \"Antarctica/Syowa\",\n                      \"Etc/GMT-3\",\n                      \"Indian/Antananarivo\",\n                      \"Indian/Comoro\",\n                      \"Indian/Mayotte\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Iran Standard Time\",\n                    \"abbr\": \"IDT\",\n                    \"offset\": 4.5,\n                    \"isdst\": true,\n                    \"text\": \"(UTC+03:30) Tehran\",\n                    \"utc\": [\n                      \"Asia/Tehran\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Arabian Standard Time\",\n                    \"abbr\": \"AST\",\n                    \"offset\": 4,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+04:00) Abu Dhabi, Muscat\",\n                    \"utc\": [\n                      \"Asia/Dubai\",\n                      \"Asia/Muscat\",\n                      \"Etc/GMT-4\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Azerbaijan Standard Time\",\n                    \"abbr\": \"ADT\",\n                    \"offset\": 5,\n                    \"isdst\": true,\n                    \"text\": \"(UTC+04:00) Baku\",\n                    \"utc\": [\n                      \"Asia/Baku\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Russian Standard Time\",\n                    \"abbr\": \"RST\",\n                    \"offset\": 4,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+04:00) Moscow, St. Petersburg, Volgograd\",\n                    \"utc\": [\n                      \"Europe/Moscow\",\n                      \"Europe/Samara\",\n                      \"Europe/Simferopol\",\n                      \"Europe/Volgograd\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Mauritius Standard Time\",\n                    \"abbr\": \"MST\",\n                    \"offset\": 4,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+04:00) Port Louis\",\n                    \"utc\": [\n                      \"Indian/Mahe\",\n                      \"Indian/Mauritius\",\n                      \"Indian/Reunion\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Georgian Standard Time\",\n                    \"abbr\": \"GST\",\n                    \"offset\": 4,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+04:00) Tbilisi\",\n                    \"utc\": [\n                      \"Asia/Tbilisi\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Caucasus Standard Time\",\n                    \"abbr\": \"CST\",\n                    \"offset\": 4,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+04:00) Yerevan\",\n                    \"utc\": [\n                      \"Asia/Yerevan\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Afghanistan Standard Time\",\n                    \"abbr\": \"AST\",\n                    \"offset\": 4.5,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+04:30) Kabul\",\n                    \"utc\": [\n                      \"Asia/Kabul\"\n                    ]\n                  },\n                  {\n                    \"name\": \"West Asia Standard Time\",\n                    \"abbr\": \"WAST\",\n                    \"offset\": 5,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+05:00) Ashgabat, Tashkent\",\n                    \"utc\": [\n                      \"Antarctica/Mawson\",\n                      \"Asia/Aqtau\",\n                      \"Asia/Aqtobe\",\n                      \"Asia/Ashgabat\",\n                      \"Asia/Dushanbe\",\n                      \"Asia/Oral\",\n                      \"Asia/Samarkand\",\n                      \"Asia/Tashkent\",\n                      \"Etc/GMT-5\",\n                      \"Indian/Kerguelen\",\n                      \"Indian/Maldives\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Pakistan Standard Time\",\n                    \"abbr\": \"PST\",\n                    \"offset\": 5,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+05:00) Islamabad, Karachi\",\n                    \"utc\": [\n                      \"Asia/Karachi\"\n                    ]\n                  },\n                  {\n                    \"name\": \"India Standard Time\",\n                    \"abbr\": \"IST\",\n                    \"offset\": 5.5,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi\",\n                    \"utc\": [\n                      \"Asia/Calcutta\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Sri Lanka Standard Time\",\n                    \"abbr\": \"SLST\",\n                    \"offset\": 5.5,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+05:30) Sri Jayawardenepura\",\n                    \"utc\": [\n                      \"Asia/Colombo\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Nepal Standard Time\",\n                    \"abbr\": \"NST\",\n                    \"offset\": 5.75,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+05:45) Kathmandu\",\n                    \"utc\": [\n                      \"Asia/Katmandu\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Central Asia Standard Time\",\n                    \"abbr\": \"CAST\",\n                    \"offset\": 6,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+06:00) Astana\",\n                    \"utc\": [\n                      \"Antarctica/Vostok\",\n                      \"Asia/Almaty\",\n                      \"Asia/Bishkek\",\n                      \"Asia/Qyzylorda\",\n                      \"Asia/Urumqi\",\n                      \"Etc/GMT-6\",\n                      \"Indian/Chagos\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Bangladesh Standard Time\",\n                    \"abbr\": \"BST\",\n                    \"offset\": 6,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+06:00) Dhaka\",\n                    \"utc\": [\n                      \"Asia/Dhaka\",\n                      \"Asia/Thimphu\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Ekaterinburg Standard Time\",\n                    \"abbr\": \"EST\",\n                    \"offset\": 6,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+06:00) Ekaterinburg\",\n                    \"utc\": [\n                      \"Asia/Yekaterinburg\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Myanmar Standard Time\",\n                    \"abbr\": \"MST\",\n                    \"offset\": 6.5,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+06:30) Yangon (Rangoon)\",\n                    \"utc\": [\n                      \"Asia/Rangoon\",\n                      \"Indian/Cocos\"\n                    ]\n                  },\n                  {\n                    \"name\": \"SE Asia Standard Time\",\n                    \"abbr\": \"SAST\",\n                    \"offset\": 7,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+07:00) Bangkok, Hanoi, Jakarta\",\n                    \"utc\": [\n                      \"Antarctica/Davis\",\n                      \"Asia/Bangkok\",\n                      \"Asia/Hovd\",\n                      \"Asia/Jakarta\",\n                      \"Asia/Phnom_Penh\",\n                      \"Asia/Pontianak\",\n                      \"Asia/Saigon\",\n                      \"Asia/Vientiane\",\n                      \"Etc/GMT-7\",\n                      \"Indian/Christmas\"\n                    ]\n                  },\n                  {\n                    \"name\": \"N. Central Asia Standard Time\",\n                    \"abbr\": \"NCAST\",\n                    \"offset\": 7,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+07:00) Novosibirsk\",\n                    \"utc\": [\n                      \"Asia/Novokuznetsk\",\n                      \"Asia/Novosibirsk\",\n                      \"Asia/Omsk\"\n                    ]\n                  },\n                  {\n                    \"name\": \"China Standard Time\",\n                    \"abbr\": \"CST\",\n                    \"offset\": 8,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi\",\n                    \"utc\": [\n                      \"Asia/Hong_Kong\",\n                      \"Asia/Macau\",\n                      \"Asia/Shanghai\"\n                    ]\n                  },\n                  {\n                    \"name\": \"North Asia Standard Time\",\n                    \"abbr\": \"NAST\",\n                    \"offset\": 8,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+08:00) Krasnoyarsk\",\n                    \"utc\": [\n                      \"Asia/Krasnoyarsk\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Singapore Standard Time\",\n                    \"abbr\": \"MPST\",\n                    \"offset\": 8,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+08:00) Kuala Lumpur, Singapore\",\n                    \"utc\": [\n                      \"Asia/Brunei\",\n                      \"Asia/Kuala_Lumpur\",\n                      \"Asia/Kuching\",\n                      \"Asia/Makassar\",\n                      \"Asia/Manila\",\n                      \"Asia/Singapore\",\n                      \"Etc/GMT-8\"\n                    ]\n                  },\n                  {\n                    \"name\": \"W. Australia Standard Time\",\n                    \"abbr\": \"WAST\",\n                    \"offset\": 8,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+08:00) Perth\",\n                    \"utc\": [\n                      \"Antarctica/Casey\",\n                      \"Australia/Perth\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Taipei Standard Time\",\n                    \"abbr\": \"TST\",\n                    \"offset\": 8,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+08:00) Taipei\",\n                    \"utc\": [\n                      \"Asia/Taipei\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Ulaanbaatar Standard Time\",\n                    \"abbr\": \"UST\",\n                    \"offset\": 8,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+08:00) Ulaanbaatar\",\n                    \"utc\": [\n                      \"Asia/Choibalsan\",\n                      \"Asia/Ulaanbaatar\"\n                    ]\n                  },\n                  {\n                    \"name\": \"North Asia East Standard Time\",\n                    \"abbr\": \"NAEST\",\n                    \"offset\": 9,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+09:00) Irkutsk\",\n                    \"utc\": [\n                      \"Asia/Irkutsk\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Tokyo Standard Time\",\n                    \"abbr\": \"TST\",\n                    \"offset\": 9,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+09:00) Osaka, Sapporo, Tokyo\",\n                    \"utc\": [\n                      \"Asia/Dili\",\n                      \"Asia/Jayapura\",\n                      \"Asia/Tokyo\",\n                      \"Etc/GMT-9\",\n                      \"Pacific/Palau\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Korea Standard Time\",\n                    \"abbr\": \"KST\",\n                    \"offset\": 9,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+09:00) Seoul\",\n                    \"utc\": [\n                      \"Asia/Pyongyang\",\n                      \"Asia/Seoul\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Cen. Australia Standard Time\",\n                    \"abbr\": \"CAST\",\n                    \"offset\": 9.5,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+09:30) Adelaide\",\n                    \"utc\": [\n                      \"Australia/Adelaide\",\n                      \"Australia/Broken_Hill\"\n                    ]\n                  },\n                  {\n                    \"name\": \"AUS Central Standard Time\",\n                    \"abbr\": \"ACST\",\n                    \"offset\": 9.5,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+09:30) Darwin\",\n                    \"utc\": [\n                      \"Australia/Darwin\"\n                    ]\n                  },\n                  {\n                    \"name\": \"E. Australia Standard Time\",\n                    \"abbr\": \"EAST\",\n                    \"offset\": 10,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+10:00) Brisbane\",\n                    \"utc\": [\n                      \"Australia/Brisbane\",\n                      \"Australia/Lindeman\"\n                    ]\n                  },\n                  {\n                    \"name\": \"AUS Eastern Standard Time\",\n                    \"abbr\": \"AEST\",\n                    \"offset\": 10,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+10:00) Canberra, Melbourne, Sydney\",\n                    \"utc\": [\n                      \"Australia/Melbourne\",\n                      \"Australia/Sydney\"\n                    ]\n                  },\n                  {\n                    \"name\": \"West Pacific Standard Time\",\n                    \"abbr\": \"WPST\",\n                    \"offset\": 10,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+10:00) Guam, Port Moresby\",\n                    \"utc\": [\n                      \"Antarctica/DumontDUrville\",\n                      \"Etc/GMT-10\",\n                      \"Pacific/Guam\",\n                      \"Pacific/Port_Moresby\",\n                      \"Pacific/Saipan\",\n                      \"Pacific/Truk\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Tasmania Standard Time\",\n                    \"abbr\": \"TST\",\n                    \"offset\": 10,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+10:00) Hobart\",\n                    \"utc\": [\n                      \"Australia/Currie\",\n                      \"Australia/Hobart\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Yakutsk Standard Time\",\n                    \"abbr\": \"YST\",\n                    \"offset\": 10,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+10:00) Yakutsk\",\n                    \"utc\": [\n                      \"Asia/Chita\",\n                      \"Asia/Khandyga\",\n                      \"Asia/Yakutsk\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Central Pacific Standard Time\",\n                    \"abbr\": \"CPST\",\n                    \"offset\": 11,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+11:00) Solomon Is., New Caledonia\",\n                    \"utc\": [\n                      \"Antarctica/Macquarie\",\n                      \"Etc/GMT-11\",\n                      \"Pacific/Efate\",\n                      \"Pacific/Guadalcanal\",\n                      \"Pacific/Kosrae\",\n                      \"Pacific/Noumea\",\n                      \"Pacific/Ponape\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Vladivostok Standard Time\",\n                    \"abbr\": \"VST\",\n                    \"offset\": 11,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+11:00) Vladivostok\",\n                    \"utc\": [\n                      \"Asia/Sakhalin\",\n                      \"Asia/Ust-Nera\",\n                      \"Asia/Vladivostok\"\n                    ]\n                  },\n                  {\n                    \"name\": \"New Zealand Standard Time\",\n                    \"abbr\": \"NZST\",\n                    \"offset\": 12,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+12:00) Auckland, Wellington\",\n                    \"utc\": [\n                      \"Antarctica/McMurdo\",\n                      \"Pacific/Auckland\"\n                    ]\n                  },\n                  {\n                    \"name\": \"UTC+12\",\n                    \"abbr\": \"U\",\n                    \"offset\": 12,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+12:00) Coordinated Universal Time+12\",\n                    \"utc\": [\n                      \"Etc/GMT-12\",\n                      \"Pacific/Funafuti\",\n                      \"Pacific/Kwajalein\",\n                      \"Pacific/Majuro\",\n                      \"Pacific/Nauru\",\n                      \"Pacific/Tarawa\",\n                      \"Pacific/Wake\",\n                      \"Pacific/Wallis\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Fiji Standard Time\",\n                    \"abbr\": \"FST\",\n                    \"offset\": 12,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+12:00) Fiji\",\n                    \"utc\": [\n                      \"Pacific/Fiji\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Magadan Standard Time\",\n                    \"abbr\": \"MST\",\n                    \"offset\": 12,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+12:00) Magadan\",\n                    \"utc\": [\n                      \"Asia/Anadyr\",\n                      \"Asia/Kamchatka\",\n                      \"Asia/Magadan\",\n                      \"Asia/Srednekolymsk\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Kamchatka Standard Time\",\n                    \"abbr\": \"KDT\",\n                    \"offset\": 13,\n                    \"isdst\": true,\n                    \"text\": \"(UTC+12:00) Petropavlovsk-Kamchatsky - Old\"\n                  },\n                  {\n                    \"name\": \"Tonga Standard Time\",\n                    \"abbr\": \"TST\",\n                    \"offset\": 13,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+13:00) Nuku'alofa\",\n                    \"utc\": [\n                      \"Etc/GMT-13\",\n                      \"Pacific/Enderbury\",\n                      \"Pacific/Fakaofo\",\n                      \"Pacific/Tongatapu\"\n                    ]\n                  },\n                  {\n                    \"name\": \"Samoa Standard Time\",\n                    \"abbr\": \"SST\",\n                    \"offset\": 13,\n                    \"isdst\": false,\n                    \"text\": \"(UTC+13:00) Samoa\",\n                    \"utc\": [\n                      \"Pacific/Apia\"\n                    ]\n                  }\n                ]\n    };\n\n    var o_hasOwnProperty = Object.prototype.hasOwnProperty;\n    var o_keys = (Object.keys || function(obj) {\n      var result = [];\n      for (var key in obj) {\n        if (o_hasOwnProperty.call(obj, key)) {\n          result.push(key);\n        }\n      }\n\n      return result;\n    });\n\n    function _copyObject(source, target) {\n      var keys = o_keys(source);\n      var key;\n\n      for (var i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        target[key] = source[key] || target[key];\n      }\n    }\n\n    function _copyArray(source, target) {\n      for (var i = 0, l = source.length; i < l; i++) {\n        target[i] = source[i];\n      }\n    }\n\n    function copyObject(source, _target) {\n        var isArray = Array.isArray(source);\n        var target = _target || (isArray ? new Array(source.length) : {});\n\n        if (isArray) {\n          _copyArray(source, target);\n        } else {\n          _copyObject(source, target);\n        }\n\n        return target;\n    }\n\n    /** Get the data based on key**/\n    Chance.prototype.get = function (name) {\n        return copyObject(data[name]);\n    };\n\n    // Mac Address\n    Chance.prototype.mac_address = function(options){\n        // typically mac addresses are separated by \":\"\n        // however they can also be separated by \"-\"\n        // the network variant uses a dot every fourth byte\n\n        options = initOptions(options);\n        if(!options.separator) {\n            options.separator =  options.networkVersion ? \".\" : \":\";\n        }\n\n        var mac_pool=\"ABCDEF1234567890\",\n            mac = \"\";\n        if(!options.networkVersion) {\n            mac = this.n(this.string, 6, { pool: mac_pool, length:2 }).join(options.separator);\n        } else {\n            mac = this.n(this.string, 3, { pool: mac_pool, length:4 }).join(options.separator);\n        }\n\n        return mac;\n    };\n\n    Chance.prototype.normal = function (options) {\n        options = initOptions(options, {mean : 0, dev : 1, pool : []});\n\n        testRange(\n            options.pool.constructor !== Array,\n            \"Chance: The pool option must be a valid array.\"\n        );\n\n        // If a pool has been passed, then we are returning an item from that pool,\n        // using the normal distribution settings that were passed in\n        if (options.pool.length > 0) {\n            return this.normal_pool(options);\n        }\n\n        // The Marsaglia Polar method\n        var s, u, v, norm,\n            mean = options.mean,\n            dev = options.dev;\n\n        do {\n            // U and V are from the uniform distribution on (-1, 1)\n            u = this.random() * 2 - 1;\n            v = this.random() * 2 - 1;\n\n            s = u * u + v * v;\n        } while (s >= 1);\n\n        // Compute the standard normal variate\n        norm = u * Math.sqrt(-2 * Math.log(s) / s);\n\n        // Shape and scale\n        return dev * norm + mean;\n    };\n\n    Chance.prototype.normal_pool = function(options) {\n        var performanceCounter = 0;\n        do {\n            var idx = Math.round(this.normal({ mean: options.mean, dev: options.dev }));\n            if (idx < options.pool.length && idx >= 0) {\n                return options.pool[idx];\n            } else {\n                performanceCounter++;\n            }\n        } while(performanceCounter < 100);\n\n        throw new RangeError(\"Chance: Your pool is too small for the given mean and standard deviation. Please adjust.\");\n    };\n\n    Chance.prototype.radio = function (options) {\n        // Initial Letter (Typically Designated by Side of Mississippi River)\n        options = initOptions(options, {side : \"?\"});\n        var fl = \"\";\n        switch (options.side.toLowerCase()) {\n        case \"east\":\n        case \"e\":\n            fl = \"W\";\n            break;\n        case \"west\":\n        case \"w\":\n            fl = \"K\";\n            break;\n        default:\n            fl = this.character({pool: \"KW\"});\n            break;\n        }\n\n        return fl + this.character({alpha: true, casing: \"upper\"}) +\n                this.character({alpha: true, casing: \"upper\"}) +\n                this.character({alpha: true, casing: \"upper\"});\n    };\n\n    // Set the data as key and data or the data map\n    Chance.prototype.set = function (name, values) {\n        if (typeof name === \"string\") {\n            data[name] = values;\n        } else {\n            data = copyObject(name, data);\n        }\n    };\n\n    Chance.prototype.tv = function (options) {\n        return this.radio(options);\n    };\n\n    // ID number for Brazil companies\n    Chance.prototype.cnpj = function () {\n        var n = this.n(this.natural, 8, { max: 9 });\n        var d1 = 2+n[7]*6+n[6]*7+n[5]*8+n[4]*9+n[3]*2+n[2]*3+n[1]*4+n[0]*5;\n        d1 = 11 - (d1 % 11);\n        if (d1>=10){\n            d1 = 0;\n        }\n        var d2 = d1*2+3+n[7]*7+n[6]*8+n[5]*9+n[4]*2+n[3]*3+n[2]*4+n[1]*5+n[0]*6;\n        d2 = 11 - (d2 % 11);\n        if (d2>=10){\n            d2 = 0;\n        }\n        return ''+n[0]+n[1]+'.'+n[2]+n[3]+n[4]+'.'+n[5]+n[6]+n[7]+'/0001-'+d1+d2;\n    };\n\n    // -- End Miscellaneous --\n\n    Chance.prototype.mersenne_twister = function (seed) {\n        return new MersenneTwister(seed);\n    };\n\n    Chance.prototype.blueimp_md5 = function () {\n        return new BlueImpMD5();\n    };\n\n    // Mersenne Twister from https://gist.github.com/banksean/300494\n    var MersenneTwister = function (seed) {\n        if (seed === undefined) {\n            // kept random number same size as time used previously to ensure no unexpected results downstream\n            seed = Math.floor(Math.random()*Math.pow(10,13));\n        }\n        /* Period parameters */\n        this.N = 624;\n        this.M = 397;\n        this.MATRIX_A = 0x9908b0df;   /* constant vector a */\n        this.UPPER_MASK = 0x80000000; /* most significant w-r bits */\n        this.LOWER_MASK = 0x7fffffff; /* least significant r bits */\n\n        this.mt = new Array(this.N); /* the array for the state vector */\n        this.mti = this.N + 1; /* mti==N + 1 means mt[N] is not initialized */\n\n        this.init_genrand(seed);\n    };\n\n    /* initializes mt[N] with a seed */\n    MersenneTwister.prototype.init_genrand = function (s) {\n        this.mt[0] = s >>> 0;\n        for (this.mti = 1; this.mti < this.N; this.mti++) {\n            s = this.mt[this.mti - 1] ^ (this.mt[this.mti - 1] >>> 30);\n            this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253) + this.mti;\n            /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n            /* In the previous versions, MSBs of the seed affect   */\n            /* only MSBs of the array mt[].                        */\n            /* 2002/01/09 modified by Makoto Matsumoto             */\n            this.mt[this.mti] >>>= 0;\n            /* for >32 bit machines */\n        }\n    };\n\n    /* initialize by an array with array-length */\n    /* init_key is the array for initializing keys */\n    /* key_length is its length */\n    /* slight change for C++, 2004/2/26 */\n    MersenneTwister.prototype.init_by_array = function (init_key, key_length) {\n        var i = 1, j = 0, k, s;\n        this.init_genrand(19650218);\n        k = (this.N > key_length ? this.N : key_length);\n        for (; k; k--) {\n            s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30);\n            this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525))) + init_key[j] + j; /* non linear */\n            this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n            i++;\n            j++;\n            if (i >= this.N) { this.mt[0] = this.mt[this.N - 1]; i = 1; }\n            if (j >= key_length) { j = 0; }\n        }\n        for (k = this.N - 1; k; k--) {\n            s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30);\n            this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941)) - i; /* non linear */\n            this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n            i++;\n            if (i >= this.N) { this.mt[0] = this.mt[this.N - 1]; i = 1; }\n        }\n\n        this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */\n    };\n\n    /* generates a random number on [0,0xffffffff]-interval */\n    MersenneTwister.prototype.genrand_int32 = function () {\n        var y;\n        var mag01 = new Array(0x0, this.MATRIX_A);\n        /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n        if (this.mti >= this.N) { /* generate N words at one time */\n            var kk;\n\n            if (this.mti === this.N + 1) {   /* if init_genrand() has not been called, */\n                this.init_genrand(5489); /* a default initial seed is used */\n            }\n            for (kk = 0; kk < this.N - this.M; kk++) {\n                y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk + 1]&this.LOWER_MASK);\n                this.mt[kk] = this.mt[kk + this.M] ^ (y >>> 1) ^ mag01[y & 0x1];\n            }\n            for (;kk < this.N - 1; kk++) {\n                y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk + 1]&this.LOWER_MASK);\n                this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];\n            }\n            y = (this.mt[this.N - 1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);\n            this.mt[this.N - 1] = this.mt[this.M - 1] ^ (y >>> 1) ^ mag01[y & 0x1];\n\n            this.mti = 0;\n        }\n\n        y = this.mt[this.mti++];\n\n        /* Tempering */\n        y ^= (y >>> 11);\n        y ^= (y << 7) & 0x9d2c5680;\n        y ^= (y << 15) & 0xefc60000;\n        y ^= (y >>> 18);\n\n        return y >>> 0;\n    };\n\n    /* generates a random number on [0,0x7fffffff]-interval */\n    MersenneTwister.prototype.genrand_int31 = function () {\n        return (this.genrand_int32() >>> 1);\n    };\n\n    /* generates a random number on [0,1]-real-interval */\n    MersenneTwister.prototype.genrand_real1 = function () {\n        return this.genrand_int32() * (1.0 / 4294967295.0);\n        /* divided by 2^32-1 */\n    };\n\n    /* generates a random number on [0,1)-real-interval */\n    MersenneTwister.prototype.random = function () {\n        return this.genrand_int32() * (1.0 / 4294967296.0);\n        /* divided by 2^32 */\n    };\n\n    /* generates a random number on (0,1)-real-interval */\n    MersenneTwister.prototype.genrand_real3 = function () {\n        return (this.genrand_int32() + 0.5) * (1.0 / 4294967296.0);\n        /* divided by 2^32 */\n    };\n\n    /* generates a random number on [0,1) with 53-bit resolution*/\n    MersenneTwister.prototype.genrand_res53 = function () {\n        var a = this.genrand_int32()>>>5, b = this.genrand_int32()>>>6;\n        return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0);\n    };\n\n    // BlueImp MD5 hashing algorithm from https://github.com/blueimp/JavaScript-MD5\n    var BlueImpMD5 = function () {};\n\n    BlueImpMD5.prototype.VERSION = '1.0.1';\n\n    /*\n    * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n    * to work around bugs in some JS interpreters.\n    */\n    BlueImpMD5.prototype.safe_add = function safe_add(x, y) {\n        var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n            msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n        return (msw << 16) | (lsw & 0xFFFF);\n    };\n\n    /*\n    * Bitwise rotate a 32-bit number to the left.\n    */\n    BlueImpMD5.prototype.bit_roll = function (num, cnt) {\n        return (num << cnt) | (num >>> (32 - cnt));\n    };\n\n    /*\n    * These functions implement the five basic operations the algorithm uses.\n    */\n    BlueImpMD5.prototype.md5_cmn = function (q, a, b, x, s, t) {\n        return this.safe_add(this.bit_roll(this.safe_add(this.safe_add(a, q), this.safe_add(x, t)), s), b);\n    };\n    BlueImpMD5.prototype.md5_ff = function (a, b, c, d, x, s, t) {\n        return this.md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\n    };\n    BlueImpMD5.prototype.md5_gg = function (a, b, c, d, x, s, t) {\n        return this.md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\n    };\n    BlueImpMD5.prototype.md5_hh = function (a, b, c, d, x, s, t) {\n        return this.md5_cmn(b ^ c ^ d, a, b, x, s, t);\n    };\n    BlueImpMD5.prototype.md5_ii = function (a, b, c, d, x, s, t) {\n        return this.md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\n    };\n\n    /*\n    * Calculate the MD5 of an array of little-endian words, and a bit length.\n    */\n    BlueImpMD5.prototype.binl_md5 = function (x, len) {\n        /* append padding */\n        x[len >> 5] |= 0x80 << (len % 32);\n        x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n        var i, olda, oldb, oldc, oldd,\n            a =  1732584193,\n            b = -271733879,\n            c = -1732584194,\n            d =  271733878;\n\n        for (i = 0; i < x.length; i += 16) {\n            olda = a;\n            oldb = b;\n            oldc = c;\n            oldd = d;\n\n            a = this.md5_ff(a, b, c, d, x[i],       7, -680876936);\n            d = this.md5_ff(d, a, b, c, x[i +  1], 12, -389564586);\n            c = this.md5_ff(c, d, a, b, x[i +  2], 17,  606105819);\n            b = this.md5_ff(b, c, d, a, x[i +  3], 22, -1044525330);\n            a = this.md5_ff(a, b, c, d, x[i +  4],  7, -176418897);\n            d = this.md5_ff(d, a, b, c, x[i +  5], 12,  1200080426);\n            c = this.md5_ff(c, d, a, b, x[i +  6], 17, -1473231341);\n            b = this.md5_ff(b, c, d, a, x[i +  7], 22, -45705983);\n            a = this.md5_ff(a, b, c, d, x[i +  8],  7,  1770035416);\n            d = this.md5_ff(d, a, b, c, x[i +  9], 12, -1958414417);\n            c = this.md5_ff(c, d, a, b, x[i + 10], 17, -42063);\n            b = this.md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);\n            a = this.md5_ff(a, b, c, d, x[i + 12],  7,  1804603682);\n            d = this.md5_ff(d, a, b, c, x[i + 13], 12, -40341101);\n            c = this.md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);\n            b = this.md5_ff(b, c, d, a, x[i + 15], 22,  1236535329);\n\n            a = this.md5_gg(a, b, c, d, x[i +  1],  5, -165796510);\n            d = this.md5_gg(d, a, b, c, x[i +  6],  9, -1069501632);\n            c = this.md5_gg(c, d, a, b, x[i + 11], 14,  643717713);\n            b = this.md5_gg(b, c, d, a, x[i],      20, -373897302);\n            a = this.md5_gg(a, b, c, d, x[i +  5],  5, -701558691);\n            d = this.md5_gg(d, a, b, c, x[i + 10],  9,  38016083);\n            c = this.md5_gg(c, d, a, b, x[i + 15], 14, -660478335);\n            b = this.md5_gg(b, c, d, a, x[i +  4], 20, -405537848);\n            a = this.md5_gg(a, b, c, d, x[i +  9],  5,  568446438);\n            d = this.md5_gg(d, a, b, c, x[i + 14],  9, -1019803690);\n            c = this.md5_gg(c, d, a, b, x[i +  3], 14, -187363961);\n            b = this.md5_gg(b, c, d, a, x[i +  8], 20,  1163531501);\n            a = this.md5_gg(a, b, c, d, x[i + 13],  5, -1444681467);\n            d = this.md5_gg(d, a, b, c, x[i +  2],  9, -51403784);\n            c = this.md5_gg(c, d, a, b, x[i +  7], 14,  1735328473);\n            b = this.md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);\n\n            a = this.md5_hh(a, b, c, d, x[i +  5],  4, -378558);\n            d = this.md5_hh(d, a, b, c, x[i +  8], 11, -2022574463);\n            c = this.md5_hh(c, d, a, b, x[i + 11], 16,  1839030562);\n            b = this.md5_hh(b, c, d, a, x[i + 14], 23, -35309556);\n            a = this.md5_hh(a, b, c, d, x[i +  1],  4, -1530992060);\n            d = this.md5_hh(d, a, b, c, x[i +  4], 11,  1272893353);\n            c = this.md5_hh(c, d, a, b, x[i +  7], 16, -155497632);\n            b = this.md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);\n            a = this.md5_hh(a, b, c, d, x[i + 13],  4,  681279174);\n            d = this.md5_hh(d, a, b, c, x[i],      11, -358537222);\n            c = this.md5_hh(c, d, a, b, x[i +  3], 16, -722521979);\n            b = this.md5_hh(b, c, d, a, x[i +  6], 23,  76029189);\n            a = this.md5_hh(a, b, c, d, x[i +  9],  4, -640364487);\n            d = this.md5_hh(d, a, b, c, x[i + 12], 11, -421815835);\n            c = this.md5_hh(c, d, a, b, x[i + 15], 16,  530742520);\n            b = this.md5_hh(b, c, d, a, x[i +  2], 23, -995338651);\n\n            a = this.md5_ii(a, b, c, d, x[i],       6, -198630844);\n            d = this.md5_ii(d, a, b, c, x[i +  7], 10,  1126891415);\n            c = this.md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);\n            b = this.md5_ii(b, c, d, a, x[i +  5], 21, -57434055);\n            a = this.md5_ii(a, b, c, d, x[i + 12],  6,  1700485571);\n            d = this.md5_ii(d, a, b, c, x[i +  3], 10, -1894986606);\n            c = this.md5_ii(c, d, a, b, x[i + 10], 15, -1051523);\n            b = this.md5_ii(b, c, d, a, x[i +  1], 21, -2054922799);\n            a = this.md5_ii(a, b, c, d, x[i +  8],  6,  1873313359);\n            d = this.md5_ii(d, a, b, c, x[i + 15], 10, -30611744);\n            c = this.md5_ii(c, d, a, b, x[i +  6], 15, -1560198380);\n            b = this.md5_ii(b, c, d, a, x[i + 13], 21,  1309151649);\n            a = this.md5_ii(a, b, c, d, x[i +  4],  6, -145523070);\n            d = this.md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);\n            c = this.md5_ii(c, d, a, b, x[i +  2], 15,  718787259);\n            b = this.md5_ii(b, c, d, a, x[i +  9], 21, -343485551);\n\n            a = this.safe_add(a, olda);\n            b = this.safe_add(b, oldb);\n            c = this.safe_add(c, oldc);\n            d = this.safe_add(d, oldd);\n        }\n        return [a, b, c, d];\n    };\n\n    /*\n    * Convert an array of little-endian words to a string\n    */\n    BlueImpMD5.prototype.binl2rstr = function (input) {\n        var i,\n            output = '';\n        for (i = 0; i < input.length * 32; i += 8) {\n            output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);\n        }\n        return output;\n    };\n\n    /*\n    * Convert a raw string to an array of little-endian words\n    * Characters >255 have their high-byte silently ignored.\n    */\n    BlueImpMD5.prototype.rstr2binl = function (input) {\n        var i,\n            output = [];\n        output[(input.length >> 2) - 1] = undefined;\n        for (i = 0; i < output.length; i += 1) {\n            output[i] = 0;\n        }\n        for (i = 0; i < input.length * 8; i += 8) {\n            output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32);\n        }\n        return output;\n    };\n\n    /*\n    * Calculate the MD5 of a raw string\n    */\n    BlueImpMD5.prototype.rstr_md5 = function (s) {\n        return this.binl2rstr(this.binl_md5(this.rstr2binl(s), s.length * 8));\n    };\n\n    /*\n    * Calculate the HMAC-MD5, of a key and some data (raw strings)\n    */\n    BlueImpMD5.prototype.rstr_hmac_md5 = function (key, data) {\n        var i,\n            bkey = this.rstr2binl(key),\n            ipad = [],\n            opad = [],\n            hash;\n        ipad[15] = opad[15] = undefined;\n        if (bkey.length > 16) {\n            bkey = this.binl_md5(bkey, key.length * 8);\n        }\n        for (i = 0; i < 16; i += 1) {\n            ipad[i] = bkey[i] ^ 0x36363636;\n            opad[i] = bkey[i] ^ 0x5C5C5C5C;\n        }\n        hash = this.binl_md5(ipad.concat(this.rstr2binl(data)), 512 + data.length * 8);\n        return this.binl2rstr(this.binl_md5(opad.concat(hash), 512 + 128));\n    };\n\n    /*\n    * Convert a raw string to a hex string\n    */\n    BlueImpMD5.prototype.rstr2hex = function (input) {\n        var hex_tab = '0123456789abcdef',\n            output = '',\n            x,\n            i;\n        for (i = 0; i < input.length; i += 1) {\n            x = input.charCodeAt(i);\n            output += hex_tab.charAt((x >>> 4) & 0x0F) +\n                hex_tab.charAt(x & 0x0F);\n        }\n        return output;\n    };\n\n    /*\n    * Encode a string as utf-8\n    */\n    BlueImpMD5.prototype.str2rstr_utf8 = function (input) {\n        return unescape(encodeURIComponent(input));\n    };\n\n    /*\n    * Take string arguments and return either raw or hex encoded strings\n    */\n    BlueImpMD5.prototype.raw_md5 = function (s) {\n        return this.rstr_md5(this.str2rstr_utf8(s));\n    };\n    BlueImpMD5.prototype.hex_md5 = function (s) {\n        return this.rstr2hex(this.raw_md5(s));\n    };\n    BlueImpMD5.prototype.raw_hmac_md5 = function (k, d) {\n        return this.rstr_hmac_md5(this.str2rstr_utf8(k), this.str2rstr_utf8(d));\n    };\n    BlueImpMD5.prototype.hex_hmac_md5 = function (k, d) {\n        return this.rstr2hex(this.raw_hmac_md5(k, d));\n    };\n\n    BlueImpMD5.prototype.md5 = function (string, key, raw) {\n        if (!key) {\n            if (!raw) {\n                return this.hex_md5(string);\n            }\n\n            return this.raw_md5(string);\n        }\n\n        if (!raw) {\n            return this.hex_hmac_md5(key, string);\n        }\n\n        return this.raw_hmac_md5(key, string);\n    };\n\n    // CommonJS module\n    if (true) {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = Chance;\n        }\n        exports.Chance = Chance;\n    }\n\n    // Register as an anonymous AMD module\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n            return Chance;\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n\n    // if there is a importsScrips object define chance for worker\n    if (typeof importScripts !== 'undefined') {\n        chance = new Chance();\n    }\n\n    // If there is a window object, that at least has a document property,\n    // instantiate and define chance on the window\n    if (typeof window === \"object\" && typeof window.document === \"object\") {\n        window.Chance = Chance;\n        window.chance = new Chance();\n    }\n})();\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NoYW5jZS9jaGFuY2UuanM/ZTBmZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAgQ2hhbmNlLmpzIDEuMC40XG4vLyAgaHR0cDovL2NoYW5jZWpzLmNvbVxuLy8gIChjKSAyMDEzIFZpY3RvciBRdWlublxuLy8gIENoYW5jZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIG9yIG1vZGlmaWVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIENvbnN0YW50c1xuICAgIHZhciBNQVhfSU5UID0gOTAwNzE5OTI1NDc0MDk5MjtcbiAgICB2YXIgTUlOX0lOVCA9IC1NQVhfSU5UO1xuICAgIHZhciBOVU1CRVJTID0gJzAxMjM0NTY3ODknO1xuICAgIHZhciBDSEFSU19MT1dFUiA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eic7XG4gICAgdmFyIENIQVJTX1VQUEVSID0gQ0hBUlNfTE9XRVIudG9VcHBlckNhc2UoKTtcbiAgICB2YXIgSEVYX1BPT0wgID0gTlVNQkVSUyArIFwiYWJjZGVmXCI7XG5cbiAgICAvLyBDYWNoZWQgYXJyYXkgaGVscGVyc1xuICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIC8vIENvbnN0cnVjdG9yXG4gICAgZnVuY3Rpb24gQ2hhbmNlIChzZWVkKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDaGFuY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VlZCA9PSBudWxsID8gbmV3IENoYW5jZSgpIDogbmV3IENoYW5jZShzZWVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHVzZXIgaGFzIHByb3ZpZGVkIGEgZnVuY3Rpb24sIHVzZSB0aGF0IGFzIHRoZSBnZW5lcmF0b3JcbiAgICAgICAgaWYgKHR5cGVvZiBzZWVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnJhbmRvbSA9IHNlZWQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBzZXQgYSBzdGFydGluZyB2YWx1ZSBvZiB6ZXJvIHNvIHdlIGNhbiBhZGQgdG8gaXRcbiAgICAgICAgICAgIHRoaXMuc2VlZCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2UsIGxlYXZlIHRoaXMuc2VlZCBibGFuayBzbyB0aGF0IE1UIHdpbGwgcmVjZWl2ZSBhIGJsYW5rXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzZWVkbGluZyA9IDA7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50c1tpXSkgPT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcmd1bWVudHNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgbnVtZXJpYyBoYXNoIGZvciBlYWNoIGFyZ3VtZW50LCBhZGQgdG8gc2VlZGxpbmdcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2ggPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGFyZ3VtZW50c1tpXS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaCA9IGFyZ3VtZW50c1tpXS5jaGFyQ29kZUF0KGspICsgKGhhc2ggPDwgNikgKyAoaGFzaCA8PCAxNikgLSBoYXNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlZWRsaW5nICs9IGhhc2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWVkbGluZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VlZCArPSAoYXJndW1lbnRzLmxlbmd0aCAtIGkpICogc2VlZGxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBubyBnZW5lcmF0b3IgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCB1c2Ugb3VyIE1UXG4gICAgICAgIHRoaXMubXQgPSB0aGlzLm1lcnNlbm5lX3R3aXN0ZXIodGhpcy5zZWVkKTtcbiAgICAgICAgdGhpcy5iaW1kNSA9IHRoaXMuYmx1ZWltcF9tZDUoKTtcbiAgICAgICAgdGhpcy5yYW5kb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdC5yYW5kb20odGhpcy5zZWVkKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLlZFUlNJT04gPSBcIjEuMC40XCI7XG5cbiAgICAvLyBSYW5kb20gaGVscGVyIGZ1bmN0aW9uc1xuICAgIGZ1bmN0aW9uIGluaXRPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICAgICAgaWYgKGRlZmF1bHRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2ldID0gZGVmYXVsdHNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdFJhbmdlKHRlc3QsIGVycm9yTWVzc2FnZSkge1xuICAgICAgICBpZiAodGVzdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY29kZSB0aGUgaW5wdXQgc3RyaW5nIHdpdGggQmFzZTY0LlxuICAgICAqL1xuICAgIHZhciBiYXNlNjQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBCYXNlNjQgZW5jb2RlciBhdmFpbGFibGUuJyk7XG4gICAgfTtcblxuICAgIC8vIFNlbGVjdCBwcm9wZXIgQmFzZTY0IGVuY29kZXIuXG4gICAgKGZ1bmN0aW9uIGRldGVybWluZUJhc2U2NEVuY29kZXIoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYmFzZTY0ID0gYnRvYTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBiYXNlNjQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGlucHV0KS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSkoKTtcblxuICAgIC8vIC0tIEJhc2ljcyAtLVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIHJhbmRvbSBib29sLCBlaXRoZXIgdHJ1ZSBvciBmYWxzZVxuICAgICAqXG4gICAgICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17IGxpa2VsaWhvb2Q6IDUwIH1dIGFsdGVyIHRoZSBsaWtlbGlob29kIG9mXG4gICAgICogICAgcmVjZWl2aW5nIGEgdHJ1ZSBvciBmYWxzZSB2YWx1ZSBiYWNrLlxuICAgICAqICBAdGhyb3dzIHtSYW5nZUVycm9yfSBpZiB0aGUgbGlrZWxpaG9vZCBpcyBvdXQgb2YgYm91bmRzXG4gICAgICogIEByZXR1cm5zIHtCb29sfSBlaXRoZXIgdHJ1ZSBvciBmYWxzZVxuICAgICAqL1xuICAgIENoYW5jZS5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8vIGxpa2VsaWhvb2Qgb2Ygc3VjY2VzcyAodHJ1ZSlcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtsaWtlbGlob29kIDogNTB9KTtcblxuICAgICAgICAvLyBOb3RlLCB3ZSBjb3VsZCBnZXQgc29tZSBtaW5vciBwZXJmIG9wdGltaXphdGlvbnMgYnkgY2hlY2tpbmcgcmFuZ2VcbiAgICAgICAgLy8gcHJpb3IgdG8gaW5pdGlhbGl6aW5nIGRlZmF1bHRzLCBidXQgdGhhdCBtYWtlcyBjb2RlIGEgYml0IG1lc3NpZXJcbiAgICAgICAgLy8gYW5kIHRoZSBjaGVjayBtb3JlIGNvbXBsaWNhdGVkIGFzIHdlIGhhdmUgdG8gY2hlY2sgZXhpc3RlbmNlIG9mXG4gICAgICAgIC8vIHRoZSBvYmplY3QgdGhlbiBleGlzdGVuY2Ugb2YgdGhlIGtleSBiZWZvcmUgY2hlY2tpbmcgY29uc3RyYWludHMuXG4gICAgICAgIC8vIFNpbmNlIHRoZSBvcHRpb25zIGluaXRpYWxpemF0aW9uIHNob3VsZCBiZSBtaW5vciBjb21wdXRhdGlvbmFsbHksXG4gICAgICAgIC8vIGRlY2lzaW9uIG1hZGUgZm9yIGNvZGUgY2xlYW5saW5lc3MgaW50ZW50aW9uYWxseS4gVGhpcyBpcyBtZW50aW9uZWRcbiAgICAgICAgLy8gaGVyZSBhcyBpdCdzIHRoZSBmaXJzdCBvY2N1cnJlbmNlLCB3aWxsIG5vdCBiZSBtZW50aW9uZWQgYWdhaW4uXG4gICAgICAgIHRlc3RSYW5nZShcbiAgICAgICAgICAgIG9wdGlvbnMubGlrZWxpaG9vZCA8IDAgfHwgb3B0aW9ucy5saWtlbGlob29kID4gMTAwLFxuICAgICAgICAgICAgXCJDaGFuY2U6IExpa2VsaWhvb2QgYWNjZXB0cyB2YWx1ZXMgZnJvbSAwIHRvIDEwMC5cIlxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJhbmRvbSgpICogMTAwIDwgb3B0aW9ucy5saWtlbGlob29kO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgcmFuZG9tIGNoYXJhY3Rlci5cbiAgICAgKlxuICAgICAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIGNhbiBzcGVjaWZ5IGEgY2hhcmFjdGVyIHBvb2wsIG9ubHkgYWxwaGEsXG4gICAgICogICAgb25seSBzeW1ib2xzLCBhbmQgY2FzaW5nIChsb3dlciBvciB1cHBlcilcbiAgICAgKiAgQHJldHVybnMge1N0cmluZ30gYSBzaW5nbGUgcmFuZG9tIGNoYXJhY3RlclxuICAgICAqICBAdGhyb3dzIHtSYW5nZUVycm9yfSBDYW4gb25seSBzcGVjaWZ5IGFscGhhIG9yIHN5bWJvbHMsIG5vdCBib3RoXG4gICAgICovXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5jaGFyYWN0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRlc3RSYW5nZShcbiAgICAgICAgICAgIG9wdGlvbnMuYWxwaGEgJiYgb3B0aW9ucy5zeW1ib2xzLFxuICAgICAgICAgICAgXCJDaGFuY2U6IENhbm5vdCBzcGVjaWZ5IGJvdGggYWxwaGEgYW5kIHN5bWJvbHMuXCJcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgc3ltYm9scyA9IFwiIUAjJCVeJiooKVtdXCIsXG4gICAgICAgICAgICBsZXR0ZXJzLCBwb29sO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmNhc2luZyA9PT0gJ2xvd2VyJykge1xuICAgICAgICAgICAgbGV0dGVycyA9IENIQVJTX0xPV0VSO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuY2FzaW5nID09PSAndXBwZXInKSB7XG4gICAgICAgICAgICBsZXR0ZXJzID0gQ0hBUlNfVVBQRVI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXR0ZXJzID0gQ0hBUlNfTE9XRVIgKyBDSEFSU19VUFBFUjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnBvb2wpIHtcbiAgICAgICAgICAgIHBvb2wgPSBvcHRpb25zLnBvb2w7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5hbHBoYSkge1xuICAgICAgICAgICAgcG9vbCA9IGxldHRlcnM7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zeW1ib2xzKSB7XG4gICAgICAgICAgICBwb29sID0gc3ltYm9scztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvb2wgPSBsZXR0ZXJzICsgTlVNQkVSUyArIHN5bWJvbHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9vbC5jaGFyQXQodGhpcy5uYXR1cmFsKHttYXg6IChwb29sLmxlbmd0aCAtIDEpfSkpO1xuICAgIH07XG5cbiAgICAvLyBOb3RlLCB3YW50ZWQgdG8gdXNlIFwiZmxvYXRcIiBvciBcImRvdWJsZVwiIGJ1dCB0aG9zZSBhcmUgYm90aCBKUyByZXNlcnZlZCB3b3Jkcy5cblxuICAgIC8vIE5vdGUsIGZpeGVkIG1lYW5zIE4gT1IgTEVTUyBkaWdpdHMgYWZ0ZXIgdGhlIGRlY2ltYWwuIFRoaXMgYmVjYXVzZVxuICAgIC8vIEl0IGNvdWxkIGJlIDE0LjkwMDAgYnV0IGluIEphdmFTY3JpcHQsIHdoZW4gdGhpcyBpcyBjYXN0IGFzIGEgbnVtYmVyLFxuICAgIC8vIHRoZSB0cmFpbGluZyB6ZXJvZXMgYXJlIGRyb3BwZWQuIExlZnQgdG8gdGhlIGNvbnN1bWVyIGlmIHRyYWlsaW5nIHplcm9lcyBhcmVcbiAgICAvLyBuZWVkZWRcbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgcmFuZG9tIGZsb2F0aW5nIHBvaW50IG51bWJlclxuICAgICAqXG4gICAgICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gY2FuIHNwZWNpZnkgYSBmaXhlZCBwcmVjaXNpb24sIG1pbiwgbWF4XG4gICAgICogIEByZXR1cm5zIHtOdW1iZXJ9IGEgc2luZ2xlIGZsb2F0aW5nIHBvaW50IG51bWJlclxuICAgICAqICBAdGhyb3dzIHtSYW5nZUVycm9yfSBDYW4gb25seSBzcGVjaWZ5IGZpeGVkIG9yIHByZWNpc2lvbiwgbm90IGJvdGguIEFsc29cbiAgICAgKiAgICBtaW4gY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiBtYXhcbiAgICAgKi9cbiAgICBDaGFuY2UucHJvdG90eXBlLmZsb2F0aW5nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtmaXhlZCA6IDR9KTtcbiAgICAgICAgdGVzdFJhbmdlKFxuICAgICAgICAgICAgb3B0aW9ucy5maXhlZCAmJiBvcHRpb25zLnByZWNpc2lvbixcbiAgICAgICAgICAgIFwiQ2hhbmNlOiBDYW5ub3Qgc3BlY2lmeSBib3RoIGZpeGVkIGFuZCBwcmVjaXNpb24uXCJcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgbnVtO1xuICAgICAgICB2YXIgZml4ZWQgPSBNYXRoLnBvdygxMCwgb3B0aW9ucy5maXhlZCk7XG5cbiAgICAgICAgdmFyIG1heCA9IE1BWF9JTlQgLyBmaXhlZDtcbiAgICAgICAgdmFyIG1pbiA9IC1tYXg7XG5cbiAgICAgICAgdGVzdFJhbmdlKFxuICAgICAgICAgICAgb3B0aW9ucy5taW4gJiYgb3B0aW9ucy5maXhlZCAmJiBvcHRpb25zLm1pbiA8IG1pbixcbiAgICAgICAgICAgIFwiQ2hhbmNlOiBNaW4gc3BlY2lmaWVkIGlzIG91dCBvZiByYW5nZSB3aXRoIGZpeGVkLiBNaW4gc2hvdWxkIGJlLCBhdCBsZWFzdCwgXCIgKyBtaW5cbiAgICAgICAgKTtcbiAgICAgICAgdGVzdFJhbmdlKFxuICAgICAgICAgICAgb3B0aW9ucy5tYXggJiYgb3B0aW9ucy5maXhlZCAmJiBvcHRpb25zLm1heCA+IG1heCxcbiAgICAgICAgICAgIFwiQ2hhbmNlOiBNYXggc3BlY2lmaWVkIGlzIG91dCBvZiByYW5nZSB3aXRoIGZpeGVkLiBNYXggc2hvdWxkIGJlLCBhdCBtb3N0LCBcIiArIG1heFxuICAgICAgICApO1xuXG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7IG1pbiA6IG1pbiwgbWF4IDogbWF4IH0pO1xuXG4gICAgICAgIC8vIFRvZG8gLSBNYWtlIHRoaXMgd29yayFcbiAgICAgICAgLy8gb3B0aW9ucy5wcmVjaXNpb24gPSAodHlwZW9mIG9wdGlvbnMucHJlY2lzaW9uICE9PSBcInVuZGVmaW5lZFwiKSA/IG9wdGlvbnMucHJlY2lzaW9uIDogZmFsc2U7XG5cbiAgICAgICAgbnVtID0gdGhpcy5pbnRlZ2VyKHttaW46IG9wdGlvbnMubWluICogZml4ZWQsIG1heDogb3B0aW9ucy5tYXggKiBmaXhlZH0pO1xuICAgICAgICB2YXIgbnVtX2ZpeGVkID0gKG51bSAvIGZpeGVkKS50b0ZpeGVkKG9wdGlvbnMuZml4ZWQpO1xuXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG51bV9maXhlZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSByYW5kb20gaW50ZWdlclxuICAgICAqXG4gICAgICogIE5PVEUgdGhlIG1heCBhbmQgbWluIGFyZSBJTkNMVURFRCBpbiB0aGUgcmFuZ2UuIFNvOlxuICAgICAqICBjaGFuY2UuaW50ZWdlcih7bWluOiAxLCBtYXg6IDN9KTtcbiAgICAgKiAgd291bGQgcmV0dXJuIGVpdGhlciAxLCAyLCBvciAzLlxuICAgICAqXG4gICAgICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gY2FuIHNwZWNpZnkgYSBtaW4gYW5kL29yIG1heFxuICAgICAqICBAcmV0dXJucyB7TnVtYmVyfSBhIHNpbmdsZSByYW5kb20gaW50ZWdlciBudW1iZXJcbiAgICAgKiAgQHRocm93cyB7UmFuZ2VFcnJvcn0gbWluIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gbWF4XG4gICAgICovXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5pbnRlZ2VyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gOTAwNzE5OTI1NDc0MDk5MiAoMl41MykgaXMgdGhlIG1heCBpbnRlZ2VyIG51bWJlciBpbiBKYXZhU2NyaXB0XG4gICAgICAgIC8vIFNlZTogaHR0cDovL3ZxLmlvLzEzMnNhMmpcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHttaW46IE1JTl9JTlQsIG1heDogTUFYX0lOVH0pO1xuICAgICAgICB0ZXN0UmFuZ2Uob3B0aW9ucy5taW4gPiBvcHRpb25zLm1heCwgXCJDaGFuY2U6IE1pbiBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIE1heC5cIik7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5yYW5kb20oKSAqIChvcHRpb25zLm1heCAtIG9wdGlvbnMubWluICsgMSkgKyBvcHRpb25zLm1pbik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSByYW5kb20gbmF0dXJhbFxuICAgICAqXG4gICAgICogIE5PVEUgdGhlIG1heCBhbmQgbWluIGFyZSBJTkNMVURFRCBpbiB0aGUgcmFuZ2UuIFNvOlxuICAgICAqICBjaGFuY2UubmF0dXJhbCh7bWluOiAxLCBtYXg6IDN9KTtcbiAgICAgKiAgd291bGQgcmV0dXJuIGVpdGhlciAxLCAyLCBvciAzLlxuICAgICAqXG4gICAgICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gY2FuIHNwZWNpZnkgYSBtaW4gYW5kL29yIG1heFxuICAgICAqICBAcmV0dXJucyB7TnVtYmVyfSBhIHNpbmdsZSByYW5kb20gaW50ZWdlciBudW1iZXJcbiAgICAgKiAgQHRocm93cyB7UmFuZ2VFcnJvcn0gbWluIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gbWF4XG4gICAgICovXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5uYXR1cmFsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHttaW46IDAsIG1heDogTUFYX0lOVH0pO1xuICAgICAgICB0ZXN0UmFuZ2Uob3B0aW9ucy5taW4gPCAwLCBcIkNoYW5jZTogTWluIGNhbm5vdCBiZSBsZXNzIHRoYW4gemVyby5cIik7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVnZXIob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSByYW5kb20gc3RyaW5nXG4gICAgICpcbiAgICAgKiAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBjYW4gc3BlY2lmeSBhIGxlbmd0aFxuICAgICAqICBAcmV0dXJucyB7U3RyaW5nfSBhIHN0cmluZyBvZiByYW5kb20gbGVuZ3RoXG4gICAgICogIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGxlbmd0aCBjYW5ub3QgYmUgbGVzcyB0aGFuIHplcm9cbiAgICAgKi9cbiAgICBDaGFuY2UucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7IGxlbmd0aDogdGhpcy5uYXR1cmFsKHttaW46IDUsIG1heDogMjB9KSB9KTtcbiAgICAgICAgdGVzdFJhbmdlKG9wdGlvbnMubGVuZ3RoIDwgMCwgXCJDaGFuY2U6IExlbmd0aCBjYW5ub3QgYmUgbGVzcyB0aGFuIHplcm8uXCIpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICB0ZXh0ID0gdGhpcy5uKHRoaXMuY2hhcmFjdGVyLCBsZW5ndGgsIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiB0ZXh0LmpvaW4oXCJcIik7XG4gICAgfTtcblxuICAgIC8vIC0tIEVuZCBCYXNpY3MgLS1cblxuICAgIC8vIC0tIEhlbHBlcnMgLS1cblxuICAgIENoYW5jZS5wcm90b3R5cGUuY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgICAgIHJldHVybiB3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zdWJzdHIoMSk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUubWl4aW4gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGZvciAodmFyIGZ1bmNfbmFtZSBpbiBvYmopIHtcbiAgICAgICAgICAgIENoYW5jZS5wcm90b3R5cGVbZnVuY19uYW1lXSA9IG9ialtmdW5jX25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAgR2l2ZW4gYSBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyBzb21ldGhpbmcgcmFuZG9tIGFuZCBhIG51bWJlciBvZiBpdGVtcyB0byBnZW5lcmF0ZSxcbiAgICAgKiAgICByZXR1cm4gYW4gYXJyYXkgb2YgaXRlbXMgd2hlcmUgbm9uZSByZXBlYXQuXG4gICAgICpcbiAgICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gZm4gdGhlIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzIHNvbWV0aGluZyByYW5kb21cbiAgICAgKiAgQHBhcmFtIHtOdW1iZXJ9IG51bSBudW1iZXIgb2YgdGVybXMgdG8gZ2VuZXJhdGVcbiAgICAgKiAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgYW55IG9wdGlvbnMgdG8gcGFzcyBvbiB0byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uXG4gICAgICogIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2YgbGVuZ3RoIGBudW1gIHdpdGggZXZlcnkgaXRlbSBnZW5lcmF0ZWQgYnkgYGZuYCBhbmQgdW5pcXVlXG4gICAgICpcbiAgICAgKiAgVGhlcmUgY2FuIGJlIG1vcmUgcGFyYW1ldGVycyBhZnRlciB0aGVzZS4gQWxsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBhcmUgcHJvdmlkZWQgdG8gdGhlIGdpdmVuIGZ1bmN0aW9uXG4gICAgICovXG4gICAgQ2hhbmNlLnByb3RvdHlwZS51bmlxdWUgPSBmdW5jdGlvbihmbiwgbnVtLCBvcHRpb25zKSB7XG4gICAgICAgIHRlc3RSYW5nZShcbiAgICAgICAgICAgIHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgXCJDaGFuY2U6IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24uXCJcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgY29tcGFyYXRvciA9IGZ1bmN0aW9uKGFyciwgdmFsKSB7IHJldHVybiBhcnIuaW5kZXhPZih2YWwpICE9PSAtMTsgfTtcblxuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgY29tcGFyYXRvciA9IG9wdGlvbnMuY29tcGFyYXRvciB8fCBjb21wYXJhdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyciA9IFtdLCBjb3VudCA9IDAsIHJlc3VsdCwgTUFYX0RVUExJQ0FURVMgPSBudW0gKiA1MCwgcGFyYW1zID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXG4gICAgICAgIHdoaWxlIChhcnIubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmVkUGFyYW1zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwYXJhbXMpKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZuLmFwcGx5KHRoaXMsIGNsb25lZFBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoIWNvbXBhcmF0b3IoYXJyLCByZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAvLyByZXNldCBjb3VudCB3aGVuIHVuaXF1ZSBmb3VuZFxuICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCsrY291bnQgPiBNQVhfRFVQTElDQVRFUykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2hhbmNlOiBudW0gaXMgbGlrZWx5IHRvbyBsYXJnZSBmb3Igc2FtcGxlIHNldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAgR2l2ZXMgYW4gYXJyYXkgb2YgbiByYW5kb20gdGVybXNcbiAgICAgKlxuICAgICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0aGUgZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgc29tZXRoaW5nIHJhbmRvbVxuICAgICAqICBAcGFyYW0ge051bWJlcn0gbiBudW1iZXIgb2YgdGVybXMgdG8gZ2VuZXJhdGVcbiAgICAgKiAgQHJldHVybnMge0FycmF5fSBhbiBhcnJheSBvZiBsZW5ndGggYG5gIHdpdGggaXRlbXMgZ2VuZXJhdGVkIGJ5IGBmbmBcbiAgICAgKlxuICAgICAqICBUaGVyZSBjYW4gYmUgbW9yZSBwYXJhbWV0ZXJzIGFmdGVyIHRoZXNlLiBBbGwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGFyZSBwcm92aWRlZCB0byB0aGUgZ2l2ZW4gZnVuY3Rpb25cbiAgICAgKi9cbiAgICBDaGFuY2UucHJvdG90eXBlLm4gPSBmdW5jdGlvbihmbiwgbikge1xuICAgICAgICB0ZXN0UmFuZ2UoXG4gICAgICAgICAgICB0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgIFwiQ2hhbmNlOiBUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSBuLCBhcnIgPSBbXSwgcGFyYW1zID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXG4gICAgICAgIC8vIFByb3ZpZGluZyBhIG5lZ2F0aXZlIGNvdW50IHNob3VsZCByZXN1bHQgaW4gYSBub29wLlxuICAgICAgICBpID0gTWF0aC5tYXgoIDAsIGkgKTtcblxuICAgICAgICBmb3IgKG51bGw7IGktLTsgbnVsbCkge1xuICAgICAgICAgICAgYXJyLnB1c2goZm4uYXBwbHkodGhpcywgcGFyYW1zKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH07XG5cbiAgICAvLyBIL1QgdG8gU08gZm9yIHRoaXMgb25lOiBodHRwOi8vdnEuaW8vT3RVclo1XG4gICAgQ2hhbmNlLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbiAobnVtYmVyLCB3aWR0aCwgcGFkKSB7XG4gICAgICAgIC8vIERlZmF1bHQgcGFkIHRvIDAgaWYgbm9uZSBwcm92aWRlZFxuICAgICAgICBwYWQgPSBwYWQgfHwgJzAnO1xuICAgICAgICAvLyBDb252ZXJ0IG51bWJlciB0byBhIHN0cmluZ1xuICAgICAgICBudW1iZXIgPSBudW1iZXIgKyAnJztcbiAgICAgICAgcmV0dXJuIG51bWJlci5sZW5ndGggPj0gd2lkdGggPyBudW1iZXIgOiBuZXcgQXJyYXkod2lkdGggLSBudW1iZXIubGVuZ3RoICsgMSkuam9pbihwYWQpICsgbnVtYmVyO1xuICAgIH07XG5cbiAgICAvLyBERVBSRUNBVEVEIG9uIDIwMTUtMTAtMDFcbiAgICBDaGFuY2UucHJvdG90eXBlLnBpY2sgPSBmdW5jdGlvbiAoYXJyLCBjb3VudCkge1xuICAgICAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDaGFuY2U6IENhbm5vdCBwaWNrKCkgZnJvbSBhbiBlbXB0eSBhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvdW50IHx8IGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyW3RoaXMubmF0dXJhbCh7bWF4OiBhcnIubGVuZ3RoIC0gMX0pXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNodWZmbGUoYXJyKS5zbGljZSgwLCBjb3VudCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gR2l2ZW4gYW4gYXJyYXksIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnRcbiAgICBDaGFuY2UucHJvdG90eXBlLnBpY2tvbmUgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICAgIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDaGFuY2U6IENhbm5vdCBwaWNrb25lKCkgZnJvbSBhbiBlbXB0eSBhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyW3RoaXMubmF0dXJhbCh7bWF4OiBhcnIubGVuZ3RoIC0gMX0pXTtcbiAgICB9O1xuXG4gICAgLy8gR2l2ZW4gYW4gYXJyYXksIHJldHVybnMgYSByYW5kb20gc2V0IHdpdGggJ2NvdW50JyBlbGVtZW50c1xuICAgIENoYW5jZS5wcm90b3R5cGUucGlja3NldCA9IGZ1bmN0aW9uIChhcnIsIGNvdW50KSB7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNoYW5jZTogQ2Fubm90IHBpY2tzZXQoKSBmcm9tIGFuIGVtcHR5IGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2hhbmNlOiBjb3VudCBtdXN0IGJlIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvdW50IHx8IGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gWyB0aGlzLnBpY2tvbmUoYXJyKSBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2h1ZmZsZShhcnIpLnNsaWNlKDAsIGNvdW50KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnNodWZmbGUgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICAgIHZhciBvbGRfYXJyYXkgPSBhcnIuc2xpY2UoMCksXG4gICAgICAgICAgICBuZXdfYXJyYXkgPSBbXSxcbiAgICAgICAgICAgIGogPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gTnVtYmVyKG9sZF9hcnJheS5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFBpY2sgYSByYW5kb20gaW5kZXggZnJvbSB0aGUgYXJyYXlcbiAgICAgICAgICAgIGogPSB0aGlzLm5hdHVyYWwoe21heDogb2xkX2FycmF5Lmxlbmd0aCAtIDF9KTtcbiAgICAgICAgICAgIC8vIEFkZCBpdCB0byB0aGUgbmV3IGFycmF5XG4gICAgICAgICAgICBuZXdfYXJyYXlbaV0gPSBvbGRfYXJyYXlbal07XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhhdCBlbGVtZW50IGZyb20gdGhlIG9yaWdpbmFsIGFycmF5XG4gICAgICAgICAgICBvbGRfYXJyYXkuc3BsaWNlKGosIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld19hcnJheTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyBhIHNpbmdsZSBpdGVtIGZyb20gYW4gYXJyYXkgd2l0aCByZWxhdGl2ZSB3ZWlnaHRpbmcgb2Ygb2Rkc1xuICAgIENoYW5jZS5wcm90b3R5cGUud2VpZ2h0ZWQgPSBmdW5jdGlvbiAoYXJyLCB3ZWlnaHRzLCB0cmltKSB7XG4gICAgICAgIGlmIChhcnIubGVuZ3RoICE9PSB3ZWlnaHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDaGFuY2U6IGxlbmd0aCBvZiBhcnJheSBhbmQgd2VpZ2h0cyBtdXN0IG1hdGNoXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2NhbiB3ZWlnaHRzIGFycmF5IGFuZCBzdW0gdmFsaWQgZW50cmllc1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgZm9yICh2YXIgd2VpZ2h0SW5kZXggPSAwOyB3ZWlnaHRJbmRleCA8IHdlaWdodHMubGVuZ3RoOyArK3dlaWdodEluZGV4KSB7XG4gICAgICAgICAgICB2YWwgPSB3ZWlnaHRzW3dlaWdodEluZGV4XTtcbiAgICAgICAgICAgIGlmICh2YWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdW0gPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2hhbmNlOiBubyB2YWxpZCBlbnRyaWVzIGluIGFycmF5IHdlaWdodHNcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWxlY3QgYSB2YWx1ZSB3aXRoaW4gcmFuZ2VcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gdGhpcy5yYW5kb20oKSAqIHN1bTtcblxuICAgICAgICAvLyBmaW5kIGFycmF5IGVudHJ5IGNvcnJlc3BvbmRpbmcgdG8gc2VsZWN0ZWQgdmFsdWVcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgdmFyIGxhc3RHb29kSWR4ID0gLTE7XG4gICAgICAgIHZhciBjaG9zZW5JZHg7XG4gICAgICAgIGZvciAod2VpZ2h0SW5kZXggPSAwOyB3ZWlnaHRJbmRleCA8IHdlaWdodHMubGVuZ3RoOyArK3dlaWdodEluZGV4KSB7XG4gICAgICAgICAgICB2YWwgPSB3ZWlnaHRzW3dlaWdodEluZGV4XTtcbiAgICAgICAgICAgIHRvdGFsICs9IHZhbDtcbiAgICAgICAgICAgIGlmICh2YWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkIDw9IHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNob3NlbklkeCA9IHdlaWdodEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdEdvb2RJZHggPSB3ZWlnaHRJbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaGFuZGxlIGFueSBwb3NzaWJsZSByb3VuZGluZyBlcnJvciBjb21wYXJpc29uIHRvIGVuc3VyZSBzb21ldGhpbmcgaXMgcGlja2VkXG4gICAgICAgICAgICBpZiAod2VpZ2h0SW5kZXggPT09ICh3ZWlnaHRzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgY2hvc2VuSWR4ID0gbGFzdEdvb2RJZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hvc2VuID0gYXJyW2Nob3NlbklkeF07XG4gICAgICAgIHRyaW0gPSAodHlwZW9mIHRyaW0gPT09ICd1bmRlZmluZWQnKSA/IGZhbHNlIDogdHJpbTtcbiAgICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgICAgIGFyci5zcGxpY2UoY2hvc2VuSWR4LCAxKTtcbiAgICAgICAgICAgIHdlaWdodHMuc3BsaWNlKGNob3NlbklkeCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvc2VuO1xuICAgIH07XG5cbiAgICAvLyAtLSBFbmQgSGVscGVycyAtLVxuXG4gICAgLy8gLS0gVGV4dCAtLVxuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5wYXJhZ3JhcGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHNlbnRlbmNlcyA9IG9wdGlvbnMuc2VudGVuY2VzIHx8IHRoaXMubmF0dXJhbCh7bWluOiAzLCBtYXg6IDd9KSxcbiAgICAgICAgICAgIHNlbnRlbmNlX2FycmF5ID0gdGhpcy5uKHRoaXMuc2VudGVuY2UsIHNlbnRlbmNlcyk7XG5cbiAgICAgICAgcmV0dXJuIHNlbnRlbmNlX2FycmF5LmpvaW4oJyAnKTtcbiAgICB9O1xuXG4gICAgLy8gQ291bGQgZ2V0IHNtYXJ0ZXIgYWJvdXQgdGhpcyB0aGFuIGdlbmVyYXRpbmcgcmFuZG9tIHdvcmRzIGFuZFxuICAgIC8vIGNoYWluaW5nIHRoZW0gdG9nZXRoZXIuIFN1Y2ggYXM6IGh0dHA6Ly92cS5pby8xYTVjZU9oXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5zZW50ZW5jZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgICB2YXIgd29yZHMgPSBvcHRpb25zLndvcmRzIHx8IHRoaXMubmF0dXJhbCh7bWluOiAxMiwgbWF4OiAxOH0pLFxuICAgICAgICAgICAgcHVuY3R1YXRpb24gPSBvcHRpb25zLnB1bmN0dWF0aW9uLFxuICAgICAgICAgICAgdGV4dCwgd29yZF9hcnJheSA9IHRoaXMubih0aGlzLndvcmQsIHdvcmRzKTtcblxuICAgICAgICB0ZXh0ID0gd29yZF9hcnJheS5qb2luKCcgJyk7XG5cbiAgICAgICAgLy8gQ2FwaXRhbGl6ZSBmaXJzdCBsZXR0ZXIgb2Ygc2VudGVuY2VcbiAgICAgICAgdGV4dCA9IHRoaXMuY2FwaXRhbGl6ZSh0ZXh0KTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgcHVuY3R1YXRpb24gaGFzIGEgdXNhYmxlIHZhbHVlXG4gICAgICAgIGlmIChwdW5jdHVhdGlvbiAhPT0gZmFsc2UgJiYgIS9eW1xcLlxcPzshOl0kLy50ZXN0KHB1bmN0dWF0aW9uKSkge1xuICAgICAgICAgICAgcHVuY3R1YXRpb24gPSAnLic7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgcHVuY3R1YXRpb24gbWFya1xuICAgICAgICBpZiAocHVuY3R1YXRpb24pIHtcbiAgICAgICAgICAgIHRleHQgKz0gcHVuY3R1YXRpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5zeWxsYWJsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGggfHwgdGhpcy5uYXR1cmFsKHttaW46IDIsIG1heDogM30pLFxuICAgICAgICAgICAgY29uc29uYW50cyA9ICdiY2RmZ2hqa2xtbnByc3R2d3onLCAvLyBjb25zb25hbnRzIGV4Y2VwdCBoYXJkIHRvIHNwZWFrIG9uZXNcbiAgICAgICAgICAgIHZvd2VscyA9ICdhZWlvdScsIC8vIHZvd2Vsc1xuICAgICAgICAgICAgYWxsID0gY29uc29uYW50cyArIHZvd2VscywgLy8gYWxsXG4gICAgICAgICAgICB0ZXh0ID0gJycsXG4gICAgICAgICAgICBjaHI7XG5cbiAgICAgICAgLy8gSSdtIHN1cmUgdGhlcmUncyBhIG1vcmUgZWxlZ2FudCB3YXkgdG8gZG8gdGhpcywgYnV0IHRoaXMgd29ya3NcbiAgICAgICAgLy8gZGVjZW50bHkgd2VsbC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCBjaGFyYWN0ZXIgY2FuIGJlIGFueXRoaW5nXG4gICAgICAgICAgICAgICAgY2hyID0gdGhpcy5jaGFyYWN0ZXIoe3Bvb2w6IGFsbH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25zb25hbnRzLmluZGV4T2YoY2hyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBMYXN0IGNoYXJhY3RlciB3YXMgYSB2b3dlbCwgbm93IHdlIHdhbnQgYSBjb25zb25hbnRcbiAgICAgICAgICAgICAgICBjaHIgPSB0aGlzLmNoYXJhY3Rlcih7cG9vbDogY29uc29uYW50c30pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMYXN0IGNoYXJhY3RlciB3YXMgYSBjb25zb25hbnQsIG5vdyB3ZSB3YW50IGEgdm93ZWxcbiAgICAgICAgICAgICAgICBjaHIgPSB0aGlzLmNoYXJhY3Rlcih7cG9vbDogdm93ZWxzfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHQgKz0gY2hyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2FwaXRhbGl6ZSkge1xuICAgICAgICAgICAgdGV4dCA9IHRoaXMuY2FwaXRhbGl6ZSh0ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLndvcmQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgICAgdGVzdFJhbmdlKFxuICAgICAgICAgICAgb3B0aW9ucy5zeWxsYWJsZXMgJiYgb3B0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICBcIkNoYW5jZTogQ2Fubm90IHNwZWNpZnkgYm90aCBzeWxsYWJsZXMgQU5EIGxlbmd0aC5cIlxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBzeWxsYWJsZXMgPSBvcHRpb25zLnN5bGxhYmxlcyB8fCB0aGlzLm5hdHVyYWwoe21pbjogMSwgbWF4OiAzfSksXG4gICAgICAgICAgICB0ZXh0ID0gJyc7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBFaXRoZXIgYm91bmQgd29yZCBieSBsZW5ndGhcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IHRoaXMuc3lsbGFibGUoKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRleHQubGVuZ3RoIDwgb3B0aW9ucy5sZW5ndGgpO1xuICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIG9wdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE9yIGJ5IG51bWJlciBvZiBzeWxsYWJsZXNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3lsbGFibGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IHRoaXMuc3lsbGFibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmNhcGl0YWxpemUpIHtcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLmNhcGl0YWxpemUodGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgLy8gLS0gRW5kIFRleHQgLS1cblxuICAgIC8vIC0tIFBlcnNvbiAtLVxuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5hZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHZhciBhZ2VSYW5nZTtcblxuICAgICAgICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY2hpbGQnOlxuICAgICAgICAgICAgICAgIGFnZVJhbmdlID0ge21pbjogMCwgbWF4OiAxMn07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0ZWVuJzpcbiAgICAgICAgICAgICAgICBhZ2VSYW5nZSA9IHttaW46IDEzLCBtYXg6IDE5fTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FkdWx0JzpcbiAgICAgICAgICAgICAgICBhZ2VSYW5nZSA9IHttaW46IDE4LCBtYXg6IDY1fTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Nlbmlvcic6XG4gICAgICAgICAgICAgICAgYWdlUmFuZ2UgPSB7bWluOiA2NSwgbWF4OiAxMDB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWxsJzpcbiAgICAgICAgICAgICAgICBhZ2VSYW5nZSA9IHttaW46IDAsIG1heDogMTAwfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYWdlUmFuZ2UgPSB7bWluOiAxOCwgbWF4OiA2NX07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5uYXR1cmFsKGFnZVJhbmdlKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5iaXJ0aGRheSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBhZ2UgPSB0aGlzLmFnZShvcHRpb25zKTtcbiAgICAgICAgdmFyIGN1cnJlbnRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudHlwZSkge1xuICAgICAgICAgICAgdmFyIG1pbiA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB2YXIgbWF4ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIG1pbi5zZXRGdWxsWWVhcihjdXJyZW50WWVhciAtIGFnZSAtIDEpO1xuICAgICAgICAgICAgbWF4LnNldEZ1bGxZZWFyKGN1cnJlbnRZZWFyIC0gYWdlKTtcblxuICAgICAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBtaW46IG1pbixcbiAgICAgICAgICAgICAgICBtYXg6IG1heFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywge1xuICAgICAgICAgICAgICAgIHllYXI6IGN1cnJlbnRZZWFyIC0gYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8vIENQRjsgSUQgdG8gaWRlbnRpZnkgdGF4cGF5ZXJzIGluIEJyYXppbFxuICAgIENoYW5jZS5wcm90b3R5cGUuY3BmID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZDogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgbiA9IHRoaXMubih0aGlzLm5hdHVyYWwsIDksIHsgbWF4OiA5IH0pO1xuICAgICAgICB2YXIgZDEgPSBuWzhdKjIrbls3XSozK25bNl0qNCtuWzVdKjUrbls0XSo2K25bM10qNytuWzJdKjgrblsxXSo5K25bMF0qMTA7XG4gICAgICAgIGQxID0gMTEgLSAoZDEgJSAxMSk7XG4gICAgICAgIGlmIChkMT49MTApIHtcbiAgICAgICAgICAgIGQxID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZDIgPSBkMSoyK25bOF0qMytuWzddKjQrbls2XSo1K25bNV0qNituWzRdKjcrblszXSo4K25bMl0qOStuWzFdKjEwK25bMF0qMTE7XG4gICAgICAgIGQyID0gMTEgLSAoZDIgJSAxMSk7XG4gICAgICAgIGlmIChkMj49MTApIHtcbiAgICAgICAgICAgIGQyID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3BmID0gJycrblswXStuWzFdK25bMl0rJy4nK25bM10rbls0XStuWzVdKycuJytuWzZdK25bN10rbls4XSsnLScrZDErZDI7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmZvcm1hdHRlZCA/IGNwZiA6IGNwZi5yZXBsYWNlKC9cXEQvZywnJyk7XG4gICAgfTtcblxuICAgIC8vIENOUEo6IElEIHRvIGlkZW50aWZ5IGNvbXBhbmllcyBpbiBCcmF6aWxcbiAgICBDaGFuY2UucHJvdG90eXBlLmNucGogPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywge1xuICAgICAgICAgICAgZm9ybWF0dGVkOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBuID0gdGhpcy5uKHRoaXMubmF0dXJhbCwgMTIsIHsgbWF4OiAxMiB9KTtcbiAgICAgICAgdmFyIGQxID0gblsxMV0qMituWzEwXSozK25bOV0qNCtuWzhdKjUrbls3XSo2K25bNl0qNytuWzVdKjgrbls0XSo5K25bM10qMituWzJdKjMrblsxXSo0K25bMF0qNTtcbiAgICAgICAgZDEgPSAxMSAtIChkMSAlIDExKTtcbiAgICAgICAgaWYgKGQxPDIpIHtcbiAgICAgICAgICAgIGQxID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZDIgPSBkMSoyK25bMTFdKjMrblsxMF0qNCtuWzldKjUrbls4XSo2K25bN10qNytuWzZdKjgrbls1XSo5K25bNF0qMituWzNdKjMrblsyXSo0K25bMV0qNStuWzBdKjY7XG4gICAgICAgIGQyID0gMTEgLSAoZDIgJSAxMSk7XG4gICAgICAgIGlmIChkMjwyKSB7XG4gICAgICAgICAgICBkMiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNucGogPSAnJytuWzBdK25bMV0rJy4nK25bMl0rblszXStuWzRdKycuJytuWzVdK25bNl0rbls3XSsnLycrbls4XStuWzldK25bMTBdK25bMTFdKyctJytkMStkMjtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZm9ybWF0dGVkID8gY25waiA6IGNucGoucmVwbGFjZSgvXFxEL2csJycpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtnZW5kZXI6IHRoaXMuZ2VuZGVyKCksIG5hdGlvbmFsaXR5OiAnZW4nfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBpY2sodGhpcy5nZXQoXCJmaXJzdE5hbWVzXCIpW29wdGlvbnMuZ2VuZGVyLnRvTG93ZXJDYXNlKCldW29wdGlvbnMubmF0aW9uYWxpdHkudG9Mb3dlckNhc2UoKV0pO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmdlbmRlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7ZXh0cmFHZW5kZXJzOiBbXX0pO1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrKFsnTWFsZScsICdGZW1hbGUnXS5jb25jYXQob3B0aW9ucy5leHRyYUdlbmRlcnMpKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtuYXRpb25hbGl0eTogJ2VuJ30pO1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrKHRoaXMuZ2V0KFwibGFzdE5hbWVzXCIpW29wdGlvbnMubmF0aW9uYWxpdHkudG9Mb3dlckNhc2UoKV0pO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmlzcmFlbElkPWZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB4PXRoaXMuc3RyaW5nKHtwb29sOiAnMDEyMzQ1Njc4OScsbGVuZ3RoOjh9KTtcbiAgICAgICAgdmFyIHk9MDtcbiAgICAgICAgZm9yICh2YXIgaT0wO2k8eC5sZW5ndGg7aSsrKXtcbiAgICAgICAgICAgIHZhciB0aGlzRGlnaXQ9ICB4W2ldICogIChpLzI9PT1wYXJzZUludChpLzIpID8gMSA6IDIpO1xuICAgICAgICAgICAgdGhpc0RpZ2l0PXRoaXMucGFkKHRoaXNEaWdpdCwyKS50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpc0RpZ2l0PXBhcnNlSW50KHRoaXNEaWdpdFswXSkgKyBwYXJzZUludCh0aGlzRGlnaXRbMV0pO1xuICAgICAgICAgICAgeT15K3RoaXNEaWdpdDtcbiAgICAgICAgfVxuICAgICAgICB4PXgrKDEwLXBhcnNlSW50KHkudG9TdHJpbmcoKS5zbGljZSgtMSkpKS50b1N0cmluZygpLnNsaWNlKC0xKTtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUubXJ6ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNoZWNrRGlnaXQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IFwiPEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlYWlwiLnNwbGl0KCcnKSxcbiAgICAgICAgICAgICAgICBtdWx0aXBsaWVycyA9IFsgNywgMywgMSBdLFxuICAgICAgICAgICAgICAgIHJ1bm5pbmdUb3RhbCA9IDA7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnB1dC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihjaGFyYWN0ZXIsIGlkeCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBhbHBoYS5pbmRleE9mKGNoYXJhY3Rlcik7XG5cbiAgICAgICAgICAgICAgICBpZihwb3MgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlciA9IHBvcyA9PT0gMCA/IDAgOiBwb3MgKyA5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlciA9IHBhcnNlSW50KGNoYXJhY3RlciwgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXIgKj0gbXVsdGlwbGllcnNbaWR4ICUgbXVsdGlwbGllcnMubGVuZ3RoXTtcbiAgICAgICAgICAgICAgICBydW5uaW5nVG90YWwgKz0gY2hhcmFjdGVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcnVubmluZ1RvdGFsICUgMTA7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZW5lcmF0ZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgICB2YXIgcGFkID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXkobGVuZ3RoICsgMSkuam9pbignPCcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBudW1iZXIgPSBbICdQPCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmlzc3VlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMubGFzdC50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJzw8JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuZmlyc3QudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZCgzOSAtIChvcHRzLmxhc3QubGVuZ3RoICsgb3B0cy5maXJzdC5sZW5ndGggKyAyKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLnBhc3Nwb3J0TnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tEaWdpdChvcHRzLnBhc3Nwb3J0TnVtYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMubmF0aW9uYWxpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmRvYixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRGlnaXQob3B0cy5kb2IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5nZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmV4cGlyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRGlnaXQob3B0cy5leHBpcnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkKDE0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRGlnaXQocGFkKDE0KSkgXS5qb2luKCcnKTtcblxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArXG4gICAgICAgICAgICAgICAgKGNoZWNrRGlnaXQobnVtYmVyLnN1YnN0cig0NCwgMTApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIuc3Vic3RyKDU3LCA3KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyLnN1YnN0cig2NSwgNykpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGZpcnN0OiB0aGlzLmZpcnN0KCksXG4gICAgICAgICAgICBsYXN0OiB0aGlzLmxhc3QoKSxcbiAgICAgICAgICAgIHBhc3Nwb3J0TnVtYmVyOiB0aGlzLmludGVnZXIoe21pbjogMTAwMDAwMDAwLCBtYXg6IDk5OTk5OTk5OX0pLFxuICAgICAgICAgICAgZG9iOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlID0gdGhhdC5iaXJ0aGRheSh7dHlwZTogJ2FkdWx0J30pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbZGF0ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkuc3Vic3RyKDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5wYWQoZGF0ZS5nZXRNb250aCgpICsgMSwgMiksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnBhZChkYXRlLmdldERhdGUoKSwgMildLmpvaW4oJycpO1xuICAgICAgICAgICAgfSgpKSxcbiAgICAgICAgICAgIGV4cGlyeTogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsoZGF0ZS5nZXRGdWxsWWVhcigpICsgNSkudG9TdHJpbmcoKS5zdWJzdHIoMiksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnBhZChkYXRlLmdldE1vbnRoKCkgKyAxLCAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucGFkKGRhdGUuZ2V0RGF0ZSgpLCAyKV0uam9pbignJyk7XG4gICAgICAgICAgICB9KCkpLFxuICAgICAgICAgICAgZ2VuZGVyOiB0aGlzLmdlbmRlcigpID09PSAnRmVtYWxlJyA/ICdGJzogJ00nLFxuICAgICAgICAgICAgaXNzdWVyOiAnR0JSJyxcbiAgICAgICAgICAgIG5hdGlvbmFsaXR5OiAnR0JSJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlIChvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBmaXJzdCA9IHRoaXMuZmlyc3Qob3B0aW9ucyksXG4gICAgICAgICAgICBsYXN0ID0gdGhpcy5sYXN0KG9wdGlvbnMpLFxuICAgICAgICAgICAgbmFtZTtcblxuICAgICAgICBpZiAob3B0aW9ucy5taWRkbGUpIHtcbiAgICAgICAgICAgIG5hbWUgPSBmaXJzdCArICcgJyArIHRoaXMuZmlyc3Qob3B0aW9ucykgKyAnICcgKyBsYXN0O1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubWlkZGxlX2luaXRpYWwpIHtcbiAgICAgICAgICAgIG5hbWUgPSBmaXJzdCArICcgJyArIHRoaXMuY2hhcmFjdGVyKHthbHBoYTogdHJ1ZSwgY2FzaW5nOiAndXBwZXInfSkgKyAnLiAnICsgbGFzdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSBmaXJzdCArICcgJyArIGxhc3Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wcmVmaXgpIHtcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLnByZWZpeChvcHRpb25zKSArICcgJyArIG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zdWZmaXgpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lICsgJyAnICsgdGhpcy5zdWZmaXgob3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBuYW1lIHByZWZpeGVzIGJhc2VkIG9uIHN1cHBsaWVkIGdlbmRlci5cbiAgICAvLyBAdG9kbyBpbnRyb2R1Y2UgaW50ZXJuYXRpb25hbGl6YXRpb25cbiAgICBDaGFuY2UucHJvdG90eXBlLm5hbWVfcHJlZml4ZXMgPSBmdW5jdGlvbiAoZ2VuZGVyKSB7XG4gICAgICAgIGdlbmRlciA9IGdlbmRlciB8fCBcImFsbFwiO1xuICAgICAgICBnZW5kZXIgPSBnZW5kZXIudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICB2YXIgcHJlZml4ZXMgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICdEb2N0b3InLCBhYmJyZXZpYXRpb246ICdEci4nIH1cbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoZ2VuZGVyID09PSBcIm1hbGVcIiB8fCBnZW5kZXIgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgICAgIHByZWZpeGVzLnB1c2goeyBuYW1lOiAnTWlzdGVyJywgYWJicmV2aWF0aW9uOiAnTXIuJyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZW5kZXIgPT09IFwiZmVtYWxlXCIgfHwgZ2VuZGVyID09PSBcImFsbFwiKSB7XG4gICAgICAgICAgICBwcmVmaXhlcy5wdXNoKHsgbmFtZTogJ01pc3MnLCBhYmJyZXZpYXRpb246ICdNaXNzJyB9KTtcbiAgICAgICAgICAgIHByZWZpeGVzLnB1c2goeyBuYW1lOiAnTWlzc2VzJywgYWJicmV2aWF0aW9uOiAnTXJzLicgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJlZml4ZXM7XG4gICAgfTtcblxuICAgIC8vIEFsaWFzIGZvciBuYW1lX3ByZWZpeFxuICAgIENoYW5jZS5wcm90b3R5cGUucHJlZml4ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZV9wcmVmaXgob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUubmFtZV9wcmVmaXggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywgeyBnZW5kZXI6IFwiYWxsXCIgfSk7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmZ1bGwgP1xuICAgICAgICAgICAgdGhpcy5waWNrKHRoaXMubmFtZV9wcmVmaXhlcyhvcHRpb25zLmdlbmRlcikpLm5hbWUgOlxuICAgICAgICAgICAgdGhpcy5waWNrKHRoaXMubmFtZV9wcmVmaXhlcyhvcHRpb25zLmdlbmRlcikpLmFiYnJldmlhdGlvbjtcbiAgICB9O1xuICAgIC8vSHVuZ2FyaWFuIElEIG51bWJlclxuICAgIENoYW5jZS5wcm90b3R5cGUuSElETj0gZnVuY3Rpb24oKXtcbiAgICAgLy9IdW5nYXJpYW4gSUQgbnViZXIgc3RydWN0dXJlOiBYWFhYWFhZWSAoWD1udW1iZXIsWT1DYXBpdGFsIExhdGluIGxldHRlcilcbiAgICAgIHZhciBpZG5fcG9vbD1cIjAxMjM0NTY3ODlcIjtcbiAgICAgIHZhciBpZG5fY2hycz1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlYWlwiO1xuICAgICAgdmFyIGlkbj1cIlwiO1xuICAgICAgICBpZG4rPXRoaXMuc3RyaW5nKHtwb29sOmlkbl9wb29sLGxlbmd0aDo2fSk7XG4gICAgICAgIGlkbis9dGhpcy5zdHJpbmcoe3Bvb2w6aWRuX2NocnMsbGVuZ3RoOjJ9KTtcbiAgICAgICAgcmV0dXJuIGlkbjtcbiAgICB9O1xuXG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnNzbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7c3NuRm91cjogZmFsc2UsIGRhc2hlczogdHJ1ZX0pO1xuICAgICAgICB2YXIgc3NuX3Bvb2wgPSBcIjEyMzQ1Njc4OTBcIixcbiAgICAgICAgICAgIHNzbixcbiAgICAgICAgICAgIGRhc2ggPSBvcHRpb25zLmRhc2hlcyA/ICctJyA6ICcnO1xuXG4gICAgICAgIGlmKCFvcHRpb25zLnNzbkZvdXIpIHtcbiAgICAgICAgICAgIHNzbiA9IHRoaXMuc3RyaW5nKHtwb29sOiBzc25fcG9vbCwgbGVuZ3RoOiAzfSkgKyBkYXNoICtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5nKHtwb29sOiBzc25fcG9vbCwgbGVuZ3RoOiAyfSkgKyBkYXNoICtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5nKHtwb29sOiBzc25fcG9vbCwgbGVuZ3RoOiA0fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzc24gPSB0aGlzLnN0cmluZyh7cG9vbDogc3NuX3Bvb2wsIGxlbmd0aDogNH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzc247XG4gICAgfTtcblxuICAgIC8vIFJldHVybiB0aGUgbGlzdCBvZiBhdmFpbGFibGUgbmFtZSBzdWZmaXhlc1xuICAgIC8vIEB0b2RvIGludHJvZHVjZSBpbnRlcm5hdGlvbmFsaXphdGlvblxuICAgIENoYW5jZS5wcm90b3R5cGUubmFtZV9zdWZmaXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN1ZmZpeGVzID0gW1xuICAgICAgICAgICAgeyBuYW1lOiAnRG9jdG9yIG9mIE9zdGVvcGF0aGljIE1lZGljaW5lJywgYWJicmV2aWF0aW9uOiAnRC5PLicgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ0RvY3RvciBvZiBQaGlsb3NvcGh5JywgYWJicmV2aWF0aW9uOiAnUGguRC4nIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdFc3F1aXJlJywgYWJicmV2aWF0aW9uOiAnRXNxLicgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ0p1bmlvcicsIGFiYnJldmlhdGlvbjogJ0pyLicgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ0p1cmlzIERvY3RvcicsIGFiYnJldmlhdGlvbjogJ0ouRC4nIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdNYXN0ZXIgb2YgQXJ0cycsIGFiYnJldmlhdGlvbjogJ00uQS4nIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdNYXN0ZXIgb2YgQnVzaW5lc3MgQWRtaW5pc3RyYXRpb24nLCBhYmJyZXZpYXRpb246ICdNLkIuQS4nIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdNYXN0ZXIgb2YgU2NpZW5jZScsIGFiYnJldmlhdGlvbjogJ00uUy4nIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdNZWRpY2FsIERvY3RvcicsIGFiYnJldmlhdGlvbjogJ00uRC4nIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdTZW5pb3InLCBhYmJyZXZpYXRpb246ICdTci4nIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdUaGUgVGhpcmQnLCBhYmJyZXZpYXRpb246ICdJSUknIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdUaGUgRm91cnRoJywgYWJicmV2aWF0aW9uOiAnSVYnIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdCYWNoZWxvciBvZiBFbmdpbmVlcmluZycsIGFiYnJldmlhdGlvbjogJ0IuRScgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ0JhY2hlbG9yIG9mIFRlY2hub2xvZ3knLCBhYmJyZXZpYXRpb246ICdCLlRFQ0gnIH1cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHN1ZmZpeGVzO1xuICAgIH07XG5cbiAgICAvLyBBbGlhcyBmb3IgbmFtZV9zdWZmaXhcbiAgICBDaGFuY2UucHJvdG90eXBlLnN1ZmZpeCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWVfc3VmZml4KG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLm5hbWVfc3VmZml4ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5mdWxsID9cbiAgICAgICAgICAgIHRoaXMucGljayh0aGlzLm5hbWVfc3VmZml4ZXMoKSkubmFtZSA6XG4gICAgICAgICAgICB0aGlzLnBpY2sodGhpcy5uYW1lX3N1ZmZpeGVzKCkpLmFiYnJldmlhdGlvbjtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5uYXRpb25hbGl0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoXCJuYXRpb25hbGl0aWVzXCIpO1xuICAgIH07XG5cbiAgICAvLyBHZW5lcmF0ZSByYW5kb20gbmF0aW9uYWxpdHkgYmFzZWQgb24ganNvbiBsaXN0XG4gICAgQ2hhbmNlLnByb3RvdHlwZS5uYXRpb25hbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5hdGlvbmFsaXR5ID0gdGhpcy5waWNrKHRoaXMubmF0aW9uYWxpdGllcygpKTtcbiAgICAgICAgcmV0dXJuIG5hdGlvbmFsaXR5Lm5hbWU7XG4gICAgfTtcblxuICAgIC8vIC0tIEVuZCBQZXJzb24gLS1cblxuICAgIC8vIC0tIE1vYmlsZSAtLVxuICAgIC8vIEFuZHJvaWQgR0NNIFJlZ2lzdHJhdGlvbiBJRFxuICAgIENoYW5jZS5wcm90b3R5cGUuYW5kcm9pZF9pZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiQVBBOTFcIiArIHRoaXMuc3RyaW5nKHsgcG9vbDogXCIwMTIzNDU2Nzg5YWJjZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaLV9cIiwgbGVuZ3RoOiAxNzggfSk7XG4gICAgfTtcblxuICAgIC8vIEFwcGxlIFB1c2ggVG9rZW5cbiAgICBDaGFuY2UucHJvdG90eXBlLmFwcGxlX3Rva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcoeyBwb29sOiBcImFiY2RlZjEyMzQ1Njc4OTBcIiwgbGVuZ3RoOiA2NCB9KTtcbiAgICB9O1xuXG4gICAgLy8gV2luZG93cyBQaG9uZSA4IEFOSUQyXG4gICAgQ2hhbmNlLnByb3RvdHlwZS53cDhfYW5pZDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBiYXNlNjQoIHRoaXMuaGFzaCggeyBsZW5ndGggOiAzMiB9ICkgKTtcbiAgICB9O1xuXG4gICAgLy8gV2luZG93cyBQaG9uZSA3IEFOSURcbiAgICBDaGFuY2UucHJvdG90eXBlLndwN19hbmlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0E9JyArIHRoaXMuZ3VpZCgpLnJlcGxhY2UoLy0vZywgJycpLnRvVXBwZXJDYXNlKCkgKyAnJkU9JyArIHRoaXMuaGFzaCh7IGxlbmd0aDozIH0pICsgJyZXPScgKyB0aGlzLmludGVnZXIoeyBtaW46MCwgbWF4OjkgfSk7XG4gICAgfTtcblxuICAgIC8vIEJsYWNrQmVycnkgRGV2aWNlIFBJTlxuICAgIENoYW5jZS5wcm90b3R5cGUuYmJfcGluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNoKHsgbGVuZ3RoOiA4IH0pO1xuICAgIH07XG5cbiAgICAvLyAtLSBFbmQgTW9iaWxlIC0tXG5cbiAgICAvLyAtLSBXZWIgLS1cbiAgICBDaGFuY2UucHJvdG90eXBlLmF2YXRhciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciB1cmwgPSBudWxsO1xuICAgICAgICB2YXIgVVJMX0JBU0UgPSAnLy93d3cuZ3JhdmF0YXIuY29tL2F2YXRhci8nO1xuICAgICAgICB2YXIgUFJPVE9DT0xTID0ge1xuICAgICAgICAgICAgaHR0cDogJ2h0dHAnLFxuICAgICAgICAgICAgaHR0cHM6ICdodHRwcydcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIEZJTEVfVFlQRVMgPSB7XG4gICAgICAgICAgICBibXA6ICdibXAnLFxuICAgICAgICAgICAgZ2lmOiAnZ2lmJyxcbiAgICAgICAgICAgIGpwZzogJ2pwZycsXG4gICAgICAgICAgICBwbmc6ICdwbmcnXG4gICAgICAgIH07XG4gICAgICAgIHZhciBGQUxMQkFDS1MgPSB7XG4gICAgICAgICAgICAnNDA0JzogJzQwNCcsIC8vIFJldHVybiA0MDQgaWYgbm90IGZvdW5kXG4gICAgICAgICAgICBtbTogJ21tJywgLy8gTXlzdGVyeSBtYW5cbiAgICAgICAgICAgIGlkZW50aWNvbjogJ2lkZW50aWNvbicsIC8vIEdlb21ldHJpYyBwYXR0ZXJuIGJhc2VkIG9uIGhhc2hcbiAgICAgICAgICAgIG1vbnN0ZXJpZDogJ21vbnN0ZXJpZCcsIC8vIEEgZ2VuZXJhdGVkIG1vbnN0ZXIgaWNvblxuICAgICAgICAgICAgd2F2YXRhcjogJ3dhdmF0YXInLCAvLyBBIGdlbmVyYXRlZCBmYWNlXG4gICAgICAgICAgICByZXRybzogJ3JldHJvJywgLy8gOC1iaXQgaWNvblxuICAgICAgICAgICAgYmxhbms6ICdibGFuaycgLy8gQSB0cmFuc3BhcmVudCBwbmdcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIFJBVElOR1MgPSB7XG4gICAgICAgICAgICBnOiAnZycsXG4gICAgICAgICAgICBwZzogJ3BnJyxcbiAgICAgICAgICAgIHI6ICdyJyxcbiAgICAgICAgICAgIHg6ICd4J1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIHByb3RvY29sOiBudWxsLFxuICAgICAgICAgICAgZW1haWw6IG51bGwsXG4gICAgICAgICAgICBmaWxlRXh0ZW5zaW9uOiBudWxsLFxuICAgICAgICAgICAgc2l6ZTogbnVsbCxcbiAgICAgICAgICAgIGZhbGxiYWNrOiBudWxsLFxuICAgICAgICAgICAgcmF0aW5nOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBTZXQgdG8gYSByYW5kb20gZW1haWxcbiAgICAgICAgICAgIG9wdHMuZW1haWwgPSB0aGlzLmVtYWlsKCk7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBvcHRzLmVtYWlsID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuY29uc3RydWN0b3IgPT09ICdBcnJheScpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0cyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIG9wdHMpO1xuXG4gICAgICAgIGlmICghb3B0cy5lbWFpbCkge1xuICAgICAgICAgICAgLy8gU2V0IHRvIGEgcmFuZG9tIGVtYWlsXG4gICAgICAgICAgICBvcHRzLmVtYWlsID0gdGhpcy5lbWFpbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2FmZSBjaGVja2luZyBmb3IgcGFyYW1zXG4gICAgICAgIG9wdHMucHJvdG9jb2wgPSBQUk9UT0NPTFNbb3B0cy5wcm90b2NvbF0gPyBvcHRzLnByb3RvY29sICsgJzonIDogJyc7XG4gICAgICAgIG9wdHMuc2l6ZSA9IHBhcnNlSW50KG9wdHMuc2l6ZSwgMCkgPyBvcHRzLnNpemUgOiAnJztcbiAgICAgICAgb3B0cy5yYXRpbmcgPSBSQVRJTkdTW29wdHMucmF0aW5nXSA/IG9wdHMucmF0aW5nIDogJyc7XG4gICAgICAgIG9wdHMuZmFsbGJhY2sgPSBGQUxMQkFDS1Nbb3B0cy5mYWxsYmFja10gPyBvcHRzLmZhbGxiYWNrIDogJyc7XG4gICAgICAgIG9wdHMuZmlsZUV4dGVuc2lvbiA9IEZJTEVfVFlQRVNbb3B0cy5maWxlRXh0ZW5zaW9uXSA/IG9wdHMuZmlsZUV4dGVuc2lvbiA6ICcnO1xuXG4gICAgICAgIHVybCA9XG4gICAgICAgICAgICBvcHRzLnByb3RvY29sICtcbiAgICAgICAgICAgIFVSTF9CQVNFICtcbiAgICAgICAgICAgIHRoaXMuYmltZDUubWQ1KG9wdHMuZW1haWwpICtcbiAgICAgICAgICAgIChvcHRzLmZpbGVFeHRlbnNpb24gPyAnLicgKyBvcHRzLmZpbGVFeHRlbnNpb24gOiAnJykgK1xuICAgICAgICAgICAgKG9wdHMuc2l6ZSB8fCBvcHRzLnJhdGluZyB8fCBvcHRzLmZhbGxiYWNrID8gJz8nIDogJycpICtcbiAgICAgICAgICAgIChvcHRzLnNpemUgPyAnJnM9JyArIG9wdHMuc2l6ZS50b1N0cmluZygpIDogJycpICtcbiAgICAgICAgICAgIChvcHRzLnJhdGluZyA/ICcmcj0nICsgb3B0cy5yYXRpbmcgOiAnJykgK1xuICAgICAgICAgICAgKG9wdHMuZmFsbGJhY2sgPyAnJmQ9JyArIG9wdHMuZmFsbGJhY2sgOiAnJylcbiAgICAgICAgICAgIDtcblxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAjRGVzY3JpcHRpb246XG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgKiBHZW5lcmF0ZSByYW5kb20gY29sb3IgdmFsdWUgYmFzZSBvbiBjb2xvciB0eXBlOlxuICAgICAqIC0+IGhleFxuICAgICAqIC0+IHJnYlxuICAgICAqIC0+IHJnYmFcbiAgICAgKiAtPiAweFxuICAgICAqIC0+IG5hbWVkIGNvbG9yXG4gICAgICpcbiAgICAgKiAjRXhhbXBsZXM6XG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgKiAqIEdlZXJhdGUgcmFuZG9tIGhleCBjb2xvclxuICAgICAqIGNoYW5jZS5jb2xvcigpID0+ICcjNzljMTU3JyAvICdyZ2IoMTEwLDUyLDE2NCknIC8gJzB4NjdhZTBiJyAvICcjZTJlMmUyJyAvICcjMjlDRkE3J1xuICAgICAqXG4gICAgICogKiBHZW5lcmF0ZSBIZXggYmFzZWQgY29sb3IgdmFsdWVcbiAgICAgKiBjaGFuY2UuY29sb3Ioe2Zvcm1hdDogJ2hleCd9KSAgICA9PiAnI2Q2NzExOCdcbiAgICAgKlxuICAgICAqICogR2VuZXJhdGUgc2ltcGxlIHJnYiB2YWx1ZVxuICAgICAqIGNoYW5jZS5jb2xvcih7Zm9ybWF0OiAncmdiJ30pICAgID0+ICdyZ2IoMTEwLDUyLDE2NCknXG4gICAgICpcbiAgICAgKiAqIEdlbmVyYXRlIE94IGJhc2VkIGNvbG9yIHZhbHVlXG4gICAgICogY2hhbmNlLmNvbG9yKHtmb3JtYXQ6ICcweCd9KSAgICAgPT4gJzB4NjdhZTBiJ1xuICAgICAqXG4gICAgICogKiBHZW5lcmF0ZSBncmFpc2NhbGUgYmFzZWQgdmFsdWVcbiAgICAgKiBjaGFuY2UuY29sb3Ioe2dyYXlzY2FsZTogdHJ1ZX0pICA9PiAnI2UyZTJlMidcbiAgICAgKlxuICAgICAqICogUmV0dXJuIHZhbGlkZSBjb2xvciBuYW1lXG4gICAgICogY2hhbmNlLmNvbG9yKHtmb3JtYXQ6ICduYW1lJ30pICAgPT4gJ3JlZCdcbiAgICAgKlxuICAgICAqICogTWFrZSBjb2xvciB1cHBlcmNhc2VcbiAgICAgKiBjaGFuY2UuY29sb3Ioe2Nhc2luZzogJ3VwcGVyJ30pICA9PiAnIzI5Q0ZBNydcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgW29iamVjdF0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gW3N0cmluZ10gY29sb3IgdmFsdWVcbiAgICAgKi9cbiAgICBDaGFuY2UucHJvdG90eXBlLmNvbG9yID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgICAgICBmdW5jdGlvbiBncmF5KHZhbHVlLCBkZWxpbWl0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBbdmFsdWUsIHZhbHVlLCB2YWx1ZV0uam9pbihkZWxpbWl0ZXIgfHwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmdiKGhhc0FscGhhKSB7XG5cbiAgICAgICAgICAgIHZhciByZ2JWYWx1ZSAgICA9IChoYXNBbHBoYSkgICAgPyAncmdiYScgOiAncmdiJztcbiAgICAgICAgICAgIHZhciBhbHBoYUNoYW5hbCA9IChoYXNBbHBoYSkgICAgPyAoJywnICsgdGhpcy5mbG9hdGluZyh7bWluOjAsIG1heDoxfSkpIDogXCJcIjtcbiAgICAgICAgICAgIHZhciBjb2xvclZhbHVlICA9IChpc0dyYXlzY2FsZSkgPyAoZ3JheSh0aGlzLm5hdHVyYWwoe21heDogMjU1fSksICcsJykpIDogKHRoaXMubmF0dXJhbCh7bWF4OiAyNTV9KSArICcsJyArIHRoaXMubmF0dXJhbCh7bWF4OiAyNTV9KSArICcsJyArIHRoaXMubmF0dXJhbCh7bWF4OiAyNTV9KSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZ2JWYWx1ZSArICcoJyArIGNvbG9yVmFsdWUgKyBhbHBoYUNoYW5hbCArICcpJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhleChzdGFydCwgZW5kLCB3aXRoSGFzaCkge1xuXG4gICAgICAgICAgICB2YXIgc2ltYm9sID0gKHdpdGhIYXNoKSA/IFwiI1wiIDogXCJcIjtcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uICA9IChpc0dyYXlzY2FsZSA/IGdyYXkodGhpcy5oYXNoKHtsZW5ndGg6IHN0YXJ0fSkpIDogdGhpcy5oYXNoKHtsZW5ndGg6IGVuZH0pKTtcbiAgICAgICAgICAgIHJldHVybiBzaW1ib2wgKyBleHByZXNzaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5waWNrKFsnaGV4JywgJ3Nob3J0aGV4JywgJ3JnYicsICdyZ2JhJywgJzB4JywgJ25hbWUnXSksXG4gICAgICAgICAgICBncmF5c2NhbGU6IGZhbHNlLFxuICAgICAgICAgICAgY2FzaW5nOiAnbG93ZXInXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBpc0dyYXlzY2FsZSA9IG9wdGlvbnMuZ3JheXNjYWxlO1xuICAgICAgICB2YXIgY29sb3JWYWx1ZTtcblxuICAgICAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdoZXgnKSB7XG4gICAgICAgICAgICBjb2xvclZhbHVlID0gIGhleC5jYWxsKHRoaXMsIDIsIDYsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSAnc2hvcnRoZXgnKSB7XG4gICAgICAgICAgICBjb2xvclZhbHVlID0gaGV4LmNhbGwodGhpcywgMSwgMywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdyZ2InKSB7XG4gICAgICAgICAgICBjb2xvclZhbHVlID0gcmdiLmNhbGwodGhpcywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSAncmdiYScpIHtcbiAgICAgICAgICAgIGNvbG9yVmFsdWUgPSByZ2IuY2FsbCh0aGlzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmZvcm1hdCA9PT0gJzB4Jykge1xuICAgICAgICAgICAgY29sb3JWYWx1ZSA9ICcweCcgKyBoZXguY2FsbCh0aGlzLCAyLCA2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKG9wdGlvbnMuZm9ybWF0ID09PSAnbmFtZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBpY2sodGhpcy5nZXQoXCJjb2xvck5hbWVzXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGZvcm1hdCBwcm92aWRlZC4gUGxlYXNlIHByb3ZpZGUgb25lIG9mIFwiaGV4XCIsIFwic2hvcnRoZXhcIiwgXCJyZ2JcIiwgXCJyZ2JhXCIsIFwiMHhcIiBvciBcIm5hbWVcIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmNhc2luZyA9PT0gJ3VwcGVyJyApIHtcbiAgICAgICAgICAgIGNvbG9yVmFsdWUgPSBjb2xvclZhbHVlLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sb3JWYWx1ZTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5kb21haW4gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLndvcmQoKSArICcuJyArIChvcHRpb25zLnRsZCB8fCB0aGlzLnRsZCgpKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5lbWFpbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud29yZCh7bGVuZ3RoOiBvcHRpb25zLmxlbmd0aH0pICsgJ0AnICsgKG9wdGlvbnMuZG9tYWluIHx8IHRoaXMuZG9tYWluKCkpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmZiaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCgnMTAwMDAnICsgdGhpcy5uYXR1cmFsKHttYXg6IDEwMDAwMDAwMDAwMH0pLCAxMCk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuZ29vZ2xlX2FuYWx5dGljcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFjY291bnQgPSB0aGlzLnBhZCh0aGlzLm5hdHVyYWwoe21heDogOTk5OTk5fSksIDYpO1xuICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnBhZCh0aGlzLm5hdHVyYWwoe21heDogOTl9KSwgMik7XG5cbiAgICAgICAgcmV0dXJuICdVQS0nICsgYWNjb3VudCArICctJyArIHByb3BlcnR5O1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmhhc2h0YWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnIycgKyB0aGlzLndvcmQoKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5pcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVG9kbzogVGhpcyBjb3VsZCByZXR1cm4gc29tZSByZXNlcnZlZCBJUHMuIFNlZSBodHRwOi8vdnEuaW8vMTM3ZGdZeVxuICAgICAgICAvLyB0aGlzIHNob3VsZCBwcm9iYWJseSBiZSB1cGRhdGVkIHRvIGFjY291bnQgZm9yIHRoYXQgcmFyZSBhcyBpdCBtYXkgYmVcbiAgICAgICAgcmV0dXJuIHRoaXMubmF0dXJhbCh7bWluOiAxLCBtYXg6IDI1NH0pICsgJy4nICtcbiAgICAgICAgICAgICAgIHRoaXMubmF0dXJhbCh7bWF4OiAyNTV9KSArICcuJyArXG4gICAgICAgICAgICAgICB0aGlzLm5hdHVyYWwoe21heDogMjU1fSkgKyAnLicgK1xuICAgICAgICAgICAgICAgdGhpcy5uYXR1cmFsKHttaW46IDEsIG1heDogMjU0fSk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuaXB2NiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlwX2FkZHIgPSB0aGlzLm4odGhpcy5oYXNoLCA4LCB7bGVuZ3RoOiA0fSk7XG5cbiAgICAgICAgcmV0dXJuIGlwX2FkZHIuam9pbihcIjpcIik7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUua2xvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdHVyYWwoe21pbjogMSwgbWF4OiA5OX0pO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnNlbXZlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7IGluY2x1ZGVfcHJlcmVsZWFzZTogdHJ1ZSB9KTtcblxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnBpY2tvbmUoW1wiXlwiLCBcIn5cIiwgXCI8XCIsIFwiPlwiLCBcIjw9XCIsIFwiPj1cIiwgXCI9XCJdKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmFuZ2UpIHtcbiAgICAgICAgICAgIHJhbmdlID0gb3B0aW9ucy5yYW5nZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmVyZWxlYXNlID0gXCJcIjtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZV9wcmVyZWxlYXNlKSB7XG4gICAgICAgICAgICBwcmVyZWxlYXNlID0gdGhpcy53ZWlnaHRlZChbXCJcIiwgXCItZGV2XCIsIFwiLWJldGFcIiwgXCItYWxwaGFcIl0sIFs1MCwgMTAsIDUsIDFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2UgKyB0aGlzLnJwZygnM2QxMCcpLmpvaW4oJy4nKSArIHByZXJlbGVhc2U7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUudGxkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFsnY29tJywgJ29yZycsICdlZHUnLCAnZ292JywgJ2NvLnVrJywgJ25ldCcsICdpbycsICdhYycsICdhZCcsICdhZScsICdhZicsICdhZycsICdhaScsICdhbCcsICdhbScsICdhbicsICdhbycsICdhcScsICdhcicsICdhcycsICdhdCcsICdhdScsICdhdycsICdheCcsICdheicsICdiYScsICdiYicsICdiZCcsICdiZScsICdiZicsICdiZycsICdiaCcsICdiaScsICdiaicsICdibScsICdibicsICdibycsICdicScsICdicicsICdicycsICdidCcsICdidicsICdidycsICdieScsICdieicsICdjYScsICdjYycsICdjZCcsICdjZicsICdjZycsICdjaCcsICdjaScsICdjaycsICdjbCcsICdjbScsICdjbicsICdjbycsICdjcicsICdjdScsICdjdicsICdjdycsICdjeCcsICdjeScsICdjeicsICdkZScsICdkaicsICdkaycsICdkbScsICdkbycsICdkeicsICdlYycsICdlZScsICdlZycsICdlaCcsICdlcicsICdlcycsICdldCcsICdldScsICdmaScsICdmaicsICdmaycsICdmbScsICdmbycsICdmcicsICdnYScsICdnYicsICdnZCcsICdnZScsICdnZicsICdnZycsICdnaCcsICdnaScsICdnbCcsICdnbScsICdnbicsICdncCcsICdncScsICdncicsICdncycsICdndCcsICdndScsICdndycsICdneScsICdoaycsICdobScsICdobicsICdocicsICdodCcsICdodScsICdpZCcsICdpZScsICdpbCcsICdpbScsICdpbicsICdpbycsICdpcScsICdpcicsICdpcycsICdpdCcsICdqZScsICdqbScsICdqbycsICdqcCcsICdrZScsICdrZycsICdraCcsICdraScsICdrbScsICdrbicsICdrcCcsICdrcicsICdrdycsICdreScsICdreicsICdsYScsICdsYicsICdsYycsICdsaScsICdsaycsICdscicsICdscycsICdsdCcsICdsdScsICdsdicsICdseScsICdtYScsICdtYycsICdtZCcsICdtZScsICdtZycsICdtaCcsICdtaycsICdtbCcsICdtbScsICdtbicsICdtbycsICdtcCcsICdtcScsICdtcicsICdtcycsICdtdCcsICdtdScsICdtdicsICdtdycsICdteCcsICdteScsICdteicsICduYScsICduYycsICduZScsICduZicsICduZycsICduaScsICdubCcsICdubycsICducCcsICducicsICdudScsICdueicsICdvbScsICdwYScsICdwZScsICdwZicsICdwZycsICdwaCcsICdwaycsICdwbCcsICdwbScsICdwbicsICdwcicsICdwcycsICdwdCcsICdwdycsICdweScsICdxYScsICdyZScsICdybycsICdycycsICdydScsICdydycsICdzYScsICdzYicsICdzYycsICdzZCcsICdzZScsICdzZycsICdzaCcsICdzaScsICdzaicsICdzaycsICdzbCcsICdzbScsICdzbicsICdzbycsICdzcicsICdzcycsICdzdCcsICdzdScsICdzdicsICdzeCcsICdzeScsICdzeicsICd0YycsICd0ZCcsICd0ZicsICd0ZycsICd0aCcsICd0aicsICd0aycsICd0bCcsICd0bScsICd0bicsICd0bycsICd0cCcsICd0cicsICd0dCcsICd0dicsICd0dycsICd0eicsICd1YScsICd1ZycsICd1aycsICd1cycsICd1eScsICd1eicsICd2YScsICd2YycsICd2ZScsICd2ZycsICd2aScsICd2bicsICd2dScsICd3ZicsICd3cycsICd5ZScsICd5dCcsICd6YScsICd6bScsICd6dyddO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnRsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGljayh0aGlzLnRsZHMoKSk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUudHdpdHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdAJyArIHRoaXMud29yZCgpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnVybCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7IHByb3RvY29sOiBcImh0dHBcIiwgZG9tYWluOiB0aGlzLmRvbWFpbihvcHRpb25zKSwgZG9tYWluX3ByZWZpeDogXCJcIiwgcGF0aDogdGhpcy53b3JkKCksIGV4dGVuc2lvbnM6IFtdfSk7XG5cbiAgICAgICAgdmFyIGV4dGVuc2lvbiA9IG9wdGlvbnMuZXh0ZW5zaW9ucy5sZW5ndGggPiAwID8gXCIuXCIgKyB0aGlzLnBpY2sob3B0aW9ucy5leHRlbnNpb25zKSA6IFwiXCI7XG4gICAgICAgIHZhciBkb21haW4gPSBvcHRpb25zLmRvbWFpbl9wcmVmaXggPyBvcHRpb25zLmRvbWFpbl9wcmVmaXggKyBcIi5cIiArIG9wdGlvbnMuZG9tYWluIDogb3B0aW9ucy5kb21haW47XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucHJvdG9jb2wgKyBcIjovL1wiICsgZG9tYWluICsgXCIvXCIgKyBvcHRpb25zLnBhdGggKyBleHRlbnNpb247XG4gICAgfTtcblxuICAgIC8vIC0tIEVuZCBXZWIgLS1cblxuICAgIC8vIC0tIExvY2F0aW9uIC0tXG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmFkZHJlc3MgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdHVyYWwoe21pbjogNSwgbWF4OiAyMDAwfSkgKyAnICcgKyB0aGlzLnN0cmVldChvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5hbHRpdHVkZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7Zml4ZWQ6IDUsIG1pbjogMCwgbWF4OiA4ODQ4fSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb2F0aW5nKHtcbiAgICAgICAgICAgIG1pbjogb3B0aW9ucy5taW4sXG4gICAgICAgICAgICBtYXg6IG9wdGlvbnMubWF4LFxuICAgICAgICAgICAgZml4ZWQ6IG9wdGlvbnMuZml4ZWRcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuYXJlYWNvZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywge3BhcmVucyA6IHRydWV9KTtcbiAgICAgICAgLy8gRG9uJ3Qgd2FudCBhcmVhIGNvZGVzIHRvIHN0YXJ0IHdpdGggMSwgb3IgaGF2ZSBhIDkgYXMgdGhlIHNlY29uZCBkaWdpdFxuICAgICAgICB2YXIgYXJlYWNvZGUgPSB0aGlzLm5hdHVyYWwoe21pbjogMiwgbWF4OiA5fSkudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgdGhpcy5uYXR1cmFsKHttaW46IDAsIG1heDogOH0pLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgIHRoaXMubmF0dXJhbCh7bWluOiAwLCBtYXg6IDl9KS50b1N0cmluZygpO1xuXG4gICAgICAgIHJldHVybiBvcHRpb25zLnBhcmVucyA/ICcoJyArIGFyZWFjb2RlICsgJyknIDogYXJlYWNvZGU7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuY2l0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FwaXRhbGl6ZSh0aGlzLndvcmQoe3N5bGxhYmxlczogM30pKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5jb29yZGluYXRlcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhdGl0dWRlKG9wdGlvbnMpICsgJywgJyArIHRoaXMubG9uZ2l0dWRlKG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmNvdW50cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFwiY291bnRyaWVzXCIpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmNvdW50cnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHZhciBjb3VudHJ5ID0gdGhpcy5waWNrKHRoaXMuY291bnRyaWVzKCkpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5mdWxsID8gY291bnRyeS5uYW1lIDogY291bnRyeS5hYmJyZXZpYXRpb247XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuZGVwdGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywge2ZpeGVkOiA1LCBtaW46IC0xMDk5NCwgbWF4OiAwfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb2F0aW5nKHtcbiAgICAgICAgICAgIG1pbjogb3B0aW9ucy5taW4sXG4gICAgICAgICAgICBtYXg6IG9wdGlvbnMubWF4LFxuICAgICAgICAgICAgZml4ZWQ6IG9wdGlvbnMuZml4ZWRcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuZ2VvaGFzaCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7IGxlbmd0aDogNyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nKHsgbGVuZ3RoOiBvcHRpb25zLmxlbmd0aCwgcG9vbDogJzAxMjM0NTY3ODliY2RlZmdoamttbnBxcnN0dXZ3eHl6JyB9KTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5nZW9qc29uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF0aXR1ZGUob3B0aW9ucykgKyAnLCAnICsgdGhpcy5sb25naXR1ZGUob3B0aW9ucykgKyAnLCAnICsgdGhpcy5hbHRpdHVkZShvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5sYXRpdHVkZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7Zml4ZWQ6IDUsIG1pbjogLTkwLCBtYXg6IDkwfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb2F0aW5nKHttaW46IG9wdGlvbnMubWluLCBtYXg6IG9wdGlvbnMubWF4LCBmaXhlZDogb3B0aW9ucy5maXhlZH0pO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmxvbmdpdHVkZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7Zml4ZWQ6IDUsIG1pbjogLTE4MCwgbWF4OiAxODB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvYXRpbmcoe21pbjogb3B0aW9ucy5taW4sIG1heDogb3B0aW9ucy5tYXgsIGZpeGVkOiBvcHRpb25zLmZpeGVkfSk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUucGhvbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBudW1QaWNrLFxuICAgICAgICAgICAgdWtOdW0gPSBmdW5jdGlvbiAocGFydHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VjdGlvbiA9IFtdO1xuICAgICAgICAgICAgICAgIC8vZmlsbHMgdGhlIHNlY3Rpb24gcGFydCBvZiB0aGUgcGhvbmUgbnVtYmVyIHdpdGggcmFuZG9tIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgcGFydHMuc2VjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb24ucHVzaChzZWxmLnN0cmluZyh7IHBvb2w6ICcwMTIzNDU2Nzg5JywgbGVuZ3RoOiBufSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0cy5hcmVhICsgc2VjdGlvbi5qb2luKCcgJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywge1xuICAgICAgICAgICAgZm9ybWF0dGVkOiB0cnVlLFxuICAgICAgICAgICAgY291bnRyeTogJ3VzJyxcbiAgICAgICAgICAgIG1vYmlsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5mb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucGFyZW5zID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBob25lO1xuICAgICAgICBzd2l0Y2ggKG9wdGlvbnMuY291bnRyeSkge1xuICAgICAgICAgICAgY2FzZSAnZnInOlxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5tb2JpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtUGljayA9IHRoaXMucGljayhbXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBWYWxpZCB6b25lIGFuZCBkw6lwYXJ0ZW1lbnQgY29kZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAnMDEnICsgdGhpcy5waWNrKFsnMzAnLCAnMzQnLCAnMzknLCAnNDAnLCAnNDEnLCAnNDInLCAnNDMnLCAnNDQnLCAnNDUnLCAnNDYnLCAnNDcnLCAnNDgnLCAnNDknLCAnNTMnLCAnNTUnLCAnNTYnLCAnNTgnLCAnNjAnLCAnNjQnLCAnNjknLCAnNzAnLCAnNzInLCAnNzMnLCAnNzQnLCAnNzUnLCAnNzYnLCAnNzcnLCAnNzgnLCAnNzknLCAnODAnLCAnODEnLCAnODInLCAnODMnXSkgKyBzZWxmLnN0cmluZyh7IHBvb2w6ICcwMTIzNDU2Nzg5JywgbGVuZ3RoOiA2fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnMDInICsgdGhpcy5waWNrKFsnMTQnLCAnMTgnLCAnMjInLCAnMjMnLCAnMjgnLCAnMjknLCAnMzAnLCAnMzEnLCAnMzInLCAnMzMnLCAnMzQnLCAnMzUnLCAnMzYnLCAnMzcnLCAnMzgnLCAnNDAnLCAnNDEnLCAnNDMnLCAnNDQnLCAnNDUnLCAnNDYnLCAnNDcnLCAnNDgnLCAnNDknLCAnNTAnLCAnNTEnLCAnNTInLCAnNTMnLCAnNTQnLCAnNTYnLCAnNTcnLCAnNjEnLCAnNjInLCAnNjknLCAnNzInLCAnNzYnLCAnNzcnLCAnNzgnLCAnODUnLCAnOTAnLCAnOTYnLCAnOTcnLCAnOTgnLCAnOTknXSkgKyBzZWxmLnN0cmluZyh7IHBvb2w6ICcwMTIzNDU2Nzg5JywgbGVuZ3RoOiA2fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnMDMnICsgdGhpcy5waWNrKFsnMTAnLCAnMjAnLCAnMjEnLCAnMjInLCAnMjMnLCAnMjQnLCAnMjUnLCAnMjYnLCAnMjcnLCAnMjgnLCAnMjknLCAnMzknLCAnNDQnLCAnNDUnLCAnNTEnLCAnNTInLCAnNTQnLCAnNTUnLCAnNTcnLCAnNTgnLCAnNTknLCAnNjAnLCAnNjEnLCAnNjInLCAnNjMnLCAnNjQnLCAnNjUnLCAnNjYnLCAnNjcnLCAnNjgnLCAnNjknLCAnNzAnLCAnNzEnLCAnNzInLCAnNzMnLCAnODAnLCAnODEnLCAnODInLCAnODMnLCAnODQnLCAnODUnLCAnODYnLCAnODcnLCAnODgnLCAnODknLCAnOTAnXSkgKyBzZWxmLnN0cmluZyh7IHBvb2w6ICcwMTIzNDU2Nzg5JywgbGVuZ3RoOiA2fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnMDQnICsgdGhpcy5waWNrKFsnMTEnLCAnMTMnLCAnMTUnLCAnMjAnLCAnMjInLCAnMjYnLCAnMjcnLCAnMzAnLCAnMzInLCAnMzQnLCAnMzcnLCAnNDInLCAnNDMnLCAnNDQnLCAnNTAnLCAnNTYnLCAnNTcnLCAnNjMnLCAnNjYnLCAnNjcnLCAnNjgnLCAnNjknLCAnNzAnLCAnNzEnLCAnNzInLCAnNzMnLCAnNzQnLCAnNzUnLCAnNzYnLCAnNzcnLCAnNzgnLCAnNzknLCAnODAnLCAnODEnLCAnODInLCAnODMnLCAnODQnLCAnODUnLCAnODYnLCAnODgnLCAnODknLCAnOTAnLCAnOTEnLCAnOTInLCAnOTMnLCAnOTQnLCAnOTUnLCAnOTcnLCAnOTgnXSkgKyBzZWxmLnN0cmluZyh7IHBvb2w6ICcwMTIzNDU2Nzg5JywgbGVuZ3RoOiA2fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnMDUnICsgdGhpcy5waWNrKFsnMDgnLCAnMTYnLCAnMTcnLCAnMTknLCAnMjQnLCAnMzEnLCAnMzInLCAnMzMnLCAnMzQnLCAnMzUnLCAnNDAnLCAnNDUnLCAnNDYnLCAnNDcnLCAnNDknLCAnNTMnLCAnNTUnLCAnNTYnLCAnNTcnLCAnNTgnLCAnNTknLCAnNjEnLCAnNjInLCAnNjMnLCAnNjQnLCAnNjUnLCAnNjcnLCAnNzknLCAnODEnLCAnODInLCAnODYnLCAnODcnLCAnOTAnLCAnOTQnXSkgKyBzZWxmLnN0cmluZyh7IHBvb2w6ICcwMTIzNDU2Nzg5JywgbGVuZ3RoOiA2fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnMDknICsgc2VsZi5zdHJpbmcoeyBwb29sOiAnMDEyMzQ1Njc4OScsIGxlbmd0aDogOH0pLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgcGhvbmUgPSBvcHRpb25zLmZvcm1hdHRlZCA/IG51bVBpY2subWF0Y2goLy4uL2cpLmpvaW4oJyAnKSA6IG51bVBpY2s7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtUGljayA9IHRoaXMucGljayhbJzA2JywgJzA3J10pICsgc2VsZi5zdHJpbmcoeyBwb29sOiAnMDEyMzQ1Njc4OScsIGxlbmd0aDogOH0pO1xuICAgICAgICAgICAgICAgICAgICBwaG9uZSA9IG9wdGlvbnMuZm9ybWF0dGVkID8gbnVtUGljay5tYXRjaCgvLi4vZykuam9pbignICcpIDogbnVtUGljaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd1ayc6XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLm1vYmlsZSkge1xuICAgICAgICAgICAgICAgICAgICBudW1QaWNrID0gdGhpcy5waWNrKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFsaWQgYXJlYSBjb2RlcyBvZiBtYWpvciBjaXRpZXMvY291bnRpZXMgZm9sbG93ZWQgYnkgcmFuZG9tIG51bWJlcnMgaW4gcmVxdWlyZWQgZm9ybWF0LlxuICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmVhOiAnMDEnICsgdGhpcy5jaGFyYWN0ZXIoeyBwb29sOiAnMjM0NTY5JyB9KSArICcxICcsIHNlY3Rpb25zOiBbMyw0XSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmVhOiAnMDIwICcgKyB0aGlzLmNoYXJhY3Rlcih7IHBvb2w6ICczNzgnIH0pLCBzZWN0aW9uczogWzMsNF0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJlYTogJzAyMyAnICsgdGhpcy5jaGFyYWN0ZXIoeyBwb29sOiAnODknIH0pLCBzZWN0aW9uczogWzMsNF0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJlYTogJzAyNCA3Jywgc2VjdGlvbnM6IFszLDRdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGFyZWE6ICcwMjggJyArIHRoaXMucGljayhbJzI1JywnMjgnLCczNycsJzcxJywnODInLCc5MCcsJzkyJywnOTUnXSksIHNlY3Rpb25zOiBbMiw0XSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmVhOiAnMDEyJyArIHRoaXMucGljayhbJzA0JywnMDgnLCc1NCcsJzc2JywnOTcnLCc5OCddKSArICcgJywgc2VjdGlvbnM6IFs2XSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmVhOiAnMDEzJyArIHRoaXMucGljayhbJzYzJywnNjQnLCc4NCcsJzg2J10pICsgJyAnLCBzZWN0aW9uczogWzZdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGFyZWE6ICcwMTQnICsgdGhpcy5waWNrKFsnMDQnLCcyMCcsJzYwJywnNjEnLCc4MCcsJzg4J10pICsgJyAnLCBzZWN0aW9uczogWzZdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGFyZWE6ICcwMTUnICsgdGhpcy5waWNrKFsnMjQnLCcyNycsJzYyJywnNjYnXSkgKyAnICcsIHNlY3Rpb25zOiBbNl0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJlYTogJzAxNicgKyB0aGlzLnBpY2soWycwNicsJzI5JywnMzUnLCc0NycsJzU5JywnOTUnXSkgKyAnICcsIHNlY3Rpb25zOiBbNl0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJlYTogJzAxNycgKyB0aGlzLnBpY2soWycyNicsJzQ0JywnNTAnLCc2OCddKSArICcgJywgc2VjdGlvbnM6IFs2XSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmVhOiAnMDE4JyArIHRoaXMucGljayhbJzI3JywnMzcnLCc4NCcsJzk3J10pICsgJyAnLCBzZWN0aW9uczogWzZdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGFyZWE6ICcwMTknICsgdGhpcy5waWNrKFsnMDAnLCcwNScsJzM1JywnNDYnLCc0OScsJzYzJywnOTUnXSkgKyAnICcsIHNlY3Rpb25zOiBbNl0gfVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgcGhvbmUgPSBvcHRpb25zLmZvcm1hdHRlZCA/IHVrTnVtKG51bVBpY2spIDogdWtOdW0obnVtUGljaykucmVwbGFjZSgnICcsICcnLCAnZycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG51bVBpY2sgPSB0aGlzLnBpY2soW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmVhOiAnMDcnICsgdGhpcy5waWNrKFsnNCcsJzUnLCc3JywnOCcsJzknXSksIHNlY3Rpb25zOiBbMiw2XSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmVhOiAnMDc2MjQgJywgc2VjdGlvbnM6IFs2XSB9XG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBwaG9uZSA9IG9wdGlvbnMuZm9ybWF0dGVkID8gdWtOdW0obnVtUGljaykgOiB1a051bShudW1QaWNrKS5yZXBsYWNlKCcgJywgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VzJzpcbiAgICAgICAgICAgICAgICB2YXIgYXJlYWNvZGUgPSB0aGlzLmFyZWFjb2RlKG9wdGlvbnMpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgdmFyIGV4Y2hhbmdlID0gdGhpcy5uYXR1cmFsKHsgbWluOiAyLCBtYXg6IDkgfSkudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmF0dXJhbCh7IG1pbjogMCwgbWF4OiA5IH0pLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdHVyYWwoeyBtaW46IDAsIG1heDogOSB9KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHZhciBzdWJzY3JpYmVyID0gdGhpcy5uYXR1cmFsKHsgbWluOiAxMDAwLCBtYXg6IDk5OTkgfSkudG9TdHJpbmcoKTsgLy8gdGhpcyBjb3VsZCBiZSByYW5kb20gWzAtOV17NH1cbiAgICAgICAgICAgICAgICBwaG9uZSA9IG9wdGlvbnMuZm9ybWF0dGVkID8gYXJlYWNvZGUgKyAnICcgKyBleGNoYW5nZSArICctJyArIHN1YnNjcmliZXIgOiBhcmVhY29kZSArIGV4Y2hhbmdlICsgc3Vic2NyaWJlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGhvbmU7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUucG9zdGFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQb3N0YWwgRGlzdHJpY3RcbiAgICAgICAgdmFyIHBkID0gdGhpcy5jaGFyYWN0ZXIoe3Bvb2w6IFwiWFZUU1JQTktMTUhKR0VDQkFcIn0pO1xuICAgICAgICAvLyBGb3J3YXJkIFNvcnRhdGlvbiBBcmVhIChGU0EpXG4gICAgICAgIHZhciBmc2EgPSBwZCArIHRoaXMubmF0dXJhbCh7bWF4OiA5fSkgKyB0aGlzLmNoYXJhY3Rlcih7YWxwaGE6IHRydWUsIGNhc2luZzogXCJ1cHBlclwifSk7XG4gICAgICAgIC8vIExvY2FsIERlbGl2ZXJ5IFVudXQgKExEVSlcbiAgICAgICAgdmFyIGxkdSA9IHRoaXMubmF0dXJhbCh7bWF4OiA5fSkgKyB0aGlzLmNoYXJhY3Rlcih7YWxwaGE6IHRydWUsIGNhc2luZzogXCJ1cHBlclwifSkgKyB0aGlzLm5hdHVyYWwoe21heDogOX0pO1xuXG4gICAgICAgIHJldHVybiBmc2EgKyBcIiBcIiArIGxkdTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5jb3VudGllcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7IGNvdW50cnk6ICd1aycgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChcImNvdW50aWVzXCIpW29wdGlvbnMuY291bnRyeS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5jb3VudHkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrKHRoaXMuY291bnRpZXMob3B0aW9ucykpLm5hbWU7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUucHJvdmluY2VzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHsgY291bnRyeTogJ2NhJyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFwicHJvdmluY2VzXCIpW29wdGlvbnMuY291bnRyeS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5wcm92aW5jZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucyAmJiBvcHRpb25zLmZ1bGwpID9cbiAgICAgICAgICAgIHRoaXMucGljayh0aGlzLnByb3ZpbmNlcyhvcHRpb25zKSkubmFtZSA6XG4gICAgICAgICAgICB0aGlzLnBpY2sodGhpcy5wcm92aW5jZXMob3B0aW9ucykpLmFiYnJldmlhdGlvbjtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5zdGF0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucyAmJiBvcHRpb25zLmZ1bGwpID9cbiAgICAgICAgICAgIHRoaXMucGljayh0aGlzLnN0YXRlcyhvcHRpb25zKSkubmFtZSA6XG4gICAgICAgICAgICB0aGlzLnBpY2sodGhpcy5zdGF0ZXMob3B0aW9ucykpLmFiYnJldmlhdGlvbjtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5zdGF0ZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywgeyBjb3VudHJ5OiAndXMnLCB1c19zdGF0ZXNfYW5kX2RjOiB0cnVlIH0gKTtcblxuICAgICAgICB2YXIgc3RhdGVzO1xuXG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy5jb3VudHJ5LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3VzJzpcbiAgICAgICAgICAgICAgICB2YXIgdXNfc3RhdGVzX2FuZF9kYyA9IHRoaXMuZ2V0KFwidXNfc3RhdGVzX2FuZF9kY1wiKSxcbiAgICAgICAgICAgICAgICAgICAgdGVycml0b3JpZXMgPSB0aGlzLmdldChcInRlcnJpdG9yaWVzXCIpLFxuICAgICAgICAgICAgICAgICAgICBhcm1lZF9mb3JjZXMgPSB0aGlzLmdldChcImFybWVkX2ZvcmNlc1wiKTtcblxuICAgICAgICAgICAgICAgIHN0YXRlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudXNfc3RhdGVzX2FuZF9kYykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZXMgPSBzdGF0ZXMuY29uY2F0KHVzX3N0YXRlc19hbmRfZGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50ZXJyaXRvcmllcykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZXMgPSBzdGF0ZXMuY29uY2F0KHRlcnJpdG9yaWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJtZWRfZm9yY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlcyA9IHN0YXRlcy5jb25jYXQoYXJtZWRfZm9yY2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpdCc6XG4gICAgICAgICAgICAgICAgc3RhdGVzID0gdGhpcy5nZXQoXCJjb3VudHJ5X3JlZ2lvbnNcIilbb3B0aW9ucy5jb3VudHJ5LnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndWsnOlxuICAgICAgICAgICAgICAgIHN0YXRlcyA9IHRoaXMuZ2V0KFwiY291bnRpZXNcIilbb3B0aW9ucy5jb3VudHJ5LnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlcztcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5zdHJlZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywgeyBjb3VudHJ5OiAndXMnLCBzeWxsYWJsZXM6IDIgfSk7XG4gICAgICAgIHZhciAgICAgc3RyZWV0O1xuXG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy5jb3VudHJ5LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3VzJzpcbiAgICAgICAgICAgICAgICBzdHJlZXQgPSB0aGlzLndvcmQoeyBzeWxsYWJsZXM6IG9wdGlvbnMuc3lsbGFibGVzIH0pO1xuICAgICAgICAgICAgICAgIHN0cmVldCA9IHRoaXMuY2FwaXRhbGl6ZShzdHJlZXQpO1xuICAgICAgICAgICAgICAgIHN0cmVldCArPSAnICc7XG4gICAgICAgICAgICAgICAgc3RyZWV0ICs9IG9wdGlvbnMuc2hvcnRfc3VmZml4ID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlZXRfc3VmZml4KG9wdGlvbnMpLmFiYnJldmlhdGlvbiA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWV0X3N1ZmZpeChvcHRpb25zKS5uYW1lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXQnOlxuICAgICAgICAgICAgICAgIHN0cmVldCA9IHRoaXMud29yZCh7IHN5bGxhYmxlczogb3B0aW9ucy5zeWxsYWJsZXMgfSk7XG4gICAgICAgICAgICAgICAgc3RyZWV0ID0gdGhpcy5jYXBpdGFsaXplKHN0cmVldCk7XG4gICAgICAgICAgICAgICAgc3RyZWV0ID0gKG9wdGlvbnMuc2hvcnRfc3VmZml4ID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlZXRfc3VmZml4KG9wdGlvbnMpLmFiYnJldmlhdGlvbiA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWV0X3N1ZmZpeChvcHRpb25zKS5uYW1lKSArIFwiIFwiICsgc3RyZWV0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlZXQ7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuc3RyZWV0X3N1ZmZpeCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7IGNvdW50cnk6ICd1cycgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBpY2sodGhpcy5zdHJlZXRfc3VmZml4ZXMob3B0aW9ucykpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnN0cmVldF9zdWZmaXhlcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7IGNvdW50cnk6ICd1cycgfSk7XG4gICAgICAgIC8vIFRoZXNlIGFyZSB0aGUgbW9zdCBjb21tb24gc3VmZml4ZXMuXG4gICAgICAgIHJldHVybiB0aGlzLmdldChcInN0cmVldF9zdWZmaXhlc1wiKVtvcHRpb25zLmNvdW50cnkudG9Mb3dlckNhc2UoKV07XG4gICAgfTtcblxuICAgIC8vIE5vdGU6IG9ubHkgcmV0dXJuaW5nIFVTIHppcCBjb2RlcywgaW50ZXJuYXRpb25hbGl6YXRpb24gd2lsbCBiZSBhIHdob2xlXG4gICAgLy8gb3RoZXIgYmVhc3QgdG8gdGFja2xlIGF0IHNvbWUgcG9pbnQuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS56aXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgemlwID0gdGhpcy5uKHRoaXMubmF0dXJhbCwgNSwge21heDogOX0pO1xuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGx1c2ZvdXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHppcC5wdXNoKCctJyk7XG4gICAgICAgICAgICB6aXAgPSB6aXAuY29uY2F0KHRoaXMubih0aGlzLm5hdHVyYWwsIDQsIHttYXg6IDl9KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gemlwLmpvaW4oXCJcIik7XG4gICAgfTtcblxuICAgIC8vIC0tIEVuZCBMb2NhdGlvbiAtLVxuXG4gICAgLy8gLS0gVGltZVxuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5hbXBtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib29sKCkgPyAnYW0nIDogJ3BtJztcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5kYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRhdGVfc3RyaW5nLCBkYXRlO1xuXG4gICAgICAgIC8vIElmIGludGVydmFsIGlzIHNwZWNpZmllZCB3ZSBpZ25vcmUgcHJlc2V0XG4gICAgICAgIGlmKG9wdGlvbnMgJiYgKG9wdGlvbnMubWluIHx8IG9wdGlvbnMubWF4KSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBhbWVyaWNhbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdHJpbmc6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBtaW4gPSB0eXBlb2Ygb3B0aW9ucy5taW4gIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLm1pbi5nZXRUaW1lKCkgOiAxO1xuICAgICAgICAgICAgLy8gMTAwLDAwMCwwMDAgZGF5cyBtZWFzdXJlZCByZWxhdGl2ZSB0byBtaWRuaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIDAxIEphbnVhcnksIDE5NzAgVVRDLiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjkuMS4xXG4gICAgICAgICAgICB2YXIgbWF4ID0gdHlwZW9mIG9wdGlvbnMubWF4ICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5tYXguZ2V0VGltZSgpIDogODY0MDAwMDAwMDAwMDAwMDtcblxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHRoaXMuaW50ZWdlcih7bWluOiBtaW4sIG1heDogbWF4fSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGlzLm1vbnRoKHtyYXc6IHRydWV9KTtcbiAgICAgICAgICAgIHZhciBkYXlzSW5Nb250aCA9IG0uZGF5cztcblxuICAgICAgICAgICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLm1vbnRoKSB7XG4gICAgICAgICAgICAgICAgLy8gTW9kIDEyIHRvIGFsbG93IG1vbnRocyBvdXRzaWRlIHJhbmdlIG9mIDAtMTEgKG5vdCBlbmNvdXJhZ2VkLCBidXQgYWxzbyBub3QgcHJldmVudGVkKS5cbiAgICAgICAgICAgICAgICBkYXlzSW5Nb250aCA9IHRoaXMuZ2V0KCdtb250aHMnKVsoKG9wdGlvbnMubW9udGggJSAxMikgKyAxMikgJSAxMl0uZGF5cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICB5ZWFyOiBwYXJzZUludCh0aGlzLnllYXIoKSwgMTApLFxuICAgICAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSB0byBzdWJ0cmFjdCAxIGJlY2F1c2UgRGF0ZSgpIDAtaW5kZXhlcyBtb250aCBidXQgbm90IGRheSBvciB5ZWFyXG4gICAgICAgICAgICAgICAgLy8gZm9yIHNvbWUgcmVhc29uLlxuICAgICAgICAgICAgICAgIG1vbnRoOiBtLm51bWVyaWMgLSAxLFxuICAgICAgICAgICAgICAgIGRheTogdGhpcy5uYXR1cmFsKHttaW46IDEsIG1heDogZGF5c0luTW9udGh9KSxcbiAgICAgICAgICAgICAgICBob3VyOiB0aGlzLmhvdXIoe3R3ZW50eWZvdXI6IHRydWV9KSxcbiAgICAgICAgICAgICAgICBtaW51dGU6IHRoaXMubWludXRlKCksXG4gICAgICAgICAgICAgICAgc2Vjb25kOiB0aGlzLnNlY29uZCgpLFxuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kOiB0aGlzLm1pbGxpc2Vjb25kKCksXG4gICAgICAgICAgICAgICAgYW1lcmljYW46IHRydWUsXG4gICAgICAgICAgICAgICAgc3RyaW5nOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShvcHRpb25zLnllYXIsIG9wdGlvbnMubW9udGgsIG9wdGlvbnMuZGF5LCBvcHRpb25zLmhvdXIsIG9wdGlvbnMubWludXRlLCBvcHRpb25zLnNlY29uZCwgb3B0aW9ucy5taWxsaXNlY29uZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hbWVyaWNhbikge1xuICAgICAgICAgICAgLy8gQWRkaW5nIDEgdG8gdGhlIG1vbnRoIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIERhdGUoKSAwLWluZGV4ZXNcbiAgICAgICAgICAgIC8vIG1vbnRocyBidXQgbm90IGRheSBmb3Igc29tZSBvZGQgcmVhc29uLlxuICAgICAgICAgICAgZGF0ZV9zdHJpbmcgPSAoZGF0ZS5nZXRNb250aCgpICsgMSkgKyAnLycgKyBkYXRlLmdldERhdGUoKSArICcvJyArIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGVfc3RyaW5nID0gZGF0ZS5nZXREYXRlKCkgKyAnLycgKyAoZGF0ZS5nZXRNb250aCgpICsgMSkgKyAnLycgKyBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0aW9ucy5zdHJpbmcgPyBkYXRlX3N0cmluZyA6IGRhdGU7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuaGFtbWVydGltZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUob3B0aW9ucykuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmhvdXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucywge1xuICAgICAgICAgICAgbWluOiBvcHRpb25zICYmIG9wdGlvbnMudHdlbnR5Zm91ciA/IDAgOiAxLFxuICAgICAgICAgICAgbWF4OiBvcHRpb25zICYmIG9wdGlvbnMudHdlbnR5Zm91ciA/IDIzIDogMTJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGVzdFJhbmdlKG9wdGlvbnMubWluIDwgMCwgXCJDaGFuY2U6IE1pbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAuXCIpO1xuICAgICAgICB0ZXN0UmFuZ2Uob3B0aW9ucy50d2VudHlmb3VyICYmIG9wdGlvbnMubWF4ID4gMjMsIFwiQ2hhbmNlOiBNYXggY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAyMyBmb3IgdHdlbnR5Zm91ciBvcHRpb24uXCIpO1xuICAgICAgICB0ZXN0UmFuZ2UoIW9wdGlvbnMudHdlbnR5Zm91ciAmJiBvcHRpb25zLm1heCA+IDEyLCBcIkNoYW5jZTogTWF4IGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gMTIuXCIpO1xuICAgICAgICB0ZXN0UmFuZ2Uob3B0aW9ucy5taW4gPiBvcHRpb25zLm1heCwgXCJDaGFuY2U6IE1pbiBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIE1heC5cIik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubmF0dXJhbCh7bWluOiBvcHRpb25zLm1pbiwgbWF4OiBvcHRpb25zLm1heH0pO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLm1pbGxpc2Vjb25kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXR1cmFsKHttYXg6IDk5OX0pO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLm1pbnV0ZSA9IENoYW5jZS5wcm90b3R5cGUuc2Vjb25kID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHttaW46IDAsIG1heDogNTl9KTtcblxuICAgICAgICB0ZXN0UmFuZ2Uob3B0aW9ucy5taW4gPCAwLCBcIkNoYW5jZTogTWluIGNhbm5vdCBiZSBsZXNzIHRoYW4gMC5cIik7XG4gICAgICAgIHRlc3RSYW5nZShvcHRpb25zLm1heCA+IDU5LCBcIkNoYW5jZTogTWF4IGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gNTkuXCIpO1xuICAgICAgICB0ZXN0UmFuZ2Uob3B0aW9ucy5taW4gPiBvcHRpb25zLm1heCwgXCJDaGFuY2U6IE1pbiBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIE1heC5cIik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubmF0dXJhbCh7bWluOiBvcHRpb25zLm1pbiwgbWF4OiBvcHRpb25zLm1heH0pO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLm1vbnRoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHttaW46IDEsIG1heDogMTJ9KTtcblxuICAgICAgICB0ZXN0UmFuZ2Uob3B0aW9ucy5taW4gPCAxLCBcIkNoYW5jZTogTWluIGNhbm5vdCBiZSBsZXNzIHRoYW4gMS5cIik7XG4gICAgICAgIHRlc3RSYW5nZShvcHRpb25zLm1heCA+IDEyLCBcIkNoYW5jZTogTWF4IGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gMTIuXCIpO1xuICAgICAgICB0ZXN0UmFuZ2Uob3B0aW9ucy5taW4gPiBvcHRpb25zLm1heCwgXCJDaGFuY2U6IE1pbiBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIE1heC5cIik7XG5cbiAgICAgICAgdmFyIG1vbnRoID0gdGhpcy5waWNrKHRoaXMubW9udGhzKCkuc2xpY2Uob3B0aW9ucy5taW4gLSAxLCBvcHRpb25zLm1heCkpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5yYXcgPyBtb250aCA6IG1vbnRoLm5hbWU7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUubW9udGhzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoXCJtb250aHNcIik7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuc2Vjb25kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXR1cmFsKHttYXg6IDU5fSk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUudGltZXN0YW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXR1cmFsKHttaW46IDEsIG1heDogcGFyc2VJbnQobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwLCAxMCl9KTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS53ZWVrZGF5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHt3ZWVrZGF5X29ubHk6IGZhbHNlfSk7XG4gICAgICAgIHZhciB3ZWVrZGF5cyA9IFtcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiXTtcbiAgICAgICAgaWYgKCFvcHRpb25zLndlZWtkYXlfb25seSkge1xuICAgICAgICAgICAgd2Vla2RheXMucHVzaChcIlNhdHVyZGF5XCIpO1xuICAgICAgICAgICAgd2Vla2RheXMucHVzaChcIlN1bmRheVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5waWNrb25lKHdlZWtkYXlzKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS55ZWFyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHllYXIgYXMgbWluIGlmIG5vbmUgc3BlY2lmaWVkXG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7bWluOiBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCl9KTtcblxuICAgICAgICAvLyBEZWZhdWx0IHRvIG9uZSBjZW50dXJ5IGFmdGVyIGN1cnJlbnQgeWVhciBhcyBtYXggaWYgbm9uZSBzcGVjaWZpZWRcbiAgICAgICAgb3B0aW9ucy5tYXggPSAodHlwZW9mIG9wdGlvbnMubWF4ICE9PSBcInVuZGVmaW5lZFwiKSA/IG9wdGlvbnMubWF4IDogb3B0aW9ucy5taW4gKyAxMDA7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubmF0dXJhbChvcHRpb25zKS50b1N0cmluZygpO1xuICAgIH07XG5cbiAgICAvLyAtLSBFbmQgVGltZVxuXG4gICAgLy8gLS0gRmluYW5jZSAtLVxuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5jYyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgICB2YXIgdHlwZSwgbnVtYmVyLCB0b19nZW5lcmF0ZTtcblxuICAgICAgICB0eXBlID0gKG9wdGlvbnMudHlwZSkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNjX3R5cGUoeyBuYW1lOiBvcHRpb25zLnR5cGUsIHJhdzogdHJ1ZSB9KSA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2NfdHlwZSh7IHJhdzogdHJ1ZSB9KTtcblxuICAgICAgICBudW1iZXIgPSB0eXBlLnByZWZpeC5zcGxpdChcIlwiKTtcbiAgICAgICAgdG9fZ2VuZXJhdGUgPSB0eXBlLmxlbmd0aCAtIHR5cGUucHJlZml4Lmxlbmd0aCAtIDE7XG5cbiAgICAgICAgLy8gR2VuZXJhdGVzIG4gLSAxIGRpZ2l0c1xuICAgICAgICBudW1iZXIgPSBudW1iZXIuY29uY2F0KHRoaXMubih0aGlzLmludGVnZXIsIHRvX2dlbmVyYXRlLCB7bWluOiAwLCBtYXg6IDl9KSk7XG5cbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBsYXN0IGRpZ2l0IGFjY29yZGluZyB0byBMdWhuIGFsZ29yaXRobVxuICAgICAgICBudW1iZXIucHVzaCh0aGlzLmx1aG5fY2FsY3VsYXRlKG51bWJlci5qb2luKFwiXCIpKSk7XG5cbiAgICAgICAgcmV0dXJuIG51bWJlci5qb2luKFwiXCIpO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmNjX3R5cGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JhbmtfY2FyZF9udW1iZXIjSXNzdWVyX2lkZW50aWZpY2F0aW9uX251bWJlcl8uMjhJSU4uMjlcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFwiY2NfdHlwZXNcIik7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuY2NfdHlwZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdmFyIHR5cGVzID0gdGhpcy5jY190eXBlcygpLFxuICAgICAgICAgICAgdHlwZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIEFjY2VwdCBlaXRoZXIgbmFtZSBvciBzaG9ydF9uYW1lIHRvIHNwZWNpZnkgY2FyZCB0eXBlXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVzW2ldLm5hbWUgPT09IG9wdGlvbnMubmFtZSB8fCB0eXBlc1tpXS5zaG9ydF9uYW1lID09PSBvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ3JlZGl0IGNhcmQgdHlwZSAnXCIgKyBvcHRpb25zLm5hbWUgKyBcIicnIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gdGhpcy5waWNrKHR5cGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcHRpb25zLnJhdyA/IHR5cGUgOiB0eXBlLm5hbWU7XG4gICAgfTtcblxuICAgIC8vcmV0dXJuIGFsbCB3b3JsZCBjdXJyZW5jeSBieSBJU08gNDIxN1xuICAgIENoYW5jZS5wcm90b3R5cGUuY3VycmVuY3lfdHlwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChcImN1cnJlbmN5X3R5cGVzXCIpO1xuICAgIH07XG5cbiAgICAvL3JldHVybiByYW5kb20gd29ybGQgY3VycmVuY3kgYnkgSVNPIDQyMTdcbiAgICBDaGFuY2UucHJvdG90eXBlLmN1cnJlbmN5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrKHRoaXMuY3VycmVuY3lfdHlwZXMoKSk7XG4gICAgfTtcblxuICAgIC8vcmV0dXJuIGFsbCB0aW1lem9uZXMgYXZhaWxhYmVsXG4gICAgQ2hhbmNlLnByb3RvdHlwZS50aW1lem9uZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChcInRpbWV6b25lc1wiKTtcbiAgICB9O1xuXG4gICAgLy9yZXR1cm4gcmFuZG9tIHRpbWV6b25lXG4gICAgQ2hhbmNlLnByb3RvdHlwZS50aW1lem9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGljayh0aGlzLnRpbWV6b25lcygpKTtcbiAgICB9O1xuXG4gICAgLy9SZXR1cm4gcmFuZG9tIGNvcnJlY3QgY3VycmVuY3kgZXhjaGFuZ2UgcGFpciAoZS5nLiBFVVIvVVNEKSBvciBhcnJheSBvZiBjdXJyZW5jeSBjb2RlXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5jdXJyZW5jeV9wYWlyID0gZnVuY3Rpb24gKHJldHVybkFzU3RyaW5nKSB7XG4gICAgICAgIHZhciBjdXJyZW5jaWVzID0gdGhpcy51bmlxdWUodGhpcy5jdXJyZW5jeSwgMiwge1xuICAgICAgICAgICAgY29tcGFyYXRvcjogZnVuY3Rpb24oYXJyLCB2YWwpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uKGFjYywgaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIG1hdGNoIGhhcyBiZWVuIGZvdW5kLCBzaG9ydCBjaXJjdWl0IGNoZWNrIGFuZCBqdXN0IHJldHVyblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjIHx8IChpdGVtLmNvZGUgPT09IHZhbC5jb2RlKTtcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZXR1cm5Bc1N0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbmNpZXNbMF0uY29kZSArICcvJyArIGN1cnJlbmNpZXNbMV0uY29kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW5jaWVzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuZG9sbGFyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgYSBzb21ld2hhdCBtb3JlIHNhbmUgbWF4IGZvciBkb2xsYXIgdGhhbiBhbGwgYXZhaWxhYmxlIG51bWJlcnNcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHttYXggOiAxMDAwMCwgbWluIDogMH0pO1xuXG4gICAgICAgIHZhciBkb2xsYXIgPSB0aGlzLmZsb2F0aW5nKHttaW46IG9wdGlvbnMubWluLCBtYXg6IG9wdGlvbnMubWF4LCBmaXhlZDogMn0pLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBjZW50cyA9IGRvbGxhci5zcGxpdCgnLicpWzFdO1xuXG4gICAgICAgIGlmIChjZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkb2xsYXIgKz0gJy4wMCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY2VudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgZG9sbGFyID0gZG9sbGFyICsgJzAnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvbGxhciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnLSQnICsgZG9sbGFyLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyQnICsgZG9sbGFyO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuZXVybyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodGhpcy5kb2xsYXIob3B0aW9ucykucmVwbGFjZShcIiRcIiwgXCJcIikpLnRvTG9jYWxlU3RyaW5nKCkgKyBcIuKCrFwiO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdmFyIGV4cCA9IHt9O1xuXG4gICAgICAgIGV4cC55ZWFyID0gdGhpcy5leHBfeWVhcigpO1xuXG4gICAgICAgIC8vIElmIHRoZSB5ZWFyIGlzIHRoaXMgeWVhciwgbmVlZCB0byBlbnN1cmUgbW9udGggaXMgZ3JlYXRlciB0aGFuIHRoZVxuICAgICAgICAvLyBjdXJyZW50IG1vbnRoIG9yIHRoaXMgZXhwaXJhdGlvbiB3aWxsIG5vdCBiZSB2YWxpZFxuICAgICAgICBpZiAoZXhwLnllYXIgPT09IChuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkpLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIGV4cC5tb250aCA9IHRoaXMuZXhwX21vbnRoKHtmdXR1cmU6IHRydWV9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cC5tb250aCA9IHRoaXMuZXhwX21vbnRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0aW9ucy5yYXcgPyBleHAgOiBleHAubW9udGggKyAnLycgKyBleHAueWVhcjtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5leHBfbW9udGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHZhciBtb250aCwgbW9udGhfaW50LFxuICAgICAgICAgICAgLy8gRGF0ZSBvYmplY3QgbW9udGhzIGFyZSAwIGluZGV4ZWRcbiAgICAgICAgICAgIGN1ck1vbnRoID0gbmV3IERhdGUoKS5nZXRNb250aCgpICsgMTtcblxuICAgICAgICBpZiAob3B0aW9ucy5mdXR1cmUgJiYgKGN1ck1vbnRoICE9PSAxMikpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBtb250aCA9IHRoaXMubW9udGgoe3JhdzogdHJ1ZX0pLm51bWVyaWM7XG4gICAgICAgICAgICAgICAgbW9udGhfaW50ID0gcGFyc2VJbnQobW9udGgsIDEwKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKG1vbnRoX2ludCA8PSBjdXJNb250aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb250aCA9IHRoaXMubW9udGgoe3JhdzogdHJ1ZX0pLm51bWVyaWM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9udGg7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUuZXhwX3llYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJNb250aCA9IG5ldyBEYXRlKCkuZ2V0TW9udGgoKSArIDEsXG4gICAgICAgICAgICBjdXJZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoe21pbjogKChjdXJNb250aCA9PT0gMTIpID8gKGN1clllYXIgKyAxKSA6IGN1clllYXIpLCBtYXg6IChjdXJZZWFyICsgMTApfSk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUudmF0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHsgY291bnRyeTogJ2l0JyB9KTtcbiAgICAgICAgc3dpdGNoIChvcHRpb25zLmNvdW50cnkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnaXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0X3ZhdCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIC0tIEVuZCBGaW5hbmNlXG5cbiAgICAvLyAtLSBSZWdpb25hbFxuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5pdF92YXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdF92YXQgPSB0aGlzLm5hdHVyYWwoe21pbjogMSwgbWF4OiAxODAwMDAwfSk7XG5cbiAgICAgICAgaXRfdmF0ID0gdGhpcy5wYWQoaXRfdmF0LCA3KSArIHRoaXMucGFkKHRoaXMucGljayh0aGlzLnByb3ZpbmNlcyh7IGNvdW50cnk6ICdpdCcgfSkpLmNvZGUsIDMpO1xuICAgICAgICByZXR1cm4gaXRfdmF0ICsgdGhpcy5sdWhuX2NhbGN1bGF0ZShpdF92YXQpO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIHRoaXMgZ2VuZXJhdG9yIGlzIHdyaXR0ZW4gZm9sbG93aW5nIHRoZSBvZmZpY2lhbCBhbGdvcml0aG1cbiAgICAgKiBhbGwgZGF0YSBjYW4gYmUgcGFzc2VkIGV4cGxpY2l0ZWx5IG9yIHJhbmRvbWl6ZWQgYnkgY2FsbGluZyBjaGFuY2UuY2YoKSB3aXRob3V0IG9wdGlvbnNcbiAgICAgKiB0aGUgY29kZSBkb2VzIG5vdCBjaGVjayB0aGF0IHRoZSBpbnB1dCBkYXRhIGlzIHZhbGlkIChpdCBnb2VzIGJleW9uZCB0aGUgc2NvcGUgb2YgdGhlIGdlbmVyYXRvcilcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgW09iamVjdF0gb3B0aW9ucyA9IHsgZmlyc3Q6IGZpcnN0IG5hbWUsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0OiBsYXN0IG5hbWUsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5kZXI6IGZlbWFsZXxtYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmlydGhkYXk6IEphdmFTY3JpcHQgZGF0ZSBvYmplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaXR5OiBzdHJpbmcoNCksIDEgbGV0dGVyICsgMyBudW1iZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiBAcmV0dXJuIFtzdHJpbmddIGNvZGljZSBmaXNjYWxlXG4gICAgICpcbiAgICAqL1xuICAgIENoYW5jZS5wcm90b3R5cGUuY2YgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIGdlbmRlciA9ICEhb3B0aW9ucy5nZW5kZXIgPyBvcHRpb25zLmdlbmRlciA6IHRoaXMuZ2VuZGVyKCksXG4gICAgICAgICAgICBmaXJzdCA9ICEhb3B0aW9ucy5maXJzdCA/IG9wdGlvbnMuZmlyc3QgOiB0aGlzLmZpcnN0KCB7IGdlbmRlcjogZ2VuZGVyLCBuYXRpb25hbGl0eTogJ2l0J30gKSxcbiAgICAgICAgICAgIGxhc3QgPSAhIW9wdGlvbnMubGFzdCA/IG9wdGlvbnMubGFzdCA6IHRoaXMubGFzdCggeyBuYXRpb25hbGl0eTogJ2l0J30gKSxcbiAgICAgICAgICAgIGJpcnRoZGF5ID0gISFvcHRpb25zLmJpcnRoZGF5ID8gb3B0aW9ucy5iaXJ0aGRheSA6IHRoaXMuYmlydGhkYXkoKSxcbiAgICAgICAgICAgIGNpdHkgPSAhIW9wdGlvbnMuY2l0eSA/IG9wdGlvbnMuY2l0eSA6IHRoaXMucGlja29uZShbJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0wnLCAnTScsICdaJ10pICsgdGhpcy5wYWQodGhpcy5uYXR1cmFsKHttYXg6OTk5fSksIDMpLFxuICAgICAgICAgICAgY2YgPSBbXSxcbiAgICAgICAgICAgIG5hbWVfZ2VuZXJhdG9yID0gZnVuY3Rpb24obmFtZSwgaXNMYXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybl92YWx1ZSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5fdmFsdWUgPSBuYW1lLnNwbGl0KFwiXCIpLmNvbmNhdChcIlhYWFwiLnNwbGl0KFwiXCIpKS5zcGxpY2UoMCwzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXAgPSBuYW1lLnRvVXBwZXJDYXNlKCkuc3BsaXQoJycpLm1hcChmdW5jdGlvbihjKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJCQ0RGR0hKS0xNTlBSU1RWV1pcIi5pbmRleE9mKGMpICE9PSAtMSkgPyBjIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXAubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSB0ZW1wLnN1YnN0cigwLDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gdGVtcFswXSArIHRlbXAuc3Vic3RyKDIsMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXAubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuX3ZhbHVlID0gdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBuYW1lLnRvVXBwZXJDYXNlKCkuc3BsaXQoJycpLm1hcChmdW5jdGlvbihjKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwiQUVJT1VcIi5pbmRleE9mKGMpICE9PSAtMSkgPyBjIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbignJykuc3Vic3RyKDAsIDMgLSByZXR1cm5fdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm5fdmFsdWUgPSByZXR1cm5fdmFsdWUgKyB0ZW1wO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5fdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0ZV9nZW5lcmF0b3IgPSBmdW5jdGlvbihiaXJ0aGRheSwgZ2VuZGVyLCB0aGF0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxldHRlcm1vbnRocyA9IFsnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0gnLCAnTCcsICdNJywgJ1AnLCAnUicsICdTJywgJ1QnXTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAgYmlydGhkYXkuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpLnN1YnN0cigyKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXR0ZXJtb250aHNbYmlydGhkYXkuZ2V0TW9udGgoKV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5wYWQoYmlydGhkYXkuZ2V0RGF0ZSgpICsgKChnZW5kZXIudG9Mb3dlckNhc2UoKSA9PT0gXCJmZW1hbGVcIikgPyA0MCA6IDApLCAyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGVja2RpZ2l0X2dlbmVyYXRvciA9IGZ1bmN0aW9uKGNmKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlMSA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlMiA9IFwiQUJDREVGR0hJSkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW5zICA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIixcbiAgICAgICAgICAgICAgICAgICAgb2RkcyAgID0gXCJCQUtQTENRRFJFVk9TRlRHVUhNSU5KV1pZWFwiLFxuICAgICAgICAgICAgICAgICAgICBkaWdpdCAgPSAwO1xuXG5cbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAlIDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0ICs9IGV2ZW5zLmluZGV4T2YocmFuZ2UyW3JhbmdlMS5pbmRleE9mKGNmW2ldKV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXQgKz0gIG9kZHMuaW5kZXhPZihyYW5nZTJbcmFuZ2UxLmluZGV4T2YoY2ZbaV0pXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW5zW2RpZ2l0ICUgMjZdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBjZiA9IGNmLmNvbmNhdChuYW1lX2dlbmVyYXRvcihsYXN0LCB0cnVlKSwgbmFtZV9nZW5lcmF0b3IoZmlyc3QpLCBkYXRlX2dlbmVyYXRvcihiaXJ0aGRheSwgZ2VuZGVyLCB0aGlzKSwgY2l0eS50b1VwcGVyQ2FzZSgpLnNwbGl0KFwiXCIpKS5qb2luKFwiXCIpO1xuICAgICAgICBjZiArPSBjaGVja2RpZ2l0X2dlbmVyYXRvcihjZi50b1VwcGVyQ2FzZSgpLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gY2YudG9VcHBlckNhc2UoKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5wbF9wZXNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG51bWJlciA9IHRoaXMubmF0dXJhbCh7bWluOiAxLCBtYXg6IDk5OTk5OTk5OTl9KTtcbiAgICAgICAgdmFyIGFyciA9IHRoaXMucGFkKG51bWJlciwgMTApLnNwbGl0KCcnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFycltpXSA9IHBhcnNlSW50KGFycltpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udHJvbE51bWJlciA9ICgxICogYXJyWzBdICsgMyAqIGFyclsxXSArIDcgKiBhcnJbMl0gKyA5ICogYXJyWzNdICsgMSAqIGFycls0XSArIDMgKiBhcnJbNV0gKyA3ICogYXJyWzZdICsgOSAqIGFycls3XSArIDEgKiBhcnJbOF0gKyAzICogYXJyWzldKSAlIDEwO1xuICAgICAgICBpZihjb250cm9sTnVtYmVyICE9PSAwKSB7XG4gICAgICAgICAgICBjb250cm9sTnVtYmVyID0gMTAgLSBjb250cm9sTnVtYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyci5qb2luKCcnKSArIGNvbnRyb2xOdW1iZXI7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUucGxfbmlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbnVtYmVyID0gdGhpcy5uYXR1cmFsKHttaW46IDEsIG1heDogOTk5OTk5OTk5fSk7XG4gICAgICAgIHZhciBhcnIgPSB0aGlzLnBhZChudW1iZXIsIDkpLnNwbGl0KCcnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFycltpXSA9IHBhcnNlSW50KGFycltpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udHJvbE51bWJlciA9ICg2ICogYXJyWzBdICsgNSAqIGFyclsxXSArIDcgKiBhcnJbMl0gKyAyICogYXJyWzNdICsgMyAqIGFycls0XSArIDQgKiBhcnJbNV0gKyA1ICogYXJyWzZdICsgNiAqIGFycls3XSArIDcgKiBhcnJbOF0pICUgMTE7XG4gICAgICAgIGlmKGNvbnRyb2xOdW1iZXIgPT09IDEwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wbF9uaXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnIuam9pbignJykgKyBjb250cm9sTnVtYmVyO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnBsX3JlZ29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbnVtYmVyID0gdGhpcy5uYXR1cmFsKHttaW46IDEsIG1heDogOTk5OTk5OTl9KTtcbiAgICAgICAgdmFyIGFyciA9IHRoaXMucGFkKG51bWJlciwgOCkuc3BsaXQoJycpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyW2ldID0gcGFyc2VJbnQoYXJyW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250cm9sTnVtYmVyID0gKDggKiBhcnJbMF0gKyA5ICogYXJyWzFdICsgMiAqIGFyclsyXSArIDMgKiBhcnJbM10gKyA0ICogYXJyWzRdICsgNSAqIGFycls1XSArIDYgKiBhcnJbNl0gKyA3ICogYXJyWzddKSAlIDExO1xuICAgICAgICBpZihjb250cm9sTnVtYmVyID09PSAxMCkge1xuICAgICAgICAgICAgY29udHJvbE51bWJlciA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyLmpvaW4oJycpICsgY29udHJvbE51bWJlcjtcbiAgICB9O1xuXG4gICAgLy8gLS0gRW5kIFJlZ2lvbmFsXG5cbiAgICAvLyAtLSBNaXNjZWxsYW5lb3VzIC0tXG5cbiAgICAvLyBEaWNlIC0gRm9yIGFsbCB0aGUgYm9hcmQgZ2FtZSBnZWVrcyBvdXQgdGhlcmUsIG15c2VsZiBpbmNsdWRlZCA7KVxuICAgIGZ1bmN0aW9uIGRpY2VGbiAocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hdHVyYWwocmFuZ2UpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBDaGFuY2UucHJvdG90eXBlLmQ0ID0gZGljZUZuKHttaW46IDEsIG1heDogNH0pO1xuICAgIENoYW5jZS5wcm90b3R5cGUuZDYgPSBkaWNlRm4oe21pbjogMSwgbWF4OiA2fSk7XG4gICAgQ2hhbmNlLnByb3RvdHlwZS5kOCA9IGRpY2VGbih7bWluOiAxLCBtYXg6IDh9KTtcbiAgICBDaGFuY2UucHJvdG90eXBlLmQxMCA9IGRpY2VGbih7bWluOiAxLCBtYXg6IDEwfSk7XG4gICAgQ2hhbmNlLnByb3RvdHlwZS5kMTIgPSBkaWNlRm4oe21pbjogMSwgbWF4OiAxMn0pO1xuICAgIENoYW5jZS5wcm90b3R5cGUuZDIwID0gZGljZUZuKHttaW46IDEsIG1heDogMjB9KTtcbiAgICBDaGFuY2UucHJvdG90eXBlLmQzMCA9IGRpY2VGbih7bWluOiAxLCBtYXg6IDMwfSk7XG4gICAgQ2hhbmNlLnByb3RvdHlwZS5kMTAwID0gZGljZUZuKHttaW46IDEsIG1heDogMTAwfSk7XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLnJwZyA9IGZ1bmN0aW9uICh0aHJvd24sIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXRocm93bikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBIHR5cGUgb2YgZGllIHJvbGwgbXVzdCBiZSBpbmNsdWRlZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBiaXRzID0gdGhyb3duLnRvTG93ZXJDYXNlKCkuc3BsaXQoXCJkXCIpLFxuICAgICAgICAgICAgICAgIHJvbGxzID0gW107XG5cbiAgICAgICAgICAgIGlmIChiaXRzLmxlbmd0aCAhPT0gMiB8fCAhcGFyc2VJbnQoYml0c1swXSwgMTApIHx8ICFwYXJzZUludChiaXRzWzFdLCAxMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGZvcm1hdCBwcm92aWRlZC4gUGxlYXNlIHByb3ZpZGUgI2QjIHdoZXJlIHRoZSBmaXJzdCAjIGlzIHRoZSBudW1iZXIgb2YgZGljZSB0byByb2xsLCB0aGUgc2Vjb25kICMgaXMgdGhlIG1heCBvZiBlYWNoIGRpZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBiaXRzWzBdOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgcm9sbHNbaSAtIDFdID0gdGhpcy5uYXR1cmFsKHttaW46IDEsIG1heDogYml0c1sxXX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2Ygb3B0aW9ucy5zdW0gIT09ICd1bmRlZmluZWQnICYmIG9wdGlvbnMuc3VtKSA/IHJvbGxzLnJlZHVjZShmdW5jdGlvbiAocCwgYykgeyByZXR1cm4gcCArIGM7IH0pIDogcm9sbHM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gR3VpZFxuICAgIENoYW5jZS5wcm90b3R5cGUuZ3VpZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7IHZlcnNpb246IDUgfSk7XG5cbiAgICAgICAgdmFyIGd1aWRfcG9vbCA9IFwiYWJjZGVmMTIzNDU2Nzg5MFwiLFxuICAgICAgICAgICAgdmFyaWFudF9wb29sID0gXCJhYjg5XCIsXG4gICAgICAgICAgICBndWlkID0gdGhpcy5zdHJpbmcoeyBwb29sOiBndWlkX3Bvb2wsIGxlbmd0aDogOCB9KSArICctJyArXG4gICAgICAgICAgICAgICAgICAgdGhpcy5zdHJpbmcoeyBwb29sOiBndWlkX3Bvb2wsIGxlbmd0aDogNCB9KSArICctJyArXG4gICAgICAgICAgICAgICAgICAgLy8gVGhlIFZlcnNpb25cbiAgICAgICAgICAgICAgICAgICBvcHRpb25zLnZlcnNpb24gK1xuICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyaW5nKHsgcG9vbDogZ3VpZF9wb29sLCBsZW5ndGg6IDMgfSkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgIC8vIFRoZSBWYXJpYW50XG4gICAgICAgICAgICAgICAgICAgdGhpcy5zdHJpbmcoeyBwb29sOiB2YXJpYW50X3Bvb2wsIGxlbmd0aDogMSB9KSArXG4gICAgICAgICAgICAgICAgICAgdGhpcy5zdHJpbmcoeyBwb29sOiBndWlkX3Bvb2wsIGxlbmd0aDogMyB9KSArICctJyArXG4gICAgICAgICAgICAgICAgICAgdGhpcy5zdHJpbmcoeyBwb29sOiBndWlkX3Bvb2wsIGxlbmd0aDogMTIgfSk7XG4gICAgICAgIHJldHVybiBndWlkO1xuICAgIH07XG5cbiAgICAvLyBIYXNoXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtsZW5ndGggOiA0MCwgY2FzaW5nOiAnbG93ZXInfSk7XG4gICAgICAgIHZhciBwb29sID0gb3B0aW9ucy5jYXNpbmcgPT09ICd1cHBlcicgPyBIRVhfUE9PTC50b1VwcGVyQ2FzZSgpIDogSEVYX1BPT0w7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZyh7cG9vbDogcG9vbCwgbGVuZ3RoOiBvcHRpb25zLmxlbmd0aH0pO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLmx1aG5fY2hlY2sgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgICAgIHZhciBzdHIgPSBudW0udG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGNoZWNrRGlnaXQgPSArc3RyLnN1YnN0cmluZyhzdHIubGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybiBjaGVja0RpZ2l0ID09PSB0aGlzLmx1aG5fY2FsY3VsYXRlKCtzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKSk7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUubHVobl9jYWxjdWxhdGUgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgICAgIHZhciBkaWdpdHMgPSBudW0udG9TdHJpbmcoKS5zcGxpdChcIlwiKS5yZXZlcnNlKCk7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICB2YXIgZGlnaXQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkaWdpdHMubGVuZ3RoOyBsID4gaTsgKytpKSB7XG4gICAgICAgICAgICBkaWdpdCA9ICtkaWdpdHNbaV07XG4gICAgICAgICAgICBpZiAoaSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkaWdpdCAqPSAyO1xuICAgICAgICAgICAgICAgIGlmIChkaWdpdCA+IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlnaXQgLT0gOTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdW0gKz0gZGlnaXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChzdW0gKiA5KSAlIDEwO1xuICAgIH07XG5cbiAgICAvLyBNRDUgSGFzaFxuICAgIENoYW5jZS5wcm90b3R5cGUubWQ1ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0cyA9IHsgc3RyOiAnJywga2V5OiBudWxsLCByYXc6IGZhbHNlIH07XG5cbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRzLnN0ciA9IHRoaXMuc3RyaW5nKCk7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBvcHRzLnN0ciA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKG9wdGlvbnMuY29uc3RydWN0b3IgPT09ICdBcnJheScpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0cyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIG9wdHMpO1xuXG4gICAgICAgIGlmKCFvcHRzLnN0cil7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHRvIHJldHVybiBhbiBtZDUgaGFzaC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmJpbWQ1Lm1kNShvcHRzLnN0ciwgb3B0cy5rZXksIG9wdHMucmF3KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogI0Rlc2NyaXB0aW9uOlxuICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICogR2VuZXJhdGUgcmFuZG9tIGZpbGUgbmFtZSB3aXRoIGV4dGVudGlvblxuICAgICAqXG4gICAgICogVGhlIGFyZ3VtZW50IHByb3ZpZGUgZXh0ZW50aW9uIHR5cGVcbiAgICAgKiAtPiByYXN0ZXJcbiAgICAgKiAtPiB2ZWN0b3JcbiAgICAgKiAtPiAzZFxuICAgICAqIC0+IGRvY3VtZW50XG4gICAgICpcbiAgICAgKiBJZiBub3RpbmcgaXMgcHJvdmlkZWQgdGhlIGZ1bmN0aW9uIHJldHVybiByYW5kb20gZmlsZSBuYW1lIHdpdGggcmFuZG9tXG4gICAgICogZXh0ZW50aW9uIHR5cGUgb2YgYW55IGtpbmRcbiAgICAgKlxuICAgICAqIFRoZSB1c2VyIGNhbiB2YWxpZGF0ZSB0aGUgZmlsZSBuYW1lIGxlbmd0aCByYW5nZVxuICAgICAqIElmIG5vdGluZyBwcm92aWRlZCB0aGUgZ2VuZXJhdGVkIGZpbGUgbmFtZSBpcyByYWRvbVxuICAgICAqXG4gICAgICogI0V4dGVudGlvbiBQb29sIDpcbiAgICAgKiAqIEN1cnJlbnRseSB0aGUgc3VwcG9ydGVkIGV4dGVudGlvbnMgYXJlXG4gICAgICogIC0+IHNvbWUgb2YgdGhlIG1vc3QgcG9wdWxhciByYXN0ZXIgaW1hZ2UgZXh0ZW50aW9uc1xuICAgICAqICAtPiBzb21lIG9mIHRoZSBtb3N0IHBvcHVsYXIgdmVjdG9yIGltYWdlIGV4dGVudGlvbnNcbiAgICAgKiAgLT4gc29tZSBvZiB0aGUgbW9zdCBwb3B1bGFyIDNkIGltYWdlIGV4dGVudGlvbnNcbiAgICAgKiAgLT4gc29tZSBvZiB0aGUgbW9zdCBwb3B1bGFyIGRvY3VtZW50IGV4dGVudGlvbnNcbiAgICAgKlxuICAgICAqICNFeGFtcGxlcyA6XG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgKlxuICAgICAqIFJldHVybiByYW5kb20gZmlsZSBuYW1lIHdpdGggcmFuZG9tIGV4dGVudGlvbi4gVGhlIGZpbGUgZXh0ZW50aW9uXG4gICAgICogaXMgcHJvdmlkZWQgYnkgYSBwcmVkaWZpbmVkIGNvbGxlY3Rpb24gb2YgZXh0ZW50aW9ucy4gTW9yZSBhYm91dGggdGhlIGV4dGVudGlvblxuICAgICAqIHBvb2wgY2FuIGJlIGZvbmQgaW4gI0V4dGVudGlvbiBQb29sIHNlY3Rpb25cbiAgICAgKlxuICAgICAqIGNoYW5jZS5maWxlKClcbiAgICAgKiA9PiBkc2ZzZGhqZi54bWxcbiAgICAgKlxuICAgICAqIEluIG9yZGVyIHRvIGdlbmVyYXRlIGEgZmlsZSBuYW1lIHdpdGggc3NwZWNpZmljIGxlbmd0aCwgc3BlY2lmeSB0aGVcbiAgICAgKiBsZW5ndGggcHJvcGVydHkgYW5kIGludGVnZXIgdmFsdWUuIFRoZSBleHRlbnRpb24gaXMgZ29pbmcgdG8gYmUgcmFuZG9tXG4gICAgICpcbiAgICAgKiBjaGFuY2UuZmlsZSh7bGVuZ3RoIDogMTB9KVxuICAgICAqID0+IGFzcnRpbmVxb3MucGRmXG4gICAgICpcbiAgICAgKiBJbiBvcmRlciB0byBnZWVyYXRlIGZpbGUgd2l0aCBleHRlbnRpb24gZm9ybSBzb21lIG9mIHRoZSBwcmVkaWZpbmVkIGdyb3Vwc1xuICAgICAqIG9mIHRoZSBleHRlbnRpb24gcG9vbCBqdXN0IHNwZWNpZnkgdGhlIGV4dGVudG9uIHBvb2wgY2F0ZWdvcnkgaW4gZmlsZVR5cGUgcHJvcGVydHlcbiAgICAgKlxuICAgICAqIGNoYW5jZS5maWxlKHtmaWxlVHlwZSA6ICdyYXN0ZXInfSlcbiAgICAgKiA9PiBkc2hnc3Nkcy5wc2RcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gcHJvdmlkZSBzcGVjaWZpYyBleHRlbnRpb24gZm9yIHlvdXIgZmlsZXNcbiAgICAgKiBjaGFuY2UuZmlsZSh7ZXh0ZW50aW9uIDogJ2h0bWwnfSlcbiAgICAgKiA9PiBkamZzZC5odG1sXG4gICAgICpcbiAgICAgKiBPciB5b3UgY291bGQgcGFzcyBjdXN0b20gY29sbGVjdGlvbiBvZiBleHRlbnRvbnMgYnQgYXJyYXkgb3IgYnkgb2JqZWN0XG4gICAgICogY2hhbmNlLmZpbGUoe2V4dGVudGlvbnMgOiBbLi4uXX0pXG4gICAgICogPT4gZGhnc2RzZC5wc2RcbiAgICAgKlxuICAgICAqIGNoYW5jZS5maWxlKHtleHRlbnRpb25zIDogeyBrZXkgOiBbLi4uXSwga2V5IDogWy4uLl19fSlcbiAgICAgKiA9PiBkanNma3NkanNkLnhtbFxuICAgICAqXG4gICAgICogQHBhcmFtICBbY29sbGVjdGlvbl0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gW3N0cmluZ11cbiAgICAgKlxuICAgICAqL1xuICAgIENoYW5jZS5wcm90b3R5cGUuZmlsZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICAgICAgICB2YXIgZmlsZU9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgcG9vbENvbGxlY3Rpb25LZXkgPSBcImZpbGVFeHRlbnNpb25cIjtcbiAgICAgICAgdmFyIHR5cGVSYW5nZSAgID0gT2JqZWN0LmtleXModGhpcy5nZXQoXCJmaWxlRXh0ZW5zaW9uXCIpKTsvL1sncmFzdGVyJywgJ3ZlY3RvcicsICczZCcsICdkb2N1bWVudCddO1xuICAgICAgICB2YXIgZmlsZU5hbWU7XG4gICAgICAgIHZhciBmaWxlRXh0ZW50aW9uO1xuXG4gICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBmaWxlIG5hbWVcbiAgICAgICAgZmlsZU5hbWUgPSB0aGlzLndvcmQoe2xlbmd0aCA6IGZpbGVPcHRpb25zLmxlbmd0aH0pO1xuXG4gICAgICAgIC8vIEdlbmVyYXRlIGZpbGUgYnkgc3BlY2lmaWMgZXh0ZW50aW9uIHByb3ZpZGVkIGJ5IHRoZSB1c2VyXG4gICAgICAgIGlmKGZpbGVPcHRpb25zLmV4dGVudGlvbikge1xuXG4gICAgICAgICAgICBmaWxlRXh0ZW50aW9uID0gZmlsZU9wdGlvbnMuZXh0ZW50aW9uO1xuICAgICAgICAgICAgcmV0dXJuIChmaWxlTmFtZSArICcuJyArIGZpbGVFeHRlbnRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgZmlsZSBieSBzcGVjaWZpYyBheHRlbnRpb24gY29sbGVjdGlvblxuICAgICAgICBpZihmaWxlT3B0aW9ucy5leHRlbnRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkoZmlsZU9wdGlvbnMuZXh0ZW50aW9ucykpIHtcblxuICAgICAgICAgICAgICAgIGZpbGVFeHRlbnRpb24gPSB0aGlzLnBpY2tvbmUoZmlsZU9wdGlvbnMuZXh0ZW50aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChmaWxlTmFtZSArICcuJyArIGZpbGVFeHRlbnRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihmaWxlT3B0aW9ucy5leHRlbnRpb25zLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcblxuICAgICAgICAgICAgICAgIHZhciBleHRlbnRpb25PYmplY3RDb2xsZWN0aW9uID0gZmlsZU9wdGlvbnMuZXh0ZW50aW9ucztcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV4dGVudGlvbk9iamVjdENvbGxlY3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgZmlsZUV4dGVudGlvbiA9IHRoaXMucGlja29uZShleHRlbnRpb25PYmplY3RDb2xsZWN0aW9uW3RoaXMucGlja29uZShrZXlzKV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAoZmlsZU5hbWUgKyAnLicgKyBmaWxlRXh0ZW50aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0IGNvbGxlY3Rpb24gb2YgdHlwZSBBcnJheSBvciBPYmplY3QgdG8gYmUgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIGZpbGUgZXh0ZW50aW9uIGJhc2VkIG9uIHNwZWNpZmljIGZpbGUgdHlwZVxuICAgICAgICBpZihmaWxlT3B0aW9ucy5maWxlVHlwZSkge1xuXG4gICAgICAgICAgICB2YXIgZmlsZVR5cGUgPSBmaWxlT3B0aW9ucy5maWxlVHlwZTtcbiAgICAgICAgICAgIGlmKHR5cGVSYW5nZS5pbmRleE9mKGZpbGVUeXBlKSAhPT0gLTEpIHtcblxuICAgICAgICAgICAgICAgIGZpbGVFeHRlbnRpb24gPSB0aGlzLnBpY2tvbmUodGhpcy5nZXQocG9vbENvbGxlY3Rpb25LZXkpW2ZpbGVUeXBlXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChmaWxlTmFtZSArICcuJyArIGZpbGVFeHRlbnRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3QgZmlsZSB0eXBlIHZhbHVlIHRvIGJlICdyYXN0ZXInLCAndmVjdG9yJywgJzNkJyBvciAnZG9jdW1lbnQnIFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBmaWxlIG5hbWUgaWYgbm8gZXh0ZW50b24gb3B0aW9ucyBhcmUgcGFzc2VkXG4gICAgICAgIGZpbGVFeHRlbnRpb24gPSB0aGlzLnBpY2tvbmUodGhpcy5nZXQocG9vbENvbGxlY3Rpb25LZXkpW3RoaXMucGlja29uZSh0eXBlUmFuZ2UpXSk7XG4gICAgICAgIHJldHVybiAoZmlsZU5hbWUgKyAnLicgKyBmaWxlRXh0ZW50aW9uKTtcbiAgICB9O1xuXG4gICAgdmFyIGRhdGEgPSB7XG5cbiAgICAgICAgZmlyc3ROYW1lczoge1xuICAgICAgICAgICAgXCJtYWxlXCI6IHtcbiAgICAgICAgICAgICAgICBcImVuXCI6IFtcIkphbWVzXCIsIFwiSm9oblwiLCBcIlJvYmVydFwiLCBcIk1pY2hhZWxcIiwgXCJXaWxsaWFtXCIsIFwiRGF2aWRcIiwgXCJSaWNoYXJkXCIsIFwiSm9zZXBoXCIsIFwiQ2hhcmxlc1wiLCBcIlRob21hc1wiLCBcIkNocmlzdG9waGVyXCIsIFwiRGFuaWVsXCIsIFwiTWF0dGhld1wiLCBcIkdlb3JnZVwiLCBcIkRvbmFsZFwiLCBcIkFudGhvbnlcIiwgXCJQYXVsXCIsIFwiTWFya1wiLCBcIkVkd2FyZFwiLCBcIlN0ZXZlblwiLCBcIktlbm5ldGhcIiwgXCJBbmRyZXdcIiwgXCJCcmlhblwiLCBcIkpvc2h1YVwiLCBcIktldmluXCIsIFwiUm9uYWxkXCIsIFwiVGltb3RoeVwiLCBcIkphc29uXCIsIFwiSmVmZnJleVwiLCBcIkZyYW5rXCIsIFwiR2FyeVwiLCBcIlJ5YW5cIiwgXCJOaWNob2xhc1wiLCBcIkVyaWNcIiwgXCJTdGVwaGVuXCIsIFwiSmFjb2JcIiwgXCJMYXJyeVwiLCBcIkpvbmF0aGFuXCIsIFwiU2NvdHRcIiwgXCJSYXltb25kXCIsIFwiSnVzdGluXCIsIFwiQnJhbmRvblwiLCBcIkdyZWdvcnlcIiwgXCJTYW11ZWxcIiwgXCJCZW5qYW1pblwiLCBcIlBhdHJpY2tcIiwgXCJKYWNrXCIsIFwiSGVucnlcIiwgXCJXYWx0ZXJcIiwgXCJEZW5uaXNcIiwgXCJKZXJyeVwiLCBcIkFsZXhhbmRlclwiLCBcIlBldGVyXCIsIFwiVHlsZXJcIiwgXCJEb3VnbGFzXCIsIFwiSGFyb2xkXCIsIFwiQWFyb25cIiwgXCJKb3NlXCIsIFwiQWRhbVwiLCBcIkFydGh1clwiLCBcIlphY2hhcnlcIiwgXCJDYXJsXCIsIFwiTmF0aGFuXCIsIFwiQWxiZXJ0XCIsIFwiS3lsZVwiLCBcIkxhd3JlbmNlXCIsIFwiSm9lXCIsIFwiV2lsbGllXCIsIFwiR2VyYWxkXCIsIFwiUm9nZXJcIiwgXCJLZWl0aFwiLCBcIkplcmVteVwiLCBcIlRlcnJ5XCIsIFwiSGFycnlcIiwgXCJSYWxwaFwiLCBcIlNlYW5cIiwgXCJKZXNzZVwiLCBcIlJveVwiLCBcIkxvdWlzXCIsIFwiQmlsbHlcIiwgXCJBdXN0aW5cIiwgXCJCcnVjZVwiLCBcIkV1Z2VuZVwiLCBcIkNocmlzdGlhblwiLCBcIkJyeWFuXCIsIFwiV2F5bmVcIiwgXCJSdXNzZWxsXCIsIFwiSG93YXJkXCIsIFwiRnJlZFwiLCBcIkV0aGFuXCIsIFwiSm9yZGFuXCIsIFwiUGhpbGlwXCIsIFwiQWxhblwiLCBcIkp1YW5cIiwgXCJSYW5keVwiLCBcIlZpbmNlbnRcIiwgXCJCb2JieVwiLCBcIkR5bGFuXCIsIFwiSm9obm55XCIsIFwiUGhpbGxpcFwiLCBcIlZpY3RvclwiLCBcIkNsYXJlbmNlXCIsIFwiRXJuZXN0XCIsIFwiTWFydGluXCIsIFwiQ3JhaWdcIiwgXCJTdGFubGV5XCIsIFwiU2hhd25cIiwgXCJUcmF2aXNcIiwgXCJCcmFkbGV5XCIsIFwiTGVvbmFyZFwiLCBcIkVhcmxcIiwgXCJHYWJyaWVsXCIsIFwiSmltbXlcIiwgXCJGcmFuY2lzXCIsIFwiVG9kZFwiLCBcIk5vYWhcIiwgXCJEYW5ueVwiLCBcIkRhbGVcIiwgXCJDb2R5XCIsIFwiQ2FybG9zXCIsIFwiQWxsZW5cIiwgXCJGcmVkZXJpY2tcIiwgXCJMb2dhblwiLCBcIkN1cnRpc1wiLCBcIkFsZXhcIiwgXCJKb2VsXCIsIFwiTHVpc1wiLCBcIk5vcm1hblwiLCBcIk1hcnZpblwiLCBcIkdsZW5uXCIsIFwiVG9ueVwiLCBcIk5hdGhhbmllbFwiLCBcIlJvZG5leVwiLCBcIk1lbHZpblwiLCBcIkFsZnJlZFwiLCBcIlN0ZXZlXCIsIFwiQ2FtZXJvblwiLCBcIkNoYWRcIiwgXCJFZHdpblwiLCBcIkNhbGViXCIsIFwiRXZhblwiLCBcIkFudG9uaW9cIiwgXCJMZWVcIiwgXCJIZXJiZXJ0XCIsIFwiSmVmZmVyeVwiLCBcIklzYWFjXCIsIFwiRGVyZWtcIiwgXCJSaWNreVwiLCBcIk1hcmN1c1wiLCBcIlRoZW9kb3JlXCIsIFwiRWxpamFoXCIsIFwiTHVrZVwiLCBcIkplc3VzXCIsIFwiRWRkaWVcIiwgXCJUcm95XCIsIFwiTWlrZVwiLCBcIkR1c3RpblwiLCBcIlJheVwiLCBcIkFkcmlhblwiLCBcIkJlcm5hcmRcIiwgXCJMZXJveVwiLCBcIkFuZ2VsXCIsIFwiUmFuZGFsbFwiLCBcIldlc2xleVwiLCBcIklhblwiLCBcIkphcmVkXCIsIFwiTWFzb25cIiwgXCJIdW50ZXJcIiwgXCJDYWx2aW5cIiwgXCJPc2NhclwiLCBcIkNsaWZmb3JkXCIsIFwiSmF5XCIsIFwiU2hhbmVcIiwgXCJSb25uaWVcIiwgXCJCYXJyeVwiLCBcIkx1Y2FzXCIsIFwiQ29yZXlcIiwgXCJNYW51ZWxcIiwgXCJMZW9cIiwgXCJUb21teVwiLCBcIldhcnJlblwiLCBcIkphY2tzb25cIiwgXCJJc2FpYWhcIiwgXCJDb25ub3JcIiwgXCJEb25cIiwgXCJEZWFuXCIsIFwiSm9uXCIsIFwiSnVsaWFuXCIsIFwiTWlndWVsXCIsIFwiQmlsbFwiLCBcIkxsb3lkXCIsIFwiQ2hhcmxpZVwiLCBcIk1pdGNoZWxsXCIsIFwiTGVvblwiLCBcIkplcm9tZVwiLCBcIkRhcnJlbGxcIiwgXCJKZXJlbWlhaFwiLCBcIkFsdmluXCIsIFwiQnJldHRcIiwgXCJTZXRoXCIsIFwiRmxveWRcIiwgXCJKaW1cIiwgXCJCbGFrZVwiLCBcIk1pY2hlYWxcIiwgXCJHb3Jkb25cIiwgXCJUcmV2b3JcIiwgXCJMZXdpc1wiLCBcIkVyaWtcIiwgXCJFZGdhclwiLCBcIlZlcm5vblwiLCBcIkRldmluXCIsIFwiR2F2aW5cIiwgXCJKYXlkZW5cIiwgXCJDaHJpc1wiLCBcIkNseWRlXCIsIFwiVG9tXCIsIFwiRGVycmlja1wiLCBcIk1hcmlvXCIsIFwiQnJlbnRcIiwgXCJNYXJjXCIsIFwiSGVybWFuXCIsIFwiQ2hhc2VcIiwgXCJEb21pbmljXCIsIFwiUmljYXJkb1wiLCBcIkZyYW5rbGluXCIsIFwiTWF1cmljZVwiLCBcIk1heFwiLCBcIkFpZGVuXCIsIFwiT3dlblwiLCBcIkxlc3RlclwiLCBcIkdpbGJlcnRcIiwgXCJFbG1lclwiLCBcIkdlbmVcIiwgXCJGcmFuY2lzY29cIiwgXCJHbGVuXCIsIFwiQ29yeVwiLCBcIkdhcnJldHRcIiwgXCJDbGF5dG9uXCIsIFwiU2FtXCIsIFwiSm9yZ2VcIiwgXCJDaGVzdGVyXCIsIFwiQWxlamFuZHJvXCIsIFwiSmVmZlwiLCBcIkhhcnZleVwiLCBcIk1pbHRvblwiLCBcIkNvbGVcIiwgXCJJdmFuXCIsIFwiQW5kcmVcIiwgXCJEdWFuZVwiLCBcIkxhbmRvblwiXSxcbiAgICAgICAgICAgICAgICAvLyBEYXRhIHRha2VuIGZyb20gaHR0cDovL3d3dy5kYXRpLmdvdi5pdC9kYXRhc2V0L2NvbXVuZS1kaS1maXJlbnplXzAxNjNcbiAgICAgICAgICAgICAgICBcIml0XCI6IFtcIkFkb2xmb1wiLCBcIkFsYmVydG9cIiwgXCJBbGRvXCIsIFwiQWxlc3NhbmRyb1wiLCBcIkFsZXNzaW9cIiwgXCJBbGZyZWRvXCIsIFwiQWx2YXJvXCIsIFwiQW5kcmVhXCIsIFwiQW5nZWxvXCIsIFwiQW5naW9sb1wiLCBcIkFudG9uaW5vXCIsIFwiQW50b25pb1wiLCBcIkF0dGlsaW9cIiwgXCJCZW5pdG9cIiwgXCJCZXJuYXJkb1wiLCBcIkJydW5vXCIsIFwiQ2FybG9cIiwgXCJDZXNhcmVcIiwgXCJDaHJpc3RpYW5cIiwgXCJDbGF1ZGlvXCIsIFwiQ29ycmFkb1wiLCBcIkNvc2ltb1wiLCBcIkNyaXN0aWFuXCIsIFwiQ3Jpc3RpYW5vXCIsIFwiRGFuaWVsZVwiLCBcIkRhcmlvXCIsIFwiRGF2aWRcIiwgXCJEYXZpZGVcIiwgXCJEaWVnb1wiLCBcIkRpbm9cIiwgXCJEb21lbmljb1wiLCBcIkR1Y2Npb1wiLCBcIkVkb2FyZG9cIiwgXCJFbGlhXCIsIFwiRWxpb1wiLCBcIkVtYW51ZWxlXCIsIFwiRW1pbGlhbm9cIiwgXCJFbWlsaW9cIiwgXCJFbnJpY29cIiwgXCJFbnpvXCIsIFwiRXR0b3JlXCIsIFwiRmFiaW9cIiwgXCJGYWJyaXppb1wiLCBcIkZlZGVyaWNvXCIsIFwiRmVyZGluYW5kb1wiLCBcIkZlcm5hbmRvXCIsIFwiRmlsaXBwb1wiLCBcIkZyYW5jZXNjb1wiLCBcIkZyYW5jb1wiLCBcIkdhYnJpZWxlXCIsIFwiR2lhY29tb1wiLCBcIkdpYW1wYW9sb1wiLCBcIkdpYW1waWVyb1wiLCBcIkdpYW5jYXJsb1wiLCBcIkdpYW5mcmFuY29cIiwgXCJHaWFubHVjYVwiLCBcIkdpYW5tYXJjb1wiLCBcIkdpYW5uaVwiLCBcIkdpbm9cIiwgXCJHaW9yZ2lvXCIsIFwiR2lvdmFubmlcIiwgXCJHaXVsaWFub1wiLCBcIkdpdWxpb1wiLCBcIkdpdXNlcHBlXCIsIFwiR3Jhemlhbm9cIiwgXCJHcmVnb3Jpb1wiLCBcIkd1aWRvXCIsIFwiSWFjb3BvXCIsIFwiSmFjb3BvXCIsIFwiTGFwb1wiLCBcIkxlb25hcmRvXCIsIFwiTG9yZW56b1wiLCBcIkx1Y2FcIiwgXCJMdWNpYW5vXCIsIFwiTHVpZ2lcIiwgXCJNYW51ZWxcIiwgXCJNYXJjZWxsb1wiLCBcIk1hcmNvXCIsIFwiTWFyaW5vXCIsIFwiTWFyaW9cIiwgXCJNYXNzaW1pbGlhbm9cIiwgXCJNYXNzaW1vXCIsIFwiTWF0dGVvXCIsIFwiTWF0dGlhXCIsIFwiTWF1cml6aW9cIiwgXCJNYXVyb1wiLCBcIk1pY2hlbGVcIiwgXCJNaXJrb1wiLCBcIk1vaGFtZWRcIiwgXCJOZWxsb1wiLCBcIk5lcmlcIiwgXCJOaWNjb2zDslwiLCBcIk5pY29sYVwiLCBcIk9zdmFsZG9cIiwgXCJPdGVsbG9cIiwgXCJQYW9sb1wiLCBcIlBpZXIgTHVpZ2lcIiwgXCJQaWVyb1wiLCBcIlBpZXRyb1wiLCBcIlJhZmZhZWxlXCIsIFwiUmVtb1wiLCBcIlJlbmF0b1wiLCBcIlJlbnpvXCIsIFwiUmljY2FyZG9cIiwgXCJSb2JlcnRvXCIsIFwiUm9sYW5kb1wiLCBcIlJvbWFub1wiLCBcIlNhbHZhdG9yZVwiLCBcIlNhbXVlbGVcIiwgXCJTYW5kcm9cIiwgXCJTZXJnaW9cIiwgXCJTaWx2YW5vXCIsIFwiU2ltb25lXCIsIFwiU3RlZmFub1wiLCBcIlRob21hc1wiLCBcIlRvbW1hc29cIiwgXCJVYmFsZG9cIiwgXCJVZ29cIiwgXCJVbWJlcnRvXCIsIFwiVmFsZXJpb1wiLCBcIlZhbHRlclwiLCBcIlZhc2NvXCIsIFwiVmluY2Vuem9cIiwgXCJWaXR0b3Jpb1wiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmVtYWxlXCI6IHtcbiAgICAgICAgICAgICAgICBcImVuXCI6IFtcIk1hcnlcIiwgXCJFbW1hXCIsIFwiRWxpemFiZXRoXCIsIFwiTWlubmllXCIsIFwiTWFyZ2FyZXRcIiwgXCJJZGFcIiwgXCJBbGljZVwiLCBcIkJlcnRoYVwiLCBcIlNhcmFoXCIsIFwiQW5uaWVcIiwgXCJDbGFyYVwiLCBcIkVsbGFcIiwgXCJGbG9yZW5jZVwiLCBcIkNvcmFcIiwgXCJNYXJ0aGFcIiwgXCJMYXVyYVwiLCBcIk5lbGxpZVwiLCBcIkdyYWNlXCIsIFwiQ2FycmllXCIsIFwiTWF1ZGVcIiwgXCJNYWJlbFwiLCBcIkJlc3NpZVwiLCBcIkplbm5pZVwiLCBcIkdlcnRydWRlXCIsIFwiSnVsaWFcIiwgXCJIYXR0aWVcIiwgXCJFZGl0aFwiLCBcIk1hdHRpZVwiLCBcIlJvc2VcIiwgXCJDYXRoZXJpbmVcIiwgXCJMaWxsaWFuXCIsIFwiQWRhXCIsIFwiTGlsbGllXCIsIFwiSGVsZW5cIiwgXCJKZXNzaWVcIiwgXCJMb3Vpc2VcIiwgXCJFdGhlbFwiLCBcIkx1bGFcIiwgXCJNeXJ0bGVcIiwgXCJFdmFcIiwgXCJGcmFuY2VzXCIsIFwiTGVuYVwiLCBcIkx1Y3lcIiwgXCJFZG5hXCIsIFwiTWFnZ2llXCIsIFwiUGVhcmxcIiwgXCJEYWlzeVwiLCBcIkZhbm5pZVwiLCBcIkpvc2VwaGluZVwiLCBcIkRvcmFcIiwgXCJSb3NhXCIsIFwiS2F0aGVyaW5lXCIsIFwiQWduZXNcIiwgXCJNYXJpZVwiLCBcIk5vcmFcIiwgXCJNYXlcIiwgXCJNYW1pZVwiLCBcIkJsYW5jaGVcIiwgXCJTdGVsbGFcIiwgXCJFbGxlblwiLCBcIk5hbmN5XCIsIFwiRWZmaWVcIiwgXCJTYWxsaWVcIiwgXCJOZXR0aWVcIiwgXCJEZWxsYVwiLCBcIkxpenppZVwiLCBcIkZsb3JhXCIsIFwiU3VzaWVcIiwgXCJNYXVkXCIsIFwiTWFlXCIsIFwiRXR0YVwiLCBcIkhhcnJpZXRcIiwgXCJTYWRpZVwiLCBcIkNhcm9saW5lXCIsIFwiS2F0aWVcIiwgXCJMeWRpYVwiLCBcIkVsc2llXCIsIFwiS2F0ZVwiLCBcIlN1c2FuXCIsIFwiTW9sbGllXCIsIFwiQWxtYVwiLCBcIkFkZGllXCIsIFwiR2VvcmdpYVwiLCBcIkVsaXphXCIsIFwiTHVsdVwiLCBcIk5hbm5pZVwiLCBcIkxvdHRpZVwiLCBcIkFtYW5kYVwiLCBcIkJlbGxlXCIsIFwiQ2hhcmxvdHRlXCIsIFwiUmViZWNjYVwiLCBcIlJ1dGhcIiwgXCJWaW9sYVwiLCBcIk9saXZlXCIsIFwiQW1lbGlhXCIsIFwiSGFubmFoXCIsIFwiSmFuZVwiLCBcIlZpcmdpbmlhXCIsIFwiRW1pbHlcIiwgXCJNYXRpbGRhXCIsIFwiSXJlbmVcIiwgXCJLYXRocnluXCIsIFwiRXN0aGVyXCIsIFwiV2lsbGllXCIsIFwiSGVucmlldHRhXCIsIFwiT2xsaWVcIiwgXCJBbXlcIiwgXCJSYWNoZWxcIiwgXCJTYXJhXCIsIFwiRXN0ZWxsYVwiLCBcIlRoZXJlc2FcIiwgXCJBdWd1c3RhXCIsIFwiT3JhXCIsIFwiUGF1bGluZVwiLCBcIkpvc2llXCIsIFwiTG9sYVwiLCBcIlNvcGhpYVwiLCBcIkxlb25hXCIsIFwiQW5uZVwiLCBcIk1pbGRyZWRcIiwgXCJBbm5cIiwgXCJCZXVsYWhcIiwgXCJDYWxsaWVcIiwgXCJMb3VcIiwgXCJEZWxpYVwiLCBcIkVsZWFub3JcIiwgXCJCYXJiYXJhXCIsIFwiSXZhXCIsIFwiTG91aXNhXCIsIFwiTWFyaWFcIiwgXCJNYXltZVwiLCBcIkV2ZWx5blwiLCBcIkVzdGVsbGVcIiwgXCJOaW5hXCIsIFwiQmV0dHlcIiwgXCJNYXJpb25cIiwgXCJCZXR0aWVcIiwgXCJEb3JvdGh5XCIsIFwiTHVlbGxhXCIsIFwiSW5lelwiLCBcIkxlbGFcIiwgXCJSb3NpZVwiLCBcIkFsbGllXCIsIFwiTWlsbGllXCIsIFwiSmFuaWVcIiwgXCJDb3JuZWxpYVwiLCBcIlZpY3RvcmlhXCIsIFwiUnVieVwiLCBcIldpbmlmcmVkXCIsIFwiQWx0YVwiLCBcIkNlbGlhXCIsIFwiQ2hyaXN0aW5lXCIsIFwiQmVhdHJpY2VcIiwgXCJCaXJkaWVcIiwgXCJIYXJyaWV0dFwiLCBcIk1hYmxlXCIsIFwiTXlyYVwiLCBcIlNvcGhpZVwiLCBcIlRpbGxpZVwiLCBcIklzYWJlbFwiLCBcIlN5bHZpYVwiLCBcIkNhcm9seW5cIiwgXCJJc2FiZWxsZVwiLCBcIkxlaWxhXCIsIFwiU2FsbHlcIiwgXCJJbmFcIiwgXCJFc3NpZVwiLCBcIkJlcnRpZVwiLCBcIk5lbGxcIiwgXCJBbGJlcnRhXCIsIFwiS2F0aGFyaW5lXCIsIFwiTG9yYVwiLCBcIlJlbmFcIiwgXCJNaW5hXCIsIFwiUmhvZGFcIiwgXCJNYXRoaWxkYVwiLCBcIkFiYmllXCIsIFwiRXVsYVwiLCBcIkRvbGxpZVwiLCBcIkhldHRpZVwiLCBcIkV1bmljZVwiLCBcIkZhbm55XCIsIFwiT2xhXCIsIFwiTGVub3JhXCIsIFwiQWRlbGFpZGVcIiwgXCJDaHJpc3RpbmFcIiwgXCJMZWxpYVwiLCBcIk5lbGxlXCIsIFwiU3VlXCIsIFwiSm9oYW5uYVwiLCBcIkxpbGx5XCIsIFwiTHVjaW5kYVwiLCBcIk1pbmVydmFcIiwgXCJMZXR0aWVcIiwgXCJSb3hpZVwiLCBcIkN5bnRoaWFcIiwgXCJIZWxlbmFcIiwgXCJIaWxkYVwiLCBcIkh1bGRhXCIsIFwiQmVybmljZVwiLCBcIkdlbmV2aWV2ZVwiLCBcIkplYW5cIiwgXCJDb3JkZWxpYVwiLCBcIk1hcmlhblwiLCBcIkZyYW5jaXNcIiwgXCJKZWFuZXR0ZVwiLCBcIkFkZWxpbmVcIiwgXCJHdXNzaWVcIiwgXCJMZWFoXCIsIFwiTG9pc1wiLCBcIkx1cmFcIiwgXCJNaXR0aWVcIiwgXCJIYWxsaWVcIiwgXCJJc2FiZWxsYVwiLCBcIk9sZ2FcIiwgXCJQaG9lYmVcIiwgXCJUZXJlc2FcIiwgXCJIZXN0ZXJcIiwgXCJMaWRhXCIsIFwiTGluYVwiLCBcIldpbm5pZVwiLCBcIkNsYXVkaWFcIiwgXCJNYXJndWVyaXRlXCIsIFwiVmVyYVwiLCBcIkNlY2VsaWFcIiwgXCJCZXNzXCIsIFwiRW1pbGllXCIsIFwiSm9oblwiLCBcIlJvc2V0dGFcIiwgXCJWZXJuYVwiLCBcIk15cnRpZVwiLCBcIkNlY2lsaWFcIiwgXCJFbHZhXCIsIFwiT2xpdmlhXCIsIFwiT3BoZWxpYVwiLCBcIkdlb3JnaWVcIiwgXCJFbG5vcmFcIiwgXCJWaW9sZXRcIiwgXCJBZGVsZVwiLCBcIkxpbHlcIiwgXCJMaW5uaWVcIiwgXCJMb3JldHRhXCIsIFwiTWFkZ2VcIiwgXCJQb2xseVwiLCBcIlZpcmdpZVwiLCBcIkV1Z2VuaWFcIiwgXCJMdWNpbGVcIiwgXCJMdWNpbGxlXCIsIFwiTWFiZWxsZVwiLCBcIlJvc2FsaWVcIl0sXG4gICAgICAgICAgICAgICAgLy8gRGF0YSB0YWtlbiBmcm9tIGh0dHA6Ly93d3cuZGF0aS5nb3YuaXQvZGF0YXNldC9jb211bmUtZGktZmlyZW56ZV8wMTYyXG4gICAgICAgICAgICAgICAgXCJpdFwiOiBbXCJBZGFcIiwgXCJBZHJpYW5hXCIsIFwiQWxlc3NhbmRyYVwiLCBcIkFsZXNzaWFcIiwgXCJBbGljZVwiLCBcIkFuZ2VsYVwiLCBcIkFubmFcIiwgXCJBbm5hIE1hcmlhXCIsIFwiQW5uYWxpc2FcIiwgXCJBbm5pdGFcIiwgXCJBbm51bnppYXRhXCIsIFwiQW50b25lbGxhXCIsIFwiQXJpYW5uYVwiLCBcIkFzaWFcIiwgXCJBc3N1bnRhXCIsIFwiQXVyb3JhXCIsIFwiQmFyYmFyYVwiLCBcIkJlYXRyaWNlXCIsIFwiQmVuZWRldHRhXCIsIFwiQmlhbmNhXCIsIFwiQnJ1bmFcIiwgXCJDYW1pbGxhXCIsIFwiQ2FybGFcIiwgXCJDYXJsb3R0YVwiLCBcIkNhcm1lbGFcIiwgXCJDYXJvbGluYVwiLCBcIkNhdGVyaW5hXCIsIFwiQ2F0aWFcIiwgXCJDZWNpbGlhXCIsIFwiQ2hpYXJhXCIsIFwiQ2luemlhXCIsIFwiQ2xhcmFcIiwgXCJDbGF1ZGlhXCIsIFwiQ29zdGFuemFcIiwgXCJDcmlzdGluYVwiLCBcIkRhbmllbGFcIiwgXCJEZWJvcmFcIiwgXCJEaWxldHRhXCIsIFwiRGluYVwiLCBcIkRvbmF0ZWxsYVwiLCBcIkVsZW5hXCIsIFwiRWxlb25vcmFcIiwgXCJFbGlzYVwiLCBcIkVsaXNhYmV0dGFcIiwgXCJFbWFudWVsYVwiLCBcIkVtbWFcIiwgXCJFdmFcIiwgXCJGZWRlcmljYVwiLCBcIkZlcm5hbmRhXCIsIFwiRmlvcmVsbGFcIiwgXCJGaW9yZW56YVwiLCBcIkZsb3JhXCIsIFwiRnJhbmNhXCIsIFwiRnJhbmNlc2NhXCIsIFwiR2FicmllbGxhXCIsIFwiR2FpYVwiLCBcIkdlbW1hXCIsIFwiR2lhZGFcIiwgXCJHaWFubmFcIiwgXCJHaW5hXCIsIFwiR2luZXZyYVwiLCBcIkdpb3JnaWFcIiwgXCJHaW92YW5uYVwiLCBcIkdpdWxpYVwiLCBcIkdpdWxpYW5hXCIsIFwiR2l1c2VwcGFcIiwgXCJHaXVzZXBwaW5hXCIsIFwiR3JhemlhXCIsIFwiR3JhemllbGxhXCIsIFwiR3JldGFcIiwgXCJJZGFcIiwgXCJJbGFyaWFcIiwgXCJJbmVzXCIsIFwiSW9sYW5kYVwiLCBcIklyZW5lXCIsIFwiSXJtYVwiLCBcIklzYWJlbGxhXCIsIFwiSmVzc2ljYVwiLCBcIkxhdXJhXCIsIFwiTGVkYVwiLCBcIkxldGl6aWFcIiwgXCJMaWNpYVwiLCBcIkxpZGlhXCIsIFwiTGlsaWFuYVwiLCBcIkxpbmFcIiwgXCJMaW5kYVwiLCBcIkxpc2FcIiwgXCJMaXZpYVwiLCBcIkxvcmV0dGFcIiwgXCJMdWFuYVwiLCBcIkx1Y2lhXCIsIFwiTHVjaWFuYVwiLCBcIkx1Y3JlemlhXCIsIFwiTHVpc2FcIiwgXCJNYW51ZWxhXCIsIFwiTWFyYVwiLCBcIk1hcmNlbGxhXCIsIFwiTWFyZ2hlcml0YVwiLCBcIk1hcmlhXCIsIFwiTWFyaWEgQ3Jpc3RpbmFcIiwgXCJNYXJpYSBHcmF6aWFcIiwgXCJNYXJpYSBMdWlzYVwiLCBcIk1hcmlhIFBpYVwiLCBcIk1hcmlhIFRlcmVzYVwiLCBcIk1hcmluYVwiLCBcIk1hcmlzYVwiLCBcIk1hcnRhXCIsIFwiTWFydGluYVwiLCBcIk1hcnppYVwiLCBcIk1hdGlsZGVcIiwgXCJNZWxpc3NhXCIsIFwiTWljaGVsYVwiLCBcIk1pbGVuYVwiLCBcIk1pcmVsbGFcIiwgXCJNb25pY2FcIiwgXCJOYXRhbGluYVwiLCBcIk5lbGxhXCIsIFwiTmljb2xldHRhXCIsIFwiTm9lbWlcIiwgXCJPbGdhXCIsIFwiUGFvbGFcIiwgXCJQYXRyaXppYVwiLCBcIlBpZXJhXCIsIFwiUGllcmluYVwiLCBcIlJhZmZhZWxsYVwiLCBcIlJlYmVjY2FcIiwgXCJSZW5hdGFcIiwgXCJSaW5hXCIsIFwiUml0YVwiLCBcIlJvYmVydGFcIiwgXCJSb3NhXCIsIFwiUm9zYW5uYVwiLCBcIlJvc3NhbmFcIiwgXCJSb3NzZWxsYVwiLCBcIlNhYnJpbmFcIiwgXCJTYW5kcmFcIiwgXCJTYXJhXCIsIFwiU2VyZW5hXCIsIFwiU2lsdmFuYVwiLCBcIlNpbHZpYVwiLCBcIlNpbW9uYVwiLCBcIlNpbW9uZXR0YVwiLCBcIlNvZmlhXCIsIFwiU29uaWFcIiwgXCJTdGVmYW5pYVwiLCBcIlN1c2FubmFcIiwgXCJUZXJlc2FcIiwgXCJUaW5hXCIsIFwiVGl6aWFuYVwiLCBcIlRvc2NhXCIsIFwiVmFsZW50aW5hXCIsIFwiVmFsZXJpYVwiLCBcIlZhbmRhXCIsIFwiVmFuZXNzYVwiLCBcIlZhbm5hXCIsIFwiVmVyYVwiLCBcIlZlcm9uaWNhXCIsIFwiVmlsbWFcIiwgXCJWaW9sYVwiLCBcIlZpcmdpbmlhXCIsIFwiVml0dG9yaWFcIl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsYXN0TmFtZXM6IHtcbiAgICAgICAgICAgIFwiZW5cIjogWydTbWl0aCcsICdKb2huc29uJywgJ1dpbGxpYW1zJywgJ0pvbmVzJywgJ0Jyb3duJywgJ0RhdmlzJywgJ01pbGxlcicsICdXaWxzb24nLCAnTW9vcmUnLCAnVGF5bG9yJywgJ0FuZGVyc29uJywgJ1Rob21hcycsICdKYWNrc29uJywgJ1doaXRlJywgJ0hhcnJpcycsICdNYXJ0aW4nLCAnVGhvbXBzb24nLCAnR2FyY2lhJywgJ01hcnRpbmV6JywgJ1JvYmluc29uJywgJ0NsYXJrJywgJ1JvZHJpZ3VleicsICdMZXdpcycsICdMZWUnLCAnV2Fsa2VyJywgJ0hhbGwnLCAnQWxsZW4nLCAnWW91bmcnLCAnSGVybmFuZGV6JywgJ0tpbmcnLCAnV3JpZ2h0JywgJ0xvcGV6JywgJ0hpbGwnLCAnU2NvdHQnLCAnR3JlZW4nLCAnQWRhbXMnLCAnQmFrZXInLCAnR29uemFsZXonLCAnTmVsc29uJywgJ0NhcnRlcicsICdNaXRjaGVsbCcsICdQZXJleicsICdSb2JlcnRzJywgJ1R1cm5lcicsICdQaGlsbGlwcycsICdDYW1wYmVsbCcsICdQYXJrZXInLCAnRXZhbnMnLCAnRWR3YXJkcycsICdDb2xsaW5zJywgJ1N0ZXdhcnQnLCAnU2FuY2hleicsICdNb3JyaXMnLCAnUm9nZXJzJywgJ1JlZWQnLCAnQ29vaycsICdNb3JnYW4nLCAnQmVsbCcsICdNdXJwaHknLCAnQmFpbGV5JywgJ1JpdmVyYScsICdDb29wZXInLCAnUmljaGFyZHNvbicsICdDb3gnLCAnSG93YXJkJywgJ1dhcmQnLCAnVG9ycmVzJywgJ1BldGVyc29uJywgJ0dyYXknLCAnUmFtaXJleicsICdKYW1lcycsICdXYXRzb24nLCAnQnJvb2tzJywgJ0tlbGx5JywgJ1NhbmRlcnMnLCAnUHJpY2UnLCAnQmVubmV0dCcsICdXb29kJywgJ0Jhcm5lcycsICdSb3NzJywgJ0hlbmRlcnNvbicsICdDb2xlbWFuJywgJ0plbmtpbnMnLCAnUGVycnknLCAnUG93ZWxsJywgJ0xvbmcnLCAnUGF0dGVyc29uJywgJ0h1Z2hlcycsICdGbG9yZXMnLCAnV2FzaGluZ3RvbicsICdCdXRsZXInLCAnU2ltbW9ucycsICdGb3N0ZXInLCAnR29uemFsZXMnLCAnQnJ5YW50JywgJ0FsZXhhbmRlcicsICdSdXNzZWxsJywgJ0dyaWZmaW4nLCAnRGlheicsICdIYXllcycsICdNeWVycycsICdGb3JkJywgJ0hhbWlsdG9uJywgJ0dyYWhhbScsICdTdWxsaXZhbicsICdXYWxsYWNlJywgJ1dvb2RzJywgJ0NvbGUnLCAnV2VzdCcsICdKb3JkYW4nLCAnT3dlbnMnLCAnUmV5bm9sZHMnLCAnRmlzaGVyJywgJ0VsbGlzJywgJ0hhcnJpc29uJywgJ0dpYnNvbicsICdNY0RvbmFsZCcsICdDcnV6JywgJ01hcnNoYWxsJywgJ09ydGl6JywgJ0dvbWV6JywgJ011cnJheScsICdGcmVlbWFuJywgJ1dlbGxzJywgJ1dlYmInLCAnU2ltcHNvbicsICdTdGV2ZW5zJywgJ1R1Y2tlcicsICdQb3J0ZXInLCAnSHVudGVyJywgJ0hpY2tzJywgJ0NyYXdmb3JkJywgJ0hlbnJ5JywgJ0JveWQnLCAnTWFzb24nLCAnTW9yYWxlcycsICdLZW5uZWR5JywgJ1dhcnJlbicsICdEaXhvbicsICdSYW1vcycsICdSZXllcycsICdCdXJucycsICdHb3Jkb24nLCAnU2hhdycsICdIb2xtZXMnLCAnUmljZScsICdSb2JlcnRzb24nLCAnSHVudCcsICdCbGFjaycsICdEYW5pZWxzJywgJ1BhbG1lcicsICdNaWxscycsICdOaWNob2xzJywgJ0dyYW50JywgJ0tuaWdodCcsICdGZXJndXNvbicsICdSb3NlJywgJ1N0b25lJywgJ0hhd2tpbnMnLCAnRHVubicsICdQZXJraW5zJywgJ0h1ZHNvbicsICdTcGVuY2VyJywgJ0dhcmRuZXInLCAnU3RlcGhlbnMnLCAnUGF5bmUnLCAnUGllcmNlJywgJ0JlcnJ5JywgJ01hdHRoZXdzJywgJ0Fybm9sZCcsICdXYWduZXInLCAnV2lsbGlzJywgJ1JheScsICdXYXRraW5zJywgJ09sc29uJywgJ0NhcnJvbGwnLCAnRHVuY2FuJywgJ1NueWRlcicsICdIYXJ0JywgJ0N1bm5pbmdoYW0nLCAnQnJhZGxleScsICdMYW5lJywgJ0FuZHJld3MnLCAnUnVpeicsICdIYXJwZXInLCAnRm94JywgJ1JpbGV5JywgJ0FybXN0cm9uZycsICdDYXJwZW50ZXInLCAnV2VhdmVyJywgJ0dyZWVuZScsICdMYXdyZW5jZScsICdFbGxpb3R0JywgJ0NoYXZleicsICdTaW1zJywgJ0F1c3RpbicsICdQZXRlcnMnLCAnS2VsbGV5JywgJ0ZyYW5rbGluJywgJ0xhd3NvbicsICdGaWVsZHMnLCAnR3V0aWVycmV6JywgJ1J5YW4nLCAnU2NobWlkdCcsICdDYXJyJywgJ1Zhc3F1ZXonLCAnQ2FzdGlsbG8nLCAnV2hlZWxlcicsICdDaGFwbWFuJywgJ09saXZlcicsICdNb250Z29tZXJ5JywgJ1JpY2hhcmRzJywgJ1dpbGxpYW1zb24nLCAnSm9obnN0b24nLCAnQmFua3MnLCAnTWV5ZXInLCAnQmlzaG9wJywgJ01jQ295JywgJ0hvd2VsbCcsICdBbHZhcmV6JywgJ01vcnJpc29uJywgJ0hhbnNlbicsICdGZXJuYW5kZXonLCAnR2FyemEnLCAnSGFydmV5JywgJ0xpdHRsZScsICdCdXJ0b24nLCAnU3RhbmxleScsICdOZ3V5ZW4nLCAnR2VvcmdlJywgJ0phY29icycsICdSZWlkJywgJ0tpbScsICdGdWxsZXInLCAnTHluY2gnLCAnRGVhbicsICdHaWxiZXJ0JywgJ0dhcnJldHQnLCAnUm9tZXJvJywgJ1dlbGNoJywgJ0xhcnNvbicsICdGcmF6aWVyJywgJ0J1cmtlJywgJ0hhbnNvbicsICdEYXknLCAnTWVuZG96YScsICdNb3Jlbm8nLCAnQm93bWFuJywgJ01lZGluYScsICdGb3dsZXInLCAnQnJld2VyJywgJ0hvZmZtYW4nLCAnQ2FybHNvbicsICdTaWx2YScsICdQZWFyc29uJywgJ0hvbGxhbmQnLCAnRG91Z2xhcycsICdGbGVtaW5nJywgJ0plbnNlbicsICdWYXJnYXMnLCAnQnlyZCcsICdEYXZpZHNvbicsICdIb3BraW5zJywgJ01heScsICdUZXJyeScsICdIZXJyZXJhJywgJ1dhZGUnLCAnU290bycsICdXYWx0ZXJzJywgJ0N1cnRpcycsICdOZWFsJywgJ0NhbGR3ZWxsJywgJ0xvd2UnLCAnSmVubmluZ3MnLCAnQmFybmV0dCcsICdHcmF2ZXMnLCAnSmltZW5leicsICdIb3J0b24nLCAnU2hlbHRvbicsICdCYXJyZXR0JywgJ09icmllbicsICdDYXN0cm8nLCAnU3V0dG9uJywgJ0dyZWdvcnknLCAnTWNLaW5uZXknLCAnTHVjYXMnLCAnTWlsZXMnLCAnQ3JhaWcnLCAnUm9kcmlxdWV6JywgJ0NoYW1iZXJzJywgJ0hvbHQnLCAnTGFtYmVydCcsICdGbGV0Y2hlcicsICdXYXR0cycsICdCYXRlcycsICdIYWxlJywgJ1Job2RlcycsICdQZW5hJywgJ0JlY2snLCAnTmV3bWFuJywgJ0hheW5lcycsICdNY0RhbmllbCcsICdNZW5kZXonLCAnQnVzaCcsICdWYXVnaG4nLCAnUGFya3MnLCAnRGF3c29uJywgJ1NhbnRpYWdvJywgJ05vcnJpcycsICdIYXJkeScsICdMb3ZlJywgJ1N0ZWVsZScsICdDdXJyeScsICdQb3dlcnMnLCAnU2NodWx0eicsICdCYXJrZXInLCAnR3V6bWFuJywgJ1BhZ2UnLCAnTXVub3onLCAnQmFsbCcsICdLZWxsZXInLCAnQ2hhbmRsZXInLCAnV2ViZXInLCAnTGVvbmFyZCcsICdXYWxzaCcsICdMeW9ucycsICdSYW1zZXknLCAnV29sZmUnLCAnU2NobmVpZGVyJywgJ011bGxpbnMnLCAnQmVuc29uJywgJ1NoYXJwJywgJ0Jvd2VuJywgJ0RhbmllbCcsICdCYXJiZXInLCAnQ3VtbWluZ3MnLCAnSGluZXMnLCAnQmFsZHdpbicsICdHcmlmZml0aCcsICdWYWxkZXonLCAnSHViYmFyZCcsICdTYWxhemFyJywgJ1JlZXZlcycsICdXYXJuZXInLCAnU3RldmVuc29uJywgJ0J1cmdlc3MnLCAnU2FudG9zJywgJ1RhdGUnLCAnQ3Jvc3MnLCAnR2FybmVyJywgJ01hbm4nLCAnTWFjaycsICdNb3NzJywgJ1Rob3JudG9uJywgJ0Rlbm5pcycsICdNY0dlZScsICdGYXJtZXInLCAnRGVsZ2FkbycsICdBZ3VpbGFyJywgJ1ZlZ2EnLCAnR2xvdmVyJywgJ01hbm5pbmcnLCAnQ29oZW4nLCAnSGFybW9uJywgJ1JvZGdlcnMnLCAnUm9iYmlucycsICdOZXd0b24nLCAnVG9kZCcsICdCbGFpcicsICdIaWdnaW5zJywgJ0luZ3JhbScsICdSZWVzZScsICdDYW5ub24nLCAnU3RyaWNrbGFuZCcsICdUb3duc2VuZCcsICdQb3R0ZXInLCAnR29vZHdpbicsICdXYWx0b24nLCAnUm93ZScsICdIYW1wdG9uJywgJ09ydGVnYScsICdQYXR0b24nLCAnU3dhbnNvbicsICdKb3NlcGgnLCAnRnJhbmNpcycsICdHb29kbWFuJywgJ01hbGRvbmFkbycsICdZYXRlcycsICdCZWNrZXInLCAnRXJpY2tzb24nLCAnSG9kZ2VzJywgJ1Jpb3MnLCAnQ29ubmVyJywgJ0Fka2lucycsICdXZWJzdGVyJywgJ05vcm1hbicsICdNYWxvbmUnLCAnSGFtbW9uZCcsICdGbG93ZXJzJywgJ0NvYmInLCAnTW9vZHknLCAnUXVpbm4nLCAnQmxha2UnLCAnTWF4d2VsbCcsICdQb3BlJywgJ0Zsb3lkJywgJ09zYm9ybmUnLCAnUGF1bCcsICdNY0NhcnRoeScsICdHdWVycmVybycsICdMaW5kc2V5JywgJ0VzdHJhZGEnLCAnU2FuZG92YWwnLCAnR2liYnMnLCAnVHlsZXInLCAnR3Jvc3MnLCAnRml0emdlcmFsZCcsICdTdG9rZXMnLCAnRG95bGUnLCAnU2hlcm1hbicsICdTYXVuZGVycycsICdXaXNlJywgJ0NvbG9uJywgJ0dpbGwnLCAnQWx2YXJhZG8nLCAnR3JlZXInLCAnUGFkaWxsYScsICdTaW1vbicsICdXYXRlcnMnLCAnTnVuZXonLCAnQmFsbGFyZCcsICdTY2h3YXJ0eicsICdNY0JyaWRlJywgJ0hvdXN0b24nLCAnQ2hyaXN0ZW5zZW4nLCAnS2xlaW4nLCAnUHJhdHQnLCAnQnJpZ2dzJywgJ1BhcnNvbnMnLCAnTWNMYXVnaGxpbicsICdaaW1tZXJtYW4nLCAnRnJlbmNoJywgJ0J1Y2hhbmFuJywgJ01vcmFuJywgJ0NvcGVsYW5kJywgJ1JveScsICdQaXR0bWFuJywgJ0JyYWR5JywgJ01jQ29ybWljaycsICdIb2xsb3dheScsICdCcm9jaycsICdQb29sZScsICdGcmFuaycsICdMb2dhbicsICdPd2VuJywgJ0Jhc3MnLCAnTWFyc2gnLCAnRHJha2UnLCAnV29uZycsICdKZWZmZXJzb24nLCAnUGFyaycsICdNb3J0b24nLCAnQWJib3R0JywgJ1NwYXJrcycsICdQYXRyaWNrJywgJ05vcnRvbicsICdIdWZmJywgJ0NsYXl0b24nLCAnTWFzc2V5JywgJ0xsb3lkJywgJ0ZpZ3Vlcm9hJywgJ0NhcnNvbicsICdCb3dlcnMnLCAnUm9iZXJzb24nLCAnQmFydG9uJywgJ1RyYW4nLCAnTGFtYicsICdIYXJyaW5ndG9uJywgJ0Nhc2V5JywgJ0Jvb25lJywgJ0NvcnRleicsICdDbGFya2UnLCAnTWF0aGlzJywgJ1NpbmdsZXRvbicsICdXaWxraW5zJywgJ0NhaW4nLCAnQnJ5YW4nLCAnVW5kZXJ3b29kJywgJ0hvZ2FuJywgJ01jS2VuemllJywgJ0NvbGxpZXInLCAnTHVuYScsICdQaGVscHMnLCAnTWNHdWlyZScsICdBbGxpc29uJywgJ0JyaWRnZXMnLCAnV2lsa2Vyc29uJywgJ05hc2gnLCAnU3VtbWVycycsICdBdGtpbnMnXSxcbiAgICAgICAgICAgICAgICAvLyBEYXRhIHRha2VuIGZyb20gaHR0cDovL3d3dy5kYXRpLmdvdi5pdC9kYXRhc2V0L2NvbXVuZS1kaS1maXJlbnplXzAxNjQgKGZpcnN0IDEwMDApXG4gICAgICAgICAgICBcIml0XCI6IFtcIkFjY2lhaVwiLCBcIkFnbGlldHRpXCIsIFwiQWdvc3RpbmlcIiwgXCJBZ3Jlc3RpXCIsIFwiQWhtZWRcIiwgXCJBaWF6emlcIiwgXCJBbGJhbmVzZVwiLCBcIkFsYmVydGlcIiwgXCJBbGVzc2lcIiwgXCJBbGZhbmlcIiwgXCJBbGluYXJpXCIsIFwiQWx0ZXJpbmlcIiwgXCJBbWF0b1wiLCBcIkFtbWFubmF0aVwiLCBcIkFuY2lsbG90dGlcIiwgXCJBbmRyZWlcIiwgXCJBbmRyZWluaVwiLCBcIkFuZHJlb25pXCIsIFwiQW5nZWxpXCIsIFwiQW5pY2hpbmlcIiwgXCJBbnRvbmVsbGlcIiwgXCJBbnRvbmluaVwiLCBcIkFyZW5hXCIsIFwiQXJpYW5pXCIsIFwiQXJuZXRvbGlcIiwgXCJBcnJpZ2hpXCIsIFwiQmFjY2FuaVwiLCBcIkJhY2NldHRpXCIsIFwiQmFjY2lcIiwgXCJCYWNoZXJpbmlcIiwgXCJCYWRpaVwiLCBcIkJhZ2dpYW5pXCIsIFwiQmFnbGlvbmlcIiwgXCJCYWduaVwiLCBcIkJhZ25vbGlcIiwgXCJCYWxkYXNzaW5pXCIsIFwiQmFsZGlcIiwgXCJCYWxkaW5pXCIsIFwiQmFsbGVyaW5pXCIsIFwiQmFsbGlcIiwgXCJCYWxsaW5pXCIsIFwiQmFsbG9uaVwiLCBcIkJhbWJpXCIsIFwiQmFuY2hpXCIsIFwiQmFuZGluZWxsaVwiLCBcIkJhbmRpbmlcIiwgXCJCYW5pXCIsIFwiQmFyYmV0dGlcIiwgXCJCYXJiaWVyaVwiLCBcIkJhcmNoaWVsbGlcIiwgXCJCYXJkYXp6aVwiLCBcIkJhcmRlbGxpXCIsIFwiQmFyZGlcIiwgXCJCYXJkdWNjaVwiLCBcIkJhcmdlbGxpbmlcIiwgXCJCYXJnaWFjY2hpXCIsIFwiQmFybmlcIiwgXCJCYXJvbmNlbGxpXCIsIFwiQmFyb25jaW5pXCIsIFwiQmFyb25lXCIsIFwiQmFyb25pXCIsIFwiQmFyb250aVwiLCBcIkJhcnRhbGVzaVwiLCBcIkJhcnRvbGV0dGlcIiwgXCJCYXJ0b2xpXCIsIFwiQmFydG9saW5pXCIsIFwiQmFydG9sb25pXCIsIFwiQmFydG9sb3p6aVwiLCBcIkJhc2FnbmlcIiwgXCJCYXNpbGVcIiwgXCJCYXNzaVwiLCBcIkJhdGFjY2hpXCIsIFwiQmF0dGFnbGlhXCIsIFwiQmF0dGFnbGluaVwiLCBcIkJhdXNpXCIsIFwiQmVjYWdsaVwiLCBcIkJlY2F0dGluaVwiLCBcIkJlY2NoaVwiLCBcIkJlY3VjY2lcIiwgXCJCZWxsYW5kaVwiLCBcIkJlbGxlc2lcIiwgXCJCZWxsaVwiLCBcIkJlbGxpbmlcIiwgXCJCZWxsdWNjaVwiLCBcIkJlbmNpbmlcIiwgXCJCZW5lZGV0dGlcIiwgXCJCZW5lbGxpXCIsIFwiQmVuaVwiLCBcIkJlbmluaVwiLCBcIkJlbnNpXCIsIFwiQmVudWNjaVwiLCBcIkJlbnZlbnV0aVwiLCBcIkJlcmxpbmNpb25pXCIsIFwiQmVybmFjY2hpb25pXCIsIFwiQmVybmFyZGlcIiwgXCJCZXJuYXJkaW5pXCIsIFwiQmVybmlcIiwgXCJCZXJuaW5pXCIsIFwiQmVydGVsbGlcIiwgXCJCZXJ0aVwiLCBcIkJlcnRpbmlcIiwgXCJCZXNzaVwiLCBcIkJldHRpXCIsIFwiQmV0dGluaVwiLCBcIkJpYWdpXCIsIFwiQmlhZ2luaVwiLCBcIkJpYWdpb25pXCIsIFwiQmlhZ2lvdHRpXCIsIFwiQmlhbmNhbGFuaVwiLCBcIkJpYW5jaGlcIiwgXCJCaWFuY2hpbmlcIiwgXCJCaWFuY29cIiwgXCJCaWZmb2xpXCIsIFwiQmlnYXp6aVwiLCBcIkJpZ2lcIiwgXCJCaWxpb3R0aVwiLCBcIkJpbGxpXCIsIFwiQmluYXp6aVwiLCBcIkJpbmRpXCIsIFwiQmluaVwiLCBcIkJpb25kaVwiLCBcIkJpenphcnJpXCIsIFwiQm9jY2lcIiwgXCJCb2dhbmlcIiwgXCJCb2xvZ25lc2lcIiwgXCJCb25haXV0aVwiLCBcIkJvbmFubmlcIiwgXCJCb25jaWFuaVwiLCBcIkJvbmNpbmVsbGlcIiwgXCJCb25kaVwiLCBcIkJvbmVjaGlcIiwgXCJCb25naW5pXCIsIFwiQm9uaVwiLCBcIkJvbmluaVwiLCBcIkJvcmNoaVwiLCBcIkJvcmV0dGlcIiwgXCJCb3JnaGlcIiwgXCJCb3JnaGluaVwiLCBcIkJvcmdpb2xpXCIsIFwiQm9ycmlcIiwgXCJCb3JzZWxsaVwiLCBcIkJvc2NoaVwiLCBcIkJvdHRhaVwiLCBcIkJyYWNjaVwiLCBcIkJyYWNjaW5pXCIsIFwiQnJhbmRpXCIsIFwiQnJhc2NoaVwiLCBcIkJyYXZpXCIsIFwiQnJhenppbmlcIiwgXCJCcmVzY2hpXCIsIFwiQnJpbGxpXCIsIFwiQnJpenppXCIsIFwiQnJvZ2VsbGlcIiwgXCJCcm9naVwiLCBcIkJyb2dpb25pXCIsIFwiQnJ1bmVsbGlcIiwgXCJCcnVuZXR0aVwiLCBcIkJydW5pXCIsIFwiQnJ1bm9cIiwgXCJCcnVub3JpXCIsIFwiQnJ1c2NoaVwiLCBcIkJ1Y2NpXCIsIFwiQnVjY2lhcmVsbGlcIiwgXCJCdWNjaW9uaVwiLCBcIkJ1Y2VsbGlcIiwgXCJCdWxsaVwiLCBcIkJ1cmJlcmlcIiwgXCJCdXJjaGlcIiwgXCJCdXJnYXNzaVwiLCBcIkJ1cnJvbmlcIiwgXCJCdXNzb3R0aVwiLCBcIkJ1dGlcIiwgXCJDYWNpb2xsaVwiLCBcIkNhaWFuaVwiLCBcIkNhbGFicmVzZVwiLCBcIkNhbGFtYWlcIiwgXCJDYWxhbWFuZHJlaVwiLCBcIkNhbGRpbmlcIiwgXCJDYWxvJ1wiLCBcIkNhbG9uYWNpXCIsIFwiQ2Fsb3NpXCIsIFwiQ2FsdmVsbGlcIiwgXCJDYW1iaVwiLCBcIkNhbWljaW90dG9saVwiLCBcIkNhbW1lbGxpXCIsIFwiQ2FtbWlsbGlcIiwgXCJDYW1wb2xtaVwiLCBcIkNhbnRpbmlcIiwgXCJDYXBhbm5pXCIsIFwiQ2FwZWNjaGlcIiwgXCJDYXBvbmlcIiwgXCJDYXBwZWxsZXR0aVwiLCBcIkNhcHBlbGxpXCIsIFwiQ2FwcGVsbGluaVwiLCBcIkNhcHB1Z2lcIiwgXCJDYXByZXR0aVwiLCBcIkNhcHV0b1wiLCBcIkNhcmJvbmVcIiwgXCJDYXJib25pXCIsIFwiQ2FyZGluaVwiLCBcIkNhcmxlc2lcIiwgXCJDYXJsZXR0aVwiLCBcIkNhcmxpXCIsIFwiQ2Fyb3RpXCIsIFwiQ2Fyb3R0aVwiLCBcIkNhcnJhaVwiLCBcIkNhcnJhcmVzaVwiLCBcIkNhcnRhXCIsIFwiQ2FydXNvXCIsIFwiQ2FzYWxpbmlcIiwgXCJDYXNhdGlcIiwgXCJDYXNlbGxpXCIsIFwiQ2FzaW5pXCIsIFwiQ2FzdGFnbm9saVwiLCBcIkNhc3RlbGxhbmlcIiwgXCJDYXN0ZWxsaVwiLCBcIkNhc3RlbGx1Y2NpXCIsIFwiQ2F0YWxhbm9cIiwgXCJDYXRhcnppXCIsIFwiQ2F0ZWxhbmlcIiwgXCJDYXZhY2lvY2NoaVwiLCBcIkNhdmFsbGFyb1wiLCBcIkNhdmFsbGluaVwiLCBcIkNhdmljY2hpXCIsIFwiQ2F2aW5pXCIsIFwiQ2VjY2FyZWxsaVwiLCBcIkNlY2NhdGVsbGlcIiwgXCJDZWNjaGVyZWxsaVwiLCBcIkNlY2NoZXJpbmlcIiwgXCJDZWNjaGlcIiwgXCJDZWNjaGluaVwiLCBcIkNlY2NvbmlcIiwgXCJDZWlcIiwgXCJDZWxsYWlcIiwgXCJDZWxsaVwiLCBcIkNlbGxpbmlcIiwgXCJDZW5jZXR0aVwiLCBcIkNlbmlcIiwgXCJDZW5uaVwiLCBcIkNlcmJhaVwiLCBcIkNlc2FyaVwiLCBcIkNlc2VyaVwiLCBcIkNoZWNjYWNjaVwiLCBcIkNoZWNjaGlcIiwgXCJDaGVjY3VjY2lcIiwgXCJDaGVsaVwiLCBcIkNoZWxsaW5pXCIsIFwiQ2hlblwiLCBcIkNoZW5nXCIsIFwiQ2hlcmljaVwiLCBcIkNoZXJ1YmluaVwiLCBcIkNoaWFyYW1vbnRpXCIsIFwiQ2hpYXJhbnRpbmlcIiwgXCJDaGlhcmVsbGlcIiwgXCJDaGlhcmlcIiwgXCJDaGlhcmluaVwiLCBcIkNoaWFydWdpXCIsIFwiQ2hpYXZhY2NpXCIsIFwiQ2hpZXNpXCIsIFwiQ2hpbWVudGlcIiwgXCJDaGluaVwiLCBcIkNoaXJpY2lcIiwgXCJDaGl0aVwiLCBcIkNpYWJhdHRpXCIsIFwiQ2lhbXBpXCIsIFwiQ2lhbmNoaVwiLCBcIkNpYW5mYW5lbGxpXCIsIFwiQ2lhbmZlcm9uaVwiLCBcIkNpYW5pXCIsIFwiQ2lhcGV0dGlcIiwgXCJDaWFwcGlcIiwgXCJDaWFyZGlcIiwgXCJDaWF0dGlcIiwgXCJDaWNhbGlcIiwgXCJDaWNjb25lXCIsIFwiQ2luZWxsaVwiLCBcIkNpbmlcIiwgXCJDaW9iYW51XCIsIFwiQ2lvbGxpXCIsIFwiQ2lvbmlcIiwgXCJDaXByaWFuaVwiLCBcIkNpcmlsbG9cIiwgXCJDaXJyaVwiLCBcIkNpdWNjaGlcIiwgXCJDaXVmZmlcIiwgXCJDaXVsbGlcIiwgXCJDaXVsbGluaVwiLCBcIkNsZW1lbnRlXCIsIFwiQ29jY2hpXCIsIFwiQ29nbm9tZVwiLCBcIkNvbGlcIiwgXCJDb2xsaW5pXCIsIFwiQ29sb21ib1wiLCBcIkNvbHppXCIsIFwiQ29tcGFyaW5pXCIsIFwiQ29uZm9ydGlcIiwgXCJDb25zaWdsaVwiLCBcIkNvbnRlXCIsIFwiQ29udGlcIiwgXCJDb250aW5pXCIsIFwiQ29wcGluaVwiLCBcIkNvcHBvbGFcIiwgXCJDb3JzaVwiLCBcIkNvcnNpbmlcIiwgXCJDb3J0aVwiLCBcIkNvcnRpbmlcIiwgXCJDb3NpXCIsIFwiQ29zdGFcIiwgXCJDb3N0YW50aW5pXCIsIFwiQ29zdGFudGlub1wiLCBcIkNvenppXCIsIFwiQ3Jlc2NpXCIsIFwiQ3Jlc2Npb2xpXCIsIFwiQ3Jlc3RpXCIsIFwiQ3JpbmlcIiwgXCJDdXJyYWRpXCIsIFwiRCdBZ29zdGlub1wiLCBcIkQnQWxlc3NhbmRyb1wiLCBcIkQnQW1pY29cIiwgXCJEJ0FuZ2Vsb1wiLCBcIkRhZGRpXCIsIFwiRGFpbmVsbGlcIiwgXCJEYWxsYWlcIiwgXCJEYW50aVwiLCBcIkRhdml0dGlcIiwgXCJEZSBBbmdlbGlzXCIsIFwiRGUgTHVjYVwiLCBcIkRlIE1hcmNvXCIsIFwiRGUgUm9zYVwiLCBcIkRlIFNhbnRpc1wiLCBcIkRlIFNpbW9uZVwiLCBcIkRlIFZpdGFcIiwgXCJEZWdsJ0lubm9jZW50aVwiLCBcIkRlZ2xpIElubm9jZW50aVwiLCBcIkRlaVwiLCBcIkRlbCBMdW5nb1wiLCBcIkRlbCBSZVwiLCBcIkRpIE1hcmNvXCIsIFwiRGkgU3RlZmFub1wiLCBcIkRpbmlcIiwgXCJEaW9wXCIsIFwiRG9icmVcIiwgXCJEb2xmaVwiLCBcIkRvbmF0aVwiLCBcIkRvbmRvbGlcIiwgXCJEb25nXCIsIFwiRG9ubmluaVwiLCBcIkR1Y2NpXCIsIFwiRHVtaXRydVwiLCBcIkVybWluaVwiLCBcIkVzcG9zaXRvXCIsIFwiRXZhbmdlbGlzdGlcIiwgXCJGYWJicmlcIiwgXCJGYWJicmluaVwiLCBcIkZhYmJyaXp6aVwiLCBcIkZhYmJyb25pXCIsIFwiRmFiYnJ1Y2NpXCIsIFwiRmFiaWFuaVwiLCBcIkZhY2NoaW5pXCIsIFwiRmFnZ2lcIiwgXCJGYWdpb2xpXCIsIFwiRmFpbGxpXCIsIFwiRmFpbmlcIiwgXCJGYWxjaWFuaVwiLCBcIkZhbGNpbmlcIiwgXCJGYWxjb25lXCIsIFwiRmFsbGFuaVwiLCBcIkZhbG9ybmlcIiwgXCJGYWxzaW5pXCIsIFwiRmFsdWdpYW5pXCIsIFwiRmFuY2VsbGlcIiwgXCJGYW5lbGxpXCIsIFwiRmFuZXR0aVwiLCBcIkZhbmZhbmlcIiwgXCJGYW5pXCIsIFwiRmFudGFwcGllJ1wiLCBcIkZhbnRlY2hpXCIsIFwiRmFudGlcIiwgXCJGYW50aW5pXCIsIFwiRmFudG9uaVwiLCBcIkZhcmluYVwiLCBcIkZhdHRvcmlcIiwgXCJGYXZpbGxpXCIsIFwiRmVkaVwiLCBcIkZlaVwiLCBcIkZlcnJhbnRlXCIsIFwiRmVycmFyYVwiLCBcIkZlcnJhcmlcIiwgXCJGZXJyYXJvXCIsIFwiRmVycmV0dGlcIiwgXCJGZXJyaVwiLCBcIkZlcnJpbmlcIiwgXCJGZXJyb25pXCIsIFwiRmlhc2NoaVwiLCBcIkZpYmJpXCIsIFwiRmllc29saVwiLCBcIkZpbGlwcGlcIiwgXCJGaWxpcHBpbmlcIiwgXCJGaW5pXCIsIFwiRmlvcmF2YW50aVwiLCBcIkZpb3JlXCIsIFwiRmlvcmVudGluaVwiLCBcIkZpb3JpbmlcIiwgXCJGaXNzaVwiLCBcIkZvY2FyZGlcIiwgXCJGb2dnaVwiLCBcIkZvbnRhbmFcIiwgXCJGb250YW5lbGxpXCIsIFwiRm9udGFuaVwiLCBcIkZvcmNvbmlcIiwgXCJGb3JtaWdsaVwiLCBcIkZvcnRlXCIsIFwiRm9ydGlcIiwgXCJGb3J0aW5pXCIsIFwiRm9zc2F0aVwiLCBcIkZvc3NpXCIsIFwiRnJhbmNhbGFuY2lcIiwgXCJGcmFuY2VzY2hpXCIsIFwiRnJhbmNlc2NoaW5pXCIsIFwiRnJhbmNoaVwiLCBcIkZyYW5jaGluaVwiLCBcIkZyYW5jaVwiLCBcIkZyYW5jaW5pXCIsIFwiRnJhbmNpb25pXCIsIFwiRnJhbmNvXCIsIFwiRnJhc3NpbmV0aVwiLCBcIkZyYXRpXCIsIFwiRnJhdGluaVwiLCBcIkZyaWxsaVwiLCBcIkZyaXp6aVwiLCBcIkZyb3NhbGlcIiwgXCJGcm9zaW5pXCIsIFwiRnJ1bGxpbmlcIiwgXCJGdXNjb1wiLCBcIkZ1c2lcIiwgXCJHYWJicmllbGxpXCIsIFwiR2FiZWxsaW5pXCIsIFwiR2FnbGlhcmRpXCIsIFwiR2FsYW50aVwiLCBcIkdhbGFyZGlcIiwgXCJHYWxlb3R0aVwiLCBcIkdhbGxldHRpXCIsIFwiR2FsbGlcIiwgXCJHYWxsb1wiLCBcIkdhbGxvcmlcIiwgXCJHYW1iYWNjaWFuaVwiLCBcIkdhcmdhbmlcIiwgXCJHYXJvZmFsb1wiLCBcIkdhcnVnbGllcmlcIiwgXCJHYXNoaVwiLCBcIkdhc3BlcmluaVwiLCBcIkdhdHRpXCIsIFwiR2VsbGlcIiwgXCJHZW5zaW5pXCIsIFwiR2VudGlsZVwiLCBcIkdlbnRpbGlcIiwgXCJHZXJpXCIsIFwiR2VyaW5pXCIsIFwiR2hlcmlcIiwgXCJHaGluaVwiLCBcIkdpYWNoZXR0aVwiLCBcIkdpYWNoaVwiLCBcIkdpYWNvbWVsbGlcIiwgXCJHaWFuYXNzaVwiLCBcIkdpYW5pXCIsIFwiR2lhbm5lbGxpXCIsIFwiR2lhbm5ldHRpXCIsIFwiR2lhbm5pXCIsIFwiR2lhbm5pbmlcIiwgXCJHaWFubm9uaVwiLCBcIkdpYW5ub3R0aVwiLCBcIkdpYW5ub3p6aVwiLCBcIkdpZ2xpXCIsIFwiR2lvcmRhbm9cIiwgXCJHaW9yZ2V0dGlcIiwgXCJHaW9yZ2lcIiwgXCJHaW92YWNjaGluaVwiLCBcIkdpb3Zhbm5lbGxpXCIsIFwiR2lvdmFubmV0dGlcIiwgXCJHaW92YW5uaW5pXCIsIFwiR2lvdmFubm9uaVwiLCBcIkdpdWxpYW5pXCIsIFwiR2l1bnRpXCIsIFwiR2l1bnRpbmlcIiwgXCJHaXVzdGlcIiwgXCJHb25uZWxsaVwiLCBcIkdvcmV0dGlcIiwgXCJHb3JpXCIsIFwiR3JhZGlcIiwgXCJHcmFtaWduaVwiLCBcIkdyYXNzaVwiLCBcIkdyYXNzb1wiLCBcIkdyYXppYW5pXCIsIFwiR3JhenppbmlcIiwgXCJHcmVjb1wiLCBcIkdyaWZvbmlcIiwgXCJHcmlsbG9cIiwgXCJHcmltYWxkaVwiLCBcIkdyb3NzaVwiLCBcIkd1YWx0aWVyaVwiLCBcIkd1YXJkdWNjaVwiLCBcIkd1YXJpbm9cIiwgXCJHdWFybmllcmlcIiwgXCJHdWFzdGlcIiwgXCJHdWVycmFcIiwgXCJHdWVycmlcIiwgXCJHdWVycmluaVwiLCBcIkd1aWRpXCIsIFwiR3VpZG90dGlcIiwgXCJIZVwiLCBcIkhveGhhXCIsIFwiSHVcIiwgXCJIdWFuZ1wiLCBcIklhbmRlbGxpXCIsIFwiSWduZXN0aVwiLCBcIklubm9jZW50aVwiLCBcIkppblwiLCBcIkxhIFJvc2FcIiwgXCJMYWlcIiwgXCJMYW5kaVwiLCBcIkxhbmRpbmlcIiwgXCJMYW5pbmlcIiwgXCJMYXBpXCIsIFwiTGFwaW5pXCIsIFwiTGFyaVwiLCBcIkxhc2NpYWxmYXJpXCIsIFwiTGFzdHJ1Y2NpXCIsIFwiTGF0aW5pXCIsIFwiTGF6emVyaVwiLCBcIkxhenplcmluaVwiLCBcIkxlbGxpXCIsIFwiTGVuemlcIiwgXCJMZW9uYXJkaVwiLCBcIkxlb25jaW5pXCIsIFwiTGVvbmVcIiwgXCJMZW9uaVwiLCBcIkxlcHJpXCIsIFwiTGlcIiwgXCJMaWFvXCIsIFwiTGluXCIsIFwiTGluYXJpXCIsIFwiTGlwcGlcIiwgXCJMaXNpXCIsIFwiTGl2aVwiLCBcIkxvbWJhcmRpXCIsIFwiTG9tYmFyZGluaVwiLCBcIkxvbWJhcmRvXCIsIFwiTG9uZ29cIiwgXCJMb3BlelwiLCBcIkxvcmVuemlcIiwgXCJMb3JlbnppbmlcIiwgXCJMb3JpbmlcIiwgXCJMb3R0aVwiLCBcIkx1XCIsIFwiTHVjY2hlc2lcIiwgXCJMdWNoZXJpbmlcIiwgXCJMdW5naGlcIiwgXCJMdXBpXCIsIFwiTWFkaWFpXCIsIFwiTWFlc3RyaW5pXCIsIFwiTWFmZmVpXCIsIFwiTWFnZ2lcIiwgXCJNYWdnaW5pXCIsIFwiTWFnaGVyaW5pXCIsIFwiTWFnaW5pXCIsIFwiTWFnbmFuaVwiLCBcIk1hZ25lbGxpXCIsIFwiTWFnbmlcIiwgXCJNYWdub2xmaVwiLCBcIk1hZ3JpbmlcIiwgXCJNYWxhdm9sdGlcIiwgXCJNYWxldm9sdGlcIiwgXCJNYW5jYVwiLCBcIk1hbmNpbmlcIiwgXCJNYW5ldHRpXCIsIFwiTWFuZnJlZGlcIiwgXCJNYW5nYW5pXCIsIFwiTWFubmVsbGlcIiwgXCJNYW5uaVwiLCBcIk1hbm5pbmlcIiwgXCJNYW5udWNjaVwiLCBcIk1hbnVlbGxpXCIsIFwiTWFuemluaVwiLCBcIk1hcmNlbGxpXCIsIFwiTWFyY2hlc2VcIiwgXCJNYXJjaGV0dGlcIiwgXCJNYXJjaGlcIiwgXCJNYXJjaGlhbmlcIiwgXCJNYXJjaGlvbm5pXCIsIFwiTWFyY29uaVwiLCBcIk1hcmN1Y2NpXCIsIFwiTWFyZ2hlcmlcIiwgXCJNYXJpXCIsIFwiTWFyaWFuaVwiLCBcIk1hcmlsbGlcIiwgXCJNYXJpbmFpXCIsIFwiTWFyaW5hcmlcIiwgXCJNYXJpbmVsbGlcIiwgXCJNYXJpbmlcIiwgXCJNYXJpbm9cIiwgXCJNYXJpb3R0aVwiLCBcIk1hcnNpbGlcIiwgXCJNYXJ0ZWxsaVwiLCBcIk1hcnRpbmVsbGlcIiwgXCJNYXJ0aW5pXCIsIFwiTWFydGlub1wiLCBcIk1hcnppXCIsIFwiTWFzaVwiLCBcIk1hc2luaVwiLCBcIk1hc29uaVwiLCBcIk1hc3NhaVwiLCBcIk1hdGVyYXNzaVwiLCBcIk1hdHRlaVwiLCBcIk1hdHRlaW5pXCIsIFwiTWF0dGV1Y2NpXCIsIFwiTWF0dGV1enppXCIsIFwiTWF0dGlvbGlcIiwgXCJNYXR0b2xpbmlcIiwgXCJNYXR1Y2NpXCIsIFwiTWF1cm9cIiwgXCJNYXp6YW50aVwiLCBcIk1henplaVwiLCBcIk1henpldHRpXCIsIFwiTWF6emlcIiwgXCJNYXp6aW5pXCIsIFwiTWF6em9jY2hpXCIsIFwiTWF6em9saVwiLCBcIk1henpvbmlcIiwgXCJNYXp6dW9saVwiLCBcIk1lYWNjaVwiLCBcIk1lY29jY2lcIiwgXCJNZWluaVwiLCBcIk1lbGFuaVwiLCBcIk1lbGVcIiwgXCJNZWxpXCIsIFwiTWVuZ29uaVwiLCBcIk1lbmljaGV0dGlcIiwgXCJNZW9uaVwiLCBcIk1lcmxpbmlcIiwgXCJNZXNzZXJpXCIsIFwiTWVzc2luYVwiLCBcIk1ldWNjaVwiLCBcIk1pY2NpbmVzaVwiLCBcIk1pY2VsaVwiLCBcIk1pY2hlbGlcIiwgXCJNaWNoZWxpbmlcIiwgXCJNaWNoZWxvenppXCIsIFwiTWlnbGlvcmlcIiwgXCJNaWdsaW9yaW5pXCIsIFwiTWlsYW5pXCIsIFwiTWluaWF0aVwiLCBcIk1pc3VyaVwiLCBcIk1vbmFjb1wiLCBcIk1vbnRhZ25hbmlcIiwgXCJNb250YWduaVwiLCBcIk1vbnRhbmFyaVwiLCBcIk1vbnRlbGF0aWNpXCIsIFwiTW9udGlcIiwgXCJNb250aWdpYW5pXCIsIFwiTW9udGluaVwiLCBcIk1vcmFuZGlcIiwgXCJNb3JhbmRpbmlcIiwgXCJNb3JlbGxpXCIsIFwiTW9yZXR0aVwiLCBcIk1vcmdhbnRpXCIsIFwiTW9yaVwiLCBcIk1vcmluaVwiLCBcIk1vcm9uaVwiLCBcIk1vcm96emlcIiwgXCJNdWduYWlcIiwgXCJNdWduYWluaVwiLCBcIk11c3RhZmFcIiwgXCJOYWxkaVwiLCBcIk5hbGRpbmlcIiwgXCJOYW5uZWxsaVwiLCBcIk5hbm5pXCIsIFwiTmFubmluaVwiLCBcIk5hbm51Y2NpXCIsIFwiTmFyZGlcIiwgXCJOYXJkaW5pXCIsIFwiTmFyZG9uaVwiLCBcIk5hdGFsaVwiLCBcIk5kaWF5ZVwiLCBcIk5lbmNldHRpXCIsIFwiTmVuY2luaVwiLCBcIk5lbmNpb25pXCIsIFwiTmVyaVwiLCBcIk5lc2lcIiwgXCJOZXN0aVwiLCBcIk5pY2NvbGFpXCIsIFwiTmljY29saVwiLCBcIk5pY2NvbGluaVwiLCBcIk5pZ2lcIiwgXCJOaXN0cmlcIiwgXCJOb2NlbnRpbmlcIiwgXCJOb2ZlcmluaVwiLCBcIk5vdmVsbGlcIiwgXCJOdWNjaVwiLCBcIk51dGlcIiwgXCJOdXRpbmlcIiwgXCJPbGl2YVwiLCBcIk9saXZpZXJpXCIsIFwiT2xtaVwiLCBcIk9ybGFuZGlcIiwgXCJPcmxhbmRpbmlcIiwgXCJPcmxhbmRvXCIsIFwiT3JzaW5pXCIsIFwiT3J0b2xhbmlcIiwgXCJPdHRhbmVsbGlcIiwgXCJQYWNjaWFuaVwiLCBcIlBhY2VcIiwgXCJQYWNpXCIsIFwiUGFjaW5pXCIsIFwiUGFnYW5pXCIsIFwiUGFnYW5vXCIsIFwiUGFnZ2V0dGlcIiwgXCJQYWdsaWFpXCIsIFwiUGFnbmlcIiwgXCJQYWduaW5pXCIsIFwiUGFsYWRpbmlcIiwgXCJQYWxhZ2lcIiwgXCJQYWxjaGV0dGlcIiwgXCJQYWxsb25pXCIsIFwiUGFsbWllcmlcIiwgXCJQYWx1bWJvXCIsIFwiUGFtcGFsb25pXCIsIFwiUGFuY2FuaVwiLCBcIlBhbmRvbGZpXCIsIFwiUGFuZG9sZmluaVwiLCBcIlBhbmVyYWlcIiwgXCJQYW5pY2hpXCIsIFwiUGFvbGV0dGlcIiwgXCJQYW9saVwiLCBcIlBhb2xpbmlcIiwgXCJQYXBpXCIsIFwiUGFwaW5pXCIsIFwiUGFwdWNjaVwiLCBcIlBhcmVudGlcIiwgXCJQYXJpZ2lcIiwgXCJQYXJpc2lcIiwgXCJQYXJyaVwiLCBcIlBhcnJpbmlcIiwgXCJQYXNxdWluaVwiLCBcIlBhc3NlcmlcIiwgXCJQZWNjaGlvbGlcIiwgXCJQZWNvcmluaVwiLCBcIlBlbGxlZ3JpbmlcIiwgXCJQZXBpXCIsIFwiUGVyaW5pXCIsIFwiUGVycm9uZVwiLCBcIlBlcnV6emlcIiwgXCJQZXNjaVwiLCBcIlBlc3RlbGxpXCIsIFwiUGV0cmlcIiwgXCJQZXRyaW5pXCIsIFwiUGV0cnVjY2lcIiwgXCJQZXR0aW5pXCIsIFwiUGV6emF0aVwiLCBcIlBlenphdGluaVwiLCBcIlBpYW5pXCIsIFwiUGlhenphXCIsIFwiUGlhenplc2lcIiwgXCJQaWF6emluaVwiLCBcIlBpY2NhcmRpXCIsIFwiUGljY2hpXCIsIFwiUGljY2luaVwiLCBcIlBpY2Npb2xpXCIsIFwiUGllcmFjY2luaVwiLCBcIlBpZXJhY2Npb25pXCIsIFwiUGllcmFsbGlcIiwgXCJQaWVyYXR0aW5pXCIsIFwiUGllcmlcIiwgXCJQaWVyaW5pXCIsIFwiUGllcm9uaVwiLCBcIlBpZXRyaW5pXCIsIFwiUGluaVwiLCBcIlBpbm5hXCIsIFwiUGludG9cIiwgXCJQaW56YW5pXCIsIFwiUGluemF1dGlcIiwgXCJQaXJhc1wiLCBcIlBpc2FuaVwiLCBcIlBpc3RvbGVzaVwiLCBcIlBvZ2dlc2lcIiwgXCJQb2dnaVwiLCBcIlBvZ2dpYWxpXCIsIFwiUG9nZ2lvbGluaVwiLCBcIlBvbGlcIiwgXCJQb2xsYXN0cmlcIiwgXCJQb3JjaWFuaVwiLCBcIlBvenppXCIsIFwiUHJhdGVsbGVzaVwiLCBcIlByYXRlc2lcIiwgXCJQcm9zcGVyaVwiLCBcIlBydW5ldGlcIiwgXCJQdWNjaVwiLCBcIlB1Y2NpbmlcIiwgXCJQdWNjaW9uaVwiLCBcIlB1Z2lcIiwgXCJQdWdsaWVzZVwiLCBcIlB1bGl0aVwiLCBcIlF1ZXJjaVwiLCBcIlF1ZXJjaW9saVwiLCBcIlJhZGRpXCIsIFwiUmFkdVwiLCBcIlJhZmZhZWxsaVwiLCBcIlJhZ2F6emluaVwiLCBcIlJhbmZhZ25pXCIsIFwiUmFuaWVyaVwiLCBcIlJhc3RyZWxsaVwiLCBcIlJhdWdlaVwiLCBcIlJhdmVnZ2lcIiwgXCJSZW5haVwiLCBcIlJlbnppXCIsIFwiUmV0dG9yaVwiLCBcIlJpY2NpXCIsIFwiUmljY2lhcmRpXCIsIFwiUmlkaVwiLCBcIlJpZG9sZmlcIiwgXCJSaWdhY2NpXCIsIFwiUmlnaGlcIiwgXCJSaWdoaW5pXCIsIFwiUmluYWxkaVwiLCBcIlJpc2FsaXRpXCIsIFwiUmlzdG9yaVwiLCBcIlJpenpvXCIsIFwiUm9jY2hpXCIsIFwiUm9jY2hpbmlcIiwgXCJSb2dhaVwiLCBcIlJvbWFnbm9saVwiLCBcIlJvbWFuZWxsaVwiLCBcIlJvbWFuaVwiLCBcIlJvbWFub1wiLCBcIlJvbWVpXCIsIFwiUm9tZW9cIiwgXCJSb21pdGlcIiwgXCJSb21vbGlcIiwgXCJSb21vbGluaVwiLCBcIlJvbnRpbmlcIiwgXCJSb3NhdGlcIiwgXCJSb3NlbGxpXCIsIFwiUm9zaVwiLCBcIlJvc3NldHRpXCIsIFwiUm9zc2lcIiwgXCJSb3NzaW5pXCIsIFwiUm92YWlcIiwgXCJSdWdnZXJpXCIsIFwiUnVnZ2llcm9cIiwgXCJSdXNzb1wiLCBcIlNhYmF0aW5pXCIsIFwiU2FjY2FyZGlcIiwgXCJTYWNjaGV0dGlcIiwgXCJTYWNjaGlcIiwgXCJTYWNjb1wiLCBcIlNhbGVybm9cIiwgXCJTYWxpbWJlbmlcIiwgXCJTYWx1Y2NpXCIsIFwiU2FsdmFkb3JpXCIsIFwiU2FsdmVzdHJpbmlcIiwgXCJTYWx2aVwiLCBcIlNhbHZpbmlcIiwgXCJTYW5lc2lcIiwgXCJTYW5pXCIsIFwiU2FubmFcIiwgXCJTYW50aVwiLCBcIlNhbnRpbmlcIiwgXCJTYW50b25pXCIsIFwiU2FudG9yb1wiLCBcIlNhbnR1Y2NpXCIsIFwiU2FyZGlcIiwgXCJTYXJyaVwiLCBcIlNhcnRpXCIsIFwiU2Fzc2lcIiwgXCJTYm9sY2lcIiwgXCJTY2FsaVwiLCBcIlNjYXJwZWxsaVwiLCBcIlNjYXJzZWxsaVwiLCBcIlNjb3BldGFuaVwiLCBcIlNlY2NpXCIsIFwiU2VsdmlcIiwgXCJTZW5hdG9yaVwiLCBcIlNlbmVzaVwiLCBcIlNlcmFmaW5pXCIsIFwiU2VyZW5pXCIsIFwiU2VycmFcIiwgXCJTZXN0aW5pXCIsIFwiU2d1YW5jaVwiLCBcIlNpZW5pXCIsIFwiU2lnbm9yaW5pXCIsIFwiU2lsdmVzdHJpXCIsIFwiU2ltb25jaW5pXCIsIFwiU2ltb25ldHRpXCIsIFwiU2ltb25pXCIsIFwiU2luZ2hcIiwgXCJTb2RpXCIsIFwiU29sZGlcIiwgXCJTb21pZ2xpXCIsIFwiU29yYmlcIiwgXCJTb3JlbGxpXCIsIFwiU29ycmVudGlub1wiLCBcIlNvdHRpbGlcIiwgXCJTcGluYVwiLCBcIlNwaW5lbGxpXCIsIFwiU3RhY2Npb2xpXCIsIFwiU3RhZGVyaW5pXCIsIFwiU3RlZmFuZWxsaVwiLCBcIlN0ZWZhbmlcIiwgXCJTdGVmYW5pbmlcIiwgXCJTdGVsbGFcIiwgXCJTdXNpbmlcIiwgXCJUYWNjaGlcIiwgXCJUYWNjb25pXCIsIFwiVGFkZGVpXCIsIFwiVGFnbGlhZmVycmlcIiwgXCJUYW1idXJpbmlcIiwgXCJUYW5nYW5lbGxpXCIsIFwiVGFuaVwiLCBcIlRhbmluaVwiLCBcIlRhcGluYXNzaVwiLCBcIlRhcmNoaVwiLCBcIlRhcmNoaWFuaVwiLCBcIlRhcmdpb25pXCIsIFwiVGFzc2lcIiwgXCJUYXNzaW5pXCIsIFwiVGVtcGVzdGlcIiwgXCJUZXJ6YW5pXCIsIFwiVGVzaVwiLCBcIlRlc3RhXCIsIFwiVGVzdGlcIiwgXCJUaWxsaVwiLCBcIlRpbnRpXCIsIFwiVGlyaW5uYW56aVwiLCBcIlRvY2NhZm9uZGlcIiwgXCJUb2ZhbmFyaVwiLCBcIlRvZmFuaVwiLCBcIlRvZ25hY2NpbmlcIiwgXCJUb25lbGxpXCIsIFwiVG9uaW5pXCIsIFwiVG9yZWxsaVwiLCBcIlRvcnJpbmlcIiwgXCJUb3NpXCIsIFwiVG90aVwiLCBcIlRvenppXCIsIFwiVHJhbWJ1c3RpXCIsIFwiVHJhcGFuaVwiLCBcIlR1Y2NpXCIsIFwiVHVyY2hpXCIsIFwiVWdvbGluaVwiLCBcIlVsaXZpXCIsIFwiVmFsZW50ZVwiLCBcIlZhbGVudGlcIiwgXCJWYWxlbnRpbmlcIiwgXCJWYW5nZWxpc3RpXCIsIFwiVmFubmlcIiwgXCJWYW5uaW5pXCIsIFwiVmFubm9uaVwiLCBcIlZhbm5venppXCIsIFwiVmFubnVjY2hpXCIsIFwiVmFubnVjY2lcIiwgXCJWZW50dXJhXCIsIFwiVmVudHVyaVwiLCBcIlZlbnR1cmluaVwiLCBcIlZlc3RyaVwiLCBcIlZldHRvcmlcIiwgXCJWaWNoaVwiLCBcIlZpY2lhbmlcIiwgXCJWaWVyaVwiLCBcIlZpZ2lhbmlcIiwgXCJWaWdub2xpXCIsIFwiVmlnbm9saW5pXCIsIFwiVmlnbm96emlcIiwgXCJWaWxsYW5pXCIsIFwiVmluY2lcIiwgXCJWaXNhbmlcIiwgXCJWaXRhbGVcIiwgXCJWaXRhbGlcIiwgXCJWaXRpXCIsIFwiVml2aWFuaVwiLCBcIlZpdm9saVwiLCBcIlZvbHBlXCIsIFwiVm9scGlcIiwgXCJXYW5nXCIsIFwiV3VcIiwgXCJYdVwiLCBcIllhbmdcIiwgXCJZZVwiLCBcIlphZ2xpXCIsIFwiWmFuaVwiLCBcIlphbmllcmlcIiwgXCJaYW5vYmluaVwiLCBcIlplY2NoaVwiLCBcIlpldHRpXCIsIFwiWmhhbmdcIiwgXCJaaGVuZ1wiLCBcIlpob3VcIiwgXCJaaHVcIiwgXCJaaW5nb25pXCIsIFwiWmluaVwiLCBcIlpvcHBpXCJdXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRGF0YSB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS91bXBpcnNreS9jb3VudHJ5LWxpc3QvYmxvYi9tYXN0ZXIvZGF0YS9lbl9VUy9jb3VudHJ5Lmpzb25cbiAgICAgICAgY291bnRyaWVzOiBbe1wibmFtZVwiOlwiQWZnaGFuaXN0YW5cIixcImFiYnJldmlhdGlvblwiOlwiQUZcIn0se1wibmFtZVwiOlwiw4VsYW5kIElzbGFuZHNcIixcImFiYnJldmlhdGlvblwiOlwiQVhcIn0se1wibmFtZVwiOlwiQWxiYW5pYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJBTFwifSx7XCJuYW1lXCI6XCJBbGdlcmlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkRaXCJ9LHtcIm5hbWVcIjpcIkFtZXJpY2FuIFNhbW9hXCIsXCJhYmJyZXZpYXRpb25cIjpcIkFTXCJ9LHtcIm5hbWVcIjpcIkFuZG9ycmFcIixcImFiYnJldmlhdGlvblwiOlwiQURcIn0se1wibmFtZVwiOlwiQW5nb2xhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkFPXCJ9LHtcIm5hbWVcIjpcIkFuZ3VpbGxhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkFJXCJ9LHtcIm5hbWVcIjpcIkFudGFyY3RpY2FcIixcImFiYnJldmlhdGlvblwiOlwiQVFcIn0se1wibmFtZVwiOlwiQW50aWd1YSAmIEJhcmJ1ZGFcIixcImFiYnJldmlhdGlvblwiOlwiQUdcIn0se1wibmFtZVwiOlwiQXJnZW50aW5hXCIsXCJhYmJyZXZpYXRpb25cIjpcIkFSXCJ9LHtcIm5hbWVcIjpcIkFybWVuaWFcIixcImFiYnJldmlhdGlvblwiOlwiQU1cIn0se1wibmFtZVwiOlwiQXJ1YmFcIixcImFiYnJldmlhdGlvblwiOlwiQVdcIn0se1wibmFtZVwiOlwiQXNjZW5zaW9uIElzbGFuZFwiLFwiYWJicmV2aWF0aW9uXCI6XCJBQ1wifSx7XCJuYW1lXCI6XCJBdXN0cmFsaWFcIixcImFiYnJldmlhdGlvblwiOlwiQVVcIn0se1wibmFtZVwiOlwiQXVzdHJpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJBVFwifSx7XCJuYW1lXCI6XCJBemVyYmFpamFuXCIsXCJhYmJyZXZpYXRpb25cIjpcIkFaXCJ9LHtcIm5hbWVcIjpcIkJhaGFtYXNcIixcImFiYnJldmlhdGlvblwiOlwiQlNcIn0se1wibmFtZVwiOlwiQmFocmFpblwiLFwiYWJicmV2aWF0aW9uXCI6XCJCSFwifSx7XCJuYW1lXCI6XCJCYW5nbGFkZXNoXCIsXCJhYmJyZXZpYXRpb25cIjpcIkJEXCJ9LHtcIm5hbWVcIjpcIkJhcmJhZG9zXCIsXCJhYmJyZXZpYXRpb25cIjpcIkJCXCJ9LHtcIm5hbWVcIjpcIkJlbGFydXNcIixcImFiYnJldmlhdGlvblwiOlwiQllcIn0se1wibmFtZVwiOlwiQmVsZ2l1bVwiLFwiYWJicmV2aWF0aW9uXCI6XCJCRVwifSx7XCJuYW1lXCI6XCJCZWxpemVcIixcImFiYnJldmlhdGlvblwiOlwiQlpcIn0se1wibmFtZVwiOlwiQmVuaW5cIixcImFiYnJldmlhdGlvblwiOlwiQkpcIn0se1wibmFtZVwiOlwiQmVybXVkYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJCTVwifSx7XCJuYW1lXCI6XCJCaHV0YW5cIixcImFiYnJldmlhdGlvblwiOlwiQlRcIn0se1wibmFtZVwiOlwiQm9saXZpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJCT1wifSx7XCJuYW1lXCI6XCJCb3NuaWEgJiBIZXJ6ZWdvdmluYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJCQVwifSx7XCJuYW1lXCI6XCJCb3Rzd2FuYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJCV1wifSx7XCJuYW1lXCI6XCJCcmF6aWxcIixcImFiYnJldmlhdGlvblwiOlwiQlJcIn0se1wibmFtZVwiOlwiQnJpdGlzaCBJbmRpYW4gT2NlYW4gVGVycml0b3J5XCIsXCJhYmJyZXZpYXRpb25cIjpcIklPXCJ9LHtcIm5hbWVcIjpcIkJyaXRpc2ggVmlyZ2luIElzbGFuZHNcIixcImFiYnJldmlhdGlvblwiOlwiVkdcIn0se1wibmFtZVwiOlwiQnJ1bmVpXCIsXCJhYmJyZXZpYXRpb25cIjpcIkJOXCJ9LHtcIm5hbWVcIjpcIkJ1bGdhcmlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkJHXCJ9LHtcIm5hbWVcIjpcIkJ1cmtpbmEgRmFzb1wiLFwiYWJicmV2aWF0aW9uXCI6XCJCRlwifSx7XCJuYW1lXCI6XCJCdXJ1bmRpXCIsXCJhYmJyZXZpYXRpb25cIjpcIkJJXCJ9LHtcIm5hbWVcIjpcIkNhbWJvZGlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIktIXCJ9LHtcIm5hbWVcIjpcIkNhbWVyb29uXCIsXCJhYmJyZXZpYXRpb25cIjpcIkNNXCJ9LHtcIm5hbWVcIjpcIkNhbmFkYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJDQVwifSx7XCJuYW1lXCI6XCJDYW5hcnkgSXNsYW5kc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJJQ1wifSx7XCJuYW1lXCI6XCJDYXBlIFZlcmRlXCIsXCJhYmJyZXZpYXRpb25cIjpcIkNWXCJ9LHtcIm5hbWVcIjpcIkNhcmliYmVhbiBOZXRoZXJsYW5kc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJCUVwifSx7XCJuYW1lXCI6XCJDYXltYW4gSXNsYW5kc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJLWVwifSx7XCJuYW1lXCI6XCJDZW50cmFsIEFmcmljYW4gUmVwdWJsaWNcIixcImFiYnJldmlhdGlvblwiOlwiQ0ZcIn0se1wibmFtZVwiOlwiQ2V1dGEgJiBNZWxpbGxhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkVBXCJ9LHtcIm5hbWVcIjpcIkNoYWRcIixcImFiYnJldmlhdGlvblwiOlwiVERcIn0se1wibmFtZVwiOlwiQ2hpbGVcIixcImFiYnJldmlhdGlvblwiOlwiQ0xcIn0se1wibmFtZVwiOlwiQ2hpbmFcIixcImFiYnJldmlhdGlvblwiOlwiQ05cIn0se1wibmFtZVwiOlwiQ2hyaXN0bWFzIElzbGFuZFwiLFwiYWJicmV2aWF0aW9uXCI6XCJDWFwifSx7XCJuYW1lXCI6XCJDb2NvcyAoS2VlbGluZykgSXNsYW5kc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJDQ1wifSx7XCJuYW1lXCI6XCJDb2xvbWJpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJDT1wifSx7XCJuYW1lXCI6XCJDb21vcm9zXCIsXCJhYmJyZXZpYXRpb25cIjpcIktNXCJ9LHtcIm5hbWVcIjpcIkNvbmdvIC0gQnJhenphdmlsbGVcIixcImFiYnJldmlhdGlvblwiOlwiQ0dcIn0se1wibmFtZVwiOlwiQ29uZ28gLSBLaW5zaGFzYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJDRFwifSx7XCJuYW1lXCI6XCJDb29rIElzbGFuZHNcIixcImFiYnJldmlhdGlvblwiOlwiQ0tcIn0se1wibmFtZVwiOlwiQ29zdGEgUmljYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJDUlwifSx7XCJuYW1lXCI6XCJDw7R0ZSBkJ0l2b2lyZVwiLFwiYWJicmV2aWF0aW9uXCI6XCJDSVwifSx7XCJuYW1lXCI6XCJDcm9hdGlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkhSXCJ9LHtcIm5hbWVcIjpcIkN1YmFcIixcImFiYnJldmlhdGlvblwiOlwiQ1VcIn0se1wibmFtZVwiOlwiQ3VyYcOnYW9cIixcImFiYnJldmlhdGlvblwiOlwiQ1dcIn0se1wibmFtZVwiOlwiQ3lwcnVzXCIsXCJhYmJyZXZpYXRpb25cIjpcIkNZXCJ9LHtcIm5hbWVcIjpcIkN6ZWNoIFJlcHVibGljXCIsXCJhYmJyZXZpYXRpb25cIjpcIkNaXCJ9LHtcIm5hbWVcIjpcIkRlbm1hcmtcIixcImFiYnJldmlhdGlvblwiOlwiREtcIn0se1wibmFtZVwiOlwiRGllZ28gR2FyY2lhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkRHXCJ9LHtcIm5hbWVcIjpcIkRqaWJvdXRpXCIsXCJhYmJyZXZpYXRpb25cIjpcIkRKXCJ9LHtcIm5hbWVcIjpcIkRvbWluaWNhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkRNXCJ9LHtcIm5hbWVcIjpcIkRvbWluaWNhbiBSZXB1YmxpY1wiLFwiYWJicmV2aWF0aW9uXCI6XCJET1wifSx7XCJuYW1lXCI6XCJFY3VhZG9yXCIsXCJhYmJyZXZpYXRpb25cIjpcIkVDXCJ9LHtcIm5hbWVcIjpcIkVneXB0XCIsXCJhYmJyZXZpYXRpb25cIjpcIkVHXCJ9LHtcIm5hbWVcIjpcIkVsIFNhbHZhZG9yXCIsXCJhYmJyZXZpYXRpb25cIjpcIlNWXCJ9LHtcIm5hbWVcIjpcIkVxdWF0b3JpYWwgR3VpbmVhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkdRXCJ9LHtcIm5hbWVcIjpcIkVyaXRyZWFcIixcImFiYnJldmlhdGlvblwiOlwiRVJcIn0se1wibmFtZVwiOlwiRXN0b25pYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJFRVwifSx7XCJuYW1lXCI6XCJFdGhpb3BpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJFVFwifSx7XCJuYW1lXCI6XCJGYWxrbGFuZCBJc2xhbmRzXCIsXCJhYmJyZXZpYXRpb25cIjpcIkZLXCJ9LHtcIm5hbWVcIjpcIkZhcm9lIElzbGFuZHNcIixcImFiYnJldmlhdGlvblwiOlwiRk9cIn0se1wibmFtZVwiOlwiRmlqaVwiLFwiYWJicmV2aWF0aW9uXCI6XCJGSlwifSx7XCJuYW1lXCI6XCJGaW5sYW5kXCIsXCJhYmJyZXZpYXRpb25cIjpcIkZJXCJ9LHtcIm5hbWVcIjpcIkZyYW5jZVwiLFwiYWJicmV2aWF0aW9uXCI6XCJGUlwifSx7XCJuYW1lXCI6XCJGcmVuY2ggR3VpYW5hXCIsXCJhYmJyZXZpYXRpb25cIjpcIkdGXCJ9LHtcIm5hbWVcIjpcIkZyZW5jaCBQb2x5bmVzaWFcIixcImFiYnJldmlhdGlvblwiOlwiUEZcIn0se1wibmFtZVwiOlwiRnJlbmNoIFNvdXRoZXJuIFRlcnJpdG9yaWVzXCIsXCJhYmJyZXZpYXRpb25cIjpcIlRGXCJ9LHtcIm5hbWVcIjpcIkdhYm9uXCIsXCJhYmJyZXZpYXRpb25cIjpcIkdBXCJ9LHtcIm5hbWVcIjpcIkdhbWJpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJHTVwifSx7XCJuYW1lXCI6XCJHZW9yZ2lhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkdFXCJ9LHtcIm5hbWVcIjpcIkdlcm1hbnlcIixcImFiYnJldmlhdGlvblwiOlwiREVcIn0se1wibmFtZVwiOlwiR2hhbmFcIixcImFiYnJldmlhdGlvblwiOlwiR0hcIn0se1wibmFtZVwiOlwiR2licmFsdGFyXCIsXCJhYmJyZXZpYXRpb25cIjpcIkdJXCJ9LHtcIm5hbWVcIjpcIkdyZWVjZVwiLFwiYWJicmV2aWF0aW9uXCI6XCJHUlwifSx7XCJuYW1lXCI6XCJHcmVlbmxhbmRcIixcImFiYnJldmlhdGlvblwiOlwiR0xcIn0se1wibmFtZVwiOlwiR3JlbmFkYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJHRFwifSx7XCJuYW1lXCI6XCJHdWFkZWxvdXBlXCIsXCJhYmJyZXZpYXRpb25cIjpcIkdQXCJ9LHtcIm5hbWVcIjpcIkd1YW1cIixcImFiYnJldmlhdGlvblwiOlwiR1VcIn0se1wibmFtZVwiOlwiR3VhdGVtYWxhXCIsXCJhYmJyZXZpYXRpb25cIjpcIkdUXCJ9LHtcIm5hbWVcIjpcIkd1ZXJuc2V5XCIsXCJhYmJyZXZpYXRpb25cIjpcIkdHXCJ9LHtcIm5hbWVcIjpcIkd1aW5lYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJHTlwifSx7XCJuYW1lXCI6XCJHdWluZWEtQmlzc2F1XCIsXCJhYmJyZXZpYXRpb25cIjpcIkdXXCJ9LHtcIm5hbWVcIjpcIkd1eWFuYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJHWVwifSx7XCJuYW1lXCI6XCJIYWl0aVwiLFwiYWJicmV2aWF0aW9uXCI6XCJIVFwifSx7XCJuYW1lXCI6XCJIb25kdXJhc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJITlwifSx7XCJuYW1lXCI6XCJIb25nIEtvbmcgU0FSIENoaW5hXCIsXCJhYmJyZXZpYXRpb25cIjpcIkhLXCJ9LHtcIm5hbWVcIjpcIkh1bmdhcnlcIixcImFiYnJldmlhdGlvblwiOlwiSFVcIn0se1wibmFtZVwiOlwiSWNlbGFuZFwiLFwiYWJicmV2aWF0aW9uXCI6XCJJU1wifSx7XCJuYW1lXCI6XCJJbmRpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJJTlwifSx7XCJuYW1lXCI6XCJJbmRvbmVzaWFcIixcImFiYnJldmlhdGlvblwiOlwiSURcIn0se1wibmFtZVwiOlwiSXJhblwiLFwiYWJicmV2aWF0aW9uXCI6XCJJUlwifSx7XCJuYW1lXCI6XCJJcmFxXCIsXCJhYmJyZXZpYXRpb25cIjpcIklRXCJ9LHtcIm5hbWVcIjpcIklyZWxhbmRcIixcImFiYnJldmlhdGlvblwiOlwiSUVcIn0se1wibmFtZVwiOlwiSXNsZSBvZiBNYW5cIixcImFiYnJldmlhdGlvblwiOlwiSU1cIn0se1wibmFtZVwiOlwiSXNyYWVsXCIsXCJhYmJyZXZpYXRpb25cIjpcIklMXCJ9LHtcIm5hbWVcIjpcIkl0YWx5XCIsXCJhYmJyZXZpYXRpb25cIjpcIklUXCJ9LHtcIm5hbWVcIjpcIkphbWFpY2FcIixcImFiYnJldmlhdGlvblwiOlwiSk1cIn0se1wibmFtZVwiOlwiSmFwYW5cIixcImFiYnJldmlhdGlvblwiOlwiSlBcIn0se1wibmFtZVwiOlwiSmVyc2V5XCIsXCJhYmJyZXZpYXRpb25cIjpcIkpFXCJ9LHtcIm5hbWVcIjpcIkpvcmRhblwiLFwiYWJicmV2aWF0aW9uXCI6XCJKT1wifSx7XCJuYW1lXCI6XCJLYXpha2hzdGFuXCIsXCJhYmJyZXZpYXRpb25cIjpcIktaXCJ9LHtcIm5hbWVcIjpcIktlbnlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIktFXCJ9LHtcIm5hbWVcIjpcIktpcmliYXRpXCIsXCJhYmJyZXZpYXRpb25cIjpcIktJXCJ9LHtcIm5hbWVcIjpcIktvc292b1wiLFwiYWJicmV2aWF0aW9uXCI6XCJYS1wifSx7XCJuYW1lXCI6XCJLdXdhaXRcIixcImFiYnJldmlhdGlvblwiOlwiS1dcIn0se1wibmFtZVwiOlwiS3lyZ3l6c3RhblwiLFwiYWJicmV2aWF0aW9uXCI6XCJLR1wifSx7XCJuYW1lXCI6XCJMYW9zXCIsXCJhYmJyZXZpYXRpb25cIjpcIkxBXCJ9LHtcIm5hbWVcIjpcIkxhdHZpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJMVlwifSx7XCJuYW1lXCI6XCJMZWJhbm9uXCIsXCJhYmJyZXZpYXRpb25cIjpcIkxCXCJ9LHtcIm5hbWVcIjpcIkxlc290aG9cIixcImFiYnJldmlhdGlvblwiOlwiTFNcIn0se1wibmFtZVwiOlwiTGliZXJpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJMUlwifSx7XCJuYW1lXCI6XCJMaWJ5YVwiLFwiYWJicmV2aWF0aW9uXCI6XCJMWVwifSx7XCJuYW1lXCI6XCJMaWVjaHRlbnN0ZWluXCIsXCJhYmJyZXZpYXRpb25cIjpcIkxJXCJ9LHtcIm5hbWVcIjpcIkxpdGh1YW5pYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJMVFwifSx7XCJuYW1lXCI6XCJMdXhlbWJvdXJnXCIsXCJhYmJyZXZpYXRpb25cIjpcIkxVXCJ9LHtcIm5hbWVcIjpcIk1hY2F1IFNBUiBDaGluYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJNT1wifSx7XCJuYW1lXCI6XCJNYWNlZG9uaWFcIixcImFiYnJldmlhdGlvblwiOlwiTUtcIn0se1wibmFtZVwiOlwiTWFkYWdhc2NhclwiLFwiYWJicmV2aWF0aW9uXCI6XCJNR1wifSx7XCJuYW1lXCI6XCJNYWxhd2lcIixcImFiYnJldmlhdGlvblwiOlwiTVdcIn0se1wibmFtZVwiOlwiTWFsYXlzaWFcIixcImFiYnJldmlhdGlvblwiOlwiTVlcIn0se1wibmFtZVwiOlwiTWFsZGl2ZXNcIixcImFiYnJldmlhdGlvblwiOlwiTVZcIn0se1wibmFtZVwiOlwiTWFsaVwiLFwiYWJicmV2aWF0aW9uXCI6XCJNTFwifSx7XCJuYW1lXCI6XCJNYWx0YVwiLFwiYWJicmV2aWF0aW9uXCI6XCJNVFwifSx7XCJuYW1lXCI6XCJNYXJzaGFsbCBJc2xhbmRzXCIsXCJhYmJyZXZpYXRpb25cIjpcIk1IXCJ9LHtcIm5hbWVcIjpcIk1hcnRpbmlxdWVcIixcImFiYnJldmlhdGlvblwiOlwiTVFcIn0se1wibmFtZVwiOlwiTWF1cml0YW5pYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJNUlwifSx7XCJuYW1lXCI6XCJNYXVyaXRpdXNcIixcImFiYnJldmlhdGlvblwiOlwiTVVcIn0se1wibmFtZVwiOlwiTWF5b3R0ZVwiLFwiYWJicmV2aWF0aW9uXCI6XCJZVFwifSx7XCJuYW1lXCI6XCJNZXhpY29cIixcImFiYnJldmlhdGlvblwiOlwiTVhcIn0se1wibmFtZVwiOlwiTWljcm9uZXNpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJGTVwifSx7XCJuYW1lXCI6XCJNb2xkb3ZhXCIsXCJhYmJyZXZpYXRpb25cIjpcIk1EXCJ9LHtcIm5hbWVcIjpcIk1vbmFjb1wiLFwiYWJicmV2aWF0aW9uXCI6XCJNQ1wifSx7XCJuYW1lXCI6XCJNb25nb2xpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJNTlwifSx7XCJuYW1lXCI6XCJNb250ZW5lZ3JvXCIsXCJhYmJyZXZpYXRpb25cIjpcIk1FXCJ9LHtcIm5hbWVcIjpcIk1vbnRzZXJyYXRcIixcImFiYnJldmlhdGlvblwiOlwiTVNcIn0se1wibmFtZVwiOlwiTW9yb2Njb1wiLFwiYWJicmV2aWF0aW9uXCI6XCJNQVwifSx7XCJuYW1lXCI6XCJNb3phbWJpcXVlXCIsXCJhYmJyZXZpYXRpb25cIjpcIk1aXCJ9LHtcIm5hbWVcIjpcIk15YW5tYXIgKEJ1cm1hKVwiLFwiYWJicmV2aWF0aW9uXCI6XCJNTVwifSx7XCJuYW1lXCI6XCJOYW1pYmlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIk5BXCJ9LHtcIm5hbWVcIjpcIk5hdXJ1XCIsXCJhYmJyZXZpYXRpb25cIjpcIk5SXCJ9LHtcIm5hbWVcIjpcIk5lcGFsXCIsXCJhYmJyZXZpYXRpb25cIjpcIk5QXCJ9LHtcIm5hbWVcIjpcIk5ldGhlcmxhbmRzXCIsXCJhYmJyZXZpYXRpb25cIjpcIk5MXCJ9LHtcIm5hbWVcIjpcIk5ldyBDYWxlZG9uaWFcIixcImFiYnJldmlhdGlvblwiOlwiTkNcIn0se1wibmFtZVwiOlwiTmV3IFplYWxhbmRcIixcImFiYnJldmlhdGlvblwiOlwiTlpcIn0se1wibmFtZVwiOlwiTmljYXJhZ3VhXCIsXCJhYmJyZXZpYXRpb25cIjpcIk5JXCJ9LHtcIm5hbWVcIjpcIk5pZ2VyXCIsXCJhYmJyZXZpYXRpb25cIjpcIk5FXCJ9LHtcIm5hbWVcIjpcIk5pZ2VyaWFcIixcImFiYnJldmlhdGlvblwiOlwiTkdcIn0se1wibmFtZVwiOlwiTml1ZVwiLFwiYWJicmV2aWF0aW9uXCI6XCJOVVwifSx7XCJuYW1lXCI6XCJOb3Jmb2xrIElzbGFuZFwiLFwiYWJicmV2aWF0aW9uXCI6XCJORlwifSx7XCJuYW1lXCI6XCJOb3J0aCBLb3JlYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJLUFwifSx7XCJuYW1lXCI6XCJOb3J0aGVybiBNYXJpYW5hIElzbGFuZHNcIixcImFiYnJldmlhdGlvblwiOlwiTVBcIn0se1wibmFtZVwiOlwiTm9yd2F5XCIsXCJhYmJyZXZpYXRpb25cIjpcIk5PXCJ9LHtcIm5hbWVcIjpcIk9tYW5cIixcImFiYnJldmlhdGlvblwiOlwiT01cIn0se1wibmFtZVwiOlwiUGFraXN0YW5cIixcImFiYnJldmlhdGlvblwiOlwiUEtcIn0se1wibmFtZVwiOlwiUGFsYXVcIixcImFiYnJldmlhdGlvblwiOlwiUFdcIn0se1wibmFtZVwiOlwiUGFsZXN0aW5pYW4gVGVycml0b3JpZXNcIixcImFiYnJldmlhdGlvblwiOlwiUFNcIn0se1wibmFtZVwiOlwiUGFuYW1hXCIsXCJhYmJyZXZpYXRpb25cIjpcIlBBXCJ9LHtcIm5hbWVcIjpcIlBhcHVhIE5ldyBHdWluZWFcIixcImFiYnJldmlhdGlvblwiOlwiUEdcIn0se1wibmFtZVwiOlwiUGFyYWd1YXlcIixcImFiYnJldmlhdGlvblwiOlwiUFlcIn0se1wibmFtZVwiOlwiUGVydVwiLFwiYWJicmV2aWF0aW9uXCI6XCJQRVwifSx7XCJuYW1lXCI6XCJQaGlsaXBwaW5lc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJQSFwifSx7XCJuYW1lXCI6XCJQaXRjYWlybiBJc2xhbmRzXCIsXCJhYmJyZXZpYXRpb25cIjpcIlBOXCJ9LHtcIm5hbWVcIjpcIlBvbGFuZFwiLFwiYWJicmV2aWF0aW9uXCI6XCJQTFwifSx7XCJuYW1lXCI6XCJQb3J0dWdhbFwiLFwiYWJicmV2aWF0aW9uXCI6XCJQVFwifSx7XCJuYW1lXCI6XCJQdWVydG8gUmljb1wiLFwiYWJicmV2aWF0aW9uXCI6XCJQUlwifSx7XCJuYW1lXCI6XCJRYXRhclwiLFwiYWJicmV2aWF0aW9uXCI6XCJRQVwifSx7XCJuYW1lXCI6XCJSw6l1bmlvblwiLFwiYWJicmV2aWF0aW9uXCI6XCJSRVwifSx7XCJuYW1lXCI6XCJSb21hbmlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIlJPXCJ9LHtcIm5hbWVcIjpcIlJ1c3NpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJSVVwifSx7XCJuYW1lXCI6XCJSd2FuZGFcIixcImFiYnJldmlhdGlvblwiOlwiUldcIn0se1wibmFtZVwiOlwiU2Ftb2FcIixcImFiYnJldmlhdGlvblwiOlwiV1NcIn0se1wibmFtZVwiOlwiU2FuIE1hcmlub1wiLFwiYWJicmV2aWF0aW9uXCI6XCJTTVwifSx7XCJuYW1lXCI6XCJTw6NvIFRvbcOpIGFuZCBQcsOtbmNpcGVcIixcImFiYnJldmlhdGlvblwiOlwiU1RcIn0se1wibmFtZVwiOlwiU2F1ZGkgQXJhYmlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIlNBXCJ9LHtcIm5hbWVcIjpcIlNlbmVnYWxcIixcImFiYnJldmlhdGlvblwiOlwiU05cIn0se1wibmFtZVwiOlwiU2VyYmlhXCIsXCJhYmJyZXZpYXRpb25cIjpcIlJTXCJ9LHtcIm5hbWVcIjpcIlNleWNoZWxsZXNcIixcImFiYnJldmlhdGlvblwiOlwiU0NcIn0se1wibmFtZVwiOlwiU2llcnJhIExlb25lXCIsXCJhYmJyZXZpYXRpb25cIjpcIlNMXCJ9LHtcIm5hbWVcIjpcIlNpbmdhcG9yZVwiLFwiYWJicmV2aWF0aW9uXCI6XCJTR1wifSx7XCJuYW1lXCI6XCJTaW50IE1hYXJ0ZW5cIixcImFiYnJldmlhdGlvblwiOlwiU1hcIn0se1wibmFtZVwiOlwiU2xvdmFraWFcIixcImFiYnJldmlhdGlvblwiOlwiU0tcIn0se1wibmFtZVwiOlwiU2xvdmVuaWFcIixcImFiYnJldmlhdGlvblwiOlwiU0lcIn0se1wibmFtZVwiOlwiU29sb21vbiBJc2xhbmRzXCIsXCJhYmJyZXZpYXRpb25cIjpcIlNCXCJ9LHtcIm5hbWVcIjpcIlNvbWFsaWFcIixcImFiYnJldmlhdGlvblwiOlwiU09cIn0se1wibmFtZVwiOlwiU291dGggQWZyaWNhXCIsXCJhYmJyZXZpYXRpb25cIjpcIlpBXCJ9LHtcIm5hbWVcIjpcIlNvdXRoIEdlb3JnaWEgJiBTb3V0aCBTYW5kd2ljaCBJc2xhbmRzXCIsXCJhYmJyZXZpYXRpb25cIjpcIkdTXCJ9LHtcIm5hbWVcIjpcIlNvdXRoIEtvcmVhXCIsXCJhYmJyZXZpYXRpb25cIjpcIktSXCJ9LHtcIm5hbWVcIjpcIlNvdXRoIFN1ZGFuXCIsXCJhYmJyZXZpYXRpb25cIjpcIlNTXCJ9LHtcIm5hbWVcIjpcIlNwYWluXCIsXCJhYmJyZXZpYXRpb25cIjpcIkVTXCJ9LHtcIm5hbWVcIjpcIlNyaSBMYW5rYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJMS1wifSx7XCJuYW1lXCI6XCJTdC4gQmFydGjDqWxlbXlcIixcImFiYnJldmlhdGlvblwiOlwiQkxcIn0se1wibmFtZVwiOlwiU3QuIEhlbGVuYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJTSFwifSx7XCJuYW1lXCI6XCJTdC4gS2l0dHMgJiBOZXZpc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJLTlwifSx7XCJuYW1lXCI6XCJTdC4gTHVjaWFcIixcImFiYnJldmlhdGlvblwiOlwiTENcIn0se1wibmFtZVwiOlwiU3QuIE1hcnRpblwiLFwiYWJicmV2aWF0aW9uXCI6XCJNRlwifSx7XCJuYW1lXCI6XCJTdC4gUGllcnJlICYgTWlxdWVsb25cIixcImFiYnJldmlhdGlvblwiOlwiUE1cIn0se1wibmFtZVwiOlwiU3QuIFZpbmNlbnQgJiBHcmVuYWRpbmVzXCIsXCJhYmJyZXZpYXRpb25cIjpcIlZDXCJ9LHtcIm5hbWVcIjpcIlN1ZGFuXCIsXCJhYmJyZXZpYXRpb25cIjpcIlNEXCJ9LHtcIm5hbWVcIjpcIlN1cmluYW1lXCIsXCJhYmJyZXZpYXRpb25cIjpcIlNSXCJ9LHtcIm5hbWVcIjpcIlN2YWxiYXJkICYgSmFuIE1heWVuXCIsXCJhYmJyZXZpYXRpb25cIjpcIlNKXCJ9LHtcIm5hbWVcIjpcIlN3YXppbGFuZFwiLFwiYWJicmV2aWF0aW9uXCI6XCJTWlwifSx7XCJuYW1lXCI6XCJTd2VkZW5cIixcImFiYnJldmlhdGlvblwiOlwiU0VcIn0se1wibmFtZVwiOlwiU3dpdHplcmxhbmRcIixcImFiYnJldmlhdGlvblwiOlwiQ0hcIn0se1wibmFtZVwiOlwiU3lyaWFcIixcImFiYnJldmlhdGlvblwiOlwiU1lcIn0se1wibmFtZVwiOlwiVGFpd2FuXCIsXCJhYmJyZXZpYXRpb25cIjpcIlRXXCJ9LHtcIm5hbWVcIjpcIlRhamlraXN0YW5cIixcImFiYnJldmlhdGlvblwiOlwiVEpcIn0se1wibmFtZVwiOlwiVGFuemFuaWFcIixcImFiYnJldmlhdGlvblwiOlwiVFpcIn0se1wibmFtZVwiOlwiVGhhaWxhbmRcIixcImFiYnJldmlhdGlvblwiOlwiVEhcIn0se1wibmFtZVwiOlwiVGltb3ItTGVzdGVcIixcImFiYnJldmlhdGlvblwiOlwiVExcIn0se1wibmFtZVwiOlwiVG9nb1wiLFwiYWJicmV2aWF0aW9uXCI6XCJUR1wifSx7XCJuYW1lXCI6XCJUb2tlbGF1XCIsXCJhYmJyZXZpYXRpb25cIjpcIlRLXCJ9LHtcIm5hbWVcIjpcIlRvbmdhXCIsXCJhYmJyZXZpYXRpb25cIjpcIlRPXCJ9LHtcIm5hbWVcIjpcIlRyaW5pZGFkICYgVG9iYWdvXCIsXCJhYmJyZXZpYXRpb25cIjpcIlRUXCJ9LHtcIm5hbWVcIjpcIlRyaXN0YW4gZGEgQ3VuaGFcIixcImFiYnJldmlhdGlvblwiOlwiVEFcIn0se1wibmFtZVwiOlwiVHVuaXNpYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJUTlwifSx7XCJuYW1lXCI6XCJUdXJrZXlcIixcImFiYnJldmlhdGlvblwiOlwiVFJcIn0se1wibmFtZVwiOlwiVHVya21lbmlzdGFuXCIsXCJhYmJyZXZpYXRpb25cIjpcIlRNXCJ9LHtcIm5hbWVcIjpcIlR1cmtzICYgQ2FpY29zIElzbGFuZHNcIixcImFiYnJldmlhdGlvblwiOlwiVENcIn0se1wibmFtZVwiOlwiVHV2YWx1XCIsXCJhYmJyZXZpYXRpb25cIjpcIlRWXCJ9LHtcIm5hbWVcIjpcIlUuUy4gT3V0bHlpbmcgSXNsYW5kc1wiLFwiYWJicmV2aWF0aW9uXCI6XCJVTVwifSx7XCJuYW1lXCI6XCJVLlMuIFZpcmdpbiBJc2xhbmRzXCIsXCJhYmJyZXZpYXRpb25cIjpcIlZJXCJ9LHtcIm5hbWVcIjpcIlVnYW5kYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJVR1wifSx7XCJuYW1lXCI6XCJVa3JhaW5lXCIsXCJhYmJyZXZpYXRpb25cIjpcIlVBXCJ9LHtcIm5hbWVcIjpcIlVuaXRlZCBBcmFiIEVtaXJhdGVzXCIsXCJhYmJyZXZpYXRpb25cIjpcIkFFXCJ9LHtcIm5hbWVcIjpcIlVuaXRlZCBLaW5nZG9tXCIsXCJhYmJyZXZpYXRpb25cIjpcIkdCXCJ9LHtcIm5hbWVcIjpcIlVuaXRlZCBTdGF0ZXNcIixcImFiYnJldmlhdGlvblwiOlwiVVNcIn0se1wibmFtZVwiOlwiVXJ1Z3VheVwiLFwiYWJicmV2aWF0aW9uXCI6XCJVWVwifSx7XCJuYW1lXCI6XCJVemJla2lzdGFuXCIsXCJhYmJyZXZpYXRpb25cIjpcIlVaXCJ9LHtcIm5hbWVcIjpcIlZhbnVhdHVcIixcImFiYnJldmlhdGlvblwiOlwiVlVcIn0se1wibmFtZVwiOlwiVmF0aWNhbiBDaXR5XCIsXCJhYmJyZXZpYXRpb25cIjpcIlZBXCJ9LHtcIm5hbWVcIjpcIlZlbmV6dWVsYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJWRVwifSx7XCJuYW1lXCI6XCJWaWV0bmFtXCIsXCJhYmJyZXZpYXRpb25cIjpcIlZOXCJ9LHtcIm5hbWVcIjpcIldhbGxpcyAmIEZ1dHVuYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJXRlwifSx7XCJuYW1lXCI6XCJXZXN0ZXJuIFNhaGFyYVwiLFwiYWJicmV2aWF0aW9uXCI6XCJFSFwifSx7XCJuYW1lXCI6XCJZZW1lblwiLFwiYWJicmV2aWF0aW9uXCI6XCJZRVwifSx7XCJuYW1lXCI6XCJaYW1iaWFcIixcImFiYnJldmlhdGlvblwiOlwiWk1cIn0se1wibmFtZVwiOlwiWmltYmFid2VcIixcImFiYnJldmlhdGlvblwiOlwiWldcIn1dLFxuXG5cdFx0Y291bnRpZXM6IHtcbiAgICAgICAgICAgIC8vIERhdGEgdGFrZW4gZnJvbSBodHRwOi8vd3d3LmRvd25sb2FkZXhjZWxmaWxlcy5jb20vZ2JfZW4vZG93bmxvYWQtZXhjZWwtZmlsZS1saXN0LWNvdW50aWVzLXVrXG4gICAgICAgICAgICBcInVrXCI6IFtcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0JhdGggYW5kIE5vcnRoIEVhc3QgU29tZXJzZXQnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0JlZGZvcmQnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0JsYWNrYnVybiB3aXRoIERhcndlbid9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnQmxhY2twb29sJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdCb3VybmVtb3V0aCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnQnJhY2tuZWxsIEZvcmVzdCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnQnJpZ2h0b24gJiBIb3ZlJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdCcmlzdG9sJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdCdWNraW5naGFtc2hpcmUnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0NhbWJyaWRnZXNoaXJlJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdDZW50cmFsIEJlZGZvcmRzaGlyZSd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnQ2hlc2hpcmUgRWFzdCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnQ2hlc2hpcmUgV2VzdCBhbmQgQ2hlc3Rlcid9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnQ29ybndhbGwnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0NvdW50eSBEdXJoYW0nfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0N1bWJyaWEnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0Rhcmxpbmd0b24nfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0RlcmJ5J30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdEZXJieXNoaXJlJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdEZXZvbid9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnRG9yc2V0J30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdFYXN0IFJpZGluZyBvZiBZb3Jrc2hpcmUnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0Vhc3QgU3Vzc2V4J30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdFc3NleCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnR2xvdWNlc3RlcnNoaXJlJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdHcmVhdGVyIExvbmRvbid9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnR3JlYXRlciBNYW5jaGVzdGVyJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdIYWx0b24nfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0hhbXBzaGlyZSd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnSGFydGxlcG9vbCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnSGVyZWZvcmRzaGlyZSd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnSGVydGZvcmRzaGlyZSd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnSHVsbCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnSXNsZSBvZiBXaWdodCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnSXNsZXMgb2YgU2NpbGx5J30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdLZW50J30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdMYW5jYXNoaXJlJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdMZWljZXN0ZXInfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0xlaWNlc3RlcnNoaXJlJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdMaW5jb2xuc2hpcmUnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0x1dG9uJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdNZWR3YXknfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ01lcnNleXNpZGUnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ01pZGRsZXNicm91Z2gnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ01pbHRvbiBLZXluZXMnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ05vcmZvbGsnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ05vcnRoIEVhc3QgTGluY29sbnNoaXJlJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdOb3J0aCBMaW5jb2xuc2hpcmUnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ05vcnRoIFNvbWVyc2V0J30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdOb3J0aCBZb3Jrc2hpcmUnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ05vcnRoYW1wdG9uc2hpcmUnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ05vcnRodW1iZXJsYW5kJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdOb3R0aW5naGFtJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdOb3R0aW5naGFtc2hpcmUnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ094Zm9yZHNoaXJlJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdQZXRlcmJvcm91Z2gnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1BseW1vdXRoJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdQb29sZSd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnUG9ydHNtb3V0aCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnUmVhZGluZyd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnUmVkY2FyIGFuZCBDbGV2ZWxhbmQnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1J1dGxhbmQnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1Nocm9wc2hpcmUnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1Nsb3VnaCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnU29tZXJzZXQnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1NvdXRoIEdsb3VjZXN0ZXJzaGlyZSd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnU291dGggWW9ya3NoaXJlJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdTb3V0aGFtcHRvbid9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnU291dGhlbmQtb24tU2VhJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdTdGFmZm9yZHNoaXJlJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdTdG9ja3Rvbi1vbi1UZWVzJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdTdG9rZS1vbi1UcmVudCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnU3VmZm9sayd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnU3VycmV5J30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdTd2luZG9uJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdUZWxmb3JkIGFuZCBXcmVraW4nfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1RodXJyb2NrJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdUb3JiYXknfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1R5bmUgYW5kIFdlYXInfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1dhcnJpbmd0b24nfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1dhcndpY2tzaGlyZSd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnV2VzdCBCZXJrc2hpcmUnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1dlc3QgTWlkbGFuZHMnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1dlc3QgU3Vzc2V4J30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdXZXN0IFlvcmtzaGlyZSd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnV2lsdHNoaXJlJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdXaW5kc29yIGFuZCBNYWlkZW5oZWFkJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdXb2tpbmdoYW0nfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1dvcmNlc3RlcnNoaXJlJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdZb3JrJ31dXG5cdFx0XHRcdH0sXG4gICAgICAgIHByb3ZpbmNlczoge1xuICAgICAgICAgICAgXCJjYVwiOiBbXG4gICAgICAgICAgICAgICAge25hbWU6ICdBbGJlcnRhJywgYWJicmV2aWF0aW9uOiAnQUInfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0JyaXRpc2ggQ29sdW1iaWEnLCBhYmJyZXZpYXRpb246ICdCQyd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnTWFuaXRvYmEnLCBhYmJyZXZpYXRpb246ICdNQid9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnTmV3IEJydW5zd2ljaycsIGFiYnJldmlhdGlvbjogJ05CJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdOZXdmb3VuZGxhbmQgYW5kIExhYnJhZG9yJywgYWJicmV2aWF0aW9uOiAnTkwnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ05vdmEgU2NvdGlhJywgYWJicmV2aWF0aW9uOiAnTlMnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ09udGFyaW8nLCBhYmJyZXZpYXRpb246ICdPTid9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnUHJpbmNlIEVkd2FyZCBJc2xhbmQnLCBhYmJyZXZpYXRpb246ICdQRSd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnUXVlYmVjJywgYWJicmV2aWF0aW9uOiAnUUMnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1Nhc2thdGNoZXdhbicsIGFiYnJldmlhdGlvbjogJ1NLJ30sXG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgY2FzZSBjb3VsZCBiZSBtYWRlIHRoYXQgdGhlIGZvbGxvd2luZyBhcmUgbm90IGFjdHVhbGx5IHByb3ZpbmNlc1xuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgYXJlIHRlY2huaWNhbGx5IGNvbnNpZGVyZWQgXCJ0ZXJyaXRvcmllc1wiIGhvd2V2ZXIgdGhleSBhbGxcbiAgICAgICAgICAgICAgICAvLyBsb29rIHRoZSBzYW1lIG9uIGFuIGVudmVsb3BlIVxuICAgICAgICAgICAgICAgIHtuYW1lOiAnTm9ydGh3ZXN0IFRlcnJpdG9yaWVzJywgYWJicmV2aWF0aW9uOiAnTlQnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ051bmF2dXQnLCBhYmJyZXZpYXRpb246ICdOVSd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnWXVrb24nLCBhYmJyZXZpYXRpb246ICdZVCd9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJpdFwiOiBbXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkFncmlnZW50b1wiLCBhYmJyZXZpYXRpb246IFwiQUdcIiwgY29kZTogODQgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQWxlc3NhbmRyaWFcIiwgYWJicmV2aWF0aW9uOiBcIkFMXCIsIGNvZGU6IDYgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQW5jb25hXCIsIGFiYnJldmlhdGlvbjogXCJBTlwiLCBjb2RlOiA0MiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJBb3N0YVwiLCBhYmJyZXZpYXRpb246IFwiQU9cIiwgY29kZTogNyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJMJ0FxdWlsYVwiLCBhYmJyZXZpYXRpb246IFwiQVFcIiwgY29kZTogNjYgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQXJlenpvXCIsIGFiYnJldmlhdGlvbjogXCJBUlwiLCBjb2RlOiA1MSB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJBc2NvbGktUGljZW5vXCIsIGFiYnJldmlhdGlvbjogXCJBUFwiLCBjb2RlOiA0NCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJBc3RpXCIsIGFiYnJldmlhdGlvbjogXCJBVFwiLCBjb2RlOiA1IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkF2ZWxsaW5vXCIsIGFiYnJldmlhdGlvbjogXCJBVlwiLCBjb2RlOiA2NCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJCYXJpXCIsIGFiYnJldmlhdGlvbjogXCJCQVwiLCBjb2RlOiA3MiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJCYXJsZXR0YS1BbmRyaWEtVHJhbmlcIiwgYWJicmV2aWF0aW9uOiBcIkJUXCIsIGNvZGU6IDcyIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkJlbGx1bm9cIiwgYWJicmV2aWF0aW9uOiBcIkJMXCIsIGNvZGU6IDI1IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkJlbmV2ZW50b1wiLCBhYmJyZXZpYXRpb246IFwiQk5cIiwgY29kZTogNjIgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQmVyZ2Ftb1wiLCBhYmJyZXZpYXRpb246IFwiQkdcIiwgY29kZTogMTYgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQmllbGxhXCIsIGFiYnJldmlhdGlvbjogXCJCSVwiLCBjb2RlOiA5NiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJCb2xvZ25hXCIsIGFiYnJldmlhdGlvbjogXCJCT1wiLCBjb2RlOiAzNyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJCb2x6YW5vXCIsIGFiYnJldmlhdGlvbjogXCJCWlwiLCBjb2RlOiAyMSB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJCcmVzY2lhXCIsIGFiYnJldmlhdGlvbjogXCJCU1wiLCBjb2RlOiAxNyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJCcmluZGlzaVwiLCBhYmJyZXZpYXRpb246IFwiQlJcIiwgY29kZTogNzQgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQ2FnbGlhcmlcIiwgYWJicmV2aWF0aW9uOiBcIkNBXCIsIGNvZGU6IDkyIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkNhbHRhbmlzc2V0dGFcIiwgYWJicmV2aWF0aW9uOiBcIkNMXCIsIGNvZGU6IDg1IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkNhbXBvYmFzc29cIiwgYWJicmV2aWF0aW9uOiBcIkNCXCIsIGNvZGU6IDcwIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkNhcmJvbmlhIElnbGVzaWFzXCIsIGFiYnJldmlhdGlvbjogXCJDSVwiLCBjb2RlOiA3MCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJDYXNlcnRhXCIsIGFiYnJldmlhdGlvbjogXCJDRVwiLCBjb2RlOiA2MSB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJDYXRhbmlhXCIsIGFiYnJldmlhdGlvbjogXCJDVFwiLCBjb2RlOiA4NyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJDYXRhbnphcm9cIiwgYWJicmV2aWF0aW9uOiBcIkNaXCIsIGNvZGU6IDc5IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkNoaWV0aVwiLCBhYmJyZXZpYXRpb246IFwiQ0hcIiwgY29kZTogNjkgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQ29tb1wiLCBhYmJyZXZpYXRpb246IFwiQ09cIiwgY29kZTogMTMgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQ29zZW56YVwiLCBhYmJyZXZpYXRpb246IFwiQ1NcIiwgY29kZTogNzggfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQ3JlbW9uYVwiLCBhYmJyZXZpYXRpb246IFwiQ1JcIiwgY29kZTogMTkgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQ3JvdG9uZVwiLCBhYmJyZXZpYXRpb246IFwiS1JcIiwgY29kZTogMTAxIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkN1bmVvXCIsIGFiYnJldmlhdGlvbjogXCJDTlwiLCBjb2RlOiA0IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkVubmFcIiwgYWJicmV2aWF0aW9uOiBcIkVOXCIsIGNvZGU6IDg2IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkZlcm1vXCIsIGFiYnJldmlhdGlvbjogXCJGTVwiLCBjb2RlOiA4NiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJGZXJyYXJhXCIsIGFiYnJldmlhdGlvbjogXCJGRVwiLCBjb2RlOiAzOCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJGaXJlbnplXCIsIGFiYnJldmlhdGlvbjogXCJGSVwiLCBjb2RlOiA0OCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJGb2dnaWFcIiwgYWJicmV2aWF0aW9uOiBcIkZHXCIsIGNvZGU6IDcxIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkZvcmxpLUNlc2VuYVwiLCBhYmJyZXZpYXRpb246IFwiRkNcIiwgY29kZTogNzEgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiRnJvc2lub25lXCIsIGFiYnJldmlhdGlvbjogXCJGUlwiLCBjb2RlOiA2MCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJHZW5vdmFcIiwgYWJicmV2aWF0aW9uOiBcIkdFXCIsIGNvZGU6IDEwIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkdvcml6aWFcIiwgYWJicmV2aWF0aW9uOiBcIkdPXCIsIGNvZGU6IDMxIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkdyb3NzZXRvXCIsIGFiYnJldmlhdGlvbjogXCJHUlwiLCBjb2RlOiA1MyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJJbXBlcmlhXCIsIGFiYnJldmlhdGlvbjogXCJJTVwiLCBjb2RlOiA4IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIklzZXJuaWFcIiwgYWJicmV2aWF0aW9uOiBcIklTXCIsIGNvZGU6IDk0IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkxhLVNwZXppYVwiLCBhYmJyZXZpYXRpb246IFwiU1BcIiwgY29kZTogNjYgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiTGF0aW5hXCIsIGFiYnJldmlhdGlvbjogXCJMVFwiLCBjb2RlOiA1OSB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJMZWNjZVwiLCBhYmJyZXZpYXRpb246IFwiTEVcIiwgY29kZTogNzUgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiTGVjY29cIiwgYWJicmV2aWF0aW9uOiBcIkxDXCIsIGNvZGU6IDk3IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkxpdm9ybm9cIiwgYWJicmV2aWF0aW9uOiBcIkxJXCIsIGNvZGU6IDQ5IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkxvZGlcIiwgYWJicmV2aWF0aW9uOiBcIkxPXCIsIGNvZGU6IDk4IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkx1Y2NhXCIsIGFiYnJldmlhdGlvbjogXCJMVVwiLCBjb2RlOiA0NiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJNYWNlcmF0YVwiLCBhYmJyZXZpYXRpb246IFwiTUNcIiwgY29kZTogNDMgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiTWFudG92YVwiLCBhYmJyZXZpYXRpb246IFwiTU5cIiwgY29kZTogMjAgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiTWFzc2EtQ2FycmFyYVwiLCBhYmJyZXZpYXRpb246IFwiTVNcIiwgY29kZTogNDUgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiTWF0ZXJhXCIsIGFiYnJldmlhdGlvbjogXCJNVFwiLCBjb2RlOiA3NyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJNZWRpbyBDYW1waWRhbm9cIiwgYWJicmV2aWF0aW9uOiBcIlZTXCIsIGNvZGU6IDc3IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIk1lc3NpbmFcIiwgYWJicmV2aWF0aW9uOiBcIk1FXCIsIGNvZGU6IDgzIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIk1pbGFub1wiLCBhYmJyZXZpYXRpb246IFwiTUlcIiwgY29kZTogMTUgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiTW9kZW5hXCIsIGFiYnJldmlhdGlvbjogXCJNT1wiLCBjb2RlOiAzNiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJNb256YS1CcmlhbnphXCIsIGFiYnJldmlhdGlvbjogXCJNQlwiLCBjb2RlOiAzNiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJOYXBvbGlcIiwgYWJicmV2aWF0aW9uOiBcIk5BXCIsIGNvZGU6IDYzIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIk5vdmFyYVwiLCBhYmJyZXZpYXRpb246IFwiTk9cIiwgY29kZTogMyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJOdW9yb1wiLCBhYmJyZXZpYXRpb246IFwiTlVcIiwgY29kZTogOTEgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiT2dsaWFzdHJhXCIsIGFiYnJldmlhdGlvbjogXCJPR1wiLCBjb2RlOiA5MSB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJPbGJpYSBUZW1waW9cIiwgYWJicmV2aWF0aW9uOiBcIk9UXCIsIGNvZGU6IDkxIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIk9yaXN0YW5vXCIsIGFiYnJldmlhdGlvbjogXCJPUlwiLCBjb2RlOiA5NSB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJQYWRvdmFcIiwgYWJicmV2aWF0aW9uOiBcIlBEXCIsIGNvZGU6IDI4IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlBhbGVybW9cIiwgYWJicmV2aWF0aW9uOiBcIlBBXCIsIGNvZGU6IDgyIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlBhcm1hXCIsIGFiYnJldmlhdGlvbjogXCJQUlwiLCBjb2RlOiAzNCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJQYXZpYVwiLCBhYmJyZXZpYXRpb246IFwiUFZcIiwgY29kZTogMTggfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUGVydWdpYVwiLCBhYmJyZXZpYXRpb246IFwiUEdcIiwgY29kZTogNTQgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUGVzYXJvLVVyYmlub1wiLCBhYmJyZXZpYXRpb246IFwiUFVcIiwgY29kZTogNDEgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUGVzY2FyYVwiLCBhYmJyZXZpYXRpb246IFwiUEVcIiwgY29kZTogNjggfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUGlhY2VuemFcIiwgYWJicmV2aWF0aW9uOiBcIlBDXCIsIGNvZGU6IDMzIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlBpc2FcIiwgYWJicmV2aWF0aW9uOiBcIlBJXCIsIGNvZGU6IDUwIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlBpc3RvaWFcIiwgYWJicmV2aWF0aW9uOiBcIlBUXCIsIGNvZGU6IDQ3IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlBvcmRlbm9uZVwiLCBhYmJyZXZpYXRpb246IFwiUE5cIiwgY29kZTogOTMgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUG90ZW56YVwiLCBhYmJyZXZpYXRpb246IFwiUFpcIiwgY29kZTogNzYgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUHJhdG9cIiwgYWJicmV2aWF0aW9uOiBcIlBPXCIsIGNvZGU6IDEwMCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJSYWd1c2FcIiwgYWJicmV2aWF0aW9uOiBcIlJHXCIsIGNvZGU6IDg4IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlJhdmVubmFcIiwgYWJicmV2aWF0aW9uOiBcIlJBXCIsIGNvZGU6IDM5IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlJlZ2dpby1DYWxhYnJpYVwiLCBhYmJyZXZpYXRpb246IFwiUkNcIiwgY29kZTogMzUgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUmVnZ2lvLUVtaWxpYVwiLCBhYmJyZXZpYXRpb246IFwiUkVcIiwgY29kZTogMzUgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUmlldGlcIiwgYWJicmV2aWF0aW9uOiBcIlJJXCIsIGNvZGU6IDU3IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlJpbWluaVwiLCBhYmJyZXZpYXRpb246IFwiUk5cIiwgY29kZTogOTkgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUm9tYVwiLCBhYmJyZXZpYXRpb246IFwiUm9tYVwiLCBjb2RlOiA1OCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJSb3ZpZ29cIiwgYWJicmV2aWF0aW9uOiBcIlJPXCIsIGNvZGU6IDI5IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlNhbGVybm9cIiwgYWJicmV2aWF0aW9uOiBcIlNBXCIsIGNvZGU6IDY1IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlNhc3NhcmlcIiwgYWJicmV2aWF0aW9uOiBcIlNTXCIsIGNvZGU6IDkwIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlNhdm9uYVwiLCBhYmJyZXZpYXRpb246IFwiU1ZcIiwgY29kZTogOSB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJTaWVuYVwiLCBhYmJyZXZpYXRpb246IFwiU0lcIiwgY29kZTogNTIgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiU2lyYWN1c2FcIiwgYWJicmV2aWF0aW9uOiBcIlNSXCIsIGNvZGU6IDg5IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlNvbmRyaW9cIiwgYWJicmV2aWF0aW9uOiBcIlNPXCIsIGNvZGU6IDE0IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlRhcmFudG9cIiwgYWJicmV2aWF0aW9uOiBcIlRBXCIsIGNvZGU6IDczIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlRlcmFtb1wiLCBhYmJyZXZpYXRpb246IFwiVEVcIiwgY29kZTogNjcgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiVGVybmlcIiwgYWJicmV2aWF0aW9uOiBcIlRSXCIsIGNvZGU6IDU1IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlRvcmlub1wiLCBhYmJyZXZpYXRpb246IFwiVE9cIiwgY29kZTogMSB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJUcmFwYW5pXCIsIGFiYnJldmlhdGlvbjogXCJUUFwiLCBjb2RlOiA4MSB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJUcmVudG9cIiwgYWJicmV2aWF0aW9uOiBcIlROXCIsIGNvZGU6IDIyIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlRyZXZpc29cIiwgYWJicmV2aWF0aW9uOiBcIlRWXCIsIGNvZGU6IDI2IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlRyaWVzdGVcIiwgYWJicmV2aWF0aW9uOiBcIlRTXCIsIGNvZGU6IDMyIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlVkaW5lXCIsIGFiYnJldmlhdGlvbjogXCJVRFwiLCBjb2RlOiAzMCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJWYXJlc2VcIiwgYWJicmV2aWF0aW9uOiBcIlZBXCIsIGNvZGU6IDEyIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlZlbmV6aWFcIiwgYWJicmV2aWF0aW9uOiBcIlZFXCIsIGNvZGU6IDI3IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlZlcmJhbmlhXCIsIGFiYnJldmlhdGlvbjogXCJWQlwiLCBjb2RlOiAyNyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJWZXJjZWxsaVwiLCBhYmJyZXZpYXRpb246IFwiVkNcIiwgY29kZTogMiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJWZXJvbmFcIiwgYWJicmV2aWF0aW9uOiBcIlZSXCIsIGNvZGU6IDIzIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlZpYm8tVmFsZW50aWFcIiwgYWJicmV2aWF0aW9uOiBcIlZWXCIsIGNvZGU6IDEwMiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJWaWNlbnphXCIsIGFiYnJldmlhdGlvbjogXCJWSVwiLCBjb2RlOiAyNCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJWaXRlcmJvXCIsIGFiYnJldmlhdGlvbjogXCJWVFwiLCBjb2RlOiA1NiB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9zYW1zYXJnZW50L1VzZWZ1bC1BdXRvY29tcGxldGUtRGF0YS9ibG9iL21hc3Rlci9kYXRhL25hdGlvbmFsaXRpZXMuanNvblxuICAgICAgICBuYXRpb25hbGl0aWVzOiBbXG4gICAgICAgICAgIHtuYW1lOiAnQWZnaGFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQWxiYW5pYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdBbGdlcmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0FtZXJpY2FuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQW5kb3JyYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdBbmdvbGFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQW50aWd1YW5zJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQXJnZW50aW5lYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdBcm1lbmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0F1c3RyYWxpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdBdXN0cmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0F6ZXJiYWlqYW5pJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQmFoYW1pJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQmFocmFpbmknfSxcbiAgICAgICAgICAge25hbWU6ICdCYW5nbGFkZXNoaSd9LFxuICAgICAgICAgICB7bmFtZTogJ0JhcmJhZGlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0JhcmJ1ZGFucyd9LFxuICAgICAgICAgICB7bmFtZTogJ0JhdHN3YW5hJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQmVsYXJ1c2lhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0JlbGdpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdCZWxpemVhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0JlbmluZXNlJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQmh1dGFuZXNlJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQm9saXZpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdCb3NuaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQnJhemlsaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQnJpdGlzaCd9LFxuICAgICAgICAgICB7bmFtZTogJ0JydW5laWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQnVsZ2FyaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQnVya2luYWJlJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQnVybWVzZSd9LFxuICAgICAgICAgICB7bmFtZTogJ0J1cnVuZGlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0NhbWJvZGlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0NhbWVyb29uaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQ2FuYWRpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdDYXBlIFZlcmRlYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdDZW50cmFsIEFmcmljYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdDaGFkaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQ2hpbGVhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0NoaW5lc2UnfSxcbiAgICAgICAgICAge25hbWU6ICdDb2xvbWJpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdDb21vcmFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQ29uZ29sZXNlJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQ29zdGEgUmljYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdDcm9hdGlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0N1YmFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnQ3lwcmlvdCd9LFxuICAgICAgICAgICB7bmFtZTogJ0N6ZWNoJ30sXG4gICAgICAgICAgIHtuYW1lOiAnRGFuaXNoJ30sXG4gICAgICAgICAgIHtuYW1lOiAnRGppYm91dGknfSxcbiAgICAgICAgICAge25hbWU6ICdEb21pbmljYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdEdXRjaCd9LFxuICAgICAgICAgICB7bmFtZTogJ0Vhc3QgVGltb3Jlc2UnfSxcbiAgICAgICAgICAge25hbWU6ICdFY3VhZG9yZWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnRWd5cHRpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdFbWlyaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnRXF1YXRvcmlhbCBHdWluZWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnRXJpdHJlYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdFc3Rvbmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0V0aGlvcGlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0Zpamlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0ZpbGlwaW5vJ30sXG4gICAgICAgICAgIHtuYW1lOiAnRmlubmlzaCd9LFxuICAgICAgICAgICB7bmFtZTogJ0ZyZW5jaCd9LFxuICAgICAgICAgICB7bmFtZTogJ0dhYm9uZXNlJ30sXG4gICAgICAgICAgIHtuYW1lOiAnR2FtYmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0dlb3JnaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnR2VybWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnR2hhbmFpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdHcmVlayd9LFxuICAgICAgICAgICB7bmFtZTogJ0dyZW5hZGlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0d1YXRlbWFsYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdHdWluZWEtQmlzc2F1YW4nfSxcbiAgICAgICAgICAge25hbWU6ICdHdWluZWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnR3V5YW5lc2UnfSxcbiAgICAgICAgICAge25hbWU6ICdIYWl0aWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnSGVyemVnb3Zpbmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0hvbmR1cmFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnSHVuZ2FyaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnSS1LaXJpYmF0aSd9LFxuICAgICAgICAgICB7bmFtZTogJ0ljZWxhbmRlcid9LFxuICAgICAgICAgICB7bmFtZTogJ0luZGlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0luZG9uZXNpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdJcmFuaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnSXJhcWknfSxcbiAgICAgICAgICAge25hbWU6ICdJcmlzaCd9LFxuICAgICAgICAgICB7bmFtZTogJ0lzcmFlbGknfSxcbiAgICAgICAgICAge25hbWU6ICdJdGFsaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnSXZvcmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0phbWFpY2FuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnSmFwYW5lc2UnfSxcbiAgICAgICAgICAge25hbWU6ICdKb3JkYW5pYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdLYXpha2hzdGFuaSd9LFxuICAgICAgICAgICB7bmFtZTogJ0tlbnlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0tpdHRpYW4gYW5kIE5ldmlzaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnS3V3YWl0aSd9LFxuICAgICAgICAgICB7bmFtZTogJ0t5cmd5eid9LFxuICAgICAgICAgICB7bmFtZTogJ0xhb3RpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdMYXR2aWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnTGViYW5lc2UnfSxcbiAgICAgICAgICAge25hbWU6ICdMaWJlcmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0xpYnlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ0xpZWNodGVuc3RlaW5lcid9LFxuICAgICAgICAgICB7bmFtZTogJ0xpdGh1YW5pYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdMdXhlbWJvdXJnZXInfSxcbiAgICAgICAgICAge25hbWU6ICdNYWNlZG9uaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnTWFsYWdhc3knfSxcbiAgICAgICAgICAge25hbWU6ICdNYWxhd2lhbid9LFxuICAgICAgICAgICB7bmFtZTogJ01hbGF5c2lhbid9LFxuICAgICAgICAgICB7bmFtZTogJ01hbGRpdmFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnTWFsaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnTWFsdGVzZSd9LFxuICAgICAgICAgICB7bmFtZTogJ01hcnNoYWxsZXNlJ30sXG4gICAgICAgICAgIHtuYW1lOiAnTWF1cml0YW5pYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdNYXVyaXRpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdNZXhpY2FuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnTWljcm9uZXNpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdNb2xkb3Zhbid9LFxuICAgICAgICAgICB7bmFtZTogJ01vbmFjYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdNb25nb2xpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdNb3JvY2Nhbid9LFxuICAgICAgICAgICB7bmFtZTogJ01vc290aG8nfSxcbiAgICAgICAgICAge25hbWU6ICdNb3Rzd2FuYSd9LFxuICAgICAgICAgICB7bmFtZTogJ01vemFtYmljYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdOYW1pYmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ05hdXJ1YW4nfSxcbiAgICAgICAgICAge25hbWU6ICdOZXBhbGVzZSd9LFxuICAgICAgICAgICB7bmFtZTogJ05ldyBaZWFsYW5kZXInfSxcbiAgICAgICAgICAge25hbWU6ICdOaWNhcmFndWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnTmlnZXJpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdOaWdlcmllbid9LFxuICAgICAgICAgICB7bmFtZTogJ05vcnRoIEtvcmVhbid9LFxuICAgICAgICAgICB7bmFtZTogJ05vcnRoZXJuIElyaXNoJ30sXG4gICAgICAgICAgIHtuYW1lOiAnTm9yd2VnaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnT21hbmknfSxcbiAgICAgICAgICAge25hbWU6ICdQYWtpc3RhbmknfSxcbiAgICAgICAgICAge25hbWU6ICdQYWxhdWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnUGFuYW1hbmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ1BhcHVhIE5ldyBHdWluZWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnUGFyYWd1YXlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ1BlcnV2aWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnUG9saXNoJ30sXG4gICAgICAgICAgIHtuYW1lOiAnUG9ydHVndWVzZSd9LFxuICAgICAgICAgICB7bmFtZTogJ1FhdGFyaSd9LFxuICAgICAgICAgICB7bmFtZTogJ1JvbWFuaSd9LFxuICAgICAgICAgICB7bmFtZTogJ1J1c3NpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdSd2FuZGFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnU2FpbnQgTHVjaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnU2FsdmFkb3Jhbid9LFxuICAgICAgICAgICB7bmFtZTogJ1NhbW9hbid9LFxuICAgICAgICAgICB7bmFtZTogJ1NhbiBNYXJpbmVzZSd9LFxuICAgICAgICAgICB7bmFtZTogJ1NhbyBUb21lYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdTYXVkaSd9LFxuICAgICAgICAgICB7bmFtZTogJ1Njb3R0aXNoJ30sXG4gICAgICAgICAgIHtuYW1lOiAnU2VuZWdhbGVzZSd9LFxuICAgICAgICAgICB7bmFtZTogJ1NlcmJpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdTZXljaGVsbG9pcyd9LFxuICAgICAgICAgICB7bmFtZTogJ1NpZXJyYSBMZW9uZWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnU2luZ2Fwb3JlYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdTbG92YWtpYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdTbG92ZW5pYW4nfSxcbiAgICAgICAgICAge25hbWU6ICdTb2xvbW9uIElzbGFuZGVyJ30sXG4gICAgICAgICAgIHtuYW1lOiAnU29tYWxpJ30sXG4gICAgICAgICAgIHtuYW1lOiAnU291dGggQWZyaWNhbid9LFxuICAgICAgICAgICB7bmFtZTogJ1NvdXRoIEtvcmVhbid9LFxuICAgICAgICAgICB7bmFtZTogJ1NwYW5pc2gnfSxcbiAgICAgICAgICAge25hbWU6ICdTcmkgTGFua2FuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnU3VkYW5lc2UnfSxcbiAgICAgICAgICAge25hbWU6ICdTdXJpbmFtZXInfSxcbiAgICAgICAgICAge25hbWU6ICdTd2F6aSd9LFxuICAgICAgICAgICB7bmFtZTogJ1N3ZWRpc2gnfSxcbiAgICAgICAgICAge25hbWU6ICdTd2lzcyd9LFxuICAgICAgICAgICB7bmFtZTogJ1N5cmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ1RhaXdhbmVzZSd9LFxuICAgICAgICAgICB7bmFtZTogJ1RhamlrJ30sXG4gICAgICAgICAgIHtuYW1lOiAnVGFuemFuaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnVGhhaSd9LFxuICAgICAgICAgICB7bmFtZTogJ1RvZ29sZXNlJ30sXG4gICAgICAgICAgIHtuYW1lOiAnVG9uZ2FuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnVHJpbmlkYWRpYW4gb3IgVG9iYWdvbmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ1R1bmlzaWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnVHVya2lzaCd9LFxuICAgICAgICAgICB7bmFtZTogJ1R1dmFsdWFuJ30sXG4gICAgICAgICAgIHtuYW1lOiAnVWdhbmRhbid9LFxuICAgICAgICAgICB7bmFtZTogJ1VrcmFpbmlhbid9LFxuICAgICAgICAgICB7bmFtZTogJ1VydWd1YXlhJ30sXG4gICAgICAgICAgIHtuYW1lOiAnVXpiZWtpc3RhbmknfSxcbiAgICAgICAgICAge25hbWU6ICdWZW5lenVlbGEnfSxcbiAgICAgICAgICAge25hbWU6ICdWaWV0bmFtZXNlJ30sXG4gICAgICAgICAgIHtuYW1lOiAnV2Vscyd9LFxuICAgICAgICAgICB7bmFtZTogJ1llbWVuaXQnfSxcbiAgICAgICAgICAge25hbWU6ICdaYW1iaWEnfSxcbiAgICAgICAgICAge25hbWU6ICdaaW1iYWJ3ZSd9LFxuICAgICAgICBdLFxuXG4gICAgICAgIHVzX3N0YXRlc19hbmRfZGM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnQWxhYmFtYScsIGFiYnJldmlhdGlvbjogJ0FMJ30sXG4gICAgICAgICAgICB7bmFtZTogJ0FsYXNrYScsIGFiYnJldmlhdGlvbjogJ0FLJ30sXG4gICAgICAgICAgICB7bmFtZTogJ0FyaXpvbmEnLCBhYmJyZXZpYXRpb246ICdBWid9LFxuICAgICAgICAgICAge25hbWU6ICdBcmthbnNhcycsIGFiYnJldmlhdGlvbjogJ0FSJ30sXG4gICAgICAgICAgICB7bmFtZTogJ0NhbGlmb3JuaWEnLCBhYmJyZXZpYXRpb246ICdDQSd9LFxuICAgICAgICAgICAge25hbWU6ICdDb2xvcmFkbycsIGFiYnJldmlhdGlvbjogJ0NPJ30sXG4gICAgICAgICAgICB7bmFtZTogJ0Nvbm5lY3RpY3V0JywgYWJicmV2aWF0aW9uOiAnQ1QnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnRGVsYXdhcmUnLCBhYmJyZXZpYXRpb246ICdERSd9LFxuICAgICAgICAgICAge25hbWU6ICdEaXN0cmljdCBvZiBDb2x1bWJpYScsIGFiYnJldmlhdGlvbjogJ0RDJ30sXG4gICAgICAgICAgICB7bmFtZTogJ0Zsb3JpZGEnLCBhYmJyZXZpYXRpb246ICdGTCd9LFxuICAgICAgICAgICAge25hbWU6ICdHZW9yZ2lhJywgYWJicmV2aWF0aW9uOiAnR0EnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnSGF3YWlpJywgYWJicmV2aWF0aW9uOiAnSEknfSxcbiAgICAgICAgICAgIHtuYW1lOiAnSWRhaG8nLCBhYmJyZXZpYXRpb246ICdJRCd9LFxuICAgICAgICAgICAge25hbWU6ICdJbGxpbm9pcycsIGFiYnJldmlhdGlvbjogJ0lMJ30sXG4gICAgICAgICAgICB7bmFtZTogJ0luZGlhbmEnLCBhYmJyZXZpYXRpb246ICdJTid9LFxuICAgICAgICAgICAge25hbWU6ICdJb3dhJywgYWJicmV2aWF0aW9uOiAnSUEnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnS2Fuc2FzJywgYWJicmV2aWF0aW9uOiAnS1MnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnS2VudHVja3knLCBhYmJyZXZpYXRpb246ICdLWSd9LFxuICAgICAgICAgICAge25hbWU6ICdMb3Vpc2lhbmEnLCBhYmJyZXZpYXRpb246ICdMQSd9LFxuICAgICAgICAgICAge25hbWU6ICdNYWluZScsIGFiYnJldmlhdGlvbjogJ01FJ30sXG4gICAgICAgICAgICB7bmFtZTogJ01hcnlsYW5kJywgYWJicmV2aWF0aW9uOiAnTUQnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnTWFzc2FjaHVzZXR0cycsIGFiYnJldmlhdGlvbjogJ01BJ30sXG4gICAgICAgICAgICB7bmFtZTogJ01pY2hpZ2FuJywgYWJicmV2aWF0aW9uOiAnTUknfSxcbiAgICAgICAgICAgIHtuYW1lOiAnTWlubmVzb3RhJywgYWJicmV2aWF0aW9uOiAnTU4nfSxcbiAgICAgICAgICAgIHtuYW1lOiAnTWlzc2lzc2lwcGknLCBhYmJyZXZpYXRpb246ICdNUyd9LFxuICAgICAgICAgICAge25hbWU6ICdNaXNzb3VyaScsIGFiYnJldmlhdGlvbjogJ01PJ30sXG4gICAgICAgICAgICB7bmFtZTogJ01vbnRhbmEnLCBhYmJyZXZpYXRpb246ICdNVCd9LFxuICAgICAgICAgICAge25hbWU6ICdOZWJyYXNrYScsIGFiYnJldmlhdGlvbjogJ05FJ30sXG4gICAgICAgICAgICB7bmFtZTogJ05ldmFkYScsIGFiYnJldmlhdGlvbjogJ05WJ30sXG4gICAgICAgICAgICB7bmFtZTogJ05ldyBIYW1wc2hpcmUnLCBhYmJyZXZpYXRpb246ICdOSCd9LFxuICAgICAgICAgICAge25hbWU6ICdOZXcgSmVyc2V5JywgYWJicmV2aWF0aW9uOiAnTkonfSxcbiAgICAgICAgICAgIHtuYW1lOiAnTmV3IE1leGljbycsIGFiYnJldmlhdGlvbjogJ05NJ30sXG4gICAgICAgICAgICB7bmFtZTogJ05ldyBZb3JrJywgYWJicmV2aWF0aW9uOiAnTlknfSxcbiAgICAgICAgICAgIHtuYW1lOiAnTm9ydGggQ2Fyb2xpbmEnLCBhYmJyZXZpYXRpb246ICdOQyd9LFxuICAgICAgICAgICAge25hbWU6ICdOb3J0aCBEYWtvdGEnLCBhYmJyZXZpYXRpb246ICdORCd9LFxuICAgICAgICAgICAge25hbWU6ICdPaGlvJywgYWJicmV2aWF0aW9uOiAnT0gnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnT2tsYWhvbWEnLCBhYmJyZXZpYXRpb246ICdPSyd9LFxuICAgICAgICAgICAge25hbWU6ICdPcmVnb24nLCBhYmJyZXZpYXRpb246ICdPUid9LFxuICAgICAgICAgICAge25hbWU6ICdQZW5uc3lsdmFuaWEnLCBhYmJyZXZpYXRpb246ICdQQSd9LFxuICAgICAgICAgICAge25hbWU6ICdSaG9kZSBJc2xhbmQnLCBhYmJyZXZpYXRpb246ICdSSSd9LFxuICAgICAgICAgICAge25hbWU6ICdTb3V0aCBDYXJvbGluYScsIGFiYnJldmlhdGlvbjogJ1NDJ30sXG4gICAgICAgICAgICB7bmFtZTogJ1NvdXRoIERha290YScsIGFiYnJldmlhdGlvbjogJ1NEJ30sXG4gICAgICAgICAgICB7bmFtZTogJ1Rlbm5lc3NlZScsIGFiYnJldmlhdGlvbjogJ1ROJ30sXG4gICAgICAgICAgICB7bmFtZTogJ1RleGFzJywgYWJicmV2aWF0aW9uOiAnVFgnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnVXRhaCcsIGFiYnJldmlhdGlvbjogJ1VUJ30sXG4gICAgICAgICAgICB7bmFtZTogJ1Zlcm1vbnQnLCBhYmJyZXZpYXRpb246ICdWVCd9LFxuICAgICAgICAgICAge25hbWU6ICdWaXJnaW5pYScsIGFiYnJldmlhdGlvbjogJ1ZBJ30sXG4gICAgICAgICAgICB7bmFtZTogJ1dhc2hpbmd0b24nLCBhYmJyZXZpYXRpb246ICdXQSd9LFxuICAgICAgICAgICAge25hbWU6ICdXZXN0IFZpcmdpbmlhJywgYWJicmV2aWF0aW9uOiAnV1YnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnV2lzY29uc2luJywgYWJicmV2aWF0aW9uOiAnV0knfSxcbiAgICAgICAgICAgIHtuYW1lOiAnV3lvbWluZycsIGFiYnJldmlhdGlvbjogJ1dZJ31cbiAgICAgICAgXSxcblxuICAgICAgICB0ZXJyaXRvcmllczogW1xuICAgICAgICAgICAge25hbWU6ICdBbWVyaWNhbiBTYW1vYScsIGFiYnJldmlhdGlvbjogJ0FTJ30sXG4gICAgICAgICAgICB7bmFtZTogJ0ZlZGVyYXRlZCBTdGF0ZXMgb2YgTWljcm9uZXNpYScsIGFiYnJldmlhdGlvbjogJ0ZNJ30sXG4gICAgICAgICAgICB7bmFtZTogJ0d1YW0nLCBhYmJyZXZpYXRpb246ICdHVSd9LFxuICAgICAgICAgICAge25hbWU6ICdNYXJzaGFsbCBJc2xhbmRzJywgYWJicmV2aWF0aW9uOiAnTUgnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnTm9ydGhlcm4gTWFyaWFuYSBJc2xhbmRzJywgYWJicmV2aWF0aW9uOiAnTVAnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnUHVlcnRvIFJpY28nLCBhYmJyZXZpYXRpb246ICdQUid9LFxuICAgICAgICAgICAge25hbWU6ICdWaXJnaW4gSXNsYW5kcywgVS5TLicsIGFiYnJldmlhdGlvbjogJ1ZJJ31cbiAgICAgICAgXSxcblxuICAgICAgICBhcm1lZF9mb3JjZXM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnQXJtZWQgRm9yY2VzIEV1cm9wZScsIGFiYnJldmlhdGlvbjogJ0FFJ30sXG4gICAgICAgICAgICB7bmFtZTogJ0FybWVkIEZvcmNlcyBQYWNpZmljJywgYWJicmV2aWF0aW9uOiAnQVAnfSxcbiAgICAgICAgICAgIHtuYW1lOiAnQXJtZWQgRm9yY2VzIHRoZSBBbWVyaWNhcycsIGFiYnJldmlhdGlvbjogJ0FBJ31cbiAgICAgICAgXSxcblxuICAgICAgICBjb3VudHJ5X3JlZ2lvbnM6IHtcbiAgICAgICAgICAgIGl0OiBbXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlZhbGxlIGQnQW9zdGFcIiwgYWJicmV2aWF0aW9uOiBcIlZEQVwiIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlBpZW1vbnRlXCIsIGFiYnJldmlhdGlvbjogXCJQSUVcIiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJMb21iYXJkaWFcIiwgYWJicmV2aWF0aW9uOiBcIkxPTVwiIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIlZlbmV0b1wiLCBhYmJyZXZpYXRpb246IFwiVkVOXCIgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiVHJlbnRpbm8gQWx0byBBZGlnZVwiLCBhYmJyZXZpYXRpb246IFwiVEFBXCIgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiRnJpdWxpIFZlbmV6aWEgR2l1bGlhXCIsIGFiYnJldmlhdGlvbjogXCJGVkdcIiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJMaWd1cmlhXCIsIGFiYnJldmlhdGlvbjogXCJMSUdcIiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJFbWlsaWEgUm9tYWduYVwiLCBhYmJyZXZpYXRpb246IFwiRU1SXCIgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiVG9zY2FuYVwiLCBhYmJyZXZpYXRpb246IFwiVE9TXCIgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiVW1icmlhXCIsIGFiYnJldmlhdGlvbjogXCJVTUJcIiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJNYXJjaGVcIiwgYWJicmV2aWF0aW9uOiBcIk1BUlwiIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkFicnV6em9cIiwgYWJicmV2aWF0aW9uOiBcIkFCUlwiIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkxhemlvXCIsIGFiYnJldmlhdGlvbjogXCJMQVpcIiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJDYW1wYW5pYVwiLCBhYmJyZXZpYXRpb246IFwiQ0FNXCIgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUHVnbGlhXCIsIGFiYnJldmlhdGlvbjogXCJQVUdcIiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJCYXNpbGljYXRhXCIsIGFiYnJldmlhdGlvbjogXCJCQVNcIiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJNb2xpc2VcIiwgYWJicmV2aWF0aW9uOiBcIk1PTFwiIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBcIkNhbGFicmlhXCIsIGFiYnJldmlhdGlvbjogXCJDQUxcIiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJTaWNpbGlhXCIsIGFiYnJldmlhdGlvbjogXCJTSUNcIiB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJTYXJkZWduYVwiLCBhYmJyZXZpYXRpb246IFwiU0FSXCIgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0cmVldF9zdWZmaXhlczoge1xuICAgICAgICAgICAgJ3VzJzogW1xuICAgICAgICAgICAgICAgIHtuYW1lOiAnQXZlbnVlJywgYWJicmV2aWF0aW9uOiAnQXZlJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdCb3VsZXZhcmQnLCBhYmJyZXZpYXRpb246ICdCbHZkJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdDZW50ZXInLCBhYmJyZXZpYXRpb246ICdDdHInfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0NpcmNsZScsIGFiYnJldmlhdGlvbjogJ0Npcid9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnQ291cnQnLCBhYmJyZXZpYXRpb246ICdDdCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnRHJpdmUnLCBhYmJyZXZpYXRpb246ICdEcid9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnRXh0ZW5zaW9uJywgYWJicmV2aWF0aW9uOiAnRXh0J30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdHbGVuJywgYWJicmV2aWF0aW9uOiAnR2xuJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdHcm92ZScsIGFiYnJldmlhdGlvbjogJ0dydid9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnSGVpZ2h0cycsIGFiYnJldmlhdGlvbjogJ0h0cyd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnSGlnaHdheScsIGFiYnJldmlhdGlvbjogJ0h3eSd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnSnVuY3Rpb24nLCBhYmJyZXZpYXRpb246ICdKY3QnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ0tleScsIGFiYnJldmlhdGlvbjogJ0tleSd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnTGFuZScsIGFiYnJldmlhdGlvbjogJ0xuJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdMb29wJywgYWJicmV2aWF0aW9uOiAnTG9vcCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnTWFub3InLCBhYmJyZXZpYXRpb246ICdNbnInfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ01pbGwnLCBhYmJyZXZpYXRpb246ICdNaWxsJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdQYXJrJywgYWJicmV2aWF0aW9uOiAnUGFyayd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnUGFya3dheScsIGFiYnJldmlhdGlvbjogJ1Brd3knfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1Bhc3MnLCBhYmJyZXZpYXRpb246ICdQYXNzJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdQYXRoJywgYWJicmV2aWF0aW9uOiAnUGF0aCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnUGlrZScsIGFiYnJldmlhdGlvbjogJ1Bpa2UnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1BsYWNlJywgYWJicmV2aWF0aW9uOiAnUGwnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1BsYXphJywgYWJicmV2aWF0aW9uOiAnUGx6J30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdQb2ludCcsIGFiYnJldmlhdGlvbjogJ1B0J30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdSaWRnZScsIGFiYnJldmlhdGlvbjogJ1JkZyd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnUml2ZXInLCBhYmJyZXZpYXRpb246ICdSaXYnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1JvYWQnLCBhYmJyZXZpYXRpb246ICdSZCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnU3F1YXJlJywgYWJicmV2aWF0aW9uOiAnU3EnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1N0cmVldCcsIGFiYnJldmlhdGlvbjogJ1N0J30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdUZXJyYWNlJywgYWJicmV2aWF0aW9uOiAnVGVyJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdUcmFpbCcsIGFiYnJldmlhdGlvbjogJ1RybCd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnVHVybnBpa2UnLCBhYmJyZXZpYXRpb246ICdUcGtlJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdWaWV3JywgYWJicmV2aWF0aW9uOiAnVncnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ1dheScsIGFiYnJldmlhdGlvbjogJ1dheSd9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ2l0JzogW1xuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0FjY2Vzc28nLCBhYmJyZXZpYXRpb246ICdBY2MuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0FsemFpYScsIGFiYnJldmlhdGlvbjogJ0Fsei4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQXJjbycsIGFiYnJldmlhdGlvbjogJ0FyY28nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQXJjaGl2b2x0bycsIGFiYnJldmlhdGlvbjogJ0Fjdi4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQXJlbmEnLCBhYmJyZXZpYXRpb246ICdBcmVuYScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdBcmdpbmUnLCBhYmJyZXZpYXRpb246ICdBcmdpbmUnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQmFjaW5vJywgYWJicmV2aWF0aW9uOiAnQmFjaW5vJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0JhbmNoaScsIGFiYnJldmlhdGlvbjogJ0JhbmNoaScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdCYW5jaGluYScsIGFiYnJldmlhdGlvbjogJ0Jhbi4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQmFzdGlvbmknLCBhYmJyZXZpYXRpb246ICdCYXMuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0JlbHZlZGVyZScsIGFiYnJldmlhdGlvbjogJ0JlbHYuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0JvcmdhdGEnLCBhYmJyZXZpYXRpb246ICdCLnRhJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0JvcmdvJywgYWJicmV2aWF0aW9uOiAnQi5nbycgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdDYWxhdGEnLCBhYmJyZXZpYXRpb246ICdDYWwuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0NhbGxlJywgYWJicmV2aWF0aW9uOiAnQ2FsbGUnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQ2FtcGllbGxvJywgYWJicmV2aWF0aW9uOiAnQ2FtLicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdDYW1wbycsIGFiYnJldmlhdGlvbjogJ0NhbS4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQ2FuYWxlJywgYWJicmV2aWF0aW9uOiAnQ2FuLicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdDYXJyYWlhJywgYWJicmV2aWF0aW9uOiAnQ2Fyci4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQ2FzY2luYScsIGFiYnJldmlhdGlvbjogJ0Nhc2NpbmEnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQ2FzZSBzcGFyc2UnLCBhYmJyZXZpYXRpb246ICdjLnMuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0NhdmFsY2F2aWEnLCBhYmJyZXZpYXRpb246ICdDdi4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQ2lyY29udmFsbGF6aW9uZScsIGFiYnJldmlhdGlvbjogJ0N2LicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdDb21wbGFuYXJlJywgYWJicmV2aWF0aW9uOiAnQy5yZScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdDb250cmFkYScsIGFiYnJldmlhdGlvbjogJ0MuZGEnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQ29yc28nLCBhYmJyZXZpYXRpb246ICdDLnNvJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0NvcnRlJywgYWJicmV2aWF0aW9uOiAnQy50ZScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdDb3J0aWxlJywgYWJicmV2aWF0aW9uOiAnQy5sZScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdEaXJhbWF6aW9uZScsIGFiYnJldmlhdGlvbjogJ0Rpci4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnRm9uZGFjbycsIGFiYnJldmlhdGlvbjogJ0YuY28nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnRm9uZGFtZW50YScsIGFiYnJldmlhdGlvbjogJ0YudGEnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnRm9uZG8nLCBhYmJyZXZpYXRpb246ICdGLmRvJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0ZyYXppb25lJywgYWJicmV2aWF0aW9uOiAnRnIuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0lzb2xhJywgYWJicmV2aWF0aW9uOiAnSXMuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0xhcmdvJywgYWJicmV2aWF0aW9uOiAnTC5nbycgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdMaXRvcmFuZWEnLCBhYmJyZXZpYXRpb246ICdMaXQuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0x1bmdvbGFnbycsIGFiYnJldmlhdGlvbjogJ0wuZ28gbGFnbycgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdMdW5nbyBQbycsIGFiYnJldmlhdGlvbjogJ2wuZ28gUG8nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnTW9sbycsIGFiYnJldmlhdGlvbjogJ01vbG8nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnTXVyYScsIGFiYnJldmlhdGlvbjogJ011cmEnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnUGFzc2FnZ2lvIHByaXZhdG8nLCBhYmJyZXZpYXRpb246ICdwYXNzLiBwcml2LicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdQYXNzZWdnaWF0YScsIGFiYnJldmlhdGlvbjogJ1Bhc3MuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1BpYXp6YScsIGFiYnJldmlhdGlvbjogJ1AuenphJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1BpYXp6YWxlJywgYWJicmV2aWF0aW9uOiAnUC5sZScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdQb250ZScsIGFiYnJldmlhdGlvbjogJ1AudGUnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnUG9ydGljbycsIGFiYnJldmlhdGlvbjogJ1AuY28nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnUmFtcGEnLCBhYmJyZXZpYXRpb246ICdSYW1wYScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdSZWdpb25lJywgYWJicmV2aWF0aW9uOiAnUmVnLicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdSaW9uZScsIGFiYnJldmlhdGlvbjogJ1IubmUnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnUmlvJywgYWJicmV2aWF0aW9uOiAnUmlvJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1JpcGEnLCBhYmJyZXZpYXRpb246ICdSaXBhJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1JpdmEnLCBhYmJyZXZpYXRpb246ICdSaXZhJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1JvbmTDsicsIGFiYnJldmlhdGlvbjogJ1JvbmTDsicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdSb3RvbmRhJywgYWJicmV2aWF0aW9uOiAnUm90LicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdTYWdyYXRvJywgYWJicmV2aWF0aW9uOiAnU2Fnci4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnU2FsaXRhJywgYWJicmV2aWF0aW9uOiAnU2FsLicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdTY2FsaW5hdGEnLCBhYmJyZXZpYXRpb246ICdTY2FsLicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdTY2Fsb25lJywgYWJicmV2aWF0aW9uOiAnU2NhbC4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnU2xhcmdvJywgYWJicmV2aWF0aW9uOiAnU2wuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1NvdHRvcG9ydGljbycsIGFiYnJldmlhdGlvbjogJ1NvdHQuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1N0cmFkYScsIGFiYnJldmlhdGlvbjogJ1N0ci4nIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnU3RyYWRhbGUnLCBhYmJyZXZpYXRpb246ICdTdHIubGUnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnU3RyZXR0b2lhJywgYWJicmV2aWF0aW9uOiAnU3RyZXR0LicgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdUcmF2ZXJzYScsIGFiYnJldmlhdGlvbjogJ1RyYXYuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1ZpYScsIGFiYnJldmlhdGlvbjogJ1YuJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1ZpYWxlJywgYWJicmV2aWF0aW9uOiAnVi5sZScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdWaWNpbmFsZScsIGFiYnJldmlhdGlvbjogJ1ZpYy5sZScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdWaWNvbG8nLCBhYmJyZXZpYXRpb246ICdWaWMuJyB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgbW9udGhzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ0phbnVhcnknLCBzaG9ydF9uYW1lOiAnSmFuJywgbnVtZXJpYzogJzAxJywgZGF5czogMzF9LFxuICAgICAgICAgICAgLy8gTm90IG1lc3Npbmcgd2l0aCBsZWFwIHllYXJzLi4uXG4gICAgICAgICAgICB7bmFtZTogJ0ZlYnJ1YXJ5Jywgc2hvcnRfbmFtZTogJ0ZlYicsIG51bWVyaWM6ICcwMicsIGRheXM6IDI4fSxcbiAgICAgICAgICAgIHtuYW1lOiAnTWFyY2gnLCBzaG9ydF9uYW1lOiAnTWFyJywgbnVtZXJpYzogJzAzJywgZGF5czogMzF9LFxuICAgICAgICAgICAge25hbWU6ICdBcHJpbCcsIHNob3J0X25hbWU6ICdBcHInLCBudW1lcmljOiAnMDQnLCBkYXlzOiAzMH0sXG4gICAgICAgICAgICB7bmFtZTogJ01heScsIHNob3J0X25hbWU6ICdNYXknLCBudW1lcmljOiAnMDUnLCBkYXlzOiAzMX0sXG4gICAgICAgICAgICB7bmFtZTogJ0p1bmUnLCBzaG9ydF9uYW1lOiAnSnVuJywgbnVtZXJpYzogJzA2JywgZGF5czogMzB9LFxuICAgICAgICAgICAge25hbWU6ICdKdWx5Jywgc2hvcnRfbmFtZTogJ0p1bCcsIG51bWVyaWM6ICcwNycsIGRheXM6IDMxfSxcbiAgICAgICAgICAgIHtuYW1lOiAnQXVndXN0Jywgc2hvcnRfbmFtZTogJ0F1ZycsIG51bWVyaWM6ICcwOCcsIGRheXM6IDMxfSxcbiAgICAgICAgICAgIHtuYW1lOiAnU2VwdGVtYmVyJywgc2hvcnRfbmFtZTogJ1NlcCcsIG51bWVyaWM6ICcwOScsIGRheXM6IDMwfSxcbiAgICAgICAgICAgIHtuYW1lOiAnT2N0b2JlcicsIHNob3J0X25hbWU6ICdPY3QnLCBudW1lcmljOiAnMTAnLCBkYXlzOiAzMX0sXG4gICAgICAgICAgICB7bmFtZTogJ05vdmVtYmVyJywgc2hvcnRfbmFtZTogJ05vdicsIG51bWVyaWM6ICcxMScsIGRheXM6IDMwfSxcbiAgICAgICAgICAgIHtuYW1lOiAnRGVjZW1iZXInLCBzaG9ydF9uYW1lOiAnRGVjJywgbnVtZXJpYzogJzEyJywgZGF5czogMzF9XG4gICAgICAgIF0sXG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYW5rX2NhcmRfbnVtYmVyI0lzc3Vlcl9pZGVudGlmaWNhdGlvbl9udW1iZXJfLjI4SUlOLjI5XG4gICAgICAgIGNjX3R5cGVzOiBbXG4gICAgICAgICAgICB7bmFtZTogXCJBbWVyaWNhbiBFeHByZXNzXCIsIHNob3J0X25hbWU6ICdhbWV4JywgcHJlZml4OiAnMzQnLCBsZW5ndGg6IDE1fSxcbiAgICAgICAgICAgIHtuYW1lOiBcIkJhbmtjYXJkXCIsIHNob3J0X25hbWU6ICdiYW5rY2FyZCcsIHByZWZpeDogJzU2MTAnLCBsZW5ndGg6IDE2fSxcbiAgICAgICAgICAgIHtuYW1lOiBcIkNoaW5hIFVuaW9uUGF5XCIsIHNob3J0X25hbWU6ICdjaGluYXVuaW9uJywgcHJlZml4OiAnNjInLCBsZW5ndGg6IDE2fSxcbiAgICAgICAgICAgIHtuYW1lOiBcIkRpbmVycyBDbHViIENhcnRlIEJsYW5jaGVcIiwgc2hvcnRfbmFtZTogJ2RjY2FydGUnLCBwcmVmaXg6ICczMDAnLCBsZW5ndGg6IDE0fSxcbiAgICAgICAgICAgIHtuYW1lOiBcIkRpbmVycyBDbHViIGVuUm91dGVcIiwgc2hvcnRfbmFtZTogJ2RjZW5yb3V0ZScsIHByZWZpeDogJzIwMTQnLCBsZW5ndGg6IDE1fSxcbiAgICAgICAgICAgIHtuYW1lOiBcIkRpbmVycyBDbHViIEludGVybmF0aW9uYWxcIiwgc2hvcnRfbmFtZTogJ2RjaW50bCcsIHByZWZpeDogJzM2JywgbGVuZ3RoOiAxNH0sXG4gICAgICAgICAgICB7bmFtZTogXCJEaW5lcnMgQ2x1YiBVbml0ZWQgU3RhdGVzICYgQ2FuYWRhXCIsIHNob3J0X25hbWU6ICdkY3VzYycsIHByZWZpeDogJzU0JywgbGVuZ3RoOiAxNn0sXG4gICAgICAgICAgICB7bmFtZTogXCJEaXNjb3ZlciBDYXJkXCIsIHNob3J0X25hbWU6ICdkaXNjb3ZlcicsIHByZWZpeDogJzYwMTEnLCBsZW5ndGg6IDE2fSxcbiAgICAgICAgICAgIHtuYW1lOiBcIkluc3RhUGF5bWVudFwiLCBzaG9ydF9uYW1lOiAnaW5zdGFwYXknLCBwcmVmaXg6ICc2MzcnLCBsZW5ndGg6IDE2fSxcbiAgICAgICAgICAgIHtuYW1lOiBcIkpDQlwiLCBzaG9ydF9uYW1lOiAnamNiJywgcHJlZml4OiAnMzUyOCcsIGxlbmd0aDogMTZ9LFxuICAgICAgICAgICAge25hbWU6IFwiTGFzZXJcIiwgc2hvcnRfbmFtZTogJ2xhc2VyJywgcHJlZml4OiAnNjMwNCcsIGxlbmd0aDogMTZ9LFxuICAgICAgICAgICAge25hbWU6IFwiTWFlc3Ryb1wiLCBzaG9ydF9uYW1lOiAnbWFlc3RybycsIHByZWZpeDogJzUwMTgnLCBsZW5ndGg6IDE2fSxcbiAgICAgICAgICAgIHtuYW1lOiBcIk1hc3RlcmNhcmRcIiwgc2hvcnRfbmFtZTogJ21jJywgcHJlZml4OiAnNTEnLCBsZW5ndGg6IDE2fSxcbiAgICAgICAgICAgIHtuYW1lOiBcIlNvbG9cIiwgc2hvcnRfbmFtZTogJ3NvbG8nLCBwcmVmaXg6ICc2MzM0JywgbGVuZ3RoOiAxNn0sXG4gICAgICAgICAgICB7bmFtZTogXCJTd2l0Y2hcIiwgc2hvcnRfbmFtZTogJ3N3aXRjaCcsIHByZWZpeDogJzQ5MDMnLCBsZW5ndGg6IDE2fSxcbiAgICAgICAgICAgIHtuYW1lOiBcIlZpc2FcIiwgc2hvcnRfbmFtZTogJ3Zpc2EnLCBwcmVmaXg6ICc0JywgbGVuZ3RoOiAxNn0sXG4gICAgICAgICAgICB7bmFtZTogXCJWaXNhIEVsZWN0cm9uXCIsIHNob3J0X25hbWU6ICdlbGVjdHJvbicsIHByZWZpeDogJzQwMjYnLCBsZW5ndGg6IDE2fVxuICAgICAgICBdLFxuXG4gICAgICAgIC8vcmV0dXJuIGFsbCB3b3JsZCBjdXJyZW5jeSBieSBJU08gNDIxN1xuICAgICAgICBjdXJyZW5jeV90eXBlczogW1xuICAgICAgICAgICAgeydjb2RlJyA6ICdBRUQnLCAnbmFtZScgOiAnVW5pdGVkIEFyYWIgRW1pcmF0ZXMgRGlyaGFtJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0FGTicsICduYW1lJyA6ICdBZmdoYW5pc3RhbiBBZmdoYW5pJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0FMTCcsICduYW1lJyA6ICdBbGJhbmlhIExlayd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdBTUQnLCAnbmFtZScgOiAnQXJtZW5pYSBEcmFtJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0FORycsICduYW1lJyA6ICdOZXRoZXJsYW5kcyBBbnRpbGxlcyBHdWlsZGVyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0FPQScsICduYW1lJyA6ICdBbmdvbGEgS3dhbnphJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0FSUycsICduYW1lJyA6ICdBcmdlbnRpbmEgUGVzbyd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdBVUQnLCAnbmFtZScgOiAnQXVzdHJhbGlhIERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdBV0cnLCAnbmFtZScgOiAnQXJ1YmEgR3VpbGRlcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdBWk4nLCAnbmFtZScgOiAnQXplcmJhaWphbiBOZXcgTWFuYXQnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQkFNJywgJ25hbWUnIDogJ0Jvc25pYSBhbmQgSGVyemVnb3ZpbmEgQ29udmVydGlibGUgTWFya2EnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQkJEJywgJ25hbWUnIDogJ0JhcmJhZG9zIERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdCRFQnLCAnbmFtZScgOiAnQmFuZ2xhZGVzaCBUYWthJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0JHTicsICduYW1lJyA6ICdCdWxnYXJpYSBMZXYnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQkhEJywgJ25hbWUnIDogJ0JhaHJhaW4gRGluYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQklGJywgJ25hbWUnIDogJ0J1cnVuZGkgRnJhbmMnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQk1EJywgJ25hbWUnIDogJ0Jlcm11ZGEgRG9sbGFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0JORCcsICduYW1lJyA6ICdCcnVuZWkgRGFydXNzYWxhbSBEb2xsYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQk9CJywgJ25hbWUnIDogJ0JvbGl2aWEgQm9saXZpYW5vJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0JSTCcsICduYW1lJyA6ICdCcmF6aWwgUmVhbCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdCU0QnLCAnbmFtZScgOiAnQmFoYW1hcyBEb2xsYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQlROJywgJ25hbWUnIDogJ0JodXRhbiBOZ3VsdHJ1bSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdCV1AnLCAnbmFtZScgOiAnQm90c3dhbmEgUHVsYSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdCWVInLCAnbmFtZScgOiAnQmVsYXJ1cyBSdWJsZSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdCWkQnLCAnbmFtZScgOiAnQmVsaXplIERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdDQUQnLCAnbmFtZScgOiAnQ2FuYWRhIERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdDREYnLCAnbmFtZScgOiAnQ29uZ28vS2luc2hhc2EgRnJhbmMnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQ0hGJywgJ25hbWUnIDogJ1N3aXR6ZXJsYW5kIEZyYW5jJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0NMUCcsICduYW1lJyA6ICdDaGlsZSBQZXNvJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0NOWScsICduYW1lJyA6ICdDaGluYSBZdWFuIFJlbm1pbmJpJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0NPUCcsICduYW1lJyA6ICdDb2xvbWJpYSBQZXNvJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0NSQycsICduYW1lJyA6ICdDb3N0YSBSaWNhIENvbG9uJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0NVQycsICduYW1lJyA6ICdDdWJhIENvbnZlcnRpYmxlIFBlc28nfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQ1VQJywgJ25hbWUnIDogJ0N1YmEgUGVzbyd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdDVkUnLCAnbmFtZScgOiAnQ2FwZSBWZXJkZSBFc2N1ZG8nfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnQ1pLJywgJ25hbWUnIDogJ0N6ZWNoIFJlcHVibGljIEtvcnVuYSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdESkYnLCAnbmFtZScgOiAnRGppYm91dGkgRnJhbmMnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnREtLJywgJ25hbWUnIDogJ0Rlbm1hcmsgS3JvbmUnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnRE9QJywgJ25hbWUnIDogJ0RvbWluaWNhbiBSZXB1YmxpYyBQZXNvJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0RaRCcsICduYW1lJyA6ICdBbGdlcmlhIERpbmFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0VHUCcsICduYW1lJyA6ICdFZ3lwdCBQb3VuZCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdFUk4nLCAnbmFtZScgOiAnRXJpdHJlYSBOYWtmYSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdFVEInLCAnbmFtZScgOiAnRXRoaW9waWEgQmlycid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdFVVInLCAnbmFtZScgOiAnRXVybyBNZW1iZXIgQ291bnRyaWVzJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0ZKRCcsICduYW1lJyA6ICdGaWppIERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdGS1AnLCAnbmFtZScgOiAnRmFsa2xhbmQgSXNsYW5kcyAoTWFsdmluYXMpIFBvdW5kJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0dCUCcsICduYW1lJyA6ICdVbml0ZWQgS2luZ2RvbSBQb3VuZCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdHRUwnLCAnbmFtZScgOiAnR2VvcmdpYSBMYXJpJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0dHUCcsICduYW1lJyA6ICdHdWVybnNleSBQb3VuZCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdHSFMnLCAnbmFtZScgOiAnR2hhbmEgQ2VkaSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdHSVAnLCAnbmFtZScgOiAnR2licmFsdGFyIFBvdW5kJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0dNRCcsICduYW1lJyA6ICdHYW1iaWEgRGFsYXNpJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0dORicsICduYW1lJyA6ICdHdWluZWEgRnJhbmMnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnR1RRJywgJ25hbWUnIDogJ0d1YXRlbWFsYSBRdWV0emFsJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0dZRCcsICduYW1lJyA6ICdHdXlhbmEgRG9sbGFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0hLRCcsICduYW1lJyA6ICdIb25nIEtvbmcgRG9sbGFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0hOTCcsICduYW1lJyA6ICdIb25kdXJhcyBMZW1waXJhJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0hSSycsICduYW1lJyA6ICdDcm9hdGlhIEt1bmEnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnSFRHJywgJ25hbWUnIDogJ0hhaXRpIEdvdXJkZSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdIVUYnLCAnbmFtZScgOiAnSHVuZ2FyeSBGb3JpbnQnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnSURSJywgJ25hbWUnIDogJ0luZG9uZXNpYSBSdXBpYWgnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnSUxTJywgJ25hbWUnIDogJ0lzcmFlbCBTaGVrZWwnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnSU1QJywgJ25hbWUnIDogJ0lzbGUgb2YgTWFuIFBvdW5kJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0lOUicsICduYW1lJyA6ICdJbmRpYSBSdXBlZSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdJUUQnLCAnbmFtZScgOiAnSXJhcSBEaW5hcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdJUlInLCAnbmFtZScgOiAnSXJhbiBSaWFsJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0lTSycsICduYW1lJyA6ICdJY2VsYW5kIEtyb25hJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0pFUCcsICduYW1lJyA6ICdKZXJzZXkgUG91bmQnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnSk1EJywgJ25hbWUnIDogJ0phbWFpY2EgRG9sbGFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0pPRCcsICduYW1lJyA6ICdKb3JkYW4gRGluYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnSlBZJywgJ25hbWUnIDogJ0phcGFuIFllbid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdLRVMnLCAnbmFtZScgOiAnS2VueWEgU2hpbGxpbmcnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnS0dTJywgJ25hbWUnIDogJ0t5cmd5enN0YW4gU29tJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0tIUicsICduYW1lJyA6ICdDYW1ib2RpYSBSaWVsJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0tNRicsICduYW1lJyA6ICdDb21vcm9zIEZyYW5jJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0tQVycsICduYW1lJyA6ICdLb3JlYSAoTm9ydGgpIFdvbid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdLUlcnLCAnbmFtZScgOiAnS29yZWEgKFNvdXRoKSBXb24nfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnS1dEJywgJ25hbWUnIDogJ0t1d2FpdCBEaW5hcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdLWUQnLCAnbmFtZScgOiAnQ2F5bWFuIElzbGFuZHMgRG9sbGFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0taVCcsICduYW1lJyA6ICdLYXpha2hzdGFuIFRlbmdlJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0xBSycsICduYW1lJyA6ICdMYW9zIEtpcCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdMQlAnLCAnbmFtZScgOiAnTGViYW5vbiBQb3VuZCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdMS1InLCAnbmFtZScgOiAnU3JpIExhbmthIFJ1cGVlJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0xSRCcsICduYW1lJyA6ICdMaWJlcmlhIERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdMU0wnLCAnbmFtZScgOiAnTGVzb3RobyBMb3RpJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ0xUTCcsICduYW1lJyA6ICdMaXRodWFuaWEgTGl0YXMnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnTFlEJywgJ25hbWUnIDogJ0xpYnlhIERpbmFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ01BRCcsICduYW1lJyA6ICdNb3JvY2NvIERpcmhhbSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdNREwnLCAnbmFtZScgOiAnTW9sZG92YSBMZXUnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnTUdBJywgJ25hbWUnIDogJ01hZGFnYXNjYXIgQXJpYXJ5J30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ01LRCcsICduYW1lJyA6ICdNYWNlZG9uaWEgRGVuYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnTU1LJywgJ25hbWUnIDogJ015YW5tYXIgKEJ1cm1hKSBLeWF0J30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ01OVCcsICduYW1lJyA6ICdNb25nb2xpYSBUdWdocmlrJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ01PUCcsICduYW1lJyA6ICdNYWNhdSBQYXRhY2EnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnTVJPJywgJ25hbWUnIDogJ01hdXJpdGFuaWEgT3VndWl5YSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdNVVInLCAnbmFtZScgOiAnTWF1cml0aXVzIFJ1cGVlJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ01WUicsICduYW1lJyA6ICdNYWxkaXZlcyAoTWFsZGl2ZSBJc2xhbmRzKSBSdWZpeWFhJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ01XSycsICduYW1lJyA6ICdNYWxhd2kgS3dhY2hhJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ01YTicsICduYW1lJyA6ICdNZXhpY28gUGVzbyd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdNWVInLCAnbmFtZScgOiAnTWFsYXlzaWEgUmluZ2dpdCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdNWk4nLCAnbmFtZScgOiAnTW96YW1iaXF1ZSBNZXRpY2FsJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ05BRCcsICduYW1lJyA6ICdOYW1pYmlhIERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdOR04nLCAnbmFtZScgOiAnTmlnZXJpYSBOYWlyYSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdOSU8nLCAnbmFtZScgOiAnTmljYXJhZ3VhIENvcmRvYmEnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnTk9LJywgJ25hbWUnIDogJ05vcndheSBLcm9uZSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdOUFInLCAnbmFtZScgOiAnTmVwYWwgUnVwZWUnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnTlpEJywgJ25hbWUnIDogJ05ldyBaZWFsYW5kIERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdPTVInLCAnbmFtZScgOiAnT21hbiBSaWFsJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1BBQicsICduYW1lJyA6ICdQYW5hbWEgQmFsYm9hJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1BFTicsICduYW1lJyA6ICdQZXJ1IE51ZXZvIFNvbCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdQR0snLCAnbmFtZScgOiAnUGFwdWEgTmV3IEd1aW5lYSBLaW5hJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1BIUCcsICduYW1lJyA6ICdQaGlsaXBwaW5lcyBQZXNvJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1BLUicsICduYW1lJyA6ICdQYWtpc3RhbiBSdXBlZSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdQTE4nLCAnbmFtZScgOiAnUG9sYW5kIFpsb3R5J30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1BZRycsICduYW1lJyA6ICdQYXJhZ3VheSBHdWFyYW5pJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1FBUicsICduYW1lJyA6ICdRYXRhciBSaXlhbCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdST04nLCAnbmFtZScgOiAnUm9tYW5pYSBOZXcgTGV1J30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1JTRCcsICduYW1lJyA6ICdTZXJiaWEgRGluYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnUlVCJywgJ25hbWUnIDogJ1J1c3NpYSBSdWJsZSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdSV0YnLCAnbmFtZScgOiAnUndhbmRhIEZyYW5jJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1NBUicsICduYW1lJyA6ICdTYXVkaSBBcmFiaWEgUml5YWwnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnU0JEJywgJ25hbWUnIDogJ1NvbG9tb24gSXNsYW5kcyBEb2xsYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnU0NSJywgJ25hbWUnIDogJ1NleWNoZWxsZXMgUnVwZWUnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnU0RHJywgJ25hbWUnIDogJ1N1ZGFuIFBvdW5kJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1NFSycsICduYW1lJyA6ICdTd2VkZW4gS3JvbmEnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnU0dEJywgJ25hbWUnIDogJ1NpbmdhcG9yZSBEb2xsYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnU0hQJywgJ25hbWUnIDogJ1NhaW50IEhlbGVuYSBQb3VuZCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdTTEwnLCAnbmFtZScgOiAnU2llcnJhIExlb25lIExlb25lJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1NPUycsICduYW1lJyA6ICdTb21hbGlhIFNoaWxsaW5nJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1NQTCcsICduYW1lJyA6ICdTZWJvcmdhIEx1aWdpbm8nfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnU1JEJywgJ25hbWUnIDogJ1N1cmluYW1lIERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdTVEQnLCAnbmFtZScgOiAnU8OjbyBUb23DqSBhbmQgUHLDrW5jaXBlIERvYnJhJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1NWQycsICduYW1lJyA6ICdFbCBTYWx2YWRvciBDb2xvbid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdTWVAnLCAnbmFtZScgOiAnU3lyaWEgUG91bmQnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnU1pMJywgJ25hbWUnIDogJ1N3YXppbGFuZCBMaWxhbmdlbmknfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnVEhCJywgJ25hbWUnIDogJ1RoYWlsYW5kIEJhaHQnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnVEpTJywgJ25hbWUnIDogJ1RhamlraXN0YW4gU29tb25pJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1RNVCcsICduYW1lJyA6ICdUdXJrbWVuaXN0YW4gTWFuYXQnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnVE5EJywgJ25hbWUnIDogJ1R1bmlzaWEgRGluYXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnVE9QJywgJ25hbWUnIDogJ1RvbmdhIFBhXFwnYW5nYSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdUUlknLCAnbmFtZScgOiAnVHVya2V5IExpcmEnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnVFREJywgJ25hbWUnIDogJ1RyaW5pZGFkIGFuZCBUb2JhZ28gRG9sbGFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1RWRCcsICduYW1lJyA6ICdUdXZhbHUgRG9sbGFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1RXRCcsICduYW1lJyA6ICdUYWl3YW4gTmV3IERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdUWlMnLCAnbmFtZScgOiAnVGFuemFuaWEgU2hpbGxpbmcnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnVUFIJywgJ25hbWUnIDogJ1VrcmFpbmUgSHJ5dm5pYSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdVR1gnLCAnbmFtZScgOiAnVWdhbmRhIFNoaWxsaW5nJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1VTRCcsICduYW1lJyA6ICdVbml0ZWQgU3RhdGVzIERvbGxhcid9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdVWVUnLCAnbmFtZScgOiAnVXJ1Z3VheSBQZXNvJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1VaUycsICduYW1lJyA6ICdVemJla2lzdGFuIFNvbSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdWRUYnLCAnbmFtZScgOiAnVmVuZXp1ZWxhIEJvbGl2YXInfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnVk5EJywgJ25hbWUnIDogJ1ZpZXQgTmFtIERvbmcnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnVlVWJywgJ25hbWUnIDogJ1ZhbnVhdHUgVmF0dSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdXU1QnLCAnbmFtZScgOiAnU2Ftb2EgVGFsYSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdYQUYnLCAnbmFtZScgOiAnQ29tbXVuYXV0w6kgRmluYW5jacOocmUgQWZyaWNhaW5lIChCRUFDKSBDRkEgRnJhbmMgQkVBQyd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdYQ0QnLCAnbmFtZScgOiAnRWFzdCBDYXJpYmJlYW4gRG9sbGFyJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1hEUicsICduYW1lJyA6ICdJbnRlcm5hdGlvbmFsIE1vbmV0YXJ5IEZ1bmQgKElNRikgU3BlY2lhbCBEcmF3aW5nIFJpZ2h0cyd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdYT0YnLCAnbmFtZScgOiAnQ29tbXVuYXV0w6kgRmluYW5jacOocmUgQWZyaWNhaW5lIChCQ0VBTykgRnJhbmMnfSxcbiAgICAgICAgICAgIHsnY29kZScgOiAnWFBGJywgJ25hbWUnIDogJ0NvbXB0b2lycyBGcmFuw6dhaXMgZHUgUGFjaWZpcXVlIChDRlApIEZyYW5jJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1lFUicsICduYW1lJyA6ICdZZW1lbiBSaWFsJ30sXG4gICAgICAgICAgICB7J2NvZGUnIDogJ1pBUicsICduYW1lJyA6ICdTb3V0aCBBZnJpY2EgUmFuZCd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdaTVcnLCAnbmFtZScgOiAnWmFtYmlhIEt3YWNoYSd9LFxuICAgICAgICAgICAgeydjb2RlJyA6ICdaV0QnLCAnbmFtZScgOiAnWmltYmFid2UgRG9sbGFyJ31cbiAgICAgICAgXSxcblxuICAgICAgICAvLyByZXR1cm4gdGhlIG5hbWVzIG9mIGFsbCB2YWxpZGUgY29sb3JzXG4gICAgICAgIGNvbG9yTmFtZXMgOiBbICBcIkFsaWNlQmx1ZVwiLCBcIkJsYWNrXCIsIFwiTmF2eVwiLCBcIkRhcmtCbHVlXCIsIFwiTWVkaXVtQmx1ZVwiLCBcIkJsdWVcIiwgXCJEYXJrR3JlZW5cIiwgXCJHcmVlblwiLCBcIlRlYWxcIiwgXCJEYXJrQ3lhblwiLCBcIkRlZXBTa3lCbHVlXCIsIFwiRGFya1R1cnF1b2lzZVwiLCBcIk1lZGl1bVNwcmluZ0dyZWVuXCIsIFwiTGltZVwiLCBcIlNwcmluZ0dyZWVuXCIsXG4gICAgICAgICAgICBcIkFxdWFcIiwgXCJDeWFuXCIsIFwiTWlkbmlnaHRCbHVlXCIsIFwiRG9kZ2VyQmx1ZVwiLCBcIkxpZ2h0U2VhR3JlZW5cIiwgXCJGb3Jlc3RHcmVlblwiLCBcIlNlYUdyZWVuXCIsIFwiRGFya1NsYXRlR3JheVwiLCBcIkxpbWVHcmVlblwiLCBcIk1lZGl1bVNlYUdyZWVuXCIsIFwiVHVycXVvaXNlXCIsIFwiUm95YWxCbHVlXCIsIFwiU3RlZWxCbHVlXCIsIFwiRGFya1NsYXRlQmx1ZVwiLCBcIk1lZGl1bVR1cnF1b2lzZVwiLFxuICAgICAgICAgICAgXCJJbmRpZ29cIiwgXCJEYXJrT2xpdmVHcmVlblwiLCBcIkNhZGV0Qmx1ZVwiLCBcIkNvcm5mbG93ZXJCbHVlXCIsIFwiUmViZWNjYVB1cnBsZVwiLCBcIk1lZGl1bUFxdWFNYXJpbmVcIiwgXCJEaW1HcmF5XCIsIFwiU2xhdGVCbHVlXCIsIFwiT2xpdmVEcmFiXCIsIFwiU2xhdGVHcmF5XCIsIFwiTGlnaHRTbGF0ZUdyYXlcIiwgXCJNZWRpdW1TbGF0ZUJsdWVcIiwgXCJMYXduR3JlZW5cIiwgXCJDaGFydHJldXNlXCIsXG4gICAgICAgICAgICBcIkFxdWFtYXJpbmVcIiwgXCJNYXJvb25cIiwgXCJQdXJwbGVcIiwgXCJPbGl2ZVwiLCBcIkdyYXlcIiwgXCJTa3lCbHVlXCIsIFwiTGlnaHRTa3lCbHVlXCIsIFwiQmx1ZVZpb2xldFwiLCBcIkRhcmtSZWRcIiwgXCJEYXJrTWFnZW50YVwiLCBcIlNhZGRsZUJyb3duXCIsIFwiSXZvcnlcIiwgXCJXaGl0ZVwiLFxuICAgICAgICAgICAgXCJEYXJrU2VhR3JlZW5cIiwgXCJMaWdodEdyZWVuXCIsIFwiTWVkaXVtUHVycGxlXCIsIFwiRGFya1Zpb2xldFwiLCBcIlBhbGVHcmVlblwiLCBcIkRhcmtPcmNoaWRcIiwgXCJZZWxsb3dHcmVlblwiLCBcIlNpZW5uYVwiLCBcIkJyb3duXCIsIFwiRGFya0dyYXlcIiwgXCJMaWdodEJsdWVcIiwgXCJHcmVlblllbGxvd1wiLCBcIlBhbGVUdXJxdW9pc2VcIiwgXCJMaWdodFN0ZWVsQmx1ZVwiLCBcIlBvd2RlckJsdWVcIixcbiAgICAgICAgICAgIFwiRmlyZUJyaWNrXCIsIFwiRGFya0dvbGRlblJvZFwiLCBcIk1lZGl1bU9yY2hpZFwiLCBcIlJvc3lCcm93blwiLCBcIkRhcmtLaGFraVwiLCBcIlNpbHZlclwiLCBcIk1lZGl1bVZpb2xldFJlZFwiLCBcIkluZGlhblJlZFwiLCBcIlBlcnVcIiwgXCJDaG9jb2xhdGVcIiwgXCJUYW5cIiwgXCJMaWdodEdyYXlcIiwgXCJUaGlzdGxlXCIsIFwiT3JjaGlkXCIsIFwiR29sZGVuUm9kXCIsIFwiUGFsZVZpb2xldFJlZFwiLFxuICAgICAgICAgICAgXCJDcmltc29uXCIsIFwiR2FpbnNib3JvXCIsIFwiUGx1bVwiLCBcIkJ1cmx5V29vZFwiLCBcIkxpZ2h0Q3lhblwiLCBcIkxhdmVuZGVyXCIsIFwiRGFya1NhbG1vblwiLCBcIlZpb2xldFwiLCBcIlBhbGVHb2xkZW5Sb2RcIiwgXCJMaWdodENvcmFsXCIsIFwiS2hha2lcIiwgXCJBbGljZUJsdWVcIiwgXCJIb25leURld1wiLCBcIkF6dXJlXCIsIFwiU2FuZHlCcm93blwiLCBcIldoZWF0XCIsIFwiQmVpZ2VcIiwgXCJXaGl0ZVNtb2tlXCIsXG4gICAgICAgICAgICBcIk1pbnRDcmVhbVwiLCBcIkdob3N0V2hpdGVcIiwgXCJTYWxtb25cIiwgXCJBbnRpcXVlV2hpdGVcIiwgXCJMaW5lblwiLCBcIkxpZ2h0R29sZGVuUm9kWWVsbG93XCIsIFwiT2xkTGFjZVwiLCBcIlJlZFwiLCBcIkZ1Y2hzaWFcIiwgXCJNYWdlbnRhXCIsIFwiRGVlcFBpbmtcIiwgXCJPcmFuZ2VSZWRcIiwgXCJUb21hdG9cIiwgXCJIb3RQaW5rXCIsIFwiQ29yYWxcIiwgXCJEYXJrT3JhbmdlXCIsIFwiTGlnaHRTYWxtb25cIiwgXCJPcmFuZ2VcIixcbiAgICAgICAgICAgIFwiTGlnaHRQaW5rXCIsIFwiUGlua1wiLCBcIkdvbGRcIiwgXCJQZWFjaFB1ZmZcIiwgXCJOYXZham9XaGl0ZVwiLCBcIk1vY2Nhc2luXCIsIFwiQmlzcXVlXCIsIFwiTWlzdHlSb3NlXCIsIFwiQmxhbmNoZWRBbG1vbmRcIiwgXCJQYXBheWFXaGlwXCIsIFwiTGF2ZW5kZXJCbHVzaFwiLCBcIlNlYVNoZWxsXCIsIFwiQ29ybnNpbGtcIiwgXCJMZW1vbkNoaWZmb25cIiwgXCJGbG9yYWxXaGl0ZVwiLCBcIlNub3dcIiwgXCJZZWxsb3dcIiwgXCJMaWdodFllbGxvd1wiXG4gICAgICAgIF0sXG5cbiAgICAgICAgZmlsZUV4dGVuc2lvbiA6IHtcbiAgICAgICAgICAgIFwicmFzdGVyXCIgICAgOiBbXCJibXBcIiwgXCJnaWZcIiwgXCJncGxcIiwgXCJpY29cIiwgXCJqcGVnXCIsIFwicHNkXCIsIFwicG5nXCIsIFwicHNwXCIsIFwicmF3XCIsIFwidGlmZlwiXSxcbiAgICAgICAgICAgIFwidmVjdG9yXCIgICAgOiBbXCIzZHZcIiwgXCJhbWZcIiwgXCJhd2dcIiwgXCJhaVwiLCBcImNnbVwiLCBcImNkclwiLCBcImNteFwiLCBcImR4ZlwiLCBcImUyZFwiLCBcImVndFwiLCBcImVwc1wiLCBcImZzXCIsIFwib2RnXCIsIFwic3ZnXCIsIFwieGFyXCJdLFxuICAgICAgICAgICAgXCIzZFwiICAgICAgICA6IFtcIjNkbWZcIiwgXCIzZG1cIiwgXCIzbWZcIiwgXCIzZHNcIiwgXCJhbjhcIiwgXCJhb2lcIiwgXCJibGVuZFwiLCBcImNhbDNkXCIsIFwiY29iXCIsIFwiY3RtXCIsIFwiaW9iXCIsIFwiamFzXCIsIFwibWF4XCIsIFwibWJcIiwgXCJtZHhcIiwgXCJvYmpcIiwgXCJ4XCIsIFwieDNkXCJdLFxuICAgICAgICAgICAgXCJkb2N1bWVudFwiICA6IFtcImRvY1wiLCBcImRvY3hcIiwgXCJkb3RcIiwgXCJodG1sXCIsIFwieG1sXCIsIFwib2R0XCIsIFwib2RtXCIsIFwib3R0XCIsIFwiY3N2XCIsIFwicnRmXCIsIFwidGV4XCIsIFwieGh0bWxcIiwgXCJ4cHNcIl1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEYXRhIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2RtZmlsaXBlbmtvL3RpbWV6b25lcy5qc29uL2Jsb2IvbWFzdGVyL3RpbWV6b25lcy5qc29uXG4gICAgICAgIHRpbWV6b25lczogW1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJEYXRlbGluZSBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIkRTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAtMTIsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMtMTI6MDApIEludGVybmF0aW9uYWwgRGF0ZSBMaW5lIFdlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiRXRjL0dNVCsxMlwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlVUQy0xMVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJVXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IC0xMSxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQy0xMTowMCkgQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUtMTFcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiRXRjL0dNVCsxMVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiUGFjaWZpYy9NaWR3YXlcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIlBhY2lmaWMvTml1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiUGFjaWZpYy9QYWdvX1BhZ29cIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJIYXdhaWlhbiBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIkhTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAtMTAsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMtMTA6MDApIEhhd2FpaVwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdGMvR01UKzEwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJQYWNpZmljL0hvbm9sdWx1XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJQYWNpZmljL0pvaG5zdG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJQYWNpZmljL1Jhcm90b25nYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiUGFjaWZpYy9UYWhpdGlcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJBbGFza2FuIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiQUtEVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAtOCxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDLTA5OjAwKSBBbGFza2FcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9BbmNob3JhZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvSnVuZWF1XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL05vbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvU2l0a2FcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvWWFrdXRhdFwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlBhY2lmaWMgU3RhbmRhcmQgVGltZSAoTWV4aWNvKVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJQRFRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogLTcsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQy0wODowMCkgQmFqYSBDYWxpZm9ybmlhXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvU2FudGFfSXNhYmVsXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUGFjaWZpYyBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIlBEVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAtNyxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDLTA4OjAwKSBQYWNpZmljIFRpbWUgKFVTICYgQ2FuYWRhKVwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0Rhd3NvblwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9Mb3NfQW5nZWxlc1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9UaWp1YW5hXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL1ZhbmNvdXZlclwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9XaGl0ZWhvcnNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJQU1Q4UERUXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVVMgTW91bnRhaW4gU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJVTVNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IC03LFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDLTA3OjAwKSBBcml6b25hXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvQ3Jlc3RvblwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9EYXdzb25fQ3JlZWtcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvSGVybW9zaWxsb1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9QaG9lbml4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdGMvR01UKzdcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJNb3VudGFpbiBTdGFuZGFyZCBUaW1lIChNZXhpY28pXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIk1EVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAtNixcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDLTA3OjAwKSBDaGlodWFodWEsIExhIFBheiwgTWF6YXRsYW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9DaGlodWFodWFcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvTWF6YXRsYW5cIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJNb3VudGFpbiBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIk1EVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAtNixcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDLTA3OjAwKSBNb3VudGFpbiBUaW1lIChVUyAmIENhbmFkYSlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9Cb2lzZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9DYW1icmlkZ2VfQmF5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0RlbnZlclwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9FZG1vbnRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9JbnV2aWtcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvT2ppbmFnYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9ZZWxsb3drbmlmZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiTVNUN01EVFwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkNlbnRyYWwgQW1lcmljYSBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIkNBU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogLTYsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMtMDY6MDApIENlbnRyYWwgQW1lcmljYVwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0JlbGl6ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9Db3N0YV9SaWNhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0VsX1NhbHZhZG9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0d1YXRlbWFsYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9NYW5hZ3VhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL1RlZ3VjaWdhbHBhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdGMvR01UKzZcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIlBhY2lmaWMvR2FsYXBhZ29zXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ2VudHJhbCBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIkNEVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAtNSxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDLTA2OjAwKSBDZW50cmFsIFRpbWUgKFVTICYgQ2FuYWRhKVwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0NoaWNhZ29cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvSW5kaWFuYS9Lbm94XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0luZGlhbmEvVGVsbF9DaXR5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL01hdGFtb3Jvc1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9NZW5vbWluZWVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvTm9ydGhfRGFrb3RhL0JldWxhaFwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9Ob3J0aF9EYWtvdGEvQ2VudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL05vcnRoX0Rha290YS9OZXdfU2FsZW1cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvUmFpbnlfUml2ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvUmFua2luX0lubGV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL1Jlc29sdXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL1dpbm5pcGVnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJDU1Q2Q0RUXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ2VudHJhbCBTdGFuZGFyZCBUaW1lIChNZXhpY28pXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIkNEVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAtNSxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDLTA2OjAwKSBHdWFkYWxhamFyYSwgTWV4aWNvIENpdHksIE1vbnRlcnJleVwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0JhaGlhX0JhbmRlcmFzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0NhbmN1blwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9NZXJpZGFcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvTWV4aWNvX0NpdHlcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvTW9udGVycmV5XCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ2FuYWRhIENlbnRyYWwgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJDQ1NUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IC02LFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDLTA2OjAwKSBTYXNrYXRjaGV3YW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9SZWdpbmFcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvU3dpZnRfQ3VycmVudFwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlNBIFBhY2lmaWMgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJTUFNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IC01LFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDLTA1OjAwKSBCb2dvdGEsIExpbWEsIFF1aXRvXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvQm9nb3RhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0NheW1hblwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9Db3JhbF9IYXJib3VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0VpcnVuZXBlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0d1YXlhcXVpbFwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9KYW1haWNhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0xpbWFcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvUGFuYW1hXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL1Jpb19CcmFuY29cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV0Yy9HTVQrNVwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkVhc3Rlcm4gU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJFRFRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogLTQsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQy0wNTowMCkgRWFzdGVybiBUaW1lIChVUyAmIENhbmFkYSlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9EZXRyb2l0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0hhdmFuYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9JbmRpYW5hL1BldGVyc2J1cmdcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvSW5kaWFuYS9WaW5jZW5uZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvSW5kaWFuYS9XaW5hbWFjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0lxYWx1aXRcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvS2VudHVja3kvTW9udGljZWxsb1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9Mb3Vpc3ZpbGxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL01vbnRyZWFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL05hc3NhdVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9OZXdfWW9ya1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9OaXBpZ29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL1BhbmduaXJ0dW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL1BvcnQtYXUtUHJpbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL1RodW5kZXJfQmF5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL1Rvcm9udG9cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkVTVDVFRFRcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJVUyBFYXN0ZXJuIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiVUVEVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAtNCxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDLTA1OjAwKSBJbmRpYW5hIChFYXN0KVwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0luZGlhbmEvTWFyZW5nb1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9JbmRpYW5hL1ZldmF5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0luZGlhbmFwb2xpc1wiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlZlbmV6dWVsYSBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIlZTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAtNC41LFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDLTA0OjMwKSBDYXJhY2FzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvQ2FyYWNhc1wiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlBhcmFndWF5IFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiUFNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IC00LFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDLTA0OjAwKSBBc3VuY2lvblwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0FzdW5jaW9uXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQXRsYW50aWMgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJBRFRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogLTMsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQy0wNDowMCkgQXRsYW50aWMgVGltZSAoQ2FuYWRhKVwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0dsYWNlX0JheVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9Hb29zZV9CYXlcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvSGFsaWZheFwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9Nb25jdG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL1RodWxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBdGxhbnRpYy9CZXJtdWRhXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ2VudHJhbCBCcmF6aWxpYW4gU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJDQlNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IC00LFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDLTA0OjAwKSBDdWlhYmFcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9DYW1wb19HcmFuZGVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvQ3VpYWJhXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiU0EgV2VzdGVybiBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIlNXU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogLTQsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMtMDQ6MDApIEdlb3JnZXRvd24sIExhIFBheiwgTWFuYXVzLCBTYW4gSnVhblwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0FuZ3VpbGxhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0FudGlndWFcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvQXJ1YmFcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvQmFyYmFkb3NcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvQmxhbmMtU2FibG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0JvYV9WaXN0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9DdXJhY2FvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0RvbWluaWNhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0dyYW5kX1R1cmtcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvR3JlbmFkYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9HdWFkZWxvdXBlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0d1eWFuYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9LcmFsZW5kaWprXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0xhX1BhelwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9Mb3dlcl9QcmluY2VzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL01hbmF1c1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9NYXJpZ290XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL01hcnRpbmlxdWVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvTW9udHNlcnJhdFwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9Qb3J0X29mX1NwYWluXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL1BvcnRvX1ZlbGhvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL1B1ZXJ0b19SaWNvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL1NhbnRvX0RvbWluZ29cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvU3RfQmFydGhlbGVteVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9TdF9LaXR0c1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9TdF9MdWNpYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9TdF9UaG9tYXNcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvU3RfVmluY2VudFwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9Ub3J0b2xhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdGMvR01UKzRcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJQYWNpZmljIFNBIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiUFNTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAtNCxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQy0wNDowMCkgU2FudGlhZ29cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9TYW50aWFnb1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW50YXJjdGljYS9QYWxtZXJcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJOZXdmb3VuZGxhbmQgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJORFRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogLTIuNSxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDLTAzOjMwKSBOZXdmb3VuZGxhbmRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9TdF9Kb2huc1wiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkUuIFNvdXRoIEFtZXJpY2EgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJFU0FTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAtMyxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQy0wMzowMCkgQnJhc2lsaWFcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9TYW9fUGF1bG9cIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJBcmdlbnRpbmEgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJBU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogLTMsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMtMDM6MDApIEJ1ZW5vcyBBaXJlc1wiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0FyZ2VudGluYS9MYV9SaW9qYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9BcmdlbnRpbmEvUmlvX0dhbGxlZ29zXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0FyZ2VudGluYS9TYWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9BcmdlbnRpbmEvU2FuX0p1YW5cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvQXJnZW50aW5hL1Nhbl9MdWlzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0FyZ2VudGluYS9UdWN1bWFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0FyZ2VudGluYS9Vc2h1YWlhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0J1ZW5vc19BaXJlc1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9DYXRhbWFyY2FcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvQ29yZG9iYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9KdWp1eVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9NZW5kb3phXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiU0EgRWFzdGVybiBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIlNFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogLTMsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMtMDM6MDApIENheWVubmUsIEZvcnRhbGV6YVwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0FyYWd1YWluYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9CZWxlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9DYXllbm5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0ZvcnRhbGV6YVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9NYWNlaW9cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvUGFyYW1hcmlib1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9SZWNpZmVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvU2FudGFyZW1cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFudGFyY3RpY2EvUm90aGVyYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXRsYW50aWMvU3RhbmxleVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXRjL0dNVCszXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiR3JlZW5sYW5kIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiR0RUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IC0yLFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMtMDM6MDApIEdyZWVubGFuZFwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0dvZHRoYWJcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJNb250ZXZpZGVvIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiTVNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IC0zLFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDLTAzOjAwKSBNb250ZXZpZGVvXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvTW9udGV2aWRlb1wiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkJhaGlhIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiQlNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IC0zLFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDLTAzOjAwKSBTYWx2YWRvclwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0JhaGlhXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVVRDLTAyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIlVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogLTIsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMtMDI6MDApIENvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lLTAyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFtZXJpY2EvTm9yb25oYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXRsYW50aWMvU291dGhfR2VvcmdpYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXRjL0dNVCsyXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTWlkLUF0bGFudGljIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiTURUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IC0xLFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMtMDI6MDApIE1pZC1BdGxhbnRpYyAtIE9sZFwiXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJBem9yZXMgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJBRFRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogMCxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDLTAxOjAwKSBBem9yZXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQW1lcmljYS9TY29yZXNieXN1bmRcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkF0bGFudGljL0F6b3Jlc1wiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkNhcGUgVmVyZGUgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJDVlNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IC0xLFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDLTAxOjAwKSBDYXBlIFZlcmRlIElzLlwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBdGxhbnRpYy9DYXBlX1ZlcmRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdGMvR01UKzFcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJNb3JvY2NvIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiTURUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDEsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQykgQ2FzYWJsYW5jYVwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvQ2FzYWJsYW5jYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQWZyaWNhL0VsX0FhaXVuXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVVRDXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIkNVVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAwLFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKSBDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbWVyaWNhL0Rhbm1hcmtzaGF2blwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXRjL0dNVFwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkdNVCBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIkdEVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAxLFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMpIER1YmxpbiwgRWRpbmJ1cmdoLCBMaXNib24sIExvbmRvblwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBdGxhbnRpYy9DYW5hcnlcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkF0bGFudGljL0ZhZXJvZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXRsYW50aWMvTWFkZWlyYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXVyb3BlL0R1YmxpblwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXVyb3BlL0d1ZXJuc2V5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdXJvcGUvSXNsZV9vZl9NYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9KZXJzZXlcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9MaXNib25cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9Mb25kb25cIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJHcmVlbndpY2ggU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJHU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogMCxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQykgTW9ucm92aWEsIFJleWtqYXZpa1wiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvQWJpZGphblwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQWZyaWNhL0FjY3JhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvQmFtYWtvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvQmFuanVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvQmlzc2F1XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvQ29uYWtyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQWZyaWNhL0Rha2FyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvRnJlZXRvd25cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFmcmljYS9Mb21lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvTW9ucm92aWFcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFmcmljYS9Ob3Vha2Nob3R0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvT3VhZ2Fkb3Vnb3VcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFmcmljYS9TYW9fVG9tZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXRsYW50aWMvUmV5a2phdmlrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBdGxhbnRpYy9TdF9IZWxlbmFcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJXLiBFdXJvcGUgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJXRURUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDIsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswMTowMCkgQW1zdGVyZGFtLCBCZXJsaW4sIEJlcm4sIFJvbWUsIFN0b2NraG9sbSwgVmllbm5hXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFyY3RpYy9Mb25neWVhcmJ5ZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9BbXN0ZXJkYW1cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9BbmRvcnJhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdXJvcGUvQmVybGluXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdXJvcGUvQnVzaW5nZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9HaWJyYWx0YXJcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9MdXhlbWJvdXJnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdXJvcGUvTWFsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9Nb25hY29cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9Pc2xvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdXJvcGUvUm9tZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXVyb3BlL1Nhbl9NYXJpbm9cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9TdG9ja2hvbG1cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9WYWR1elwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXVyb3BlL1ZhdGljYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9WaWVubmFcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9adXJpY2hcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJDZW50cmFsIEV1cm9wZSBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIkNFRFRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogMixcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzAxOjAwKSBCZWxncmFkZSwgQnJhdGlzbGF2YSwgQnVkYXBlc3QsIExqdWJsamFuYSwgUHJhZ3VlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9CZWxncmFkZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXVyb3BlL0JyYXRpc2xhdmFcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9CdWRhcGVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXVyb3BlL0xqdWJsamFuYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXVyb3BlL1BvZGdvcmljYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXVyb3BlL1ByYWd1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXVyb3BlL1RpcmFuZVwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlJvbWFuY2UgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJSRFRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogMixcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzAxOjAwKSBCcnVzc2VscywgQ29wZW5oYWdlbiwgTWFkcmlkLCBQYXJpc1wiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvQ2V1dGFcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9CcnVzc2Vsc1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXVyb3BlL0NvcGVuaGFnZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9NYWRyaWRcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9QYXJpc1wiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkNlbnRyYWwgRXVyb3BlYW4gU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJDRURUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDIsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswMTowMCkgU2FyYWpldm8sIFNrb3BqZSwgV2Fyc2F3LCBaYWdyZWJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiRXVyb3BlL1NhcmFqZXZvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdXJvcGUvU2tvcGplXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdXJvcGUvV2Fyc2F3XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdXJvcGUvWmFncmViXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVy4gQ2VudHJhbCBBZnJpY2EgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJXQ0FTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAxLFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzAxOjAwKSBXZXN0IENlbnRyYWwgQWZyaWNhXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFmcmljYS9BbGdpZXJzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvQmFuZ3VpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvQnJhenphdmlsbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFmcmljYS9Eb3VhbGFcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFmcmljYS9LaW5zaGFzYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQWZyaWNhL0xhZ29zXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvTGlicmV2aWxsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQWZyaWNhL0x1YW5kYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQWZyaWNhL01hbGFib1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQWZyaWNhL05kamFtZW5hXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvTmlhbWV5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvUG9ydG8tTm92b1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQWZyaWNhL1R1bmlzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdGMvR01ULTFcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJOYW1pYmlhIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiTlNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDEsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMDE6MDApIFdpbmRob2VrXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFmcmljYS9XaW5kaG9la1wiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkdUQiBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIkdEVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAzLFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMDI6MDApIEF0aGVucywgQnVjaGFyZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvTmljb3NpYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXVyb3BlL0F0aGVuc1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXVyb3BlL0J1Y2hhcmVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXVyb3BlL0NoaXNpbmF1XCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTWlkZGxlIEVhc3QgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJNRURUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDMsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswMjowMCkgQmVpcnV0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvQmVpcnV0XCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiRWd5cHQgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogMixcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswMjowMCkgQ2Fpcm9cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQWZyaWNhL0NhaXJvXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiU3lyaWEgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJTRFRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogMyxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzAyOjAwKSBEYW1hc2N1c1wiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL0RhbWFzY3VzXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiRS4gRXVyb3BlIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiRUVEVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAzLFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMDI6MDApIEUuIEV1cm9wZVwiXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJTb3V0aCBBZnJpY2EgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJTQVNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDIsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMDI6MDApIEhhcmFyZSwgUHJldG9yaWFcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQWZyaWNhL0JsYW50eXJlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvQnVqdW1idXJhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvR2Fib3JvbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFmcmljYS9IYXJhcmVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFmcmljYS9Kb2hhbm5lc2J1cmdcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFmcmljYS9LaWdhbGlcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFmcmljYS9MdWJ1bWJhc2hpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvTHVzYWthXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvTWFwdXRvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvTWFzZXJ1XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvTWJhYmFuZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXRjL0dNVC0yXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiRkxFIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiRkRUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDMsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswMjowMCkgSGVsc2lua2ksIEt5aXYsIFJpZ2EsIFNvZmlhLCBUYWxsaW5uLCBWaWxuaXVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9IZWxzaW5raVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXVyb3BlL0tpZXZcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9NYXJpZWhhbW5cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9SaWdhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdXJvcGUvU29maWFcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9UYWxsaW5uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdXJvcGUvVXpoZ29yb2RcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9WaWxuaXVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdXJvcGUvWmFwb3Jvemh5ZVwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlR1cmtleSBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIlREVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAzLFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMDI6MDApIElzdGFuYnVsXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9Jc3RhbmJ1bFwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIklzcmFlbCBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIkpEVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAzLFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMDI6MDApIEplcnVzYWxlbVwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL0plcnVzYWxlbVwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkxpYnlhIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiTFNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDIsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMDI6MDApIFRyaXBvbGlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQWZyaWNhL1RyaXBvbGlcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJKb3JkYW4gU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJKU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogMyxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswMzowMCkgQW1tYW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9BbW1hblwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkFyYWJpYyBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIkFTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAzLFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzAzOjAwKSBCYWdoZGFkXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvQmFnaGRhZFwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkthbGluaW5ncmFkIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiS1NUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDMsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMDM6MDApIEthbGluaW5ncmFkLCBNaW5za1wiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdXJvcGUvS2FsaW5pbmdyYWRcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9NaW5za1wiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkFyYWIgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJBU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogMyxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswMzowMCkgS3V3YWl0LCBSaXlhZGhcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9BZGVuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL0JhaHJhaW5cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvS3V3YWl0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL1FhdGFyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL1JpeWFkaFwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkUuIEFmcmljYSBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIkVBU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogMyxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswMzowMCkgTmFpcm9iaVwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvQWRkaXNfQWJhYmFcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFmcmljYS9Bc21lcmFcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFmcmljYS9EYXJfZXNfU2FsYWFtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvRGppYm91dGlcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFmcmljYS9KdWJhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvS2FtcGFsYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQWZyaWNhL0toYXJ0b3VtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvTW9nYWRpc2h1XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBZnJpY2EvTmFpcm9iaVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQW50YXJjdGljYS9TeW93YVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXRjL0dNVC0zXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJJbmRpYW4vQW50YW5hbmFyaXZvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJJbmRpYW4vQ29tb3JvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJJbmRpYW4vTWF5b3R0ZVwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIklyYW4gU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJJRFRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogNC41LFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMDM6MzApIFRlaHJhblwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL1RlaHJhblwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkFyYWJpYW4gU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJBU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogNCxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswNDowMCkgQWJ1IERoYWJpLCBNdXNjYXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9EdWJhaVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9NdXNjYXRcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV0Yy9HTVQtNFwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkF6ZXJiYWlqYW4gU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJBRFRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogNSxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzA0OjAwKSBCYWt1XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvQmFrdVwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlJ1c3NpYW4gU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJSU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogNCxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswNDowMCkgTW9zY293LCBTdC4gUGV0ZXJzYnVyZywgVm9sZ29ncmFkXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9Nb3Njb3dcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9TYW1hcmFcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV1cm9wZS9TaW1mZXJvcG9sXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdXJvcGUvVm9sZ29ncmFkXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTWF1cml0aXVzIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiTVNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDQsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMDQ6MDApIFBvcnQgTG91aXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiSW5kaWFuL01haGVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkluZGlhbi9NYXVyaXRpdXNcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkluZGlhbi9SZXVuaW9uXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiR2VvcmdpYW4gU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJHU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogNCxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswNDowMCkgVGJpbGlzaVwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL1RiaWxpc2lcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJDYXVjYXN1cyBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIkNTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiA0LFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzA0OjAwKSBZZXJldmFuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvWWVyZXZhblwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkFmZ2hhbmlzdGFuIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiQVNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDQuNSxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswNDozMCkgS2FidWxcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9LYWJ1bFwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIldlc3QgQXNpYSBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIldBU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogNSxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswNTowMCkgQXNoZ2FiYXQsIFRhc2hrZW50XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFudGFyY3RpY2EvTWF3c29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL0FxdGF1XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL0FxdG9iZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9Bc2hnYWJhdFwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9EdXNoYW5iZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9PcmFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL1NhbWFya2FuZFwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9UYXNoa2VudFwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXRjL0dNVC01XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJJbmRpYW4vS2VyZ3VlbGVuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJJbmRpYW4vTWFsZGl2ZXNcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJQYWtpc3RhbiBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIlBTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiA1LFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzA1OjAwKSBJc2xhbWFiYWQsIEthcmFjaGlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9LYXJhY2hpXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiSW5kaWEgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJJU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogNS41LFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzA1OjMwKSBDaGVubmFpLCBLb2xrYXRhLCBNdW1iYWksIE5ldyBEZWxoaVwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL0NhbGN1dHRhXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiU3JpIExhbmthIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiU0xTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiA1LjUsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMDU6MzApIFNyaSBKYXlhd2FyZGVuZXB1cmFcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9Db2xvbWJvXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTmVwYWwgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJOU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogNS43NSxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswNTo0NSkgS2F0aG1hbmR1XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvS2F0bWFuZHVcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJDZW50cmFsIEFzaWEgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJDQVNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDYsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMDY6MDApIEFzdGFuYVwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbnRhcmN0aWNhL1Zvc3Rva1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9BbG1hdHlcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvQmlzaGtla1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9ReXp5bG9yZGFcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvVXJ1bXFpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdGMvR01ULTZcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkluZGlhbi9DaGFnb3NcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJCYW5nbGFkZXNoIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiQlNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDYsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMDY6MDApIERoYWthXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvRGhha2FcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvVGhpbXBodVwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkVrYXRlcmluYnVyZyBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIkVTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiA2LFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzA2OjAwKSBFa2F0ZXJpbmJ1cmdcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9ZZWthdGVyaW5idXJnXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTXlhbm1hciBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIk1TVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiA2LjUsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMDY6MzApIFlhbmdvbiAoUmFuZ29vbilcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9SYW5nb29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJJbmRpYW4vQ29jb3NcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJTRSBBc2lhIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiU0FTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiA3LFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzA3OjAwKSBCYW5na29rLCBIYW5vaSwgSmFrYXJ0YVwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbnRhcmN0aWNhL0RhdmlzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL0Jhbmdrb2tcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvSG92ZFwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9KYWthcnRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL1Bobm9tX1BlbmhcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvUG9udGlhbmFrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL1NhaWdvblwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9WaWVudGlhbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV0Yy9HTVQtN1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiSW5kaWFuL0NocmlzdG1hc1wiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIk4uIENlbnRyYWwgQXNpYSBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIk5DQVNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDcsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMDc6MDApIE5vdm9zaWJpcnNrXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvTm92b2t1em5ldHNrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL05vdm9zaWJpcnNrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL09tc2tcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJDaGluYSBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIkNTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiA4LFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzA4OjAwKSBCZWlqaW5nLCBDaG9uZ3FpbmcsIEhvbmcgS29uZywgVXJ1bXFpXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvSG9uZ19Lb25nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL01hY2F1XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL1NoYW5naGFpXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTm9ydGggQXNpYSBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIk5BU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogOCxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswODowMCkgS3Jhc25veWFyc2tcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9LcmFzbm95YXJza1wiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlNpbmdhcG9yZSBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIk1QU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogOCxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswODowMCkgS3VhbGEgTHVtcHVyLCBTaW5nYXBvcmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9CcnVuZWlcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvS3VhbGFfTHVtcHVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL0t1Y2hpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvTWFrYXNzYXJcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvTWFuaWxhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL1NpbmdhcG9yZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXRjL0dNVC04XCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVy4gQXVzdHJhbGlhIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiV0FTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiA4LFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzA4OjAwKSBQZXJ0aFwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBbnRhcmN0aWNhL0Nhc2V5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBdXN0cmFsaWEvUGVydGhcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJUYWlwZWkgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJUU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogOCxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswODowMCkgVGFpcGVpXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvVGFpcGVpXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVWxhYW5iYWF0YXIgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJVU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogOCxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswODowMCkgVWxhYW5iYWF0YXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9DaG9pYmFsc2FuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL1VsYWFuYmFhdGFyXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTm9ydGggQXNpYSBFYXN0IFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiTkFFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogOSxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswOTowMCkgSXJrdXRza1wiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL0lya3V0c2tcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJUb2t5byBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIlRTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiA5LFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzA5OjAwKSBPc2FrYSwgU2FwcG9ybywgVG9reW9cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9EaWxpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL0pheWFwdXJhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL1Rva3lvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdGMvR01ULTlcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIlBhY2lmaWMvUGFsYXVcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJLb3JlYSBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIktTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiA5LFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzA5OjAwKSBTZW91bFwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL1B5b25neWFuZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9TZW91bFwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkNlbi4gQXVzdHJhbGlhIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiQ0FTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiA5LjUsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMDk6MzApIEFkZWxhaWRlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkF1c3RyYWxpYS9BZGVsYWlkZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXVzdHJhbGlhL0Jyb2tlbl9IaWxsXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQVVTIENlbnRyYWwgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJBQ1NUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDkuNSxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQyswOTozMCkgRGFyd2luXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkF1c3RyYWxpYS9EYXJ3aW5cIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJFLiBBdXN0cmFsaWEgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJFQVNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDEwLFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzEwOjAwKSBCcmlzYmFuZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInV0Y1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJBdXN0cmFsaWEvQnJpc2JhbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkF1c3RyYWxpYS9MaW5kZW1hblwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkFVUyBFYXN0ZXJuIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiQUVTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAxMCxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQysxMDowMCkgQ2FuYmVycmEsIE1lbGJvdXJuZSwgU3lkbmV5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkF1c3RyYWxpYS9NZWxib3VybmVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkF1c3RyYWxpYS9TeWRuZXlcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJXZXN0IFBhY2lmaWMgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJXUFNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDEwLFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzEwOjAwKSBHdWFtLCBQb3J0IE1vcmVzYnlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQW50YXJjdGljYS9EdW1vbnREVXJ2aWxsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXRjL0dNVC0xMFwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiUGFjaWZpYy9HdWFtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJQYWNpZmljL1BvcnRfTW9yZXNieVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiUGFjaWZpYy9TYWlwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIlBhY2lmaWMvVHJ1a1wiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlRhc21hbmlhIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiVFNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDEwLFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzEwOjAwKSBIb2JhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQXVzdHJhbGlhL0N1cnJpZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXVzdHJhbGlhL0hvYmFydFwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIllha3V0c2sgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJZU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogMTAsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMTA6MDApIFlha3V0c2tcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9DaGl0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9LaGFuZHlnYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9ZYWt1dHNrXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ2VudHJhbCBQYWNpZmljIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiQ1BTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAxMSxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQysxMTowMCkgU29sb21vbiBJcy4sIE5ldyBDYWxlZG9uaWFcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQW50YXJjdGljYS9NYWNxdWFyaWVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkV0Yy9HTVQtMTFcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIlBhY2lmaWMvRWZhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIlBhY2lmaWMvR3VhZGFsY2FuYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIlBhY2lmaWMvS29zcmFlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJQYWNpZmljL05vdW1lYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiUGFjaWZpYy9Qb25hcGVcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJWbGFkaXZvc3RvayBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIlZTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAxMSxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQysxMTowMCkgVmxhZGl2b3N0b2tcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9TYWtoYWxpblwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9Vc3QtTmVyYVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9WbGFkaXZvc3Rva1wiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIk5ldyBaZWFsYW5kIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiTlpTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAxMixcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQysxMjowMCkgQXVja2xhbmQsIFdlbGxpbmd0b25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQW50YXJjdGljYS9NY011cmRvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJQYWNpZmljL0F1Y2tsYW5kXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVVRDKzEyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIlVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogMTIsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMTI6MDApIENvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lKzEyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkV0Yy9HTVQtMTJcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIlBhY2lmaWMvRnVuYWZ1dGlcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIlBhY2lmaWMvS3dhamFsZWluXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJQYWNpZmljL01hanVyb1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiUGFjaWZpYy9OYXVydVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiUGFjaWZpYy9UYXJhd2FcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIlBhY2lmaWMvV2FrZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiUGFjaWZpYy9XYWxsaXNcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJGaWppIFN0YW5kYXJkIFRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhYmJyXCI6IFwiRlNUXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IDEyLFxuICAgICAgICAgICAgICAgICAgICBcImlzZHN0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzEyOjAwKSBGaWppXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXRjXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIlBhY2lmaWMvRmlqaVwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIk1hZ2FkYW4gU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJNU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogMTIsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMTI6MDApIE1hZ2FkYW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiQXNpYS9BbmFkeXJcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvS2FtY2hhdGthXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJBc2lhL01hZ2FkYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzaWEvU3JlZG5la29seW1za1wiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkthbWNoYXRrYSBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIktEVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAxMyxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIoVVRDKzEyOjAwKSBQZXRyb3BhdmxvdnNrLUthbWNoYXRza3kgLSBPbGRcIlxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVG9uZ2EgU3RhbmRhcmQgVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImFiYnJcIjogXCJUU1RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvZmZzZXRcIjogMTMsXG4gICAgICAgICAgICAgICAgICAgIFwiaXNkc3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIihVVEMrMTM6MDApIE51a3UnYWxvZmFcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiRXRjL0dNVC0xM1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiUGFjaWZpYy9FbmRlcmJ1cnlcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIlBhY2lmaWMvRmFrYW9mb1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiUGFjaWZpYy9Ub25nYXRhcHVcIlxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJTYW1vYSBTdGFuZGFyZCBUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWJiclwiOiBcIlNTVFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9mZnNldFwiOiAxMyxcbiAgICAgICAgICAgICAgICAgICAgXCJpc2RzdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiKFVUQysxMzowMCkgU2Ftb2FcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1dGNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiUGFjaWZpYy9BcGlhXCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICB9O1xuXG4gICAgdmFyIG9faGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICAgIHZhciBvX2tleXMgPSAoT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvX2hhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gX2NvcHlPYmplY3Qoc291cmNlLCB0YXJnZXQpIHtcbiAgICAgIHZhciBrZXlzID0gb19rZXlzKHNvdXJjZSk7XG4gICAgICB2YXIga2V5O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV0gfHwgdGFyZ2V0W2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NvcHlBcnJheShzb3VyY2UsIHRhcmdldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzb3VyY2UubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRhcmdldFtpXSA9IHNvdXJjZVtpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgX3RhcmdldCkge1xuICAgICAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc291cmNlKTtcbiAgICAgICAgdmFyIHRhcmdldCA9IF90YXJnZXQgfHwgKGlzQXJyYXkgPyBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCkgOiB7fSk7XG5cbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICBfY29weUFycmF5KHNvdXJjZSwgdGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfY29weU9iamVjdChzb3VyY2UsIHRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKiBHZXQgdGhlIGRhdGEgYmFzZWQgb24ga2V5KiovXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gY29weU9iamVjdChkYXRhW25hbWVdKTtcbiAgICB9O1xuXG4gICAgLy8gTWFjIEFkZHJlc3NcbiAgICBDaGFuY2UucHJvdG90eXBlLm1hY19hZGRyZXNzID0gZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgICAgIC8vIHR5cGljYWxseSBtYWMgYWRkcmVzc2VzIGFyZSBzZXBhcmF0ZWQgYnkgXCI6XCJcbiAgICAgICAgLy8gaG93ZXZlciB0aGV5IGNhbiBhbHNvIGJlIHNlcGFyYXRlZCBieSBcIi1cIlxuICAgICAgICAvLyB0aGUgbmV0d29yayB2YXJpYW50IHVzZXMgYSBkb3QgZXZlcnkgZm91cnRoIGJ5dGVcblxuICAgICAgICBvcHRpb25zID0gaW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGlmKCFvcHRpb25zLnNlcGFyYXRvcikge1xuICAgICAgICAgICAgb3B0aW9ucy5zZXBhcmF0b3IgPSAgb3B0aW9ucy5uZXR3b3JrVmVyc2lvbiA/IFwiLlwiIDogXCI6XCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFjX3Bvb2w9XCJBQkNERUYxMjM0NTY3ODkwXCIsXG4gICAgICAgICAgICBtYWMgPSBcIlwiO1xuICAgICAgICBpZighb3B0aW9ucy5uZXR3b3JrVmVyc2lvbikge1xuICAgICAgICAgICAgbWFjID0gdGhpcy5uKHRoaXMuc3RyaW5nLCA2LCB7IHBvb2w6IG1hY19wb29sLCBsZW5ndGg6MiB9KS5qb2luKG9wdGlvbnMuc2VwYXJhdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hYyA9IHRoaXMubih0aGlzLnN0cmluZywgMywgeyBwb29sOiBtYWNfcG9vbCwgbGVuZ3RoOjQgfSkuam9pbihvcHRpb25zLnNlcGFyYXRvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFjO1xuICAgIH07XG5cbiAgICBDaGFuY2UucHJvdG90eXBlLm5vcm1hbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0T3B0aW9ucyhvcHRpb25zLCB7bWVhbiA6IDAsIGRldiA6IDEsIHBvb2wgOiBbXX0pO1xuXG4gICAgICAgIHRlc3RSYW5nZShcbiAgICAgICAgICAgIG9wdGlvbnMucG9vbC5jb25zdHJ1Y3RvciAhPT0gQXJyYXksXG4gICAgICAgICAgICBcIkNoYW5jZTogVGhlIHBvb2wgb3B0aW9uIG11c3QgYmUgYSB2YWxpZCBhcnJheS5cIlxuICAgICAgICApO1xuXG4gICAgICAgIC8vIElmIGEgcG9vbCBoYXMgYmVlbiBwYXNzZWQsIHRoZW4gd2UgYXJlIHJldHVybmluZyBhbiBpdGVtIGZyb20gdGhhdCBwb29sLFxuICAgICAgICAvLyB1c2luZyB0aGUgbm9ybWFsIGRpc3RyaWJ1dGlvbiBzZXR0aW5ncyB0aGF0IHdlcmUgcGFzc2VkIGluXG4gICAgICAgIGlmIChvcHRpb25zLnBvb2wubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsX3Bvb2wob3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgTWFyc2FnbGlhIFBvbGFyIG1ldGhvZFxuICAgICAgICB2YXIgcywgdSwgdiwgbm9ybSxcbiAgICAgICAgICAgIG1lYW4gPSBvcHRpb25zLm1lYW4sXG4gICAgICAgICAgICBkZXYgPSBvcHRpb25zLmRldjtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBVIGFuZCBWIGFyZSBmcm9tIHRoZSB1bmlmb3JtIGRpc3RyaWJ1dGlvbiBvbiAoLTEsIDEpXG4gICAgICAgICAgICB1ID0gdGhpcy5yYW5kb20oKSAqIDIgLSAxO1xuICAgICAgICAgICAgdiA9IHRoaXMucmFuZG9tKCkgKiAyIC0gMTtcblxuICAgICAgICAgICAgcyA9IHUgKiB1ICsgdiAqIHY7XG4gICAgICAgIH0gd2hpbGUgKHMgPj0gMSk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgc3RhbmRhcmQgbm9ybWFsIHZhcmlhdGVcbiAgICAgICAgbm9ybSA9IHUgKiBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhzKSAvIHMpO1xuXG4gICAgICAgIC8vIFNoYXBlIGFuZCBzY2FsZVxuICAgICAgICByZXR1cm4gZGV2ICogbm9ybSArIG1lYW47XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUubm9ybWFsX3Bvb2wgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBwZXJmb3JtYW5jZUNvdW50ZXIgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5yb3VuZCh0aGlzLm5vcm1hbCh7IG1lYW46IG9wdGlvbnMubWVhbiwgZGV2OiBvcHRpb25zLmRldiB9KSk7XG4gICAgICAgICAgICBpZiAoaWR4IDwgb3B0aW9ucy5wb29sLmxlbmd0aCAmJiBpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnBvb2xbaWR4XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2VDb3VudGVyKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUocGVyZm9ybWFuY2VDb3VudGVyIDwgMTAwKTtcblxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNoYW5jZTogWW91ciBwb29sIGlzIHRvbyBzbWFsbCBmb3IgdGhlIGdpdmVuIG1lYW4gYW5kIHN0YW5kYXJkIGRldmlhdGlvbi4gUGxlYXNlIGFkanVzdC5cIik7XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUucmFkaW8gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAvLyBJbml0aWFsIExldHRlciAoVHlwaWNhbGx5IERlc2lnbmF0ZWQgYnkgU2lkZSBvZiBNaXNzaXNzaXBwaSBSaXZlcilcbiAgICAgICAgb3B0aW9ucyA9IGluaXRPcHRpb25zKG9wdGlvbnMsIHtzaWRlIDogXCI/XCJ9KTtcbiAgICAgICAgdmFyIGZsID0gXCJcIjtcbiAgICAgICAgc3dpdGNoIChvcHRpb25zLnNpZGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlIFwiZWFzdFwiOlxuICAgICAgICBjYXNlIFwiZVwiOlxuICAgICAgICAgICAgZmwgPSBcIldcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwid2VzdFwiOlxuICAgICAgICBjYXNlIFwid1wiOlxuICAgICAgICAgICAgZmwgPSBcIktcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZmwgPSB0aGlzLmNoYXJhY3Rlcih7cG9vbDogXCJLV1wifSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbCArIHRoaXMuY2hhcmFjdGVyKHthbHBoYTogdHJ1ZSwgY2FzaW5nOiBcInVwcGVyXCJ9KSArXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyYWN0ZXIoe2FscGhhOiB0cnVlLCBjYXNpbmc6IFwidXBwZXJcIn0pICtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJhY3Rlcih7YWxwaGE6IHRydWUsIGNhc2luZzogXCJ1cHBlclwifSk7XG4gICAgfTtcblxuICAgIC8vIFNldCB0aGUgZGF0YSBhcyBrZXkgYW5kIGRhdGEgb3IgdGhlIGRhdGEgbWFwXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZGF0YVtuYW1lXSA9IHZhbHVlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBjb3B5T2JqZWN0KG5hbWUsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENoYW5jZS5wcm90b3R5cGUudHYgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yYWRpbyhvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLy8gSUQgbnVtYmVyIGZvciBCcmF6aWwgY29tcGFuaWVzXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5jbnBqID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMubih0aGlzLm5hdHVyYWwsIDgsIHsgbWF4OiA5IH0pO1xuICAgICAgICB2YXIgZDEgPSAyK25bN10qNituWzZdKjcrbls1XSo4K25bNF0qOStuWzNdKjIrblsyXSozK25bMV0qNCtuWzBdKjU7XG4gICAgICAgIGQxID0gMTEgLSAoZDEgJSAxMSk7XG4gICAgICAgIGlmIChkMT49MTApe1xuICAgICAgICAgICAgZDEgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkMiA9IGQxKjIrMytuWzddKjcrbls2XSo4K25bNV0qOStuWzRdKjIrblszXSozK25bMl0qNCtuWzFdKjUrblswXSo2O1xuICAgICAgICBkMiA9IDExIC0gKGQyICUgMTEpO1xuICAgICAgICBpZiAoZDI+PTEwKXtcbiAgICAgICAgICAgIGQyID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJycrblswXStuWzFdKycuJytuWzJdK25bM10rbls0XSsnLicrbls1XStuWzZdK25bN10rJy8wMDAxLScrZDErZDI7XG4gICAgfTtcblxuICAgIC8vIC0tIEVuZCBNaXNjZWxsYW5lb3VzIC0tXG5cbiAgICBDaGFuY2UucHJvdG90eXBlLm1lcnNlbm5lX3R3aXN0ZXIgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgICByZXR1cm4gbmV3IE1lcnNlbm5lVHdpc3RlcihzZWVkKTtcbiAgICB9O1xuXG4gICAgQ2hhbmNlLnByb3RvdHlwZS5ibHVlaW1wX21kNSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbHVlSW1wTUQ1KCk7XG4gICAgfTtcblxuICAgIC8vIE1lcnNlbm5lIFR3aXN0ZXIgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9iYW5rc2Vhbi8zMDA0OTRcbiAgICB2YXIgTWVyc2VubmVUd2lzdGVyID0gZnVuY3Rpb24gKHNlZWQpIHtcbiAgICAgICAgaWYgKHNlZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8ga2VwdCByYW5kb20gbnVtYmVyIHNhbWUgc2l6ZSBhcyB0aW1lIHVzZWQgcHJldmlvdXNseSB0byBlbnN1cmUgbm8gdW5leHBlY3RlZCByZXN1bHRzIGRvd25zdHJlYW1cbiAgICAgICAgICAgIHNlZWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqTWF0aC5wb3coMTAsMTMpKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBQZXJpb2QgcGFyYW1ldGVycyAqL1xuICAgICAgICB0aGlzLk4gPSA2MjQ7XG4gICAgICAgIHRoaXMuTSA9IDM5NztcbiAgICAgICAgdGhpcy5NQVRSSVhfQSA9IDB4OTkwOGIwZGY7ICAgLyogY29uc3RhbnQgdmVjdG9yIGEgKi9cbiAgICAgICAgdGhpcy5VUFBFUl9NQVNLID0gMHg4MDAwMDAwMDsgLyogbW9zdCBzaWduaWZpY2FudCB3LXIgYml0cyAqL1xuICAgICAgICB0aGlzLkxPV0VSX01BU0sgPSAweDdmZmZmZmZmOyAvKiBsZWFzdCBzaWduaWZpY2FudCByIGJpdHMgKi9cblxuICAgICAgICB0aGlzLm10ID0gbmV3IEFycmF5KHRoaXMuTik7IC8qIHRoZSBhcnJheSBmb3IgdGhlIHN0YXRlIHZlY3RvciAqL1xuICAgICAgICB0aGlzLm10aSA9IHRoaXMuTiArIDE7IC8qIG10aT09TiArIDEgbWVhbnMgbXRbTl0gaXMgbm90IGluaXRpYWxpemVkICovXG5cbiAgICAgICAgdGhpcy5pbml0X2dlbnJhbmQoc2VlZCk7XG4gICAgfTtcblxuICAgIC8qIGluaXRpYWxpemVzIG10W05dIHdpdGggYSBzZWVkICovXG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5pbml0X2dlbnJhbmQgPSBmdW5jdGlvbiAocykge1xuICAgICAgICB0aGlzLm10WzBdID0gcyA+Pj4gMDtcbiAgICAgICAgZm9yICh0aGlzLm10aSA9IDE7IHRoaXMubXRpIDwgdGhpcy5OOyB0aGlzLm10aSsrKSB7XG4gICAgICAgICAgICBzID0gdGhpcy5tdFt0aGlzLm10aSAtIDFdIF4gKHRoaXMubXRbdGhpcy5tdGkgLSAxXSA+Pj4gMzApO1xuICAgICAgICAgICAgdGhpcy5tdFt0aGlzLm10aV0gPSAoKCgoKHMgJiAweGZmZmYwMDAwKSA+Pj4gMTYpICogMTgxMjQzMzI1MykgPDwgMTYpICsgKHMgJiAweDAwMDBmZmZmKSAqIDE4MTI0MzMyNTMpICsgdGhpcy5tdGk7XG4gICAgICAgICAgICAvKiBTZWUgS251dGggVEFPQ1AgVm9sMi4gM3JkIEVkLiBQLjEwNiBmb3IgbXVsdGlwbGllci4gKi9cbiAgICAgICAgICAgIC8qIEluIHRoZSBwcmV2aW91cyB2ZXJzaW9ucywgTVNCcyBvZiB0aGUgc2VlZCBhZmZlY3QgICAqL1xuICAgICAgICAgICAgLyogb25seSBNU0JzIG9mIHRoZSBhcnJheSBtdFtdLiAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKiAyMDAyLzAxLzA5IG1vZGlmaWVkIGJ5IE1ha290byBNYXRzdW1vdG8gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubXRbdGhpcy5tdGldID4+Pj0gMDtcbiAgICAgICAgICAgIC8qIGZvciA+MzIgYml0IG1hY2hpbmVzICovXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyogaW5pdGlhbGl6ZSBieSBhbiBhcnJheSB3aXRoIGFycmF5LWxlbmd0aCAqL1xuICAgIC8qIGluaXRfa2V5IGlzIHRoZSBhcnJheSBmb3IgaW5pdGlhbGl6aW5nIGtleXMgKi9cbiAgICAvKiBrZXlfbGVuZ3RoIGlzIGl0cyBsZW5ndGggKi9cbiAgICAvKiBzbGlnaHQgY2hhbmdlIGZvciBDKyssIDIwMDQvMi8yNiAqL1xuICAgIE1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUuaW5pdF9ieV9hcnJheSA9IGZ1bmN0aW9uIChpbml0X2tleSwga2V5X2xlbmd0aCkge1xuICAgICAgICB2YXIgaSA9IDEsIGogPSAwLCBrLCBzO1xuICAgICAgICB0aGlzLmluaXRfZ2VucmFuZCgxOTY1MDIxOCk7XG4gICAgICAgIGsgPSAodGhpcy5OID4ga2V5X2xlbmd0aCA/IHRoaXMuTiA6IGtleV9sZW5ndGgpO1xuICAgICAgICBmb3IgKDsgazsgay0tKSB7XG4gICAgICAgICAgICBzID0gdGhpcy5tdFtpIC0gMV0gXiAodGhpcy5tdFtpIC0gMV0gPj4+IDMwKTtcbiAgICAgICAgICAgIHRoaXMubXRbaV0gPSAodGhpcy5tdFtpXSBeICgoKCgocyAmIDB4ZmZmZjAwMDApID4+PiAxNikgKiAxNjY0NTI1KSA8PCAxNikgKyAoKHMgJiAweDAwMDBmZmZmKSAqIDE2NjQ1MjUpKSkgKyBpbml0X2tleVtqXSArIGo7IC8qIG5vbiBsaW5lYXIgKi9cbiAgICAgICAgICAgIHRoaXMubXRbaV0gPj4+PSAwOyAvKiBmb3IgV09SRFNJWkUgPiAzMiBtYWNoaW5lcyAqL1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgaWYgKGkgPj0gdGhpcy5OKSB7IHRoaXMubXRbMF0gPSB0aGlzLm10W3RoaXMuTiAtIDFdOyBpID0gMTsgfVxuICAgICAgICAgICAgaWYgKGogPj0ga2V5X2xlbmd0aCkgeyBqID0gMDsgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoayA9IHRoaXMuTiAtIDE7IGs7IGstLSkge1xuICAgICAgICAgICAgcyA9IHRoaXMubXRbaSAtIDFdIF4gKHRoaXMubXRbaSAtIDFdID4+PiAzMCk7XG4gICAgICAgICAgICB0aGlzLm10W2ldID0gKHRoaXMubXRbaV0gXiAoKCgoKHMgJiAweGZmZmYwMDAwKSA+Pj4gMTYpICogMTU2NjA4Mzk0MSkgPDwgMTYpICsgKHMgJiAweDAwMDBmZmZmKSAqIDE1NjYwODM5NDEpKSAtIGk7IC8qIG5vbiBsaW5lYXIgKi9cbiAgICAgICAgICAgIHRoaXMubXRbaV0gPj4+PSAwOyAvKiBmb3IgV09SRFNJWkUgPiAzMiBtYWNoaW5lcyAqL1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaWYgKGkgPj0gdGhpcy5OKSB7IHRoaXMubXRbMF0gPSB0aGlzLm10W3RoaXMuTiAtIDFdOyBpID0gMTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tdFswXSA9IDB4ODAwMDAwMDA7IC8qIE1TQiBpcyAxOyBhc3N1cmluZyBub24temVybyBpbml0aWFsIGFycmF5ICovXG4gICAgfTtcblxuICAgIC8qIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMHhmZmZmZmZmZl0taW50ZXJ2YWwgKi9cbiAgICBNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmdlbnJhbmRfaW50MzIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB5O1xuICAgICAgICB2YXIgbWFnMDEgPSBuZXcgQXJyYXkoMHgwLCB0aGlzLk1BVFJJWF9BKTtcbiAgICAgICAgLyogbWFnMDFbeF0gPSB4ICogTUFUUklYX0EgIGZvciB4PTAsMSAqL1xuXG4gICAgICAgIGlmICh0aGlzLm10aSA+PSB0aGlzLk4pIHsgLyogZ2VuZXJhdGUgTiB3b3JkcyBhdCBvbmUgdGltZSAqL1xuICAgICAgICAgICAgdmFyIGtrO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tdGkgPT09IHRoaXMuTiArIDEpIHsgICAvKiBpZiBpbml0X2dlbnJhbmQoKSBoYXMgbm90IGJlZW4gY2FsbGVkLCAqL1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdF9nZW5yYW5kKDU0ODkpOyAvKiBhIGRlZmF1bHQgaW5pdGlhbCBzZWVkIGlzIHVzZWQgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoa2sgPSAwOyBrayA8IHRoaXMuTiAtIHRoaXMuTTsga2srKykge1xuICAgICAgICAgICAgICAgIHkgPSAodGhpcy5tdFtra10mdGhpcy5VUFBFUl9NQVNLKXwodGhpcy5tdFtrayArIDFdJnRoaXMuTE9XRVJfTUFTSyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tdFtra10gPSB0aGlzLm10W2trICsgdGhpcy5NXSBeICh5ID4+PiAxKSBeIG1hZzAxW3kgJiAweDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7a2sgPCB0aGlzLk4gLSAxOyBraysrKSB7XG4gICAgICAgICAgICAgICAgeSA9ICh0aGlzLm10W2trXSZ0aGlzLlVQUEVSX01BU0spfCh0aGlzLm10W2trICsgMV0mdGhpcy5MT1dFUl9NQVNLKTtcbiAgICAgICAgICAgICAgICB0aGlzLm10W2trXSA9IHRoaXMubXRba2sgKyAodGhpcy5NIC0gdGhpcy5OKV0gXiAoeSA+Pj4gMSkgXiBtYWcwMVt5ICYgMHgxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHkgPSAodGhpcy5tdFt0aGlzLk4gLSAxXSZ0aGlzLlVQUEVSX01BU0spfCh0aGlzLm10WzBdJnRoaXMuTE9XRVJfTUFTSyk7XG4gICAgICAgICAgICB0aGlzLm10W3RoaXMuTiAtIDFdID0gdGhpcy5tdFt0aGlzLk0gLSAxXSBeICh5ID4+PiAxKSBeIG1hZzAxW3kgJiAweDFdO1xuXG4gICAgICAgICAgICB0aGlzLm10aSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB5ID0gdGhpcy5tdFt0aGlzLm10aSsrXTtcblxuICAgICAgICAvKiBUZW1wZXJpbmcgKi9cbiAgICAgICAgeSBePSAoeSA+Pj4gMTEpO1xuICAgICAgICB5IF49ICh5IDw8IDcpICYgMHg5ZDJjNTY4MDtcbiAgICAgICAgeSBePSAoeSA8PCAxNSkgJiAweGVmYzYwMDAwO1xuICAgICAgICB5IF49ICh5ID4+PiAxOCk7XG5cbiAgICAgICAgcmV0dXJuIHkgPj4+IDA7XG4gICAgfTtcblxuICAgIC8qIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMHg3ZmZmZmZmZl0taW50ZXJ2YWwgKi9cbiAgICBNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmdlbnJhbmRfaW50MzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5nZW5yYW5kX2ludDMyKCkgPj4+IDEpO1xuICAgIH07XG5cbiAgICAvKiBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uIFswLDFdLXJlYWwtaW50ZXJ2YWwgKi9cbiAgICBNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmdlbnJhbmRfcmVhbDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbnJhbmRfaW50MzIoKSAqICgxLjAgLyA0Mjk0OTY3Mjk1LjApO1xuICAgICAgICAvKiBkaXZpZGVkIGJ5IDJeMzItMSAqL1xuICAgIH07XG5cbiAgICAvKiBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uIFswLDEpLXJlYWwtaW50ZXJ2YWwgKi9cbiAgICBNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLnJhbmRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VucmFuZF9pbnQzMigpICogKDEuMCAvIDQyOTQ5NjcyOTYuMCk7XG4gICAgICAgIC8qIGRpdmlkZWQgYnkgMl4zMiAqL1xuICAgIH07XG5cbiAgICAvKiBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uICgwLDEpLXJlYWwtaW50ZXJ2YWwgKi9cbiAgICBNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmdlbnJhbmRfcmVhbDMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5nZW5yYW5kX2ludDMyKCkgKyAwLjUpICogKDEuMCAvIDQyOTQ5NjcyOTYuMCk7XG4gICAgICAgIC8qIGRpdmlkZWQgYnkgMl4zMiAqL1xuICAgIH07XG5cbiAgICAvKiBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uIFswLDEpIHdpdGggNTMtYml0IHJlc29sdXRpb24qL1xuICAgIE1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUuZ2VucmFuZF9yZXM1MyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmdlbnJhbmRfaW50MzIoKT4+PjUsIGIgPSB0aGlzLmdlbnJhbmRfaW50MzIoKT4+PjY7XG4gICAgICAgIHJldHVybiAoYSAqIDY3MTA4ODY0LjAgKyBiKSAqICgxLjAgLyA5MDA3MTk5MjU0NzQwOTkyLjApO1xuICAgIH07XG5cbiAgICAvLyBCbHVlSW1wIE1ENSBoYXNoaW5nIGFsZ29yaXRobSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTUQ1XG4gICAgdmFyIEJsdWVJbXBNRDUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIEJsdWVJbXBNRDUucHJvdG90eXBlLlZFUlNJT04gPSAnMS4wLjEnO1xuXG4gICAgLypcbiAgICAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAgICAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gICAgKi9cbiAgICBCbHVlSW1wTUQ1LnByb3RvdHlwZS5zYWZlX2FkZCA9IGZ1bmN0aW9uIHNhZmVfYWRkKHgsIHkpIHtcbiAgICAgICAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKSxcbiAgICAgICAgICAgIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICAgICAgICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAgICAqL1xuICAgIEJsdWVJbXBNRDUucHJvdG90eXBlLmJpdF9yb2xsID0gZnVuY3Rpb24gKG51bSwgY250KSB7XG4gICAgICAgIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgdGhlIGZpdmUgYmFzaWMgb3BlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHVzZXMuXG4gICAgKi9cbiAgICBCbHVlSW1wTUQ1LnByb3RvdHlwZS5tZDVfY21uID0gZnVuY3Rpb24gKHEsIGEsIGIsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZV9hZGQodGhpcy5iaXRfcm9sbCh0aGlzLnNhZmVfYWRkKHRoaXMuc2FmZV9hZGQoYSwgcSksIHRoaXMuc2FmZV9hZGQoeCwgdCkpLCBzKSwgYik7XG4gICAgfTtcbiAgICBCbHVlSW1wTUQ1LnByb3RvdHlwZS5tZDVfZmYgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZDVfY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgICB9O1xuICAgIEJsdWVJbXBNRDUucHJvdG90eXBlLm1kNV9nZyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1kNV9jbW4oKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xuICAgIH07XG4gICAgQmx1ZUltcE1ENS5wcm90b3R5cGUubWQ1X2hoID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWQ1X2NtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xuICAgIH07XG4gICAgQmx1ZUltcE1ENS5wcm90b3R5cGUubWQ1X2lpID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWQ1X2NtbihjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoLlxuICAgICovXG4gICAgQmx1ZUltcE1ENS5wcm90b3R5cGUuYmlubF9tZDUgPSBmdW5jdGlvbiAoeCwgbGVuKSB7XG4gICAgICAgIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gICAgICAgIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKGxlbiAlIDMyKTtcbiAgICAgICAgeFsoKChsZW4gKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gbGVuO1xuXG4gICAgICAgIHZhciBpLCBvbGRhLCBvbGRiLCBvbGRjLCBvbGRkLFxuICAgICAgICAgICAgYSA9ICAxNzMyNTg0MTkzLFxuICAgICAgICAgICAgYiA9IC0yNzE3MzM4NzksXG4gICAgICAgICAgICBjID0gLTE3MzI1ODQxOTQsXG4gICAgICAgICAgICBkID0gIDI3MTczMzg3ODtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgICAgICAgIG9sZGEgPSBhO1xuICAgICAgICAgICAgb2xkYiA9IGI7XG4gICAgICAgICAgICBvbGRjID0gYztcbiAgICAgICAgICAgIG9sZGQgPSBkO1xuXG4gICAgICAgICAgICBhID0gdGhpcy5tZDVfZmYoYSwgYiwgYywgZCwgeFtpXSwgICAgICAgNywgLTY4MDg3NjkzNik7XG4gICAgICAgICAgICBkID0gdGhpcy5tZDVfZmYoZCwgYSwgYiwgYywgeFtpICsgIDFdLCAxMiwgLTM4OTU2NDU4Nik7XG4gICAgICAgICAgICBjID0gdGhpcy5tZDVfZmYoYywgZCwgYSwgYiwgeFtpICsgIDJdLCAxNywgIDYwNjEwNTgxOSk7XG4gICAgICAgICAgICBiID0gdGhpcy5tZDVfZmYoYiwgYywgZCwgYSwgeFtpICsgIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgICAgICAgICAgYSA9IHRoaXMubWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSArICA0XSwgIDcsIC0xNzY0MTg4OTcpO1xuICAgICAgICAgICAgZCA9IHRoaXMubWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSArICA1XSwgMTIsICAxMjAwMDgwNDI2KTtcbiAgICAgICAgICAgIGMgPSB0aGlzLm1kNV9mZihjLCBkLCBhLCBiLCB4W2kgKyAgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgICAgICAgICBiID0gdGhpcy5tZDVfZmYoYiwgYywgZCwgYSwgeFtpICsgIDddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICAgICAgICAgIGEgPSB0aGlzLm1kNV9mZihhLCBiLCBjLCBkLCB4W2kgKyAgOF0sICA3LCAgMTc3MDAzNTQxNik7XG4gICAgICAgICAgICBkID0gdGhpcy5tZDVfZmYoZCwgYSwgYiwgYywgeFtpICsgIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xuICAgICAgICAgICAgYyA9IHRoaXMubWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2Myk7XG4gICAgICAgICAgICBiID0gdGhpcy5tZDVfZmYoYiwgYywgZCwgYSwgeFtpICsgMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xuICAgICAgICAgICAgYSA9IHRoaXMubWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSArIDEyXSwgIDcsICAxODA0NjAzNjgyKTtcbiAgICAgICAgICAgIGQgPSB0aGlzLm1kNV9mZihkLCBhLCBiLCBjLCB4W2kgKyAxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgICAgICAgICAgYyA9IHRoaXMubWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICAgICAgICAgIGIgPSB0aGlzLm1kNV9mZihiLCBjLCBkLCBhLCB4W2kgKyAxNV0sIDIyLCAgMTIzNjUzNTMyOSk7XG5cbiAgICAgICAgICAgIGEgPSB0aGlzLm1kNV9nZyhhLCBiLCBjLCBkLCB4W2kgKyAgMV0sICA1LCAtMTY1Nzk2NTEwKTtcbiAgICAgICAgICAgIGQgPSB0aGlzLm1kNV9nZyhkLCBhLCBiLCBjLCB4W2kgKyAgNl0sICA5LCAtMTA2OTUwMTYzMik7XG4gICAgICAgICAgICBjID0gdGhpcy5tZDVfZ2coYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNCwgIDY0MzcxNzcxMyk7XG4gICAgICAgICAgICBiID0gdGhpcy5tZDVfZ2coYiwgYywgZCwgYSwgeFtpXSwgICAgICAyMCwgLTM3Mzg5NzMwMik7XG4gICAgICAgICAgICBhID0gdGhpcy5tZDVfZ2coYSwgYiwgYywgZCwgeFtpICsgIDVdLCAgNSwgLTcwMTU1ODY5MSk7XG4gICAgICAgICAgICBkID0gdGhpcy5tZDVfZ2coZCwgYSwgYiwgYywgeFtpICsgMTBdLCAgOSwgIDM4MDE2MDgzKTtcbiAgICAgICAgICAgIGMgPSB0aGlzLm1kNV9nZyhjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE0LCAtNjYwNDc4MzM1KTtcbiAgICAgICAgICAgIGIgPSB0aGlzLm1kNV9nZyhiLCBjLCBkLCBhLCB4W2kgKyAgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcbiAgICAgICAgICAgIGEgPSB0aGlzLm1kNV9nZyhhLCBiLCBjLCBkLCB4W2kgKyAgOV0sICA1LCAgNTY4NDQ2NDM4KTtcbiAgICAgICAgICAgIGQgPSB0aGlzLm1kNV9nZyhkLCBhLCBiLCBjLCB4W2kgKyAxNF0sICA5LCAtMTAxOTgwMzY5MCk7XG4gICAgICAgICAgICBjID0gdGhpcy5tZDVfZ2coYywgZCwgYSwgYiwgeFtpICsgIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgICAgICAgICBiID0gdGhpcy5tZDVfZ2coYiwgYywgZCwgYSwgeFtpICsgIDhdLCAyMCwgIDExNjM1MzE1MDEpO1xuICAgICAgICAgICAgYSA9IHRoaXMubWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgIDUsIC0xNDQ0NjgxNDY3KTtcbiAgICAgICAgICAgIGQgPSB0aGlzLm1kNV9nZyhkLCBhLCBiLCBjLCB4W2kgKyAgMl0sICA5LCAtNTE0MDM3ODQpO1xuICAgICAgICAgICAgYyA9IHRoaXMubWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSArICA3XSwgMTQsICAxNzM1MzI4NDczKTtcbiAgICAgICAgICAgIGIgPSB0aGlzLm1kNV9nZyhiLCBjLCBkLCBhLCB4W2kgKyAxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG5cbiAgICAgICAgICAgIGEgPSB0aGlzLm1kNV9oaChhLCBiLCBjLCBkLCB4W2kgKyAgNV0sICA0LCAtMzc4NTU4KTtcbiAgICAgICAgICAgIGQgPSB0aGlzLm1kNV9oaChkLCBhLCBiLCBjLCB4W2kgKyAgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XG4gICAgICAgICAgICBjID0gdGhpcy5tZDVfaGgoYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNiwgIDE4MzkwMzA1NjIpO1xuICAgICAgICAgICAgYiA9IHRoaXMubWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSArIDE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgICAgICAgICBhID0gdGhpcy5tZDVfaGgoYSwgYiwgYywgZCwgeFtpICsgIDFdLCAgNCwgLTE1MzA5OTIwNjApO1xuICAgICAgICAgICAgZCA9IHRoaXMubWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSArICA0XSwgMTEsICAxMjcyODkzMzUzKTtcbiAgICAgICAgICAgIGMgPSB0aGlzLm1kNV9oaChjLCBkLCBhLCBiLCB4W2kgKyAgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICAgICAgICAgIGIgPSB0aGlzLm1kNV9oaChiLCBjLCBkLCBhLCB4W2kgKyAxMF0sIDIzLCAtMTA5NDczMDY0MCk7XG4gICAgICAgICAgICBhID0gdGhpcy5tZDVfaGgoYSwgYiwgYywgZCwgeFtpICsgMTNdLCAgNCwgIDY4MTI3OTE3NCk7XG4gICAgICAgICAgICBkID0gdGhpcy5tZDVfaGgoZCwgYSwgYiwgYywgeFtpXSwgICAgICAxMSwgLTM1ODUzNzIyMik7XG4gICAgICAgICAgICBjID0gdGhpcy5tZDVfaGgoYywgZCwgYSwgYiwgeFtpICsgIDNdLCAxNiwgLTcyMjUyMTk3OSk7XG4gICAgICAgICAgICBiID0gdGhpcy5tZDVfaGgoYiwgYywgZCwgYSwgeFtpICsgIDZdLCAyMywgIDc2MDI5MTg5KTtcbiAgICAgICAgICAgIGEgPSB0aGlzLm1kNV9oaChhLCBiLCBjLCBkLCB4W2kgKyAgOV0sICA0LCAtNjQwMzY0NDg3KTtcbiAgICAgICAgICAgIGQgPSB0aGlzLm1kNV9oaChkLCBhLCBiLCBjLCB4W2kgKyAxMl0sIDExLCAtNDIxODE1ODM1KTtcbiAgICAgICAgICAgIGMgPSB0aGlzLm1kNV9oaChjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE2LCAgNTMwNzQyNTIwKTtcbiAgICAgICAgICAgIGIgPSB0aGlzLm1kNV9oaChiLCBjLCBkLCBhLCB4W2kgKyAgMl0sIDIzLCAtOTk1MzM4NjUxKTtcblxuICAgICAgICAgICAgYSA9IHRoaXMubWQ1X2lpKGEsIGIsIGMsIGQsIHhbaV0sICAgICAgIDYsIC0xOTg2MzA4NDQpO1xuICAgICAgICAgICAgZCA9IHRoaXMubWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSArICA3XSwgMTAsICAxMTI2ODkxNDE1KTtcbiAgICAgICAgICAgIGMgPSB0aGlzLm1kNV9paShjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgICAgICAgICBiID0gdGhpcy5tZDVfaWkoYiwgYywgZCwgYSwgeFtpICsgIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICAgICAgICAgIGEgPSB0aGlzLm1kNV9paShhLCBiLCBjLCBkLCB4W2kgKyAxMl0sICA2LCAgMTcwMDQ4NTU3MSk7XG4gICAgICAgICAgICBkID0gdGhpcy5tZDVfaWkoZCwgYSwgYiwgYywgeFtpICsgIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xuICAgICAgICAgICAgYyA9IHRoaXMubWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICAgICAgICAgIGIgPSB0aGlzLm1kNV9paShiLCBjLCBkLCBhLCB4W2kgKyAgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgICAgICAgICBhID0gdGhpcy5tZDVfaWkoYSwgYiwgYywgZCwgeFtpICsgIDhdLCAgNiwgIDE4NzMzMTMzNTkpO1xuICAgICAgICAgICAgZCA9IHRoaXMubWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSArIDE1XSwgMTAsIC0zMDYxMTc0NCk7XG4gICAgICAgICAgICBjID0gdGhpcy5tZDVfaWkoYywgZCwgYSwgYiwgeFtpICsgIDZdLCAxNSwgLTE1NjAxOTgzODApO1xuICAgICAgICAgICAgYiA9IHRoaXMubWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSArIDEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcbiAgICAgICAgICAgIGEgPSB0aGlzLm1kNV9paShhLCBiLCBjLCBkLCB4W2kgKyAgNF0sICA2LCAtMTQ1NTIzMDcwKTtcbiAgICAgICAgICAgIGQgPSB0aGlzLm1kNV9paShkLCBhLCBiLCBjLCB4W2kgKyAxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XG4gICAgICAgICAgICBjID0gdGhpcy5tZDVfaWkoYywgZCwgYSwgYiwgeFtpICsgIDJdLCAxNSwgIDcxODc4NzI1OSk7XG4gICAgICAgICAgICBiID0gdGhpcy5tZDVfaWkoYiwgYywgZCwgYSwgeFtpICsgIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG5cbiAgICAgICAgICAgIGEgPSB0aGlzLnNhZmVfYWRkKGEsIG9sZGEpO1xuICAgICAgICAgICAgYiA9IHRoaXMuc2FmZV9hZGQoYiwgb2xkYik7XG4gICAgICAgICAgICBjID0gdGhpcy5zYWZlX2FkZChjLCBvbGRjKTtcbiAgICAgICAgICAgIGQgPSB0aGlzLnNhZmVfYWRkKGQsIG9sZGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbYSwgYiwgYywgZF07XG4gICAgfTtcblxuICAgIC8qXG4gICAgKiBDb252ZXJ0IGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMgdG8gYSBzdHJpbmdcbiAgICAqL1xuICAgIEJsdWVJbXBNRDUucHJvdG90eXBlLmJpbmwycnN0ciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIG91dHB1dCA9ICcnO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoICogMzI7IGkgKz0gOCkge1xuICAgICAgICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGlucHV0W2kgPj4gNV0gPj4+IChpICUgMzIpKSAmIDB4RkYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKiBDb252ZXJ0IGEgcmF3IHN0cmluZyB0byBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gICAgKiBDaGFyYWN0ZXJzID4yNTUgaGF2ZSB0aGVpciBoaWdoLWJ5dGUgc2lsZW50bHkgaWdub3JlZC5cbiAgICAqL1xuICAgIEJsdWVJbXBNRDUucHJvdG90eXBlLnJzdHIyYmlubCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIG91dHB1dCA9IFtdO1xuICAgICAgICBvdXRwdXRbKGlucHV0Lmxlbmd0aCA+PiAyKSAtIDFdID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3V0cHV0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBvdXRwdXRbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGggKiA4OyBpICs9IDgpIHtcbiAgICAgICAgICAgIG91dHB1dFtpID4+IDVdIHw9IChpbnB1dC5jaGFyQ29kZUF0KGkgLyA4KSAmIDB4RkYpIDw8IChpICUgMzIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhIHJhdyBzdHJpbmdcbiAgICAqL1xuICAgIEJsdWVJbXBNRDUucHJvdG90eXBlLnJzdHJfbWQ1ID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmlubDJyc3RyKHRoaXMuYmlubF9tZDUodGhpcy5yc3RyMmJpbmwocyksIHMubGVuZ3RoICogOCkpO1xuICAgIH07XG5cbiAgICAvKlxuICAgICogQ2FsY3VsYXRlIHRoZSBITUFDLU1ENSwgb2YgYSBrZXkgYW5kIHNvbWUgZGF0YSAocmF3IHN0cmluZ3MpXG4gICAgKi9cbiAgICBCbHVlSW1wTUQ1LnByb3RvdHlwZS5yc3RyX2htYWNfbWQ1ID0gZnVuY3Rpb24gKGtleSwgZGF0YSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGJrZXkgPSB0aGlzLnJzdHIyYmlubChrZXkpLFxuICAgICAgICAgICAgaXBhZCA9IFtdLFxuICAgICAgICAgICAgb3BhZCA9IFtdLFxuICAgICAgICAgICAgaGFzaDtcbiAgICAgICAgaXBhZFsxNV0gPSBvcGFkWzE1XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGJrZXkubGVuZ3RoID4gMTYpIHtcbiAgICAgICAgICAgIGJrZXkgPSB0aGlzLmJpbmxfbWQ1KGJrZXksIGtleS5sZW5ndGggKiA4KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkgKz0gMSkge1xuICAgICAgICAgICAgaXBhZFtpXSA9IGJrZXlbaV0gXiAweDM2MzYzNjM2O1xuICAgICAgICAgICAgb3BhZFtpXSA9IGJrZXlbaV0gXiAweDVDNUM1QzVDO1xuICAgICAgICB9XG4gICAgICAgIGhhc2ggPSB0aGlzLmJpbmxfbWQ1KGlwYWQuY29uY2F0KHRoaXMucnN0cjJiaW5sKGRhdGEpKSwgNTEyICsgZGF0YS5sZW5ndGggKiA4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmlubDJyc3RyKHRoaXMuYmlubF9tZDUob3BhZC5jb25jYXQoaGFzaCksIDUxMiArIDEyOCkpO1xuICAgIH07XG5cbiAgICAvKlxuICAgICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYSBoZXggc3RyaW5nXG4gICAgKi9cbiAgICBCbHVlSW1wTUQ1LnByb3RvdHlwZS5yc3RyMmhleCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgaGV4X3RhYiA9ICcwMTIzNDU2Nzg5YWJjZGVmJyxcbiAgICAgICAgICAgIG91dHB1dCA9ICcnLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgeCA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBvdXRwdXQgKz0gaGV4X3RhYi5jaGFyQXQoKHggPj4+IDQpICYgMHgwRikgK1xuICAgICAgICAgICAgICAgIGhleF90YWIuY2hhckF0KHggJiAweDBGKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbiAgICAvKlxuICAgICogRW5jb2RlIGEgc3RyaW5nIGFzIHV0Zi04XG4gICAgKi9cbiAgICBCbHVlSW1wTUQ1LnByb3RvdHlwZS5zdHIycnN0cl91dGY4ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAqIFRha2Ugc3RyaW5nIGFyZ3VtZW50cyBhbmQgcmV0dXJuIGVpdGhlciByYXcgb3IgaGV4IGVuY29kZWQgc3RyaW5nc1xuICAgICovXG4gICAgQmx1ZUltcE1ENS5wcm90b3R5cGUucmF3X21kNSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJzdHJfbWQ1KHRoaXMuc3RyMnJzdHJfdXRmOChzKSk7XG4gICAgfTtcbiAgICBCbHVlSW1wTUQ1LnByb3RvdHlwZS5oZXhfbWQ1ID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnN0cjJoZXgodGhpcy5yYXdfbWQ1KHMpKTtcbiAgICB9O1xuICAgIEJsdWVJbXBNRDUucHJvdG90eXBlLnJhd19obWFjX21kNSA9IGZ1bmN0aW9uIChrLCBkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJzdHJfaG1hY19tZDUodGhpcy5zdHIycnN0cl91dGY4KGspLCB0aGlzLnN0cjJyc3RyX3V0ZjgoZCkpO1xuICAgIH07XG4gICAgQmx1ZUltcE1ENS5wcm90b3R5cGUuaGV4X2htYWNfbWQ1ID0gZnVuY3Rpb24gKGssIGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnN0cjJoZXgodGhpcy5yYXdfaG1hY19tZDUoaywgZCkpO1xuICAgIH07XG5cbiAgICBCbHVlSW1wTUQ1LnByb3RvdHlwZS5tZDUgPSBmdW5jdGlvbiAoc3RyaW5nLCBrZXksIHJhdykge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgaWYgKCFyYXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oZXhfbWQ1KHN0cmluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhd19tZDUoc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmF3KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZXhfaG1hY19tZDUoa2V5LCBzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmF3X2htYWNfbWQ1KGtleSwgc3RyaW5nKTtcbiAgICB9O1xuXG4gICAgLy8gQ29tbW9uSlMgbW9kdWxlXG4gICAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IENoYW5jZTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLkNoYW5jZSA9IENoYW5jZTtcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgQU1EIG1vZHVsZVxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2hhbmNlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBhIGltcG9ydHNTY3JpcHMgb2JqZWN0IGRlZmluZSBjaGFuY2UgZm9yIHdvcmtlclxuICAgIGlmICh0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY2hhbmNlID0gbmV3IENoYW5jZSgpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgd2luZG93IG9iamVjdCwgdGhhdCBhdCBsZWFzdCBoYXMgYSBkb2N1bWVudCBwcm9wZXJ0eSxcbiAgICAvLyBpbnN0YW50aWF0ZSBhbmQgZGVmaW5lIGNoYW5jZSBvbiB0aGUgd2luZG93XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB3aW5kb3cuQ2hhbmNlID0gQ2hhbmNlO1xuICAgICAgICB3aW5kb3cuY2hhbmNlID0gbmV3IENoYW5jZSgpO1xuICAgIH1cbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY2hhbmNlL2NoYW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("\"use strict\";\n\nmodule.exports = __webpack_require__(16);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZpbmUtdXBsb2FkZXIvbGliL3MzLmpzPzZhM2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL3MzLmZpbmUtdXBsb2FkZXIvczMuZmluZS11cGxvYWRlclwiKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9maW5lLXVwbG9hZGVyL2xpYi9zMy5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;// Fine Uploader 5.13.0 - (c) 2013-present Widen Enterprises, Inc. MIT licensed. http://fineuploader.com\n(function(global) {\n    var qq = function(element) {\n        \"use strict\";\n        return {\n            hide: function() {\n                element.style.display = \"none\";\n                return this;\n            },\n            attach: function(type, fn) {\n                if (element.addEventListener) {\n                    element.addEventListener(type, fn, false);\n                } else if (element.attachEvent) {\n                    element.attachEvent(\"on\" + type, fn);\n                }\n                return function() {\n                    qq(element).detach(type, fn);\n                };\n            },\n            detach: function(type, fn) {\n                if (element.removeEventListener) {\n                    element.removeEventListener(type, fn, false);\n                } else if (element.attachEvent) {\n                    element.detachEvent(\"on\" + type, fn);\n                }\n                return this;\n            },\n            contains: function(descendant) {\n                if (!descendant) {\n                    return false;\n                }\n                if (element === descendant) {\n                    return true;\n                }\n                if (element.contains) {\n                    return element.contains(descendant);\n                } else {\n                    return !!(descendant.compareDocumentPosition(element) & 8);\n                }\n            },\n            insertBefore: function(elementB) {\n                elementB.parentNode.insertBefore(element, elementB);\n                return this;\n            },\n            remove: function() {\n                element.parentNode.removeChild(element);\n                return this;\n            },\n            css: function(styles) {\n                if (element.style == null) {\n                    throw new qq.Error(\"Can't apply style to node as it is not on the HTMLElement prototype chain!\");\n                }\n                if (styles.opacity != null) {\n                    if (typeof element.style.opacity !== \"string\" && typeof element.filters !== \"undefined\") {\n                        styles.filter = \"alpha(opacity=\" + Math.round(100 * styles.opacity) + \")\";\n                    }\n                }\n                qq.extend(element.style, styles);\n                return this;\n            },\n            hasClass: function(name, considerParent) {\n                var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n                return re.test(element.className) || !!(considerParent && re.test(element.parentNode.className));\n            },\n            addClass: function(name) {\n                if (!qq(element).hasClass(name)) {\n                    element.className += \" \" + name;\n                }\n                return this;\n            },\n            removeClass: function(name) {\n                var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n                element.className = element.className.replace(re, \" \").replace(/^\\s+|\\s+$/g, \"\");\n                return this;\n            },\n            getByClass: function(className, first) {\n                var candidates, result = [];\n                if (first && element.querySelector) {\n                    return element.querySelector(\".\" + className);\n                } else if (element.querySelectorAll) {\n                    return element.querySelectorAll(\".\" + className);\n                }\n                candidates = element.getElementsByTagName(\"*\");\n                qq.each(candidates, function(idx, val) {\n                    if (qq(val).hasClass(className)) {\n                        result.push(val);\n                    }\n                });\n                return first ? result[0] : result;\n            },\n            getFirstByClass: function(className) {\n                return qq(element).getByClass(className, true);\n            },\n            children: function() {\n                var children = [], child = element.firstChild;\n                while (child) {\n                    if (child.nodeType === 1) {\n                        children.push(child);\n                    }\n                    child = child.nextSibling;\n                }\n                return children;\n            },\n            setText: function(text) {\n                element.innerText = text;\n                element.textContent = text;\n                return this;\n            },\n            clearText: function() {\n                return qq(element).setText(\"\");\n            },\n            hasAttribute: function(attrName) {\n                var attrVal;\n                if (element.hasAttribute) {\n                    if (!element.hasAttribute(attrName)) {\n                        return false;\n                    }\n                    return /^false$/i.exec(element.getAttribute(attrName)) == null;\n                } else {\n                    attrVal = element[attrName];\n                    if (attrVal === undefined) {\n                        return false;\n                    }\n                    return /^false$/i.exec(attrVal) == null;\n                }\n            }\n        };\n    };\n    (function() {\n        \"use strict\";\n        qq.canvasToBlob = function(canvas, mime, quality) {\n            return qq.dataUriToBlob(canvas.toDataURL(mime, quality));\n        };\n        qq.dataUriToBlob = function(dataUri) {\n            var arrayBuffer, byteString, createBlob = function(data, mime) {\n                var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, blobBuilder = BlobBuilder && new BlobBuilder();\n                if (blobBuilder) {\n                    blobBuilder.append(data);\n                    return blobBuilder.getBlob(mime);\n                } else {\n                    return new Blob([ data ], {\n                        type: mime\n                    });\n                }\n            }, intArray, mimeString;\n            if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n                byteString = atob(dataUri.split(\",\")[1]);\n            } else {\n                byteString = decodeURI(dataUri.split(\",\")[1]);\n            }\n            mimeString = dataUri.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n            arrayBuffer = new ArrayBuffer(byteString.length);\n            intArray = new Uint8Array(arrayBuffer);\n            qq.each(byteString, function(idx, character) {\n                intArray[idx] = character.charCodeAt(0);\n            });\n            return createBlob(arrayBuffer, mimeString);\n        };\n        qq.log = function(message, level) {\n            if (window.console) {\n                if (!level || level === \"info\") {\n                    window.console.log(message);\n                } else {\n                    if (window.console[level]) {\n                        window.console[level](message);\n                    } else {\n                        window.console.log(\"<\" + level + \"> \" + message);\n                    }\n                }\n            }\n        };\n        qq.isObject = function(variable) {\n            return variable && !variable.nodeType && Object.prototype.toString.call(variable) === \"[object Object]\";\n        };\n        qq.isFunction = function(variable) {\n            return typeof variable === \"function\";\n        };\n        qq.isArray = function(value) {\n            return Object.prototype.toString.call(value) === \"[object Array]\" || value && window.ArrayBuffer && value.buffer && value.buffer.constructor === ArrayBuffer;\n        };\n        qq.isItemList = function(maybeItemList) {\n            return Object.prototype.toString.call(maybeItemList) === \"[object DataTransferItemList]\";\n        };\n        qq.isNodeList = function(maybeNodeList) {\n            return Object.prototype.toString.call(maybeNodeList) === \"[object NodeList]\" || maybeNodeList.item && maybeNodeList.namedItem;\n        };\n        qq.isString = function(maybeString) {\n            return Object.prototype.toString.call(maybeString) === \"[object String]\";\n        };\n        qq.trimStr = function(string) {\n            if (String.prototype.trim) {\n                return string.trim();\n            }\n            return string.replace(/^\\s+|\\s+$/g, \"\");\n        };\n        qq.format = function(str) {\n            var args = Array.prototype.slice.call(arguments, 1), newStr = str, nextIdxToReplace = newStr.indexOf(\"{}\");\n            qq.each(args, function(idx, val) {\n                var strBefore = newStr.substring(0, nextIdxToReplace), strAfter = newStr.substring(nextIdxToReplace + 2);\n                newStr = strBefore + val + strAfter;\n                nextIdxToReplace = newStr.indexOf(\"{}\", nextIdxToReplace + val.length);\n                if (nextIdxToReplace < 0) {\n                    return false;\n                }\n            });\n            return newStr;\n        };\n        qq.isFile = function(maybeFile) {\n            return window.File && Object.prototype.toString.call(maybeFile) === \"[object File]\";\n        };\n        qq.isFileList = function(maybeFileList) {\n            return window.FileList && Object.prototype.toString.call(maybeFileList) === \"[object FileList]\";\n        };\n        qq.isFileOrInput = function(maybeFileOrInput) {\n            return qq.isFile(maybeFileOrInput) || qq.isInput(maybeFileOrInput);\n        };\n        qq.isInput = function(maybeInput, notFile) {\n            var evaluateType = function(type) {\n                var normalizedType = type.toLowerCase();\n                if (notFile) {\n                    return normalizedType !== \"file\";\n                }\n                return normalizedType === \"file\";\n            };\n            if (window.HTMLInputElement) {\n                if (Object.prototype.toString.call(maybeInput) === \"[object HTMLInputElement]\") {\n                    if (maybeInput.type && evaluateType(maybeInput.type)) {\n                        return true;\n                    }\n                }\n            }\n            if (maybeInput.tagName) {\n                if (maybeInput.tagName.toLowerCase() === \"input\") {\n                    if (maybeInput.type && evaluateType(maybeInput.type)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n        qq.isBlob = function(maybeBlob) {\n            if (window.Blob && Object.prototype.toString.call(maybeBlob) === \"[object Blob]\") {\n                return true;\n            }\n        };\n        qq.isXhrUploadSupported = function() {\n            var input = document.createElement(\"input\");\n            input.type = \"file\";\n            return input.multiple !== undefined && typeof File !== \"undefined\" && typeof FormData !== \"undefined\" && typeof qq.createXhrInstance().upload !== \"undefined\";\n        };\n        qq.createXhrInstance = function() {\n            if (window.XMLHttpRequest) {\n                return new XMLHttpRequest();\n            }\n            try {\n                return new ActiveXObject(\"MSXML2.XMLHTTP.3.0\");\n            } catch (error) {\n                qq.log(\"Neither XHR or ActiveX are supported!\", \"error\");\n                return null;\n            }\n        };\n        qq.isFolderDropSupported = function(dataTransfer) {\n            return dataTransfer.items && dataTransfer.items.length > 0 && dataTransfer.items[0].webkitGetAsEntry;\n        };\n        qq.isFileChunkingSupported = function() {\n            return !qq.androidStock() && qq.isXhrUploadSupported() && (File.prototype.slice !== undefined || File.prototype.webkitSlice !== undefined || File.prototype.mozSlice !== undefined);\n        };\n        qq.sliceBlob = function(fileOrBlob, start, end) {\n            var slicer = fileOrBlob.slice || fileOrBlob.mozSlice || fileOrBlob.webkitSlice;\n            return slicer.call(fileOrBlob, start, end);\n        };\n        qq.arrayBufferToHex = function(buffer) {\n            var bytesAsHex = \"\", bytes = new Uint8Array(buffer);\n            qq.each(bytes, function(idx, byt) {\n                var byteAsHexStr = byt.toString(16);\n                if (byteAsHexStr.length < 2) {\n                    byteAsHexStr = \"0\" + byteAsHexStr;\n                }\n                bytesAsHex += byteAsHexStr;\n            });\n            return bytesAsHex;\n        };\n        qq.readBlobToHex = function(blob, startOffset, length) {\n            var initialBlob = qq.sliceBlob(blob, startOffset, startOffset + length), fileReader = new FileReader(), promise = new qq.Promise();\n            fileReader.onload = function() {\n                promise.success(qq.arrayBufferToHex(fileReader.result));\n            };\n            fileReader.onerror = promise.failure;\n            fileReader.readAsArrayBuffer(initialBlob);\n            return promise;\n        };\n        qq.extend = function(first, second, extendNested) {\n            qq.each(second, function(prop, val) {\n                if (extendNested && qq.isObject(val)) {\n                    if (first[prop] === undefined) {\n                        first[prop] = {};\n                    }\n                    qq.extend(first[prop], val, true);\n                } else {\n                    first[prop] = val;\n                }\n            });\n            return first;\n        };\n        qq.override = function(target, sourceFn) {\n            var super_ = {}, source = sourceFn(super_);\n            qq.each(source, function(srcPropName, srcPropVal) {\n                if (target[srcPropName] !== undefined) {\n                    super_[srcPropName] = target[srcPropName];\n                }\n                target[srcPropName] = srcPropVal;\n            });\n            return target;\n        };\n        qq.indexOf = function(arr, elt, from) {\n            if (arr.indexOf) {\n                return arr.indexOf(elt, from);\n            }\n            from = from || 0;\n            var len = arr.length;\n            if (from < 0) {\n                from += len;\n            }\n            for (;from < len; from += 1) {\n                if (arr.hasOwnProperty(from) && arr[from] === elt) {\n                    return from;\n                }\n            }\n            return -1;\n        };\n        qq.getUniqueId = function() {\n            return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n                var r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 3 | 8;\n                return v.toString(16);\n            });\n        };\n        qq.ie = function() {\n            return navigator.userAgent.indexOf(\"MSIE\") !== -1 || navigator.userAgent.indexOf(\"Trident\") !== -1;\n        };\n        qq.ie7 = function() {\n            return navigator.userAgent.indexOf(\"MSIE 7\") !== -1;\n        };\n        qq.ie8 = function() {\n            return navigator.userAgent.indexOf(\"MSIE 8\") !== -1;\n        };\n        qq.ie10 = function() {\n            return navigator.userAgent.indexOf(\"MSIE 10\") !== -1;\n        };\n        qq.ie11 = function() {\n            return qq.ie() && navigator.userAgent.indexOf(\"rv:11\") !== -1;\n        };\n        qq.edge = function() {\n            return navigator.userAgent.indexOf(\"Edge\") >= 0;\n        };\n        qq.safari = function() {\n            return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Apple\") !== -1;\n        };\n        qq.chrome = function() {\n            return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Google\") !== -1;\n        };\n        qq.opera = function() {\n            return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Opera\") !== -1;\n        };\n        qq.firefox = function() {\n            return !qq.edge() && !qq.ie11() && navigator.userAgent.indexOf(\"Mozilla\") !== -1 && navigator.vendor !== undefined && navigator.vendor === \"\";\n        };\n        qq.windows = function() {\n            return navigator.platform === \"Win32\";\n        };\n        qq.android = function() {\n            return navigator.userAgent.toLowerCase().indexOf(\"android\") !== -1;\n        };\n        qq.androidStock = function() {\n            return qq.android() && navigator.userAgent.toLowerCase().indexOf(\"chrome\") < 0;\n        };\n        qq.ios6 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 6_\") !== -1;\n        };\n        qq.ios7 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 7_\") !== -1;\n        };\n        qq.ios8 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 8_\") !== -1;\n        };\n        qq.ios800 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 8_0 \") !== -1;\n        };\n        qq.ios = function() {\n            return navigator.userAgent.indexOf(\"iPad\") !== -1 || navigator.userAgent.indexOf(\"iPod\") !== -1 || navigator.userAgent.indexOf(\"iPhone\") !== -1;\n        };\n        qq.iosChrome = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\"CriOS\") !== -1;\n        };\n        qq.iosSafari = function() {\n            return qq.ios() && !qq.iosChrome() && navigator.userAgent.indexOf(\"Safari\") !== -1;\n        };\n        qq.iosSafariWebView = function() {\n            return qq.ios() && !qq.iosChrome() && !qq.iosSafari();\n        };\n        qq.preventDefault = function(e) {\n            if (e.preventDefault) {\n                e.preventDefault();\n            } else {\n                e.returnValue = false;\n            }\n        };\n        qq.toElement = function() {\n            var div = document.createElement(\"div\");\n            return function(html) {\n                div.innerHTML = html;\n                var element = div.firstChild;\n                div.removeChild(element);\n                return element;\n            };\n        }();\n        qq.each = function(iterableItem, callback) {\n            var keyOrIndex, retVal;\n            if (iterableItem) {\n                if (window.Storage && iterableItem.constructor === window.Storage) {\n                    for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                        retVal = callback(iterableItem.key(keyOrIndex), iterableItem.getItem(iterableItem.key(keyOrIndex)));\n                        if (retVal === false) {\n                            break;\n                        }\n                    }\n                } else if (qq.isArray(iterableItem) || qq.isItemList(iterableItem) || qq.isNodeList(iterableItem)) {\n                    for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                        retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n                        if (retVal === false) {\n                            break;\n                        }\n                    }\n                } else if (qq.isString(iterableItem)) {\n                    for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                        retVal = callback(keyOrIndex, iterableItem.charAt(keyOrIndex));\n                        if (retVal === false) {\n                            break;\n                        }\n                    }\n                } else {\n                    for (keyOrIndex in iterableItem) {\n                        if (Object.prototype.hasOwnProperty.call(iterableItem, keyOrIndex)) {\n                            retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n                            if (retVal === false) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        qq.bind = function(oldFunc, context) {\n            if (qq.isFunction(oldFunc)) {\n                var args = Array.prototype.slice.call(arguments, 2);\n                return function() {\n                    var newArgs = qq.extend([], args);\n                    if (arguments.length) {\n                        newArgs = newArgs.concat(Array.prototype.slice.call(arguments));\n                    }\n                    return oldFunc.apply(context, newArgs);\n                };\n            }\n            throw new Error(\"first parameter must be a function!\");\n        };\n        qq.obj2url = function(obj, temp, prefixDone) {\n            var uristrings = [], prefix = \"&\", add = function(nextObj, i) {\n                var nextTemp = temp ? /\\[\\]$/.test(temp) ? temp : temp + \"[\" + i + \"]\" : i;\n                if (nextTemp !== \"undefined\" && i !== \"undefined\") {\n                    uristrings.push(typeof nextObj === \"object\" ? qq.obj2url(nextObj, nextTemp, true) : Object.prototype.toString.call(nextObj) === \"[object Function]\" ? encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj()) : encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj));\n                }\n            };\n            if (!prefixDone && temp) {\n                prefix = /\\?/.test(temp) ? /\\?$/.test(temp) ? \"\" : \"&\" : \"?\";\n                uristrings.push(temp);\n                uristrings.push(qq.obj2url(obj));\n            } else if (Object.prototype.toString.call(obj) === \"[object Array]\" && typeof obj !== \"undefined\") {\n                qq.each(obj, function(idx, val) {\n                    add(val, idx);\n                });\n            } else if (typeof obj !== \"undefined\" && obj !== null && typeof obj === \"object\") {\n                qq.each(obj, function(prop, val) {\n                    add(val, prop);\n                });\n            } else {\n                uristrings.push(encodeURIComponent(temp) + \"=\" + encodeURIComponent(obj));\n            }\n            if (temp) {\n                return uristrings.join(prefix);\n            } else {\n                return uristrings.join(prefix).replace(/^&/, \"\").replace(/%20/g, \"+\");\n            }\n        };\n        qq.obj2FormData = function(obj, formData, arrayKeyName) {\n            if (!formData) {\n                formData = new FormData();\n            }\n            qq.each(obj, function(key, val) {\n                key = arrayKeyName ? arrayKeyName + \"[\" + key + \"]\" : key;\n                if (qq.isObject(val)) {\n                    qq.obj2FormData(val, formData, key);\n                } else if (qq.isFunction(val)) {\n                    formData.append(key, val());\n                } else {\n                    formData.append(key, val);\n                }\n            });\n            return formData;\n        };\n        qq.obj2Inputs = function(obj, form) {\n            var input;\n            if (!form) {\n                form = document.createElement(\"form\");\n            }\n            qq.obj2FormData(obj, {\n                append: function(key, val) {\n                    input = document.createElement(\"input\");\n                    input.setAttribute(\"name\", key);\n                    input.setAttribute(\"value\", val);\n                    form.appendChild(input);\n                }\n            });\n            return form;\n        };\n        qq.parseJson = function(json) {\n            if (window.JSON && qq.isFunction(JSON.parse)) {\n                return JSON.parse(json);\n            } else {\n                return eval(\"(\" + json + \")\");\n            }\n        };\n        qq.getExtension = function(filename) {\n            var extIdx = filename.lastIndexOf(\".\") + 1;\n            if (extIdx > 0) {\n                return filename.substr(extIdx, filename.length - extIdx);\n            }\n        };\n        qq.getFilename = function(blobOrFileInput) {\n            if (qq.isInput(blobOrFileInput)) {\n                return blobOrFileInput.value.replace(/.*(\\/|\\\\)/, \"\");\n            } else if (qq.isFile(blobOrFileInput)) {\n                if (blobOrFileInput.fileName !== null && blobOrFileInput.fileName !== undefined) {\n                    return blobOrFileInput.fileName;\n                }\n            }\n            return blobOrFileInput.name;\n        };\n        qq.DisposeSupport = function() {\n            var disposers = [];\n            return {\n                dispose: function() {\n                    var disposer;\n                    do {\n                        disposer = disposers.shift();\n                        if (disposer) {\n                            disposer();\n                        }\n                    } while (disposer);\n                },\n                attach: function() {\n                    var args = arguments;\n                    this.addDisposer(qq(args[0]).attach.apply(this, Array.prototype.slice.call(arguments, 1)));\n                },\n                addDisposer: function(disposeFunction) {\n                    disposers.push(disposeFunction);\n                }\n            };\n        };\n    })();\n    (function() {\n        \"use strict\";\n        if (true) {\n            !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n                return qq;\n            }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        } else if (typeof module !== \"undefined\" && module.exports) {\n            module.exports = qq;\n        } else {\n            global.qq = qq;\n        }\n    })();\n    (function() {\n        \"use strict\";\n        qq.Error = function(message) {\n            this.message = \"[Fine Uploader \" + qq.version + \"] \" + message;\n        };\n        qq.Error.prototype = new Error();\n    })();\n    qq.version = \"5.13.0\";\n    qq.supportedFeatures = function() {\n        \"use strict\";\n        var supportsUploading, supportsUploadingBlobs, supportsFileDrop, supportsAjaxFileUploading, supportsFolderDrop, supportsChunking, supportsResume, supportsUploadViaPaste, supportsUploadCors, supportsDeleteFileXdr, supportsDeleteFileCorsXhr, supportsDeleteFileCors, supportsFolderSelection, supportsImagePreviews, supportsUploadProgress;\n        function testSupportsFileInputElement() {\n            var supported = true, tempInput;\n            try {\n                tempInput = document.createElement(\"input\");\n                tempInput.type = \"file\";\n                qq(tempInput).hide();\n                if (tempInput.disabled) {\n                    supported = false;\n                }\n            } catch (ex) {\n                supported = false;\n            }\n            return supported;\n        }\n        function isChrome21OrHigher() {\n            return (qq.chrome() || qq.opera()) && navigator.userAgent.match(/Chrome\\/[2][1-9]|Chrome\\/[3-9][0-9]/) !== undefined;\n        }\n        function isChrome14OrHigher() {\n            return (qq.chrome() || qq.opera()) && navigator.userAgent.match(/Chrome\\/[1][4-9]|Chrome\\/[2-9][0-9]/) !== undefined;\n        }\n        function isCrossOriginXhrSupported() {\n            if (window.XMLHttpRequest) {\n                var xhr = qq.createXhrInstance();\n                return xhr.withCredentials !== undefined;\n            }\n            return false;\n        }\n        function isXdrSupported() {\n            return window.XDomainRequest !== undefined;\n        }\n        function isCrossOriginAjaxSupported() {\n            if (isCrossOriginXhrSupported()) {\n                return true;\n            }\n            return isXdrSupported();\n        }\n        function isFolderSelectionSupported() {\n            return document.createElement(\"input\").webkitdirectory !== undefined;\n        }\n        function isLocalStorageSupported() {\n            try {\n                return !!window.localStorage && qq.isFunction(window.localStorage.setItem);\n            } catch (error) {\n                return false;\n            }\n        }\n        function isDragAndDropSupported() {\n            var span = document.createElement(\"span\");\n            return (\"draggable\" in span || \"ondragstart\" in span && \"ondrop\" in span) && !qq.android() && !qq.ios();\n        }\n        supportsUploading = testSupportsFileInputElement();\n        supportsAjaxFileUploading = supportsUploading && qq.isXhrUploadSupported();\n        supportsUploadingBlobs = supportsAjaxFileUploading && !qq.androidStock();\n        supportsFileDrop = supportsAjaxFileUploading && isDragAndDropSupported();\n        supportsFolderDrop = supportsFileDrop && isChrome21OrHigher();\n        supportsChunking = supportsAjaxFileUploading && qq.isFileChunkingSupported();\n        supportsResume = supportsAjaxFileUploading && supportsChunking && isLocalStorageSupported();\n        supportsUploadViaPaste = supportsAjaxFileUploading && isChrome14OrHigher();\n        supportsUploadCors = supportsUploading && (window.postMessage !== undefined || supportsAjaxFileUploading);\n        supportsDeleteFileCorsXhr = isCrossOriginXhrSupported();\n        supportsDeleteFileXdr = isXdrSupported();\n        supportsDeleteFileCors = isCrossOriginAjaxSupported();\n        supportsFolderSelection = isFolderSelectionSupported();\n        supportsImagePreviews = supportsAjaxFileUploading && window.FileReader !== undefined;\n        supportsUploadProgress = function() {\n            if (supportsAjaxFileUploading) {\n                return !qq.androidStock() && !qq.iosChrome();\n            }\n            return false;\n        }();\n        return {\n            ajaxUploading: supportsAjaxFileUploading,\n            blobUploading: supportsUploadingBlobs,\n            canDetermineSize: supportsAjaxFileUploading,\n            chunking: supportsChunking,\n            deleteFileCors: supportsDeleteFileCors,\n            deleteFileCorsXdr: supportsDeleteFileXdr,\n            deleteFileCorsXhr: supportsDeleteFileCorsXhr,\n            dialogElement: !!window.HTMLDialogElement,\n            fileDrop: supportsFileDrop,\n            folderDrop: supportsFolderDrop,\n            folderSelection: supportsFolderSelection,\n            imagePreviews: supportsImagePreviews,\n            imageValidation: supportsImagePreviews,\n            itemSizeValidation: supportsAjaxFileUploading,\n            pause: supportsChunking,\n            progressBar: supportsUploadProgress,\n            resume: supportsResume,\n            scaling: supportsImagePreviews && supportsUploadingBlobs,\n            tiffPreviews: qq.safari(),\n            unlimitedScaledImageSize: !qq.ios(),\n            uploading: supportsUploading,\n            uploadCors: supportsUploadCors,\n            uploadCustomHeaders: supportsAjaxFileUploading,\n            uploadNonMultipart: supportsAjaxFileUploading,\n            uploadViaPaste: supportsUploadViaPaste\n        };\n    }();\n    qq.isGenericPromise = function(maybePromise) {\n        \"use strict\";\n        return !!(maybePromise && maybePromise.then && qq.isFunction(maybePromise.then));\n    };\n    qq.Promise = function() {\n        \"use strict\";\n        var successArgs, failureArgs, successCallbacks = [], failureCallbacks = [], doneCallbacks = [], state = 0;\n        qq.extend(this, {\n            then: function(onSuccess, onFailure) {\n                if (state === 0) {\n                    if (onSuccess) {\n                        successCallbacks.push(onSuccess);\n                    }\n                    if (onFailure) {\n                        failureCallbacks.push(onFailure);\n                    }\n                } else if (state === -1) {\n                    onFailure && onFailure.apply(null, failureArgs);\n                } else if (onSuccess) {\n                    onSuccess.apply(null, successArgs);\n                }\n                return this;\n            },\n            done: function(callback) {\n                if (state === 0) {\n                    doneCallbacks.push(callback);\n                } else {\n                    callback.apply(null, failureArgs === undefined ? successArgs : failureArgs);\n                }\n                return this;\n            },\n            success: function() {\n                state = 1;\n                successArgs = arguments;\n                if (successCallbacks.length) {\n                    qq.each(successCallbacks, function(idx, callback) {\n                        callback.apply(null, successArgs);\n                    });\n                }\n                if (doneCallbacks.length) {\n                    qq.each(doneCallbacks, function(idx, callback) {\n                        callback.apply(null, successArgs);\n                    });\n                }\n                return this;\n            },\n            failure: function() {\n                state = -1;\n                failureArgs = arguments;\n                if (failureCallbacks.length) {\n                    qq.each(failureCallbacks, function(idx, callback) {\n                        callback.apply(null, failureArgs);\n                    });\n                }\n                if (doneCallbacks.length) {\n                    qq.each(doneCallbacks, function(idx, callback) {\n                        callback.apply(null, failureArgs);\n                    });\n                }\n                return this;\n            }\n        });\n    };\n    qq.BlobProxy = function(referenceBlob, onCreate) {\n        \"use strict\";\n        qq.extend(this, {\n            referenceBlob: referenceBlob,\n            create: function() {\n                return onCreate(referenceBlob);\n            }\n        });\n    };\n    qq.UploadButton = function(o) {\n        \"use strict\";\n        var self = this, disposeSupport = new qq.DisposeSupport(), options = {\n            acceptFiles: null,\n            element: null,\n            focusClass: \"qq-upload-button-focus\",\n            folders: false,\n            hoverClass: \"qq-upload-button-hover\",\n            ios8BrowserCrashWorkaround: false,\n            multiple: false,\n            name: \"qqfile\",\n            onChange: function(input) {},\n            title: null\n        }, input, buttonId;\n        qq.extend(options, o);\n        buttonId = qq.getUniqueId();\n        function createInput() {\n            var input = document.createElement(\"input\");\n            input.setAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME, buttonId);\n            input.setAttribute(\"title\", options.title);\n            self.setMultiple(options.multiple, input);\n            if (options.folders && qq.supportedFeatures.folderSelection) {\n                input.setAttribute(\"webkitdirectory\", \"\");\n            }\n            if (options.acceptFiles) {\n                input.setAttribute(\"accept\", options.acceptFiles);\n            }\n            input.setAttribute(\"type\", \"file\");\n            input.setAttribute(\"name\", options.name);\n            qq(input).css({\n                position: \"absolute\",\n                right: 0,\n                top: 0,\n                fontFamily: \"Arial\",\n                fontSize: qq.ie() && !qq.ie8() ? \"3500px\" : \"118px\",\n                margin: 0,\n                padding: 0,\n                cursor: \"pointer\",\n                opacity: 0\n            });\n            !qq.ie7() && qq(input).css({\n                height: \"100%\"\n            });\n            options.element.appendChild(input);\n            disposeSupport.attach(input, \"change\", function() {\n                options.onChange(input);\n            });\n            disposeSupport.attach(input, \"mouseover\", function() {\n                qq(options.element).addClass(options.hoverClass);\n            });\n            disposeSupport.attach(input, \"mouseout\", function() {\n                qq(options.element).removeClass(options.hoverClass);\n            });\n            disposeSupport.attach(input, \"focus\", function() {\n                qq(options.element).addClass(options.focusClass);\n            });\n            disposeSupport.attach(input, \"blur\", function() {\n                qq(options.element).removeClass(options.focusClass);\n            });\n            return input;\n        }\n        qq(options.element).css({\n            position: \"relative\",\n            overflow: \"hidden\",\n            direction: \"ltr\"\n        });\n        qq.extend(this, {\n            getInput: function() {\n                return input;\n            },\n            getButtonId: function() {\n                return buttonId;\n            },\n            setMultiple: function(isMultiple, optInput) {\n                var input = optInput || this.getInput();\n                if (options.ios8BrowserCrashWorkaround && qq.ios8() && (qq.iosChrome() || qq.iosSafariWebView())) {\n                    input.setAttribute(\"multiple\", \"\");\n                } else {\n                    if (isMultiple) {\n                        input.setAttribute(\"multiple\", \"\");\n                    } else {\n                        input.removeAttribute(\"multiple\");\n                    }\n                }\n            },\n            setAcceptFiles: function(acceptFiles) {\n                if (acceptFiles !== options.acceptFiles) {\n                    input.setAttribute(\"accept\", acceptFiles);\n                }\n            },\n            reset: function() {\n                if (input.parentNode) {\n                    qq(input).remove();\n                }\n                qq(options.element).removeClass(options.focusClass);\n                input = null;\n                input = createInput();\n            }\n        });\n        input = createInput();\n    };\n    qq.UploadButton.BUTTON_ID_ATTR_NAME = \"qq-button-id\";\n    qq.UploadData = function(uploaderProxy) {\n        \"use strict\";\n        var data = [], byUuid = {}, byStatus = {}, byProxyGroupId = {}, byBatchId = {};\n        function getDataByIds(idOrIds) {\n            if (qq.isArray(idOrIds)) {\n                var entries = [];\n                qq.each(idOrIds, function(idx, id) {\n                    entries.push(data[id]);\n                });\n                return entries;\n            }\n            return data[idOrIds];\n        }\n        function getDataByUuids(uuids) {\n            if (qq.isArray(uuids)) {\n                var entries = [];\n                qq.each(uuids, function(idx, uuid) {\n                    entries.push(data[byUuid[uuid]]);\n                });\n                return entries;\n            }\n            return data[byUuid[uuids]];\n        }\n        function getDataByStatus(status) {\n            var statusResults = [], statuses = [].concat(status);\n            qq.each(statuses, function(index, statusEnum) {\n                var statusResultIndexes = byStatus[statusEnum];\n                if (statusResultIndexes !== undefined) {\n                    qq.each(statusResultIndexes, function(i, dataIndex) {\n                        statusResults.push(data[dataIndex]);\n                    });\n                }\n            });\n            return statusResults;\n        }\n        qq.extend(this, {\n            addFile: function(spec) {\n                var status = spec.status || qq.status.SUBMITTING, id = data.push({\n                    name: spec.name,\n                    originalName: spec.name,\n                    uuid: spec.uuid,\n                    size: spec.size == null ? -1 : spec.size,\n                    status: status\n                }) - 1;\n                if (spec.batchId) {\n                    data[id].batchId = spec.batchId;\n                    if (byBatchId[spec.batchId] === undefined) {\n                        byBatchId[spec.batchId] = [];\n                    }\n                    byBatchId[spec.batchId].push(id);\n                }\n                if (spec.proxyGroupId) {\n                    data[id].proxyGroupId = spec.proxyGroupId;\n                    if (byProxyGroupId[spec.proxyGroupId] === undefined) {\n                        byProxyGroupId[spec.proxyGroupId] = [];\n                    }\n                    byProxyGroupId[spec.proxyGroupId].push(id);\n                }\n                data[id].id = id;\n                byUuid[spec.uuid] = id;\n                if (byStatus[status] === undefined) {\n                    byStatus[status] = [];\n                }\n                byStatus[status].push(id);\n                uploaderProxy.onStatusChange(id, null, status);\n                return id;\n            },\n            retrieve: function(optionalFilter) {\n                if (qq.isObject(optionalFilter) && data.length) {\n                    if (optionalFilter.id !== undefined) {\n                        return getDataByIds(optionalFilter.id);\n                    } else if (optionalFilter.uuid !== undefined) {\n                        return getDataByUuids(optionalFilter.uuid);\n                    } else if (optionalFilter.status) {\n                        return getDataByStatus(optionalFilter.status);\n                    }\n                } else {\n                    return qq.extend([], data, true);\n                }\n            },\n            reset: function() {\n                data = [];\n                byUuid = {};\n                byStatus = {};\n                byBatchId = {};\n            },\n            setStatus: function(id, newStatus) {\n                var oldStatus = data[id].status, byStatusOldStatusIndex = qq.indexOf(byStatus[oldStatus], id);\n                byStatus[oldStatus].splice(byStatusOldStatusIndex, 1);\n                data[id].status = newStatus;\n                if (byStatus[newStatus] === undefined) {\n                    byStatus[newStatus] = [];\n                }\n                byStatus[newStatus].push(id);\n                uploaderProxy.onStatusChange(id, oldStatus, newStatus);\n            },\n            uuidChanged: function(id, newUuid) {\n                var oldUuid = data[id].uuid;\n                data[id].uuid = newUuid;\n                byUuid[newUuid] = id;\n                delete byUuid[oldUuid];\n            },\n            updateName: function(id, newName) {\n                data[id].name = newName;\n            },\n            updateSize: function(id, newSize) {\n                data[id].size = newSize;\n            },\n            setParentId: function(targetId, parentId) {\n                data[targetId].parentId = parentId;\n            },\n            getIdsInProxyGroup: function(id) {\n                var proxyGroupId = data[id].proxyGroupId;\n                if (proxyGroupId) {\n                    return byProxyGroupId[proxyGroupId];\n                }\n                return [];\n            },\n            getIdsInBatch: function(id) {\n                var batchId = data[id].batchId;\n                return byBatchId[batchId];\n            }\n        });\n    };\n    qq.status = {\n        SUBMITTING: \"submitting\",\n        SUBMITTED: \"submitted\",\n        REJECTED: \"rejected\",\n        QUEUED: \"queued\",\n        CANCELED: \"canceled\",\n        PAUSED: \"paused\",\n        UPLOADING: \"uploading\",\n        UPLOAD_RETRYING: \"retrying upload\",\n        UPLOAD_SUCCESSFUL: \"upload successful\",\n        UPLOAD_FAILED: \"upload failed\",\n        DELETE_FAILED: \"delete failed\",\n        DELETING: \"deleting\",\n        DELETED: \"deleted\"\n    };\n    (function() {\n        \"use strict\";\n        qq.basePublicApi = {\n            addBlobs: function(blobDataOrArray, params, endpoint) {\n                this.addFiles(blobDataOrArray, params, endpoint);\n            },\n            addInitialFiles: function(cannedFileList) {\n                var self = this;\n                qq.each(cannedFileList, function(index, cannedFile) {\n                    self._addCannedFile(cannedFile);\n                });\n            },\n            addFiles: function(data, params, endpoint) {\n                this._maybeHandleIos8SafariWorkaround();\n                var batchId = this._storedIds.length === 0 ? qq.getUniqueId() : this._currentBatchId, processBlob = qq.bind(function(blob) {\n                    this._handleNewFile({\n                        blob: blob,\n                        name: this._options.blobs.defaultName\n                    }, batchId, verifiedFiles);\n                }, this), processBlobData = qq.bind(function(blobData) {\n                    this._handleNewFile(blobData, batchId, verifiedFiles);\n                }, this), processCanvas = qq.bind(function(canvas) {\n                    var blob = qq.canvasToBlob(canvas);\n                    this._handleNewFile({\n                        blob: blob,\n                        name: this._options.blobs.defaultName + \".png\"\n                    }, batchId, verifiedFiles);\n                }, this), processCanvasData = qq.bind(function(canvasData) {\n                    var normalizedQuality = canvasData.quality && canvasData.quality / 100, blob = qq.canvasToBlob(canvasData.canvas, canvasData.type, normalizedQuality);\n                    this._handleNewFile({\n                        blob: blob,\n                        name: canvasData.name\n                    }, batchId, verifiedFiles);\n                }, this), processFileOrInput = qq.bind(function(fileOrInput) {\n                    if (qq.isInput(fileOrInput) && qq.supportedFeatures.ajaxUploading) {\n                        var files = Array.prototype.slice.call(fileOrInput.files), self = this;\n                        qq.each(files, function(idx, file) {\n                            self._handleNewFile(file, batchId, verifiedFiles);\n                        });\n                    } else {\n                        this._handleNewFile(fileOrInput, batchId, verifiedFiles);\n                    }\n                }, this), normalizeData = function() {\n                    if (qq.isFileList(data)) {\n                        data = Array.prototype.slice.call(data);\n                    }\n                    data = [].concat(data);\n                }, self = this, verifiedFiles = [];\n                this._currentBatchId = batchId;\n                if (data) {\n                    normalizeData();\n                    qq.each(data, function(idx, fileContainer) {\n                        if (qq.isFileOrInput(fileContainer)) {\n                            processFileOrInput(fileContainer);\n                        } else if (qq.isBlob(fileContainer)) {\n                            processBlob(fileContainer);\n                        } else if (qq.isObject(fileContainer)) {\n                            if (fileContainer.blob && fileContainer.name) {\n                                processBlobData(fileContainer);\n                            } else if (fileContainer.canvas && fileContainer.name) {\n                                processCanvasData(fileContainer);\n                            }\n                        } else if (fileContainer.tagName && fileContainer.tagName.toLowerCase() === \"canvas\") {\n                            processCanvas(fileContainer);\n                        } else {\n                            self.log(fileContainer + \" is not a valid file container!  Ignoring!\", \"warn\");\n                        }\n                    });\n                    this.log(\"Received \" + verifiedFiles.length + \" files.\");\n                    this._prepareItemsForUpload(verifiedFiles, params, endpoint);\n                }\n            },\n            cancel: function(id) {\n                this._handler.cancel(id);\n            },\n            cancelAll: function() {\n                var storedIdsCopy = [], self = this;\n                qq.extend(storedIdsCopy, this._storedIds);\n                qq.each(storedIdsCopy, function(idx, storedFileId) {\n                    self.cancel(storedFileId);\n                });\n                this._handler.cancelAll();\n            },\n            clearStoredFiles: function() {\n                this._storedIds = [];\n            },\n            continueUpload: function(id) {\n                var uploadData = this._uploadData.retrieve({\n                    id: id\n                });\n                if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n                    return false;\n                }\n                if (uploadData.status === qq.status.PAUSED) {\n                    this.log(qq.format(\"Paused file ID {} ({}) will be continued.  Not paused.\", id, this.getName(id)));\n                    this._uploadFile(id);\n                    return true;\n                } else {\n                    this.log(qq.format(\"Ignoring continue for file ID {} ({}).  Not paused.\", id, this.getName(id)), \"error\");\n                }\n                return false;\n            },\n            deleteFile: function(id) {\n                return this._onSubmitDelete(id);\n            },\n            doesExist: function(fileOrBlobId) {\n                return this._handler.isValid(fileOrBlobId);\n            },\n            drawThumbnail: function(fileId, imgOrCanvas, maxSize, fromServer, customResizeFunction) {\n                var promiseToReturn = new qq.Promise(), fileOrUrl, options;\n                if (this._imageGenerator) {\n                    fileOrUrl = this._thumbnailUrls[fileId];\n                    options = {\n                        customResizeFunction: customResizeFunction,\n                        maxSize: maxSize > 0 ? maxSize : null,\n                        scale: maxSize > 0\n                    };\n                    if (!fromServer && qq.supportedFeatures.imagePreviews) {\n                        fileOrUrl = this.getFile(fileId);\n                    }\n                    if (fileOrUrl == null) {\n                        promiseToReturn.failure({\n                            container: imgOrCanvas,\n                            error: \"File or URL not found.\"\n                        });\n                    } else {\n                        this._imageGenerator.generate(fileOrUrl, imgOrCanvas, options).then(function success(modifiedContainer) {\n                            promiseToReturn.success(modifiedContainer);\n                        }, function failure(container, reason) {\n                            promiseToReturn.failure({\n                                container: container,\n                                error: reason || \"Problem generating thumbnail\"\n                            });\n                        });\n                    }\n                } else {\n                    promiseToReturn.failure({\n                        container: imgOrCanvas,\n                        error: \"Missing image generator module\"\n                    });\n                }\n                return promiseToReturn;\n            },\n            getButton: function(fileId) {\n                return this._getButton(this._buttonIdsForFileIds[fileId]);\n            },\n            getEndpoint: function(fileId) {\n                return this._endpointStore.get(fileId);\n            },\n            getFile: function(fileOrBlobId) {\n                return this._handler.getFile(fileOrBlobId) || null;\n            },\n            getInProgress: function() {\n                return this._uploadData.retrieve({\n                    status: [ qq.status.UPLOADING, qq.status.UPLOAD_RETRYING, qq.status.QUEUED ]\n                }).length;\n            },\n            getName: function(id) {\n                return this._uploadData.retrieve({\n                    id: id\n                }).name;\n            },\n            getParentId: function(id) {\n                var uploadDataEntry = this.getUploads({\n                    id: id\n                }), parentId = null;\n                if (uploadDataEntry) {\n                    if (uploadDataEntry.parentId !== undefined) {\n                        parentId = uploadDataEntry.parentId;\n                    }\n                }\n                return parentId;\n            },\n            getResumableFilesData: function() {\n                return this._handler.getResumableFilesData();\n            },\n            getSize: function(id) {\n                return this._uploadData.retrieve({\n                    id: id\n                }).size;\n            },\n            getNetUploads: function() {\n                return this._netUploaded;\n            },\n            getRemainingAllowedItems: function() {\n                var allowedItems = this._currentItemLimit;\n                if (allowedItems > 0) {\n                    return allowedItems - this._netUploadedOrQueued;\n                }\n                return null;\n            },\n            getUploads: function(optionalFilter) {\n                return this._uploadData.retrieve(optionalFilter);\n            },\n            getUuid: function(id) {\n                return this._uploadData.retrieve({\n                    id: id\n                }).uuid;\n            },\n            log: function(str, level) {\n                if (this._options.debug && (!level || level === \"info\")) {\n                    qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str);\n                } else if (level && level !== \"info\") {\n                    qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str, level);\n                }\n            },\n            pauseUpload: function(id) {\n                var uploadData = this._uploadData.retrieve({\n                    id: id\n                });\n                if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n                    return false;\n                }\n                if (qq.indexOf([ qq.status.UPLOADING, qq.status.UPLOAD_RETRYING ], uploadData.status) >= 0) {\n                    if (this._handler.pause(id)) {\n                        this._uploadData.setStatus(id, qq.status.PAUSED);\n                        return true;\n                    } else {\n                        this.log(qq.format(\"Unable to pause file ID {} ({}).\", id, this.getName(id)), \"error\");\n                    }\n                } else {\n                    this.log(qq.format(\"Ignoring pause for file ID {} ({}).  Not in progress.\", id, this.getName(id)), \"error\");\n                }\n                return false;\n            },\n            reset: function() {\n                this.log(\"Resetting uploader...\");\n                this._handler.reset();\n                this._storedIds = [];\n                this._autoRetries = [];\n                this._retryTimeouts = [];\n                this._preventRetries = [];\n                this._thumbnailUrls = [];\n                qq.each(this._buttons, function(idx, button) {\n                    button.reset();\n                });\n                this._paramsStore.reset();\n                this._endpointStore.reset();\n                this._netUploadedOrQueued = 0;\n                this._netUploaded = 0;\n                this._uploadData.reset();\n                this._buttonIdsForFileIds = [];\n                this._pasteHandler && this._pasteHandler.reset();\n                this._options.session.refreshOnReset && this._refreshSessionData();\n                this._succeededSinceLastAllComplete = [];\n                this._failedSinceLastAllComplete = [];\n                this._totalProgress && this._totalProgress.reset();\n            },\n            retry: function(id) {\n                return this._manualRetry(id);\n            },\n            scaleImage: function(id, specs) {\n                var self = this;\n                return qq.Scaler.prototype.scaleImage(id, specs, {\n                    log: qq.bind(self.log, self),\n                    getFile: qq.bind(self.getFile, self),\n                    uploadData: self._uploadData\n                });\n            },\n            setCustomHeaders: function(headers, id) {\n                this._customHeadersStore.set(headers, id);\n            },\n            setDeleteFileCustomHeaders: function(headers, id) {\n                this._deleteFileCustomHeadersStore.set(headers, id);\n            },\n            setDeleteFileEndpoint: function(endpoint, id) {\n                this._deleteFileEndpointStore.set(endpoint, id);\n            },\n            setDeleteFileParams: function(params, id) {\n                this._deleteFileParamsStore.set(params, id);\n            },\n            setEndpoint: function(endpoint, id) {\n                this._endpointStore.set(endpoint, id);\n            },\n            setForm: function(elementOrId) {\n                this._updateFormSupportAndParams(elementOrId);\n            },\n            setItemLimit: function(newItemLimit) {\n                this._currentItemLimit = newItemLimit;\n            },\n            setName: function(id, newName) {\n                this._uploadData.updateName(id, newName);\n            },\n            setParams: function(params, id) {\n                this._paramsStore.set(params, id);\n            },\n            setUuid: function(id, newUuid) {\n                return this._uploadData.uuidChanged(id, newUuid);\n            },\n            uploadStoredFiles: function() {\n                if (this._storedIds.length === 0) {\n                    this._itemError(\"noFilesError\");\n                } else {\n                    this._uploadStoredFiles();\n                }\n            }\n        };\n        qq.basePrivateApi = {\n            _addCannedFile: function(sessionData) {\n                var id = this._uploadData.addFile({\n                    uuid: sessionData.uuid,\n                    name: sessionData.name,\n                    size: sessionData.size,\n                    status: qq.status.UPLOAD_SUCCESSFUL\n                });\n                sessionData.deleteFileEndpoint && this.setDeleteFileEndpoint(sessionData.deleteFileEndpoint, id);\n                sessionData.deleteFileParams && this.setDeleteFileParams(sessionData.deleteFileParams, id);\n                if (sessionData.thumbnailUrl) {\n                    this._thumbnailUrls[id] = sessionData.thumbnailUrl;\n                }\n                this._netUploaded++;\n                this._netUploadedOrQueued++;\n                return id;\n            },\n            _annotateWithButtonId: function(file, associatedInput) {\n                if (qq.isFile(file)) {\n                    file.qqButtonId = this._getButtonId(associatedInput);\n                }\n            },\n            _batchError: function(message) {\n                this._options.callbacks.onError(null, null, message, undefined);\n            },\n            _createDeleteHandler: function() {\n                var self = this;\n                return new qq.DeleteFileAjaxRequester({\n                    method: this._options.deleteFile.method.toUpperCase(),\n                    maxConnections: this._options.maxConnections,\n                    uuidParamName: this._options.request.uuidName,\n                    customHeaders: this._deleteFileCustomHeadersStore,\n                    paramsStore: this._deleteFileParamsStore,\n                    endpointStore: this._deleteFileEndpointStore,\n                    cors: this._options.cors,\n                    log: qq.bind(self.log, self),\n                    onDelete: function(id) {\n                        self._onDelete(id);\n                        self._options.callbacks.onDelete(id);\n                    },\n                    onDeleteComplete: function(id, xhrOrXdr, isError) {\n                        self._onDeleteComplete(id, xhrOrXdr, isError);\n                        self._options.callbacks.onDeleteComplete(id, xhrOrXdr, isError);\n                    }\n                });\n            },\n            _createPasteHandler: function() {\n                var self = this;\n                return new qq.PasteSupport({\n                    targetElement: this._options.paste.targetElement,\n                    callbacks: {\n                        log: qq.bind(self.log, self),\n                        pasteReceived: function(blob) {\n                            self._handleCheckedCallback({\n                                name: \"onPasteReceived\",\n                                callback: qq.bind(self._options.callbacks.onPasteReceived, self, blob),\n                                onSuccess: qq.bind(self._handlePasteSuccess, self, blob),\n                                identifier: \"pasted image\"\n                            });\n                        }\n                    }\n                });\n            },\n            _createStore: function(initialValue, _readOnlyValues_) {\n                var store = {}, catchall = initialValue, perIdReadOnlyValues = {}, readOnlyValues = _readOnlyValues_, copy = function(orig) {\n                    if (qq.isObject(orig)) {\n                        return qq.extend({}, orig);\n                    }\n                    return orig;\n                }, getReadOnlyValues = function() {\n                    if (qq.isFunction(readOnlyValues)) {\n                        return readOnlyValues();\n                    }\n                    return readOnlyValues;\n                }, includeReadOnlyValues = function(id, existing) {\n                    if (readOnlyValues && qq.isObject(existing)) {\n                        qq.extend(existing, getReadOnlyValues());\n                    }\n                    if (perIdReadOnlyValues[id]) {\n                        qq.extend(existing, perIdReadOnlyValues[id]);\n                    }\n                };\n                return {\n                    set: function(val, id) {\n                        if (id == null) {\n                            store = {};\n                            catchall = copy(val);\n                        } else {\n                            store[id] = copy(val);\n                        }\n                    },\n                    get: function(id) {\n                        var values;\n                        if (id != null && store[id]) {\n                            values = store[id];\n                        } else {\n                            values = copy(catchall);\n                        }\n                        includeReadOnlyValues(id, values);\n                        return copy(values);\n                    },\n                    addReadOnly: function(id, values) {\n                        if (qq.isObject(store)) {\n                            if (id === null) {\n                                if (qq.isFunction(values)) {\n                                    readOnlyValues = values;\n                                } else {\n                                    readOnlyValues = readOnlyValues || {};\n                                    qq.extend(readOnlyValues, values);\n                                }\n                            } else {\n                                perIdReadOnlyValues[id] = perIdReadOnlyValues[id] || {};\n                                qq.extend(perIdReadOnlyValues[id], values);\n                            }\n                        }\n                    },\n                    remove: function(fileId) {\n                        return delete store[fileId];\n                    },\n                    reset: function() {\n                        store = {};\n                        perIdReadOnlyValues = {};\n                        catchall = initialValue;\n                    }\n                };\n            },\n            _createUploadDataTracker: function() {\n                var self = this;\n                return new qq.UploadData({\n                    getName: function(id) {\n                        return self.getName(id);\n                    },\n                    getUuid: function(id) {\n                        return self.getUuid(id);\n                    },\n                    getSize: function(id) {\n                        return self.getSize(id);\n                    },\n                    onStatusChange: function(id, oldStatus, newStatus) {\n                        self._onUploadStatusChange(id, oldStatus, newStatus);\n                        self._options.callbacks.onStatusChange(id, oldStatus, newStatus);\n                        self._maybeAllComplete(id, newStatus);\n                        if (self._totalProgress) {\n                            setTimeout(function() {\n                                self._totalProgress.onStatusChange(id, oldStatus, newStatus);\n                            }, 0);\n                        }\n                    }\n                });\n            },\n            _createUploadButton: function(spec) {\n                var self = this, acceptFiles = spec.accept || this._options.validation.acceptFiles, allowedExtensions = spec.allowedExtensions || this._options.validation.allowedExtensions, button;\n                function allowMultiple() {\n                    if (qq.supportedFeatures.ajaxUploading) {\n                        if (self._options.workarounds.iosEmptyVideos && qq.ios() && !qq.ios6() && self._isAllowedExtension(allowedExtensions, \".mov\")) {\n                            return false;\n                        }\n                        if (spec.multiple === undefined) {\n                            return self._options.multiple;\n                        }\n                        return spec.multiple;\n                    }\n                    return false;\n                }\n                button = new qq.UploadButton({\n                    acceptFiles: acceptFiles,\n                    element: spec.element,\n                    focusClass: this._options.classes.buttonFocus,\n                    folders: spec.folders,\n                    hoverClass: this._options.classes.buttonHover,\n                    ios8BrowserCrashWorkaround: this._options.workarounds.ios8BrowserCrash,\n                    multiple: allowMultiple(),\n                    name: this._options.request.inputName,\n                    onChange: function(input) {\n                        self._onInputChange(input);\n                    },\n                    title: spec.title == null ? this._options.text.fileInputTitle : spec.title\n                });\n                this._disposeSupport.addDisposer(function() {\n                    button.dispose();\n                });\n                self._buttons.push(button);\n                return button;\n            },\n            _createUploadHandler: function(additionalOptions, namespace) {\n                var self = this, lastOnProgress = {}, options = {\n                    debug: this._options.debug,\n                    maxConnections: this._options.maxConnections,\n                    cors: this._options.cors,\n                    paramsStore: this._paramsStore,\n                    endpointStore: this._endpointStore,\n                    chunking: this._options.chunking,\n                    resume: this._options.resume,\n                    blobs: this._options.blobs,\n                    log: qq.bind(self.log, self),\n                    preventRetryParam: this._options.retry.preventRetryResponseProperty,\n                    onProgress: function(id, name, loaded, total) {\n                        if (loaded < 0 || total < 0) {\n                            return;\n                        }\n                        if (lastOnProgress[id]) {\n                            if (lastOnProgress[id].loaded !== loaded || lastOnProgress[id].total !== total) {\n                                self._onProgress(id, name, loaded, total);\n                                self._options.callbacks.onProgress(id, name, loaded, total);\n                            }\n                        } else {\n                            self._onProgress(id, name, loaded, total);\n                            self._options.callbacks.onProgress(id, name, loaded, total);\n                        }\n                        lastOnProgress[id] = {\n                            loaded: loaded,\n                            total: total\n                        };\n                    },\n                    onComplete: function(id, name, result, xhr) {\n                        delete lastOnProgress[id];\n                        var status = self.getUploads({\n                            id: id\n                        }).status, retVal;\n                        if (status === qq.status.UPLOAD_SUCCESSFUL || status === qq.status.UPLOAD_FAILED) {\n                            return;\n                        }\n                        retVal = self._onComplete(id, name, result, xhr);\n                        if (retVal instanceof qq.Promise) {\n                            retVal.done(function() {\n                                self._options.callbacks.onComplete(id, name, result, xhr);\n                            });\n                        } else {\n                            self._options.callbacks.onComplete(id, name, result, xhr);\n                        }\n                    },\n                    onCancel: function(id, name, cancelFinalizationEffort) {\n                        var promise = new qq.Promise();\n                        self._handleCheckedCallback({\n                            name: \"onCancel\",\n                            callback: qq.bind(self._options.callbacks.onCancel, self, id, name),\n                            onFailure: promise.failure,\n                            onSuccess: function() {\n                                cancelFinalizationEffort.then(function() {\n                                    self._onCancel(id, name);\n                                });\n                                promise.success();\n                            },\n                            identifier: id\n                        });\n                        return promise;\n                    },\n                    onUploadPrep: qq.bind(this._onUploadPrep, this),\n                    onUpload: function(id, name) {\n                        self._onUpload(id, name);\n                        self._options.callbacks.onUpload(id, name);\n                    },\n                    onUploadChunk: function(id, name, chunkData) {\n                        self._onUploadChunk(id, chunkData);\n                        self._options.callbacks.onUploadChunk(id, name, chunkData);\n                    },\n                    onUploadChunkSuccess: function(id, chunkData, result, xhr) {\n                        self._options.callbacks.onUploadChunkSuccess.apply(self, arguments);\n                    },\n                    onResume: function(id, name, chunkData) {\n                        return self._options.callbacks.onResume(id, name, chunkData);\n                    },\n                    onAutoRetry: function(id, name, responseJSON, xhr) {\n                        return self._onAutoRetry.apply(self, arguments);\n                    },\n                    onUuidChanged: function(id, newUuid) {\n                        self.log(\"Server requested UUID change from '\" + self.getUuid(id) + \"' to '\" + newUuid + \"'\");\n                        self.setUuid(id, newUuid);\n                    },\n                    getName: qq.bind(self.getName, self),\n                    getUuid: qq.bind(self.getUuid, self),\n                    getSize: qq.bind(self.getSize, self),\n                    setSize: qq.bind(self._setSize, self),\n                    getDataByUuid: function(uuid) {\n                        return self.getUploads({\n                            uuid: uuid\n                        });\n                    },\n                    isQueued: function(id) {\n                        var status = self.getUploads({\n                            id: id\n                        }).status;\n                        return status === qq.status.QUEUED || status === qq.status.SUBMITTED || status === qq.status.UPLOAD_RETRYING || status === qq.status.PAUSED;\n                    },\n                    getIdsInProxyGroup: self._uploadData.getIdsInProxyGroup,\n                    getIdsInBatch: self._uploadData.getIdsInBatch\n                };\n                qq.each(this._options.request, function(prop, val) {\n                    options[prop] = val;\n                });\n                options.customHeaders = this._customHeadersStore;\n                if (additionalOptions) {\n                    qq.each(additionalOptions, function(key, val) {\n                        options[key] = val;\n                    });\n                }\n                return new qq.UploadHandlerController(options, namespace);\n            },\n            _fileOrBlobRejected: function(id) {\n                this._netUploadedOrQueued--;\n                this._uploadData.setStatus(id, qq.status.REJECTED);\n            },\n            _formatSize: function(bytes) {\n                if (bytes === 0) {\n                    return bytes + this._options.text.sizeSymbols[0];\n                }\n                var i = -1;\n                do {\n                    bytes = bytes / 1e3;\n                    i++;\n                } while (bytes > 999);\n                return Math.max(bytes, .1).toFixed(1) + this._options.text.sizeSymbols[i];\n            },\n            _generateExtraButtonSpecs: function() {\n                var self = this;\n                this._extraButtonSpecs = {};\n                qq.each(this._options.extraButtons, function(idx, extraButtonOptionEntry) {\n                    var multiple = extraButtonOptionEntry.multiple, validation = qq.extend({}, self._options.validation, true), extraButtonSpec = qq.extend({}, extraButtonOptionEntry);\n                    if (multiple === undefined) {\n                        multiple = self._options.multiple;\n                    }\n                    if (extraButtonSpec.validation) {\n                        qq.extend(validation, extraButtonOptionEntry.validation, true);\n                    }\n                    qq.extend(extraButtonSpec, {\n                        multiple: multiple,\n                        validation: validation\n                    }, true);\n                    self._initExtraButton(extraButtonSpec);\n                });\n            },\n            _getButton: function(buttonId) {\n                var extraButtonsSpec = this._extraButtonSpecs[buttonId];\n                if (extraButtonsSpec) {\n                    return extraButtonsSpec.element;\n                } else if (buttonId === this._defaultButtonId) {\n                    return this._options.button;\n                }\n            },\n            _getButtonId: function(buttonOrFileInputOrFile) {\n                var inputs, fileInput, fileBlobOrInput = buttonOrFileInputOrFile;\n                if (fileBlobOrInput instanceof qq.BlobProxy) {\n                    fileBlobOrInput = fileBlobOrInput.referenceBlob;\n                }\n                if (fileBlobOrInput && !qq.isBlob(fileBlobOrInput)) {\n                    if (qq.isFile(fileBlobOrInput)) {\n                        return fileBlobOrInput.qqButtonId;\n                    } else if (fileBlobOrInput.tagName.toLowerCase() === \"input\" && fileBlobOrInput.type.toLowerCase() === \"file\") {\n                        return fileBlobOrInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n                    }\n                    inputs = fileBlobOrInput.getElementsByTagName(\"input\");\n                    qq.each(inputs, function(idx, input) {\n                        if (input.getAttribute(\"type\") === \"file\") {\n                            fileInput = input;\n                            return false;\n                        }\n                    });\n                    if (fileInput) {\n                        return fileInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n                    }\n                }\n            },\n            _getNotFinished: function() {\n                return this._uploadData.retrieve({\n                    status: [ qq.status.UPLOADING, qq.status.UPLOAD_RETRYING, qq.status.QUEUED, qq.status.SUBMITTING, qq.status.SUBMITTED, qq.status.PAUSED ]\n                }).length;\n            },\n            _getValidationBase: function(buttonId) {\n                var extraButtonSpec = this._extraButtonSpecs[buttonId];\n                return extraButtonSpec ? extraButtonSpec.validation : this._options.validation;\n            },\n            _getValidationDescriptor: function(fileWrapper) {\n                if (fileWrapper.file instanceof qq.BlobProxy) {\n                    return {\n                        name: qq.getFilename(fileWrapper.file.referenceBlob),\n                        size: fileWrapper.file.referenceBlob.size\n                    };\n                }\n                return {\n                    name: this.getUploads({\n                        id: fileWrapper.id\n                    }).name,\n                    size: this.getUploads({\n                        id: fileWrapper.id\n                    }).size\n                };\n            },\n            _getValidationDescriptors: function(fileWrappers) {\n                var self = this, fileDescriptors = [];\n                qq.each(fileWrappers, function(idx, fileWrapper) {\n                    fileDescriptors.push(self._getValidationDescriptor(fileWrapper));\n                });\n                return fileDescriptors;\n            },\n            _handleCameraAccess: function() {\n                if (this._options.camera.ios && qq.ios()) {\n                    var acceptIosCamera = \"image/*;capture=camera\", button = this._options.camera.button, buttonId = button ? this._getButtonId(button) : this._defaultButtonId, optionRoot = this._options;\n                    if (buttonId && buttonId !== this._defaultButtonId) {\n                        optionRoot = this._extraButtonSpecs[buttonId];\n                    }\n                    optionRoot.multiple = false;\n                    if (optionRoot.validation.acceptFiles === null) {\n                        optionRoot.validation.acceptFiles = acceptIosCamera;\n                    } else {\n                        optionRoot.validation.acceptFiles += \",\" + acceptIosCamera;\n                    }\n                    qq.each(this._buttons, function(idx, button) {\n                        if (button.getButtonId() === buttonId) {\n                            button.setMultiple(optionRoot.multiple);\n                            button.setAcceptFiles(optionRoot.acceptFiles);\n                            return false;\n                        }\n                    });\n                }\n            },\n            _handleCheckedCallback: function(details) {\n                var self = this, callbackRetVal = details.callback();\n                if (qq.isGenericPromise(callbackRetVal)) {\n                    this.log(details.name + \" - waiting for \" + details.name + \" promise to be fulfilled for \" + details.identifier);\n                    return callbackRetVal.then(function(successParam) {\n                        self.log(details.name + \" promise success for \" + details.identifier);\n                        details.onSuccess(successParam);\n                    }, function() {\n                        if (details.onFailure) {\n                            self.log(details.name + \" promise failure for \" + details.identifier);\n                            details.onFailure();\n                        } else {\n                            self.log(details.name + \" promise failure for \" + details.identifier);\n                        }\n                    });\n                }\n                if (callbackRetVal !== false) {\n                    details.onSuccess(callbackRetVal);\n                } else {\n                    if (details.onFailure) {\n                        this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Invoking failure callback.\");\n                        details.onFailure();\n                    } else {\n                        this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Will not proceed.\");\n                    }\n                }\n                return callbackRetVal;\n            },\n            _handleNewFile: function(file, batchId, newFileWrapperList) {\n                var self = this, uuid = qq.getUniqueId(), size = -1, name = qq.getFilename(file), actualFile = file.blob || file, handler = this._customNewFileHandler ? this._customNewFileHandler : qq.bind(self._handleNewFileGeneric, self);\n                if (!qq.isInput(actualFile) && actualFile.size >= 0) {\n                    size = actualFile.size;\n                }\n                handler(actualFile, name, uuid, size, newFileWrapperList, batchId, this._options.request.uuidName, {\n                    uploadData: self._uploadData,\n                    paramsStore: self._paramsStore,\n                    addFileToHandler: function(id, file) {\n                        self._handler.add(id, file);\n                        self._netUploadedOrQueued++;\n                        self._trackButton(id);\n                    }\n                });\n            },\n            _handleNewFileGeneric: function(file, name, uuid, size, fileList, batchId) {\n                var id = this._uploadData.addFile({\n                    uuid: uuid,\n                    name: name,\n                    size: size,\n                    batchId: batchId\n                });\n                this._handler.add(id, file);\n                this._trackButton(id);\n                this._netUploadedOrQueued++;\n                fileList.push({\n                    id: id,\n                    file: file\n                });\n            },\n            _handlePasteSuccess: function(blob, extSuppliedName) {\n                var extension = blob.type.split(\"/\")[1], name = extSuppliedName;\n                if (name == null) {\n                    name = this._options.paste.defaultName;\n                }\n                name += \".\" + extension;\n                this.addFiles({\n                    name: name,\n                    blob: blob\n                });\n            },\n            _initExtraButton: function(spec) {\n                var button = this._createUploadButton({\n                    accept: spec.validation.acceptFiles,\n                    allowedExtensions: spec.validation.allowedExtensions,\n                    element: spec.element,\n                    folders: spec.folders,\n                    multiple: spec.multiple,\n                    title: spec.fileInputTitle\n                });\n                this._extraButtonSpecs[button.getButtonId()] = spec;\n            },\n            _initFormSupportAndParams: function() {\n                this._formSupport = qq.FormSupport && new qq.FormSupport(this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this));\n                if (this._formSupport && this._formSupport.attachedToForm) {\n                    this._paramsStore = this._createStore(this._options.request.params, this._formSupport.getFormInputsAsObject);\n                    this._options.autoUpload = this._formSupport.newAutoUpload;\n                    if (this._formSupport.newEndpoint) {\n                        this._options.request.endpoint = this._formSupport.newEndpoint;\n                    }\n                } else {\n                    this._paramsStore = this._createStore(this._options.request.params);\n                }\n            },\n            _isDeletePossible: function() {\n                if (!qq.DeleteFileAjaxRequester || !this._options.deleteFile.enabled) {\n                    return false;\n                }\n                if (this._options.cors.expected) {\n                    if (qq.supportedFeatures.deleteFileCorsXhr) {\n                        return true;\n                    }\n                    if (qq.supportedFeatures.deleteFileCorsXdr && this._options.cors.allowXdr) {\n                        return true;\n                    }\n                    return false;\n                }\n                return true;\n            },\n            _isAllowedExtension: function(allowed, fileName) {\n                var valid = false;\n                if (!allowed.length) {\n                    return true;\n                }\n                qq.each(allowed, function(idx, allowedExt) {\n                    if (qq.isString(allowedExt)) {\n                        var extRegex = new RegExp(\"\\\\.\" + allowedExt + \"$\", \"i\");\n                        if (fileName.match(extRegex) != null) {\n                            valid = true;\n                            return false;\n                        }\n                    }\n                });\n                return valid;\n            },\n            _itemError: function(code, maybeNameOrNames, item) {\n                var message = this._options.messages[code], allowedExtensions = [], names = [].concat(maybeNameOrNames), name = names[0], buttonId = this._getButtonId(item), validationBase = this._getValidationBase(buttonId), extensionsForMessage, placeholderMatch;\n                function r(name, replacement) {\n                    message = message.replace(name, replacement);\n                }\n                qq.each(validationBase.allowedExtensions, function(idx, allowedExtension) {\n                    if (qq.isString(allowedExtension)) {\n                        allowedExtensions.push(allowedExtension);\n                    }\n                });\n                extensionsForMessage = allowedExtensions.join(\", \").toLowerCase();\n                r(\"{file}\", this._options.formatFileName(name));\n                r(\"{extensions}\", extensionsForMessage);\n                r(\"{sizeLimit}\", this._formatSize(validationBase.sizeLimit));\n                r(\"{minSizeLimit}\", this._formatSize(validationBase.minSizeLimit));\n                placeholderMatch = message.match(/(\\{\\w+\\})/g);\n                if (placeholderMatch !== null) {\n                    qq.each(placeholderMatch, function(idx, placeholder) {\n                        r(placeholder, names[idx]);\n                    });\n                }\n                this._options.callbacks.onError(null, name, message, undefined);\n                return message;\n            },\n            _manualRetry: function(id, callback) {\n                if (this._onBeforeManualRetry(id)) {\n                    this._netUploadedOrQueued++;\n                    this._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n                    if (callback) {\n                        callback(id);\n                    } else {\n                        this._handler.retry(id);\n                    }\n                    return true;\n                }\n            },\n            _maybeAllComplete: function(id, status) {\n                var self = this, notFinished = this._getNotFinished();\n                if (status === qq.status.UPLOAD_SUCCESSFUL) {\n                    this._succeededSinceLastAllComplete.push(id);\n                } else if (status === qq.status.UPLOAD_FAILED) {\n                    this._failedSinceLastAllComplete.push(id);\n                }\n                if (notFinished === 0 && (this._succeededSinceLastAllComplete.length || this._failedSinceLastAllComplete.length)) {\n                    setTimeout(function() {\n                        self._onAllComplete(self._succeededSinceLastAllComplete, self._failedSinceLastAllComplete);\n                    }, 0);\n                }\n            },\n            _maybeHandleIos8SafariWorkaround: function() {\n                var self = this;\n                if (this._options.workarounds.ios8SafariUploads && qq.ios800() && qq.iosSafari()) {\n                    setTimeout(function() {\n                        window.alert(self._options.messages.unsupportedBrowserIos8Safari);\n                    }, 0);\n                    throw new qq.Error(this._options.messages.unsupportedBrowserIos8Safari);\n                }\n            },\n            _maybeParseAndSendUploadError: function(id, name, response, xhr) {\n                if (!response.success) {\n                    if (xhr && xhr.status !== 200 && !response.error) {\n                        this._options.callbacks.onError(id, name, \"XHR returned response code \" + xhr.status, xhr);\n                    } else {\n                        var errorReason = response.error ? response.error : this._options.text.defaultResponseError;\n                        this._options.callbacks.onError(id, name, errorReason, xhr);\n                    }\n                }\n            },\n            _maybeProcessNextItemAfterOnValidateCallback: function(validItem, items, index, params, endpoint) {\n                var self = this;\n                if (items.length > index) {\n                    if (validItem || !this._options.validation.stopOnFirstInvalidFile) {\n                        setTimeout(function() {\n                            var validationDescriptor = self._getValidationDescriptor(items[index]), buttonId = self._getButtonId(items[index].file), button = self._getButton(buttonId);\n                            self._handleCheckedCallback({\n                                name: \"onValidate\",\n                                callback: qq.bind(self._options.callbacks.onValidate, self, validationDescriptor, button),\n                                onSuccess: qq.bind(self._onValidateCallbackSuccess, self, items, index, params, endpoint),\n                                onFailure: qq.bind(self._onValidateCallbackFailure, self, items, index, params, endpoint),\n                                identifier: \"Item '\" + validationDescriptor.name + \"', size: \" + validationDescriptor.size\n                            });\n                        }, 0);\n                    } else if (!validItem) {\n                        for (;index < items.length; index++) {\n                            self._fileOrBlobRejected(items[index].id);\n                        }\n                    }\n                }\n            },\n            _onAllComplete: function(successful, failed) {\n                this._totalProgress && this._totalProgress.onAllComplete(successful, failed, this._preventRetries);\n                this._options.callbacks.onAllComplete(qq.extend([], successful), qq.extend([], failed));\n                this._succeededSinceLastAllComplete = [];\n                this._failedSinceLastAllComplete = [];\n            },\n            _onAutoRetry: function(id, name, responseJSON, xhr, callback) {\n                var self = this;\n                self._preventRetries[id] = responseJSON[self._options.retry.preventRetryResponseProperty];\n                if (self._shouldAutoRetry(id, name, responseJSON)) {\n                    var retryWaitPeriod = self._options.retry.autoAttemptDelay * 1e3;\n                    self._maybeParseAndSendUploadError.apply(self, arguments);\n                    self._options.callbacks.onAutoRetry(id, name, self._autoRetries[id]);\n                    self._onBeforeAutoRetry(id, name);\n                    self._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n                    self._retryTimeouts[id] = setTimeout(function() {\n                        self.log(\"Starting retry for \" + name + \"...\");\n                        if (callback) {\n                            callback(id);\n                        } else {\n                            self._handler.retry(id);\n                        }\n                    }, retryWaitPeriod);\n                    return true;\n                }\n            },\n            _onBeforeAutoRetry: function(id, name) {\n                this.log(\"Waiting \" + this._options.retry.autoAttemptDelay + \" seconds before retrying \" + name + \"...\");\n            },\n            _onBeforeManualRetry: function(id) {\n                var itemLimit = this._currentItemLimit, fileName;\n                if (this._preventRetries[id]) {\n                    this.log(\"Retries are forbidden for id \" + id, \"warn\");\n                    return false;\n                } else if (this._handler.isValid(id)) {\n                    fileName = this.getName(id);\n                    if (this._options.callbacks.onManualRetry(id, fileName) === false) {\n                        return false;\n                    }\n                    if (itemLimit > 0 && this._netUploadedOrQueued + 1 > itemLimit) {\n                        this._itemError(\"retryFailTooManyItems\");\n                        return false;\n                    }\n                    this.log(\"Retrying upload for '\" + fileName + \"' (id: \" + id + \")...\");\n                    return true;\n                } else {\n                    this.log(\"'\" + id + \"' is not a valid file ID\", \"error\");\n                    return false;\n                }\n            },\n            _onCancel: function(id, name) {\n                this._netUploadedOrQueued--;\n                clearTimeout(this._retryTimeouts[id]);\n                var storedItemIndex = qq.indexOf(this._storedIds, id);\n                if (!this._options.autoUpload && storedItemIndex >= 0) {\n                    this._storedIds.splice(storedItemIndex, 1);\n                }\n                this._uploadData.setStatus(id, qq.status.CANCELED);\n            },\n            _onComplete: function(id, name, result, xhr) {\n                if (!result.success) {\n                    this._netUploadedOrQueued--;\n                    this._uploadData.setStatus(id, qq.status.UPLOAD_FAILED);\n                    if (result[this._options.retry.preventRetryResponseProperty] === true) {\n                        this._preventRetries[id] = true;\n                    }\n                } else {\n                    if (result.thumbnailUrl) {\n                        this._thumbnailUrls[id] = result.thumbnailUrl;\n                    }\n                    this._netUploaded++;\n                    this._uploadData.setStatus(id, qq.status.UPLOAD_SUCCESSFUL);\n                }\n                this._maybeParseAndSendUploadError(id, name, result, xhr);\n                return result.success ? true : false;\n            },\n            _onDelete: function(id) {\n                this._uploadData.setStatus(id, qq.status.DELETING);\n            },\n            _onDeleteComplete: function(id, xhrOrXdr, isError) {\n                var name = this.getName(id);\n                if (isError) {\n                    this._uploadData.setStatus(id, qq.status.DELETE_FAILED);\n                    this.log(\"Delete request for '\" + name + \"' has failed.\", \"error\");\n                    if (xhrOrXdr.withCredentials === undefined) {\n                        this._options.callbacks.onError(id, name, \"Delete request failed\", xhrOrXdr);\n                    } else {\n                        this._options.callbacks.onError(id, name, \"Delete request failed with response code \" + xhrOrXdr.status, xhrOrXdr);\n                    }\n                } else {\n                    this._netUploadedOrQueued--;\n                    this._netUploaded--;\n                    this._handler.expunge(id);\n                    this._uploadData.setStatus(id, qq.status.DELETED);\n                    this.log(\"Delete request for '\" + name + \"' has succeeded.\");\n                }\n            },\n            _onInputChange: function(input) {\n                var fileIndex;\n                if (qq.supportedFeatures.ajaxUploading) {\n                    for (fileIndex = 0; fileIndex < input.files.length; fileIndex++) {\n                        this._annotateWithButtonId(input.files[fileIndex], input);\n                    }\n                    this.addFiles(input.files);\n                } else if (input.value.length > 0) {\n                    this.addFiles(input);\n                }\n                qq.each(this._buttons, function(idx, button) {\n                    button.reset();\n                });\n            },\n            _onProgress: function(id, name, loaded, total) {\n                this._totalProgress && this._totalProgress.onIndividualProgress(id, loaded, total);\n            },\n            _onSubmit: function(id, name) {},\n            _onSubmitCallbackSuccess: function(id, name) {\n                this._onSubmit.apply(this, arguments);\n                this._uploadData.setStatus(id, qq.status.SUBMITTED);\n                this._onSubmitted.apply(this, arguments);\n                if (this._options.autoUpload) {\n                    this._options.callbacks.onSubmitted.apply(this, arguments);\n                    this._uploadFile(id);\n                } else {\n                    this._storeForLater(id);\n                    this._options.callbacks.onSubmitted.apply(this, arguments);\n                }\n            },\n            _onSubmitDelete: function(id, onSuccessCallback, additionalMandatedParams) {\n                var uuid = this.getUuid(id), adjustedOnSuccessCallback;\n                if (onSuccessCallback) {\n                    adjustedOnSuccessCallback = qq.bind(onSuccessCallback, this, id, uuid, additionalMandatedParams);\n                }\n                if (this._isDeletePossible()) {\n                    this._handleCheckedCallback({\n                        name: \"onSubmitDelete\",\n                        callback: qq.bind(this._options.callbacks.onSubmitDelete, this, id),\n                        onSuccess: adjustedOnSuccessCallback || qq.bind(this._deleteHandler.sendDelete, this, id, uuid, additionalMandatedParams),\n                        identifier: id\n                    });\n                    return true;\n                } else {\n                    this.log(\"Delete request ignored for ID \" + id + \", delete feature is disabled or request not possible \" + \"due to CORS on a user agent that does not support pre-flighting.\", \"warn\");\n                    return false;\n                }\n            },\n            _onSubmitted: function(id) {},\n            _onTotalProgress: function(loaded, total) {\n                this._options.callbacks.onTotalProgress(loaded, total);\n            },\n            _onUploadPrep: function(id) {},\n            _onUpload: function(id, name) {\n                this._uploadData.setStatus(id, qq.status.UPLOADING);\n            },\n            _onUploadChunk: function(id, chunkData) {},\n            _onUploadStatusChange: function(id, oldStatus, newStatus) {\n                if (newStatus === qq.status.PAUSED) {\n                    clearTimeout(this._retryTimeouts[id]);\n                }\n            },\n            _onValidateBatchCallbackFailure: function(fileWrappers) {\n                var self = this;\n                qq.each(fileWrappers, function(idx, fileWrapper) {\n                    self._fileOrBlobRejected(fileWrapper.id);\n                });\n            },\n            _onValidateBatchCallbackSuccess: function(validationDescriptors, items, params, endpoint, button) {\n                var errorMessage, itemLimit = this._currentItemLimit, proposedNetFilesUploadedOrQueued = this._netUploadedOrQueued;\n                if (itemLimit === 0 || proposedNetFilesUploadedOrQueued <= itemLimit) {\n                    if (items.length > 0) {\n                        this._handleCheckedCallback({\n                            name: \"onValidate\",\n                            callback: qq.bind(this._options.callbacks.onValidate, this, validationDescriptors[0], button),\n                            onSuccess: qq.bind(this._onValidateCallbackSuccess, this, items, 0, params, endpoint),\n                            onFailure: qq.bind(this._onValidateCallbackFailure, this, items, 0, params, endpoint),\n                            identifier: \"Item '\" + items[0].file.name + \"', size: \" + items[0].file.size\n                        });\n                    } else {\n                        this._itemError(\"noFilesError\");\n                    }\n                } else {\n                    this._onValidateBatchCallbackFailure(items);\n                    errorMessage = this._options.messages.tooManyItemsError.replace(/\\{netItems\\}/g, proposedNetFilesUploadedOrQueued).replace(/\\{itemLimit\\}/g, itemLimit);\n                    this._batchError(errorMessage);\n                }\n            },\n            _onValidateCallbackFailure: function(items, index, params, endpoint) {\n                var nextIndex = index + 1;\n                this._fileOrBlobRejected(items[index].id, items[index].file.name);\n                this._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n            },\n            _onValidateCallbackSuccess: function(items, index, params, endpoint) {\n                var self = this, nextIndex = index + 1, validationDescriptor = this._getValidationDescriptor(items[index]);\n                this._validateFileOrBlobData(items[index], validationDescriptor).then(function() {\n                    self._upload(items[index].id, params, endpoint);\n                    self._maybeProcessNextItemAfterOnValidateCallback(true, items, nextIndex, params, endpoint);\n                }, function() {\n                    self._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n                });\n            },\n            _prepareItemsForUpload: function(items, params, endpoint) {\n                if (items.length === 0) {\n                    this._itemError(\"noFilesError\");\n                    return;\n                }\n                var validationDescriptors = this._getValidationDescriptors(items), buttonId = this._getButtonId(items[0].file), button = this._getButton(buttonId);\n                this._handleCheckedCallback({\n                    name: \"onValidateBatch\",\n                    callback: qq.bind(this._options.callbacks.onValidateBatch, this, validationDescriptors, button),\n                    onSuccess: qq.bind(this._onValidateBatchCallbackSuccess, this, validationDescriptors, items, params, endpoint, button),\n                    onFailure: qq.bind(this._onValidateBatchCallbackFailure, this, items),\n                    identifier: \"batch validation\"\n                });\n            },\n            _preventLeaveInProgress: function() {\n                var self = this;\n                this._disposeSupport.attach(window, \"beforeunload\", function(e) {\n                    if (self.getInProgress()) {\n                        e = e || window.event;\n                        e.returnValue = self._options.messages.onLeave;\n                        return self._options.messages.onLeave;\n                    }\n                });\n            },\n            _refreshSessionData: function() {\n                var self = this, options = this._options.session;\n                if (qq.Session && this._options.session.endpoint != null) {\n                    if (!this._session) {\n                        qq.extend(options, {\n                            cors: this._options.cors\n                        });\n                        options.log = qq.bind(this.log, this);\n                        options.addFileRecord = qq.bind(this._addCannedFile, this);\n                        this._session = new qq.Session(options);\n                    }\n                    setTimeout(function() {\n                        self._session.refresh().then(function(response, xhrOrXdr) {\n                            self._sessionRequestComplete();\n                            self._options.callbacks.onSessionRequestComplete(response, true, xhrOrXdr);\n                        }, function(response, xhrOrXdr) {\n                            self._options.callbacks.onSessionRequestComplete(response, false, xhrOrXdr);\n                        });\n                    }, 0);\n                }\n            },\n            _sessionRequestComplete: function() {},\n            _setSize: function(id, newSize) {\n                this._uploadData.updateSize(id, newSize);\n                this._totalProgress && this._totalProgress.onNewSize(id);\n            },\n            _shouldAutoRetry: function(id, name, responseJSON) {\n                var uploadData = this._uploadData.retrieve({\n                    id: id\n                });\n                if (!this._preventRetries[id] && this._options.retry.enableAuto && uploadData.status !== qq.status.PAUSED) {\n                    if (this._autoRetries[id] === undefined) {\n                        this._autoRetries[id] = 0;\n                    }\n                    if (this._autoRetries[id] < this._options.retry.maxAutoAttempts) {\n                        this._autoRetries[id] += 1;\n                        return true;\n                    }\n                }\n                return false;\n            },\n            _storeForLater: function(id) {\n                this._storedIds.push(id);\n            },\n            _trackButton: function(id) {\n                var buttonId;\n                if (qq.supportedFeatures.ajaxUploading) {\n                    buttonId = this._handler.getFile(id).qqButtonId;\n                } else {\n                    buttonId = this._getButtonId(this._handler.getInput(id));\n                }\n                if (buttonId) {\n                    this._buttonIdsForFileIds[id] = buttonId;\n                }\n            },\n            _updateFormSupportAndParams: function(formElementOrId) {\n                this._options.form.element = formElementOrId;\n                this._formSupport = qq.FormSupport && new qq.FormSupport(this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this));\n                if (this._formSupport && this._formSupport.attachedToForm) {\n                    this._paramsStore.addReadOnly(null, this._formSupport.getFormInputsAsObject);\n                    this._options.autoUpload = this._formSupport.newAutoUpload;\n                    if (this._formSupport.newEndpoint) {\n                        this.setEndpoint(this._formSupport.newEndpoint);\n                    }\n                }\n            },\n            _upload: function(id, params, endpoint) {\n                var name = this.getName(id);\n                if (params) {\n                    this.setParams(params, id);\n                }\n                if (endpoint) {\n                    this.setEndpoint(endpoint, id);\n                }\n                this._handleCheckedCallback({\n                    name: \"onSubmit\",\n                    callback: qq.bind(this._options.callbacks.onSubmit, this, id, name),\n                    onSuccess: qq.bind(this._onSubmitCallbackSuccess, this, id, name),\n                    onFailure: qq.bind(this._fileOrBlobRejected, this, id, name),\n                    identifier: id\n                });\n            },\n            _uploadFile: function(id) {\n                if (!this._handler.upload(id)) {\n                    this._uploadData.setStatus(id, qq.status.QUEUED);\n                }\n            },\n            _uploadStoredFiles: function() {\n                var idToUpload, stillSubmitting, self = this;\n                while (this._storedIds.length) {\n                    idToUpload = this._storedIds.shift();\n                    this._uploadFile(idToUpload);\n                }\n                stillSubmitting = this.getUploads({\n                    status: qq.status.SUBMITTING\n                }).length;\n                if (stillSubmitting) {\n                    qq.log(\"Still waiting for \" + stillSubmitting + \" files to clear submit queue. Will re-parse stored IDs array shortly.\");\n                    setTimeout(function() {\n                        self._uploadStoredFiles();\n                    }, 1e3);\n                }\n            },\n            _validateFileOrBlobData: function(fileWrapper, validationDescriptor) {\n                var self = this, file = function() {\n                    if (fileWrapper.file instanceof qq.BlobProxy) {\n                        return fileWrapper.file.referenceBlob;\n                    }\n                    return fileWrapper.file;\n                }(), name = validationDescriptor.name, size = validationDescriptor.size, buttonId = this._getButtonId(fileWrapper.file), validationBase = this._getValidationBase(buttonId), validityChecker = new qq.Promise();\n                validityChecker.then(function() {}, function() {\n                    self._fileOrBlobRejected(fileWrapper.id, name);\n                });\n                if (qq.isFileOrInput(file) && !this._isAllowedExtension(validationBase.allowedExtensions, name)) {\n                    this._itemError(\"typeError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (!this._options.validation.allowEmpty && size === 0) {\n                    this._itemError(\"emptyError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (size > 0 && validationBase.sizeLimit && size > validationBase.sizeLimit) {\n                    this._itemError(\"sizeError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (size > 0 && size < validationBase.minSizeLimit) {\n                    this._itemError(\"minSizeError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (qq.ImageValidation && qq.supportedFeatures.imagePreviews && qq.isFile(file)) {\n                    new qq.ImageValidation(file, qq.bind(self.log, self)).validate(validationBase.image).then(validityChecker.success, function(errorCode) {\n                        self._itemError(errorCode + \"ImageError\", name, file);\n                        validityChecker.failure();\n                    });\n                } else {\n                    validityChecker.success();\n                }\n                return validityChecker;\n            },\n            _wrapCallbacks: function() {\n                var self, safeCallback, prop;\n                self = this;\n                safeCallback = function(name, callback, args) {\n                    var errorMsg;\n                    try {\n                        return callback.apply(self, args);\n                    } catch (exception) {\n                        errorMsg = exception.message || exception.toString();\n                        self.log(\"Caught exception in '\" + name + \"' callback - \" + errorMsg, \"error\");\n                    }\n                };\n                for (prop in this._options.callbacks) {\n                    (function() {\n                        var callbackName, callbackFunc;\n                        callbackName = prop;\n                        callbackFunc = self._options.callbacks[callbackName];\n                        self._options.callbacks[callbackName] = function() {\n                            return safeCallback(callbackName, callbackFunc, arguments);\n                        };\n                    })();\n                }\n            }\n        };\n    })();\n    (function() {\n        \"use strict\";\n        qq.FineUploaderBasic = function(o) {\n            var self = this;\n            this._options = {\n                debug: false,\n                button: null,\n                multiple: true,\n                maxConnections: 3,\n                disableCancelForFormUploads: false,\n                autoUpload: true,\n                request: {\n                    customHeaders: {},\n                    endpoint: \"/server/upload\",\n                    filenameParam: \"qqfilename\",\n                    forceMultipart: true,\n                    inputName: \"qqfile\",\n                    method: \"POST\",\n                    params: {},\n                    paramsInBody: true,\n                    totalFileSizeName: \"qqtotalfilesize\",\n                    uuidName: \"qquuid\"\n                },\n                validation: {\n                    allowedExtensions: [],\n                    sizeLimit: 0,\n                    minSizeLimit: 0,\n                    itemLimit: 0,\n                    stopOnFirstInvalidFile: true,\n                    acceptFiles: null,\n                    image: {\n                        maxHeight: 0,\n                        maxWidth: 0,\n                        minHeight: 0,\n                        minWidth: 0\n                    },\n                    allowEmpty: false\n                },\n                callbacks: {\n                    onSubmit: function(id, name) {},\n                    onSubmitted: function(id, name) {},\n                    onComplete: function(id, name, responseJSON, maybeXhr) {},\n                    onAllComplete: function(successful, failed) {},\n                    onCancel: function(id, name) {},\n                    onUpload: function(id, name) {},\n                    onUploadChunk: function(id, name, chunkData) {},\n                    onUploadChunkSuccess: function(id, chunkData, responseJSON, xhr) {},\n                    onResume: function(id, fileName, chunkData) {},\n                    onProgress: function(id, name, loaded, total) {},\n                    onTotalProgress: function(loaded, total) {},\n                    onError: function(id, name, reason, maybeXhrOrXdr) {},\n                    onAutoRetry: function(id, name, attemptNumber) {},\n                    onManualRetry: function(id, name) {},\n                    onValidateBatch: function(fileOrBlobData) {},\n                    onValidate: function(fileOrBlobData) {},\n                    onSubmitDelete: function(id) {},\n                    onDelete: function(id) {},\n                    onDeleteComplete: function(id, xhrOrXdr, isError) {},\n                    onPasteReceived: function(blob) {},\n                    onStatusChange: function(id, oldStatus, newStatus) {},\n                    onSessionRequestComplete: function(response, success, xhrOrXdr) {}\n                },\n                messages: {\n                    typeError: \"{file} has an invalid extension. Valid extension(s): {extensions}.\",\n                    sizeError: \"{file} is too large, maximum file size is {sizeLimit}.\",\n                    minSizeError: \"{file} is too small, minimum file size is {minSizeLimit}.\",\n                    emptyError: \"{file} is empty, please select files again without it.\",\n                    noFilesError: \"No files to upload.\",\n                    tooManyItemsError: \"Too many items ({netItems}) would be uploaded.  Item limit is {itemLimit}.\",\n                    maxHeightImageError: \"Image is too tall.\",\n                    maxWidthImageError: \"Image is too wide.\",\n                    minHeightImageError: \"Image is not tall enough.\",\n                    minWidthImageError: \"Image is not wide enough.\",\n                    retryFailTooManyItems: \"Retry failed - you have reached your file limit.\",\n                    onLeave: \"The files are being uploaded, if you leave now the upload will be canceled.\",\n                    unsupportedBrowserIos8Safari: \"Unrecoverable error - this browser does not permit file uploading of any kind due to serious bugs in iOS8 Safari.  Please use iOS8 Chrome until Apple fixes these issues.\"\n                },\n                retry: {\n                    enableAuto: false,\n                    maxAutoAttempts: 3,\n                    autoAttemptDelay: 5,\n                    preventRetryResponseProperty: \"preventRetry\"\n                },\n                classes: {\n                    buttonHover: \"qq-upload-button-hover\",\n                    buttonFocus: \"qq-upload-button-focus\"\n                },\n                chunking: {\n                    enabled: false,\n                    concurrent: {\n                        enabled: false\n                    },\n                    mandatory: false,\n                    paramNames: {\n                        partIndex: \"qqpartindex\",\n                        partByteOffset: \"qqpartbyteoffset\",\n                        chunkSize: \"qqchunksize\",\n                        totalFileSize: \"qqtotalfilesize\",\n                        totalParts: \"qqtotalparts\"\n                    },\n                    partSize: 2e6,\n                    success: {\n                        endpoint: null\n                    }\n                },\n                resume: {\n                    enabled: false,\n                    recordsExpireIn: 7,\n                    paramNames: {\n                        resuming: \"qqresume\"\n                    }\n                },\n                formatFileName: function(fileOrBlobName) {\n                    return fileOrBlobName;\n                },\n                text: {\n                    defaultResponseError: \"Upload failure reason unknown\",\n                    fileInputTitle: \"file input\",\n                    sizeSymbols: [ \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\" ]\n                },\n                deleteFile: {\n                    enabled: false,\n                    method: \"DELETE\",\n                    endpoint: \"/server/upload\",\n                    customHeaders: {},\n                    params: {}\n                },\n                cors: {\n                    expected: false,\n                    sendCredentials: false,\n                    allowXdr: false\n                },\n                blobs: {\n                    defaultName: \"misc_data\"\n                },\n                paste: {\n                    targetElement: null,\n                    defaultName: \"pasted_image\"\n                },\n                camera: {\n                    ios: false,\n                    button: null\n                },\n                extraButtons: [],\n                session: {\n                    endpoint: null,\n                    params: {},\n                    customHeaders: {},\n                    refreshOnReset: true\n                },\n                form: {\n                    element: \"qq-form\",\n                    autoUpload: false,\n                    interceptSubmit: true\n                },\n                scaling: {\n                    customResizer: null,\n                    sendOriginal: true,\n                    orient: true,\n                    defaultType: null,\n                    defaultQuality: 80,\n                    failureText: \"Failed to scale\",\n                    includeExif: false,\n                    sizes: []\n                },\n                workarounds: {\n                    iosEmptyVideos: true,\n                    ios8SafariUploads: true,\n                    ios8BrowserCrash: false\n                }\n            };\n            qq.extend(this._options, o, true);\n            this._buttons = [];\n            this._extraButtonSpecs = {};\n            this._buttonIdsForFileIds = [];\n            this._wrapCallbacks();\n            this._disposeSupport = new qq.DisposeSupport();\n            this._storedIds = [];\n            this._autoRetries = [];\n            this._retryTimeouts = [];\n            this._preventRetries = [];\n            this._thumbnailUrls = [];\n            this._netUploadedOrQueued = 0;\n            this._netUploaded = 0;\n            this._uploadData = this._createUploadDataTracker();\n            this._initFormSupportAndParams();\n            this._customHeadersStore = this._createStore(this._options.request.customHeaders);\n            this._deleteFileCustomHeadersStore = this._createStore(this._options.deleteFile.customHeaders);\n            this._deleteFileParamsStore = this._createStore(this._options.deleteFile.params);\n            this._endpointStore = this._createStore(this._options.request.endpoint);\n            this._deleteFileEndpointStore = this._createStore(this._options.deleteFile.endpoint);\n            this._handler = this._createUploadHandler();\n            this._deleteHandler = qq.DeleteFileAjaxRequester && this._createDeleteHandler();\n            if (this._options.button) {\n                this._defaultButtonId = this._createUploadButton({\n                    element: this._options.button,\n                    title: this._options.text.fileInputTitle\n                }).getButtonId();\n            }\n            this._generateExtraButtonSpecs();\n            this._handleCameraAccess();\n            if (this._options.paste.targetElement) {\n                if (qq.PasteSupport) {\n                    this._pasteHandler = this._createPasteHandler();\n                } else {\n                    this.log(\"Paste support module not found\", \"error\");\n                }\n            }\n            this._preventLeaveInProgress();\n            this._imageGenerator = qq.ImageGenerator && new qq.ImageGenerator(qq.bind(this.log, this));\n            this._refreshSessionData();\n            this._succeededSinceLastAllComplete = [];\n            this._failedSinceLastAllComplete = [];\n            this._scaler = qq.Scaler && new qq.Scaler(this._options.scaling, qq.bind(this.log, this)) || {};\n            if (this._scaler.enabled) {\n                this._customNewFileHandler = qq.bind(this._scaler.handleNewFile, this._scaler);\n            }\n            if (qq.TotalProgress && qq.supportedFeatures.progressBar) {\n                this._totalProgress = new qq.TotalProgress(qq.bind(this._onTotalProgress, this), function(id) {\n                    var entry = self._uploadData.retrieve({\n                        id: id\n                    });\n                    return entry && entry.size || 0;\n                });\n            }\n            this._currentItemLimit = this._options.validation.itemLimit;\n        };\n        qq.FineUploaderBasic.prototype = qq.basePublicApi;\n        qq.extend(qq.FineUploaderBasic.prototype, qq.basePrivateApi);\n    })();\n    qq.AjaxRequester = function(o) {\n        \"use strict\";\n        var log, shouldParamsBeInQueryString, queue = [], requestData = {}, options = {\n            acceptHeader: null,\n            validMethods: [ \"PATCH\", \"POST\", \"PUT\" ],\n            method: \"POST\",\n            contentType: \"application/x-www-form-urlencoded\",\n            maxConnections: 3,\n            customHeaders: {},\n            endpointStore: {},\n            paramsStore: {},\n            mandatedParams: {},\n            allowXRequestedWithAndCacheControl: true,\n            successfulResponseCodes: {\n                DELETE: [ 200, 202, 204 ],\n                PATCH: [ 200, 201, 202, 203, 204 ],\n                POST: [ 200, 201, 202, 203, 204 ],\n                PUT: [ 200, 201, 202, 203, 204 ],\n                GET: [ 200 ]\n            },\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {},\n            onSend: function(id) {},\n            onComplete: function(id, xhrOrXdr, isError) {},\n            onProgress: null\n        };\n        qq.extend(options, o);\n        log = options.log;\n        if (qq.indexOf(options.validMethods, options.method) < 0) {\n            throw new Error(\"'\" + options.method + \"' is not a supported method for this type of request!\");\n        }\n        function isSimpleMethod() {\n            return qq.indexOf([ \"GET\", \"POST\", \"HEAD\" ], options.method) >= 0;\n        }\n        function containsNonSimpleHeaders(headers) {\n            var containsNonSimple = false;\n            qq.each(containsNonSimple, function(idx, header) {\n                if (qq.indexOf([ \"Accept\", \"Accept-Language\", \"Content-Language\", \"Content-Type\" ], header) < 0) {\n                    containsNonSimple = true;\n                    return false;\n                }\n            });\n            return containsNonSimple;\n        }\n        function isXdr(xhr) {\n            return options.cors.expected && xhr.withCredentials === undefined;\n        }\n        function getCorsAjaxTransport() {\n            var xhrOrXdr;\n            if (window.XMLHttpRequest || window.ActiveXObject) {\n                xhrOrXdr = qq.createXhrInstance();\n                if (xhrOrXdr.withCredentials === undefined) {\n                    xhrOrXdr = new XDomainRequest();\n                    xhrOrXdr.onload = function() {};\n                    xhrOrXdr.onerror = function() {};\n                    xhrOrXdr.ontimeout = function() {};\n                    xhrOrXdr.onprogress = function() {};\n                }\n            }\n            return xhrOrXdr;\n        }\n        function getXhrOrXdr(id, suppliedXhr) {\n            var xhrOrXdr = requestData[id].xhr;\n            if (!xhrOrXdr) {\n                if (suppliedXhr) {\n                    xhrOrXdr = suppliedXhr;\n                } else {\n                    if (options.cors.expected) {\n                        xhrOrXdr = getCorsAjaxTransport();\n                    } else {\n                        xhrOrXdr = qq.createXhrInstance();\n                    }\n                }\n                requestData[id].xhr = xhrOrXdr;\n            }\n            return xhrOrXdr;\n        }\n        function dequeue(id) {\n            var i = qq.indexOf(queue, id), max = options.maxConnections, nextId;\n            delete requestData[id];\n            queue.splice(i, 1);\n            if (queue.length >= max && i < max) {\n                nextId = queue[max - 1];\n                sendRequest(nextId);\n            }\n        }\n        function onComplete(id, xdrError) {\n            var xhr = getXhrOrXdr(id), method = options.method, isError = xdrError === true;\n            dequeue(id);\n            if (isError) {\n                log(method + \" request for \" + id + \" has failed\", \"error\");\n            } else if (!isXdr(xhr) && !isResponseSuccessful(xhr.status)) {\n                isError = true;\n                log(method + \" request for \" + id + \" has failed - response code \" + xhr.status, \"error\");\n            }\n            options.onComplete(id, xhr, isError);\n        }\n        function getParams(id) {\n            var onDemandParams = requestData[id].additionalParams, mandatedParams = options.mandatedParams, params;\n            if (options.paramsStore.get) {\n                params = options.paramsStore.get(id);\n            }\n            if (onDemandParams) {\n                qq.each(onDemandParams, function(name, val) {\n                    params = params || {};\n                    params[name] = val;\n                });\n            }\n            if (mandatedParams) {\n                qq.each(mandatedParams, function(name, val) {\n                    params = params || {};\n                    params[name] = val;\n                });\n            }\n            return params;\n        }\n        function sendRequest(id, optXhr) {\n            var xhr = getXhrOrXdr(id, optXhr), method = options.method, params = getParams(id), payload = requestData[id].payload, url;\n            options.onSend(id);\n            url = createUrl(id, params, requestData[id].additionalQueryParams);\n            if (isXdr(xhr)) {\n                xhr.onload = getXdrLoadHandler(id);\n                xhr.onerror = getXdrErrorHandler(id);\n            } else {\n                xhr.onreadystatechange = getXhrReadyStateChangeHandler(id);\n            }\n            registerForUploadProgress(id);\n            xhr.open(method, url, true);\n            if (options.cors.expected && options.cors.sendCredentials && !isXdr(xhr)) {\n                xhr.withCredentials = true;\n            }\n            setHeaders(id);\n            log(\"Sending \" + method + \" request for \" + id);\n            if (payload) {\n                xhr.send(payload);\n            } else if (shouldParamsBeInQueryString || !params) {\n                xhr.send();\n            } else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/x-www-form-urlencoded\") >= 0) {\n                xhr.send(qq.obj2url(params, \"\"));\n            } else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/json\") >= 0) {\n                xhr.send(JSON.stringify(params));\n            } else {\n                xhr.send(params);\n            }\n            return xhr;\n        }\n        function createUrl(id, params, additionalQueryParams) {\n            var endpoint = options.endpointStore.get(id), addToPath = requestData[id].addToPath;\n            if (addToPath != undefined) {\n                endpoint += \"/\" + addToPath;\n            }\n            if (shouldParamsBeInQueryString && params) {\n                endpoint = qq.obj2url(params, endpoint);\n            }\n            if (additionalQueryParams) {\n                endpoint = qq.obj2url(additionalQueryParams, endpoint);\n            }\n            return endpoint;\n        }\n        function getXhrReadyStateChangeHandler(id) {\n            return function() {\n                if (getXhrOrXdr(id).readyState === 4) {\n                    onComplete(id);\n                }\n            };\n        }\n        function registerForUploadProgress(id) {\n            var onProgress = options.onProgress;\n            if (onProgress) {\n                getXhrOrXdr(id).upload.onprogress = function(e) {\n                    if (e.lengthComputable) {\n                        onProgress(id, e.loaded, e.total);\n                    }\n                };\n            }\n        }\n        function getXdrLoadHandler(id) {\n            return function() {\n                onComplete(id);\n            };\n        }\n        function getXdrErrorHandler(id) {\n            return function() {\n                onComplete(id, true);\n            };\n        }\n        function setHeaders(id) {\n            var xhr = getXhrOrXdr(id), customHeaders = options.customHeaders, onDemandHeaders = requestData[id].additionalHeaders || {}, method = options.method, allHeaders = {};\n            if (!isXdr(xhr)) {\n                options.acceptHeader && xhr.setRequestHeader(\"Accept\", options.acceptHeader);\n                if (options.allowXRequestedWithAndCacheControl) {\n                    if (!options.cors.expected || (!isSimpleMethod() || containsNonSimpleHeaders(customHeaders))) {\n                        xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n                        xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n                    }\n                }\n                if (options.contentType && (method === \"POST\" || method === \"PUT\")) {\n                    xhr.setRequestHeader(\"Content-Type\", options.contentType);\n                }\n                qq.extend(allHeaders, qq.isFunction(customHeaders) ? customHeaders(id) : customHeaders);\n                qq.extend(allHeaders, onDemandHeaders);\n                qq.each(allHeaders, function(name, val) {\n                    xhr.setRequestHeader(name, val);\n                });\n            }\n        }\n        function isResponseSuccessful(responseCode) {\n            return qq.indexOf(options.successfulResponseCodes[options.method], responseCode) >= 0;\n        }\n        function prepareToSend(id, optXhr, addToPath, additionalParams, additionalQueryParams, additionalHeaders, payload) {\n            requestData[id] = {\n                addToPath: addToPath,\n                additionalParams: additionalParams,\n                additionalQueryParams: additionalQueryParams,\n                additionalHeaders: additionalHeaders,\n                payload: payload\n            };\n            var len = queue.push(id);\n            if (len <= options.maxConnections) {\n                return sendRequest(id, optXhr);\n            }\n        }\n        shouldParamsBeInQueryString = options.method === \"GET\" || options.method === \"DELETE\";\n        qq.extend(this, {\n            initTransport: function(id) {\n                var path, params, headers, payload, cacheBuster, additionalQueryParams;\n                return {\n                    withPath: function(appendToPath) {\n                        path = appendToPath;\n                        return this;\n                    },\n                    withParams: function(additionalParams) {\n                        params = additionalParams;\n                        return this;\n                    },\n                    withQueryParams: function(_additionalQueryParams_) {\n                        additionalQueryParams = _additionalQueryParams_;\n                        return this;\n                    },\n                    withHeaders: function(additionalHeaders) {\n                        headers = additionalHeaders;\n                        return this;\n                    },\n                    withPayload: function(thePayload) {\n                        payload = thePayload;\n                        return this;\n                    },\n                    withCacheBuster: function() {\n                        cacheBuster = true;\n                        return this;\n                    },\n                    send: function(optXhr) {\n                        if (cacheBuster && qq.indexOf([ \"GET\", \"DELETE\" ], options.method) >= 0) {\n                            params.qqtimestamp = new Date().getTime();\n                        }\n                        return prepareToSend(id, optXhr, path, params, additionalQueryParams, headers, payload);\n                    }\n                };\n            },\n            canceled: function(id) {\n                dequeue(id);\n            }\n        });\n    };\n    qq.UploadHandler = function(spec) {\n        \"use strict\";\n        var proxy = spec.proxy, fileState = {}, onCancel = proxy.onCancel, getName = proxy.getName;\n        qq.extend(this, {\n            add: function(id, fileItem) {\n                fileState[id] = fileItem;\n                fileState[id].temp = {};\n            },\n            cancel: function(id) {\n                var self = this, cancelFinalizationEffort = new qq.Promise(), onCancelRetVal = onCancel(id, getName(id), cancelFinalizationEffort);\n                onCancelRetVal.then(function() {\n                    if (self.isValid(id)) {\n                        fileState[id].canceled = true;\n                        self.expunge(id);\n                    }\n                    cancelFinalizationEffort.success();\n                });\n            },\n            expunge: function(id) {\n                delete fileState[id];\n            },\n            getThirdPartyFileId: function(id) {\n                return fileState[id].key;\n            },\n            isValid: function(id) {\n                return fileState[id] !== undefined;\n            },\n            reset: function() {\n                fileState = {};\n            },\n            _getFileState: function(id) {\n                return fileState[id];\n            },\n            _setThirdPartyFileId: function(id, thirdPartyFileId) {\n                fileState[id].key = thirdPartyFileId;\n            },\n            _wasCanceled: function(id) {\n                return !!fileState[id].canceled;\n            }\n        });\n    };\n    qq.UploadHandlerController = function(o, namespace) {\n        \"use strict\";\n        var controller = this, chunkingPossible = false, concurrentChunkingPossible = false, chunking, preventRetryResponse, log, handler, options = {\n            paramsStore: {},\n            maxConnections: 3,\n            chunking: {\n                enabled: false,\n                multiple: {\n                    enabled: false\n                }\n            },\n            log: function(str, level) {},\n            onProgress: function(id, fileName, loaded, total) {},\n            onComplete: function(id, fileName, response, xhr) {},\n            onCancel: function(id, fileName) {},\n            onUploadPrep: function(id) {},\n            onUpload: function(id, fileName) {},\n            onUploadChunk: function(id, fileName, chunkData) {},\n            onUploadChunkSuccess: function(id, chunkData, response, xhr) {},\n            onAutoRetry: function(id, fileName, response, xhr) {},\n            onResume: function(id, fileName, chunkData) {},\n            onUuidChanged: function(id, newUuid) {},\n            getName: function(id) {},\n            setSize: function(id, newSize) {},\n            isQueued: function(id) {},\n            getIdsInProxyGroup: function(id) {},\n            getIdsInBatch: function(id) {}\n        }, chunked = {\n            done: function(id, chunkIdx, response, xhr) {\n                var chunkData = handler._getChunkData(id, chunkIdx);\n                handler._getFileState(id).attemptingResume = false;\n                delete handler._getFileState(id).temp.chunkProgress[chunkIdx];\n                handler._getFileState(id).loaded += chunkData.size;\n                options.onUploadChunkSuccess(id, handler._getChunkDataForCallback(chunkData), response, xhr);\n            },\n            finalize: function(id) {\n                var size = options.getSize(id), name = options.getName(id);\n                log(\"All chunks have been uploaded for \" + id + \" - finalizing....\");\n                handler.finalizeChunks(id).then(function(response, xhr) {\n                    log(\"Finalize successful for \" + id);\n                    var normaizedResponse = upload.normalizeResponse(response, true);\n                    options.onProgress(id, name, size, size);\n                    handler._maybeDeletePersistedChunkData(id);\n                    upload.cleanup(id, normaizedResponse, xhr);\n                }, function(response, xhr) {\n                    var normaizedResponse = upload.normalizeResponse(response, false);\n                    log(\"Problem finalizing chunks for file ID \" + id + \" - \" + normaizedResponse.error, \"error\");\n                    if (normaizedResponse.reset) {\n                        chunked.reset(id);\n                    }\n                    if (!options.onAutoRetry(id, name, normaizedResponse, xhr)) {\n                        upload.cleanup(id, normaizedResponse, xhr);\n                    }\n                });\n            },\n            handleFailure: function(chunkIdx, id, response, xhr) {\n                var name = options.getName(id);\n                log(\"Chunked upload request failed for \" + id + \", chunk \" + chunkIdx);\n                handler.clearCachedChunk(id, chunkIdx);\n                var responseToReport = upload.normalizeResponse(response, false), inProgressIdx;\n                if (responseToReport.reset) {\n                    chunked.reset(id);\n                } else {\n                    inProgressIdx = qq.indexOf(handler._getFileState(id).chunking.inProgress, chunkIdx);\n                    if (inProgressIdx >= 0) {\n                        handler._getFileState(id).chunking.inProgress.splice(inProgressIdx, 1);\n                        handler._getFileState(id).chunking.remaining.unshift(chunkIdx);\n                    }\n                }\n                if (!handler._getFileState(id).temp.ignoreFailure) {\n                    if (concurrentChunkingPossible) {\n                        handler._getFileState(id).temp.ignoreFailure = true;\n                        log(qq.format(\"Going to attempt to abort these chunks: {}. These are currently in-progress: {}.\", JSON.stringify(Object.keys(handler._getXhrs(id))), JSON.stringify(handler._getFileState(id).chunking.inProgress)));\n                        qq.each(handler._getXhrs(id), function(ckid, ckXhr) {\n                            log(qq.format(\"Attempting to abort file {}.{}. XHR readyState {}. \", id, ckid, ckXhr.readyState));\n                            ckXhr.abort();\n                            ckXhr._cancelled = true;\n                        });\n                        handler.moveInProgressToRemaining(id);\n                        connectionManager.free(id, true);\n                    }\n                    if (!options.onAutoRetry(id, name, responseToReport, xhr)) {\n                        upload.cleanup(id, responseToReport, xhr);\n                    }\n                }\n            },\n            hasMoreParts: function(id) {\n                return !!handler._getFileState(id).chunking.remaining.length;\n            },\n            nextPart: function(id) {\n                var nextIdx = handler._getFileState(id).chunking.remaining.shift();\n                if (nextIdx >= handler._getTotalChunks(id)) {\n                    nextIdx = null;\n                }\n                return nextIdx;\n            },\n            reset: function(id) {\n                log(\"Server or callback has ordered chunking effort to be restarted on next attempt for item ID \" + id, \"error\");\n                handler._maybeDeletePersistedChunkData(id);\n                handler.reevaluateChunking(id);\n                handler._getFileState(id).loaded = 0;\n            },\n            sendNext: function(id) {\n                var size = options.getSize(id), name = options.getName(id), chunkIdx = chunked.nextPart(id), chunkData = handler._getChunkData(id, chunkIdx), resuming = handler._getFileState(id).attemptingResume, inProgressChunks = handler._getFileState(id).chunking.inProgress || [];\n                if (handler._getFileState(id).loaded == null) {\n                    handler._getFileState(id).loaded = 0;\n                }\n                if (resuming && options.onResume(id, name, chunkData) === false) {\n                    chunked.reset(id);\n                    chunkIdx = chunked.nextPart(id);\n                    chunkData = handler._getChunkData(id, chunkIdx);\n                    resuming = false;\n                }\n                if (chunkIdx == null && inProgressChunks.length === 0) {\n                    chunked.finalize(id);\n                } else {\n                    log(qq.format(\"Sending chunked upload request for item {}.{}, bytes {}-{} of {}.\", id, chunkIdx, chunkData.start + 1, chunkData.end, size));\n                    options.onUploadChunk(id, name, handler._getChunkDataForCallback(chunkData));\n                    inProgressChunks.push(chunkIdx);\n                    handler._getFileState(id).chunking.inProgress = inProgressChunks;\n                    if (concurrentChunkingPossible) {\n                        connectionManager.open(id, chunkIdx);\n                    }\n                    if (concurrentChunkingPossible && connectionManager.available() && handler._getFileState(id).chunking.remaining.length) {\n                        chunked.sendNext(id);\n                    }\n                    if (chunkData.blob.size === 0) {\n                        log(qq.format(\"Chunk {} for file {} will not be uploaded, zero sized chunk.\", chunkIdx, id), \"error\");\n                        chunked.handleFailure(chunkIdx, id, \"File is no longer available\", null);\n                    } else {\n                        handler.uploadChunk(id, chunkIdx, resuming).then(function success(response, xhr) {\n                            log(\"Chunked upload request succeeded for \" + id + \", chunk \" + chunkIdx);\n                            handler.clearCachedChunk(id, chunkIdx);\n                            var inProgressChunks = handler._getFileState(id).chunking.inProgress || [], responseToReport = upload.normalizeResponse(response, true), inProgressChunkIdx = qq.indexOf(inProgressChunks, chunkIdx);\n                            log(qq.format(\"Chunk {} for file {} uploaded successfully.\", chunkIdx, id));\n                            chunked.done(id, chunkIdx, responseToReport, xhr);\n                            if (inProgressChunkIdx >= 0) {\n                                inProgressChunks.splice(inProgressChunkIdx, 1);\n                            }\n                            handler._maybePersistChunkedState(id);\n                            if (!chunked.hasMoreParts(id) && inProgressChunks.length === 0) {\n                                chunked.finalize(id);\n                            } else if (chunked.hasMoreParts(id)) {\n                                chunked.sendNext(id);\n                            } else {\n                                log(qq.format(\"File ID {} has no more chunks to send and these chunk indexes are still marked as in-progress: {}\", id, JSON.stringify(inProgressChunks)));\n                            }\n                        }, function failure(response, xhr) {\n                            chunked.handleFailure(chunkIdx, id, response, xhr);\n                        }).done(function() {\n                            handler.clearXhr(id, chunkIdx);\n                        });\n                    }\n                }\n            }\n        }, connectionManager = {\n            _open: [],\n            _openChunks: {},\n            _waiting: [],\n            available: function() {\n                var max = options.maxConnections, openChunkEntriesCount = 0, openChunksCount = 0;\n                qq.each(connectionManager._openChunks, function(fileId, openChunkIndexes) {\n                    openChunkEntriesCount++;\n                    openChunksCount += openChunkIndexes.length;\n                });\n                return max - (connectionManager._open.length - openChunkEntriesCount + openChunksCount);\n            },\n            free: function(id, dontAllowNext) {\n                var allowNext = !dontAllowNext, waitingIndex = qq.indexOf(connectionManager._waiting, id), connectionsIndex = qq.indexOf(connectionManager._open, id), nextId;\n                delete connectionManager._openChunks[id];\n                if (upload.getProxyOrBlob(id) instanceof qq.BlobProxy) {\n                    log(\"Generated blob upload has ended for \" + id + \", disposing generated blob.\");\n                    delete handler._getFileState(id).file;\n                }\n                if (waitingIndex >= 0) {\n                    connectionManager._waiting.splice(waitingIndex, 1);\n                } else if (allowNext && connectionsIndex >= 0) {\n                    connectionManager._open.splice(connectionsIndex, 1);\n                    nextId = connectionManager._waiting.shift();\n                    if (nextId >= 0) {\n                        connectionManager._open.push(nextId);\n                        upload.start(nextId);\n                    }\n                }\n            },\n            getWaitingOrConnected: function() {\n                var waitingOrConnected = [];\n                qq.each(connectionManager._openChunks, function(fileId, chunks) {\n                    if (chunks && chunks.length) {\n                        waitingOrConnected.push(parseInt(fileId));\n                    }\n                });\n                qq.each(connectionManager._open, function(idx, fileId) {\n                    if (!connectionManager._openChunks[fileId]) {\n                        waitingOrConnected.push(parseInt(fileId));\n                    }\n                });\n                waitingOrConnected = waitingOrConnected.concat(connectionManager._waiting);\n                return waitingOrConnected;\n            },\n            isUsingConnection: function(id) {\n                return qq.indexOf(connectionManager._open, id) >= 0;\n            },\n            open: function(id, chunkIdx) {\n                if (chunkIdx == null) {\n                    connectionManager._waiting.push(id);\n                }\n                if (connectionManager.available()) {\n                    if (chunkIdx == null) {\n                        connectionManager._waiting.pop();\n                        connectionManager._open.push(id);\n                    } else {\n                        (function() {\n                            var openChunksEntry = connectionManager._openChunks[id] || [];\n                            openChunksEntry.push(chunkIdx);\n                            connectionManager._openChunks[id] = openChunksEntry;\n                        })();\n                    }\n                    return true;\n                }\n                return false;\n            },\n            reset: function() {\n                connectionManager._waiting = [];\n                connectionManager._open = [];\n            }\n        }, simple = {\n            send: function(id, name) {\n                handler._getFileState(id).loaded = 0;\n                log(\"Sending simple upload request for \" + id);\n                handler.uploadFile(id).then(function(response, optXhr) {\n                    log(\"Simple upload request succeeded for \" + id);\n                    var responseToReport = upload.normalizeResponse(response, true), size = options.getSize(id);\n                    options.onProgress(id, name, size, size);\n                    upload.maybeNewUuid(id, responseToReport);\n                    upload.cleanup(id, responseToReport, optXhr);\n                }, function(response, optXhr) {\n                    log(\"Simple upload request failed for \" + id);\n                    var responseToReport = upload.normalizeResponse(response, false);\n                    if (!options.onAutoRetry(id, name, responseToReport, optXhr)) {\n                        upload.cleanup(id, responseToReport, optXhr);\n                    }\n                });\n            }\n        }, upload = {\n            cancel: function(id) {\n                log(\"Cancelling \" + id);\n                options.paramsStore.remove(id);\n                connectionManager.free(id);\n            },\n            cleanup: function(id, response, optXhr) {\n                var name = options.getName(id);\n                options.onComplete(id, name, response, optXhr);\n                if (handler._getFileState(id)) {\n                    handler._clearXhrs && handler._clearXhrs(id);\n                }\n                connectionManager.free(id);\n            },\n            getProxyOrBlob: function(id) {\n                return handler.getProxy && handler.getProxy(id) || handler.getFile && handler.getFile(id);\n            },\n            initHandler: function() {\n                var handlerType = namespace ? qq[namespace] : qq.traditional, handlerModuleSubtype = qq.supportedFeatures.ajaxUploading ? \"Xhr\" : \"Form\";\n                handler = new handlerType[handlerModuleSubtype + \"UploadHandler\"](options, {\n                    getDataByUuid: options.getDataByUuid,\n                    getName: options.getName,\n                    getSize: options.getSize,\n                    getUuid: options.getUuid,\n                    log: log,\n                    onCancel: options.onCancel,\n                    onProgress: options.onProgress,\n                    onUuidChanged: options.onUuidChanged\n                });\n                if (handler._removeExpiredChunkingRecords) {\n                    handler._removeExpiredChunkingRecords();\n                }\n            },\n            isDeferredEligibleForUpload: function(id) {\n                return options.isQueued(id);\n            },\n            maybeDefer: function(id, blob) {\n                if (blob && !handler.getFile(id) && blob instanceof qq.BlobProxy) {\n                    options.onUploadPrep(id);\n                    log(\"Attempting to generate a blob on-demand for \" + id);\n                    blob.create().then(function(generatedBlob) {\n                        log(\"Generated an on-demand blob for \" + id);\n                        handler.updateBlob(id, generatedBlob);\n                        options.setSize(id, generatedBlob.size);\n                        handler.reevaluateChunking(id);\n                        upload.maybeSendDeferredFiles(id);\n                    }, function(errorMessage) {\n                        var errorResponse = {};\n                        if (errorMessage) {\n                            errorResponse.error = errorMessage;\n                        }\n                        log(qq.format(\"Failed to generate blob for ID {}.  Error message: {}.\", id, errorMessage), \"error\");\n                        options.onComplete(id, options.getName(id), qq.extend(errorResponse, preventRetryResponse), null);\n                        upload.maybeSendDeferredFiles(id);\n                        connectionManager.free(id);\n                    });\n                } else {\n                    return upload.maybeSendDeferredFiles(id);\n                }\n                return false;\n            },\n            maybeSendDeferredFiles: function(id) {\n                var idsInGroup = options.getIdsInProxyGroup(id), uploadedThisId = false;\n                if (idsInGroup && idsInGroup.length) {\n                    log(\"Maybe ready to upload proxy group file \" + id);\n                    qq.each(idsInGroup, function(idx, idInGroup) {\n                        if (upload.isDeferredEligibleForUpload(idInGroup) && !!handler.getFile(idInGroup)) {\n                            uploadedThisId = idInGroup === id;\n                            upload.now(idInGroup);\n                        } else if (upload.isDeferredEligibleForUpload(idInGroup)) {\n                            return false;\n                        }\n                    });\n                } else {\n                    uploadedThisId = true;\n                    upload.now(id);\n                }\n                return uploadedThisId;\n            },\n            maybeNewUuid: function(id, response) {\n                if (response.newUuid !== undefined) {\n                    options.onUuidChanged(id, response.newUuid);\n                }\n            },\n            normalizeResponse: function(originalResponse, successful) {\n                var response = originalResponse;\n                if (!qq.isObject(originalResponse)) {\n                    response = {};\n                    if (qq.isString(originalResponse) && !successful) {\n                        response.error = originalResponse;\n                    }\n                }\n                response.success = successful;\n                return response;\n            },\n            now: function(id) {\n                var name = options.getName(id);\n                if (!controller.isValid(id)) {\n                    throw new qq.Error(id + \" is not a valid file ID to upload!\");\n                }\n                options.onUpload(id, name);\n                if (chunkingPossible && handler._shouldChunkThisFile(id)) {\n                    chunked.sendNext(id);\n                } else {\n                    simple.send(id, name);\n                }\n            },\n            start: function(id) {\n                var blobToUpload = upload.getProxyOrBlob(id);\n                if (blobToUpload) {\n                    return upload.maybeDefer(id, blobToUpload);\n                } else {\n                    upload.now(id);\n                    return true;\n                }\n            }\n        };\n        qq.extend(this, {\n            add: function(id, file) {\n                handler.add.apply(this, arguments);\n            },\n            upload: function(id) {\n                if (connectionManager.open(id)) {\n                    return upload.start(id);\n                }\n                return false;\n            },\n            retry: function(id) {\n                if (concurrentChunkingPossible) {\n                    handler._getFileState(id).temp.ignoreFailure = false;\n                }\n                if (connectionManager.isUsingConnection(id)) {\n                    return upload.start(id);\n                } else {\n                    return controller.upload(id);\n                }\n            },\n            cancel: function(id) {\n                var cancelRetVal = handler.cancel(id);\n                if (qq.isGenericPromise(cancelRetVal)) {\n                    cancelRetVal.then(function() {\n                        upload.cancel(id);\n                    });\n                } else if (cancelRetVal !== false) {\n                    upload.cancel(id);\n                }\n            },\n            cancelAll: function() {\n                var waitingOrConnected = connectionManager.getWaitingOrConnected(), i;\n                if (waitingOrConnected.length) {\n                    for (i = waitingOrConnected.length - 1; i >= 0; i--) {\n                        controller.cancel(waitingOrConnected[i]);\n                    }\n                }\n                connectionManager.reset();\n            },\n            getFile: function(id) {\n                if (handler.getProxy && handler.getProxy(id)) {\n                    return handler.getProxy(id).referenceBlob;\n                }\n                return handler.getFile && handler.getFile(id);\n            },\n            isProxied: function(id) {\n                return !!(handler.getProxy && handler.getProxy(id));\n            },\n            getInput: function(id) {\n                if (handler.getInput) {\n                    return handler.getInput(id);\n                }\n            },\n            reset: function() {\n                log(\"Resetting upload handler\");\n                controller.cancelAll();\n                connectionManager.reset();\n                handler.reset();\n            },\n            expunge: function(id) {\n                if (controller.isValid(id)) {\n                    return handler.expunge(id);\n                }\n            },\n            isValid: function(id) {\n                return handler.isValid(id);\n            },\n            getResumableFilesData: function() {\n                if (handler.getResumableFilesData) {\n                    return handler.getResumableFilesData();\n                }\n                return [];\n            },\n            getThirdPartyFileId: function(id) {\n                if (controller.isValid(id)) {\n                    return handler.getThirdPartyFileId(id);\n                }\n            },\n            pause: function(id) {\n                if (controller.isResumable(id) && handler.pause && controller.isValid(id) && handler.pause(id)) {\n                    connectionManager.free(id);\n                    handler.moveInProgressToRemaining(id);\n                    return true;\n                }\n                return false;\n            },\n            isResumable: function(id) {\n                return !!handler.isResumable && handler.isResumable(id);\n            }\n        });\n        qq.extend(options, o);\n        log = options.log;\n        chunkingPossible = options.chunking.enabled && qq.supportedFeatures.chunking;\n        concurrentChunkingPossible = chunkingPossible && options.chunking.concurrent.enabled;\n        preventRetryResponse = function() {\n            var response = {};\n            response[options.preventRetryParam] = true;\n            return response;\n        }();\n        upload.initHandler();\n    };\n    qq.WindowReceiveMessage = function(o) {\n        \"use strict\";\n        var options = {\n            log: function(message, level) {}\n        }, callbackWrapperDetachers = {};\n        qq.extend(options, o);\n        qq.extend(this, {\n            receiveMessage: function(id, callback) {\n                var onMessageCallbackWrapper = function(event) {\n                    callback(event.data);\n                };\n                if (window.postMessage) {\n                    callbackWrapperDetachers[id] = qq(window).attach(\"message\", onMessageCallbackWrapper);\n                } else {\n                    log(\"iframe message passing not supported in this browser!\", \"error\");\n                }\n            },\n            stopReceivingMessages: function(id) {\n                if (window.postMessage) {\n                    var detacher = callbackWrapperDetachers[id];\n                    if (detacher) {\n                        detacher();\n                    }\n                }\n            }\n        });\n    };\n    qq.FormUploadHandler = function(spec) {\n        \"use strict\";\n        var options = spec.options, handler = this, proxy = spec.proxy, formHandlerInstanceId = qq.getUniqueId(), onloadCallbacks = {}, detachLoadEvents = {}, postMessageCallbackTimers = {}, isCors = options.isCors, inputName = options.inputName, getUuid = proxy.getUuid, log = proxy.log, corsMessageReceiver = new qq.WindowReceiveMessage({\n            log: log\n        });\n        function expungeFile(id) {\n            delete detachLoadEvents[id];\n            if (isCors) {\n                clearTimeout(postMessageCallbackTimers[id]);\n                delete postMessageCallbackTimers[id];\n                corsMessageReceiver.stopReceivingMessages(id);\n            }\n            var iframe = document.getElementById(handler._getIframeName(id));\n            if (iframe) {\n                iframe.setAttribute(\"src\", \"javascript:false;\");\n                qq(iframe).remove();\n            }\n        }\n        function getFileIdForIframeName(iframeName) {\n            return iframeName.split(\"_\")[0];\n        }\n        function initIframeForUpload(name) {\n            var iframe = qq.toElement(\"<iframe src='javascript:false;' name='\" + name + \"' />\");\n            iframe.setAttribute(\"id\", name);\n            iframe.style.display = \"none\";\n            document.body.appendChild(iframe);\n            return iframe;\n        }\n        function registerPostMessageCallback(iframe, callback) {\n            var iframeName = iframe.id, fileId = getFileIdForIframeName(iframeName), uuid = getUuid(fileId);\n            onloadCallbacks[uuid] = callback;\n            detachLoadEvents[fileId] = qq(iframe).attach(\"load\", function() {\n                if (handler.getInput(fileId)) {\n                    log(\"Received iframe load event for CORS upload request (iframe name \" + iframeName + \")\");\n                    postMessageCallbackTimers[iframeName] = setTimeout(function() {\n                        var errorMessage = \"No valid message received from loaded iframe for iframe name \" + iframeName;\n                        log(errorMessage, \"error\");\n                        callback({\n                            error: errorMessage\n                        });\n                    }, 1e3);\n                }\n            });\n            corsMessageReceiver.receiveMessage(iframeName, function(message) {\n                log(\"Received the following window message: '\" + message + \"'\");\n                var fileId = getFileIdForIframeName(iframeName), response = handler._parseJsonResponse(message), uuid = response.uuid, onloadCallback;\n                if (uuid && onloadCallbacks[uuid]) {\n                    log(\"Handling response for iframe name \" + iframeName);\n                    clearTimeout(postMessageCallbackTimers[iframeName]);\n                    delete postMessageCallbackTimers[iframeName];\n                    handler._detachLoadEvent(iframeName);\n                    onloadCallback = onloadCallbacks[uuid];\n                    delete onloadCallbacks[uuid];\n                    corsMessageReceiver.stopReceivingMessages(iframeName);\n                    onloadCallback(response);\n                } else if (!uuid) {\n                    log(\"'\" + message + \"' does not contain a UUID - ignoring.\");\n                }\n            });\n        }\n        qq.extend(this, new qq.UploadHandler(spec));\n        qq.override(this, function(super_) {\n            return {\n                add: function(id, fileInput) {\n                    super_.add(id, {\n                        input: fileInput\n                    });\n                    fileInput.setAttribute(\"name\", inputName);\n                    if (fileInput.parentNode) {\n                        qq(fileInput).remove();\n                    }\n                },\n                expunge: function(id) {\n                    expungeFile(id);\n                    super_.expunge(id);\n                },\n                isValid: function(id) {\n                    return super_.isValid(id) && handler._getFileState(id).input !== undefined;\n                }\n            };\n        });\n        qq.extend(this, {\n            getInput: function(id) {\n                return handler._getFileState(id).input;\n            },\n            _attachLoadEvent: function(iframe, callback) {\n                var responseDescriptor;\n                if (isCors) {\n                    registerPostMessageCallback(iframe, callback);\n                } else {\n                    detachLoadEvents[iframe.id] = qq(iframe).attach(\"load\", function() {\n                        log(\"Received response for \" + iframe.id);\n                        if (!iframe.parentNode) {\n                            return;\n                        }\n                        try {\n                            if (iframe.contentDocument && iframe.contentDocument.body && iframe.contentDocument.body.innerHTML == \"false\") {\n                                return;\n                            }\n                        } catch (error) {\n                            log(\"Error when attempting to access iframe during handling of upload response (\" + error.message + \")\", \"error\");\n                            responseDescriptor = {\n                                success: false\n                            };\n                        }\n                        callback(responseDescriptor);\n                    });\n                }\n            },\n            _createIframe: function(id) {\n                var iframeName = handler._getIframeName(id);\n                return initIframeForUpload(iframeName);\n            },\n            _detachLoadEvent: function(id) {\n                if (detachLoadEvents[id] !== undefined) {\n                    detachLoadEvents[id]();\n                    delete detachLoadEvents[id];\n                }\n            },\n            _getIframeName: function(fileId) {\n                return fileId + \"_\" + formHandlerInstanceId;\n            },\n            _initFormForUpload: function(spec) {\n                var method = spec.method, endpoint = spec.endpoint, params = spec.params, paramsInBody = spec.paramsInBody, targetName = spec.targetName, form = qq.toElement(\"<form method='\" + method + \"' enctype='multipart/form-data'></form>\"), url = endpoint;\n                if (paramsInBody) {\n                    qq.obj2Inputs(params, form);\n                } else {\n                    url = qq.obj2url(params, endpoint);\n                }\n                form.setAttribute(\"action\", url);\n                form.setAttribute(\"target\", targetName);\n                form.style.display = \"none\";\n                document.body.appendChild(form);\n                return form;\n            },\n            _parseJsonResponse: function(innerHtmlOrMessage) {\n                var response = {};\n                try {\n                    response = qq.parseJson(innerHtmlOrMessage);\n                } catch (error) {\n                    log(\"Error when attempting to parse iframe upload response (\" + error.message + \")\", \"error\");\n                }\n                return response;\n            }\n        });\n    };\n    qq.XhrUploadHandler = function(spec) {\n        \"use strict\";\n        var handler = this, namespace = spec.options.namespace, proxy = spec.proxy, chunking = spec.options.chunking, resume = spec.options.resume, chunkFiles = chunking && spec.options.chunking.enabled && qq.supportedFeatures.chunking, resumeEnabled = resume && spec.options.resume.enabled && chunkFiles && qq.supportedFeatures.resume, getName = proxy.getName, getSize = proxy.getSize, getUuid = proxy.getUuid, getEndpoint = proxy.getEndpoint, getDataByUuid = proxy.getDataByUuid, onUuidChanged = proxy.onUuidChanged, onProgress = proxy.onProgress, log = proxy.log;\n        function abort(id) {\n            qq.each(handler._getXhrs(id), function(xhrId, xhr) {\n                var ajaxRequester = handler._getAjaxRequester(id, xhrId);\n                xhr.onreadystatechange = null;\n                xhr.upload.onprogress = null;\n                xhr.abort();\n                ajaxRequester && ajaxRequester.canceled && ajaxRequester.canceled(id);\n            });\n        }\n        qq.extend(this, new qq.UploadHandler(spec));\n        qq.override(this, function(super_) {\n            return {\n                add: function(id, blobOrProxy) {\n                    if (qq.isFile(blobOrProxy) || qq.isBlob(blobOrProxy)) {\n                        super_.add(id, {\n                            file: blobOrProxy\n                        });\n                    } else if (blobOrProxy instanceof qq.BlobProxy) {\n                        super_.add(id, {\n                            proxy: blobOrProxy\n                        });\n                    } else {\n                        throw new Error(\"Passed obj is not a File, Blob, or proxy\");\n                    }\n                    handler._initTempState(id);\n                    resumeEnabled && handler._maybePrepareForResume(id);\n                },\n                expunge: function(id) {\n                    abort(id);\n                    handler._maybeDeletePersistedChunkData(id);\n                    handler._clearXhrs(id);\n                    super_.expunge(id);\n                }\n            };\n        });\n        qq.extend(this, {\n            clearCachedChunk: function(id, chunkIdx) {\n                delete handler._getFileState(id).temp.cachedChunks[chunkIdx];\n            },\n            clearXhr: function(id, chunkIdx) {\n                var tempState = handler._getFileState(id).temp;\n                if (tempState.xhrs) {\n                    delete tempState.xhrs[chunkIdx];\n                }\n                if (tempState.ajaxRequesters) {\n                    delete tempState.ajaxRequesters[chunkIdx];\n                }\n            },\n            finalizeChunks: function(id, responseParser) {\n                var lastChunkIdx = handler._getTotalChunks(id) - 1, xhr = handler._getXhr(id, lastChunkIdx);\n                if (responseParser) {\n                    return new qq.Promise().success(responseParser(xhr), xhr);\n                }\n                return new qq.Promise().success({}, xhr);\n            },\n            getFile: function(id) {\n                return handler.isValid(id) && handler._getFileState(id).file;\n            },\n            getProxy: function(id) {\n                return handler.isValid(id) && handler._getFileState(id).proxy;\n            },\n            getResumableFilesData: function() {\n                var resumableFilesData = [];\n                handler._iterateResumeRecords(function(key, uploadData) {\n                    handler.moveInProgressToRemaining(null, uploadData.chunking.inProgress, uploadData.chunking.remaining);\n                    var data = {\n                        name: uploadData.name,\n                        remaining: uploadData.chunking.remaining,\n                        size: uploadData.size,\n                        uuid: uploadData.uuid\n                    };\n                    if (uploadData.key) {\n                        data.key = uploadData.key;\n                    }\n                    resumableFilesData.push(data);\n                });\n                return resumableFilesData;\n            },\n            isResumable: function(id) {\n                return !!chunking && handler.isValid(id) && !handler._getFileState(id).notResumable;\n            },\n            moveInProgressToRemaining: function(id, optInProgress, optRemaining) {\n                var inProgress = optInProgress || handler._getFileState(id).chunking.inProgress, remaining = optRemaining || handler._getFileState(id).chunking.remaining;\n                if (inProgress) {\n                    log(qq.format(\"Moving these chunks from in-progress {}, to remaining.\", JSON.stringify(inProgress)));\n                    inProgress.reverse();\n                    qq.each(inProgress, function(idx, chunkIdx) {\n                        remaining.unshift(chunkIdx);\n                    });\n                    inProgress.length = 0;\n                }\n            },\n            pause: function(id) {\n                if (handler.isValid(id)) {\n                    log(qq.format(\"Aborting XHR upload for {} '{}' due to pause instruction.\", id, getName(id)));\n                    handler._getFileState(id).paused = true;\n                    abort(id);\n                    return true;\n                }\n            },\n            reevaluateChunking: function(id) {\n                if (chunking && handler.isValid(id)) {\n                    var state = handler._getFileState(id), totalChunks, i;\n                    delete state.chunking;\n                    state.chunking = {};\n                    totalChunks = handler._getTotalChunks(id);\n                    if (totalChunks > 1 || chunking.mandatory) {\n                        state.chunking.enabled = true;\n                        state.chunking.parts = totalChunks;\n                        state.chunking.remaining = [];\n                        for (i = 0; i < totalChunks; i++) {\n                            state.chunking.remaining.push(i);\n                        }\n                        handler._initTempState(id);\n                    } else {\n                        state.chunking.enabled = false;\n                    }\n                }\n            },\n            updateBlob: function(id, newBlob) {\n                if (handler.isValid(id)) {\n                    handler._getFileState(id).file = newBlob;\n                }\n            },\n            _clearXhrs: function(id) {\n                var tempState = handler._getFileState(id).temp;\n                qq.each(tempState.ajaxRequesters, function(chunkId) {\n                    delete tempState.ajaxRequesters[chunkId];\n                });\n                qq.each(tempState.xhrs, function(chunkId) {\n                    delete tempState.xhrs[chunkId];\n                });\n            },\n            _createXhr: function(id, optChunkIdx) {\n                return handler._registerXhr(id, optChunkIdx, qq.createXhrInstance());\n            },\n            _getAjaxRequester: function(id, optChunkIdx) {\n                var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n                return handler._getFileState(id).temp.ajaxRequesters[chunkIdx];\n            },\n            _getChunkData: function(id, chunkIndex) {\n                var chunkSize = chunking.partSize, fileSize = getSize(id), fileOrBlob = handler.getFile(id), startBytes = chunkSize * chunkIndex, endBytes = startBytes + chunkSize >= fileSize ? fileSize : startBytes + chunkSize, totalChunks = handler._getTotalChunks(id), cachedChunks = this._getFileState(id).temp.cachedChunks, blob = cachedChunks[chunkIndex] || qq.sliceBlob(fileOrBlob, startBytes, endBytes);\n                cachedChunks[chunkIndex] = blob;\n                return {\n                    part: chunkIndex,\n                    start: startBytes,\n                    end: endBytes,\n                    count: totalChunks,\n                    blob: blob,\n                    size: endBytes - startBytes\n                };\n            },\n            _getChunkDataForCallback: function(chunkData) {\n                return {\n                    partIndex: chunkData.part,\n                    startByte: chunkData.start + 1,\n                    endByte: chunkData.end,\n                    totalParts: chunkData.count\n                };\n            },\n            _getLocalStorageId: function(id) {\n                var formatVersion = \"5.0\", name = getName(id), size = getSize(id), chunkSize = chunking.partSize, endpoint = getEndpoint(id);\n                return qq.format(\"qq{}resume{}-{}-{}-{}-{}\", namespace, formatVersion, name, size, chunkSize, endpoint);\n            },\n            _getMimeType: function(id) {\n                return handler.getFile(id).type;\n            },\n            _getPersistableData: function(id) {\n                return handler._getFileState(id).chunking;\n            },\n            _getTotalChunks: function(id) {\n                if (chunking) {\n                    var fileSize = getSize(id), chunkSize = chunking.partSize;\n                    return Math.ceil(fileSize / chunkSize);\n                }\n            },\n            _getXhr: function(id, optChunkIdx) {\n                var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n                return handler._getFileState(id).temp.xhrs[chunkIdx];\n            },\n            _getXhrs: function(id) {\n                return handler._getFileState(id).temp.xhrs;\n            },\n            _iterateResumeRecords: function(callback) {\n                if (resumeEnabled) {\n                    qq.each(localStorage, function(key, item) {\n                        if (key.indexOf(qq.format(\"qq{}resume\", namespace)) === 0) {\n                            var uploadData = JSON.parse(item);\n                            callback(key, uploadData);\n                        }\n                    });\n                }\n            },\n            _initTempState: function(id) {\n                handler._getFileState(id).temp = {\n                    ajaxRequesters: {},\n                    chunkProgress: {},\n                    xhrs: {},\n                    cachedChunks: {}\n                };\n            },\n            _markNotResumable: function(id) {\n                handler._getFileState(id).notResumable = true;\n            },\n            _maybeDeletePersistedChunkData: function(id) {\n                var localStorageId;\n                if (resumeEnabled && handler.isResumable(id)) {\n                    localStorageId = handler._getLocalStorageId(id);\n                    if (localStorageId && localStorage.getItem(localStorageId)) {\n                        localStorage.removeItem(localStorageId);\n                        return true;\n                    }\n                }\n                return false;\n            },\n            _maybePrepareForResume: function(id) {\n                var state = handler._getFileState(id), localStorageId, persistedData;\n                if (resumeEnabled && state.key === undefined) {\n                    localStorageId = handler._getLocalStorageId(id);\n                    persistedData = localStorage.getItem(localStorageId);\n                    if (persistedData) {\n                        persistedData = JSON.parse(persistedData);\n                        if (getDataByUuid(persistedData.uuid)) {\n                            handler._markNotResumable(id);\n                        } else {\n                            log(qq.format(\"Identified file with ID {} and name of {} as resumable.\", id, getName(id)));\n                            onUuidChanged(id, persistedData.uuid);\n                            state.key = persistedData.key;\n                            state.chunking = persistedData.chunking;\n                            state.loaded = persistedData.loaded;\n                            state.attemptingResume = true;\n                            handler.moveInProgressToRemaining(id);\n                        }\n                    }\n                }\n            },\n            _maybePersistChunkedState: function(id) {\n                var state = handler._getFileState(id), localStorageId, persistedData;\n                if (resumeEnabled && handler.isResumable(id)) {\n                    localStorageId = handler._getLocalStorageId(id);\n                    persistedData = {\n                        name: getName(id),\n                        size: getSize(id),\n                        uuid: getUuid(id),\n                        key: state.key,\n                        chunking: state.chunking,\n                        loaded: state.loaded,\n                        lastUpdated: Date.now()\n                    };\n                    try {\n                        localStorage.setItem(localStorageId, JSON.stringify(persistedData));\n                    } catch (error) {\n                        log(qq.format(\"Unable to save resume data for '{}' due to error: '{}'.\", id, error.toString()), \"warn\");\n                    }\n                }\n            },\n            _registerProgressHandler: function(id, chunkIdx, chunkSize) {\n                var xhr = handler._getXhr(id, chunkIdx), name = getName(id), progressCalculator = {\n                    simple: function(loaded, total) {\n                        var fileSize = getSize(id);\n                        if (loaded === total) {\n                            onProgress(id, name, fileSize, fileSize);\n                        } else {\n                            onProgress(id, name, loaded >= fileSize ? fileSize - 1 : loaded, fileSize);\n                        }\n                    },\n                    chunked: function(loaded, total) {\n                        var chunkProgress = handler._getFileState(id).temp.chunkProgress, totalSuccessfullyLoadedForFile = handler._getFileState(id).loaded, loadedForRequest = loaded, totalForRequest = total, totalFileSize = getSize(id), estActualChunkLoaded = loadedForRequest - (totalForRequest - chunkSize), totalLoadedForFile = totalSuccessfullyLoadedForFile;\n                        chunkProgress[chunkIdx] = estActualChunkLoaded;\n                        qq.each(chunkProgress, function(chunkIdx, chunkLoaded) {\n                            totalLoadedForFile += chunkLoaded;\n                        });\n                        onProgress(id, name, totalLoadedForFile, totalFileSize);\n                    }\n                };\n                xhr.upload.onprogress = function(e) {\n                    if (e.lengthComputable) {\n                        var type = chunkSize == null ? \"simple\" : \"chunked\";\n                        progressCalculator[type](e.loaded, e.total);\n                    }\n                };\n            },\n            _registerXhr: function(id, optChunkIdx, xhr, optAjaxRequester) {\n                var xhrsId = optChunkIdx == null ? -1 : optChunkIdx, tempState = handler._getFileState(id).temp;\n                tempState.xhrs = tempState.xhrs || {};\n                tempState.ajaxRequesters = tempState.ajaxRequesters || {};\n                tempState.xhrs[xhrsId] = xhr;\n                if (optAjaxRequester) {\n                    tempState.ajaxRequesters[xhrsId] = optAjaxRequester;\n                }\n                return xhr;\n            },\n            _removeExpiredChunkingRecords: function() {\n                var expirationDays = resume.recordsExpireIn;\n                handler._iterateResumeRecords(function(key, uploadData) {\n                    var expirationDate = new Date(uploadData.lastUpdated);\n                    expirationDate.setDate(expirationDate.getDate() + expirationDays);\n                    if (expirationDate.getTime() <= Date.now()) {\n                        log(\"Removing expired resume record with key \" + key);\n                        localStorage.removeItem(key);\n                    }\n                });\n            },\n            _shouldChunkThisFile: function(id) {\n                var state = handler._getFileState(id);\n                if (!state.chunking) {\n                    handler.reevaluateChunking(id);\n                }\n                return state.chunking.enabled;\n            }\n        });\n    };\n    qq.DeleteFileAjaxRequester = function(o) {\n        \"use strict\";\n        var requester, options = {\n            method: \"DELETE\",\n            uuidParamName: \"qquuid\",\n            endpointStore: {},\n            maxConnections: 3,\n            customHeaders: function(id) {\n                return {};\n            },\n            paramsStore: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {},\n            onDelete: function(id) {},\n            onDeleteComplete: function(id, xhrOrXdr, isError) {}\n        };\n        qq.extend(options, o);\n        function getMandatedParams() {\n            if (options.method.toUpperCase() === \"POST\") {\n                return {\n                    _method: \"DELETE\"\n                };\n            }\n            return {};\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            validMethods: [ \"POST\", \"DELETE\" ],\n            method: options.method,\n            endpointStore: options.endpointStore,\n            paramsStore: options.paramsStore,\n            mandatedParams: getMandatedParams(),\n            maxConnections: options.maxConnections,\n            customHeaders: function(id) {\n                return options.customHeaders.get(id);\n            },\n            log: options.log,\n            onSend: options.onDelete,\n            onComplete: options.onDeleteComplete,\n            cors: options.cors\n        }));\n        qq.extend(this, {\n            sendDelete: function(id, uuid, additionalMandatedParams) {\n                var additionalOptions = additionalMandatedParams || {};\n                options.log(\"Submitting delete file request for \" + id);\n                if (options.method === \"DELETE\") {\n                    requester.initTransport(id).withPath(uuid).withParams(additionalOptions).send();\n                } else {\n                    additionalOptions[options.uuidParamName] = uuid;\n                    requester.initTransport(id).withParams(additionalOptions).send();\n                }\n            }\n        });\n    };\n    (function() {\n        function detectSubsampling(img) {\n            var iw = img.naturalWidth, ih = img.naturalHeight, canvas = document.createElement(\"canvas\"), ctx;\n            if (iw * ih > 1024 * 1024) {\n                canvas.width = canvas.height = 1;\n                ctx = canvas.getContext(\"2d\");\n                ctx.drawImage(img, -iw + 1, 0);\n                return ctx.getImageData(0, 0, 1, 1).data[3] === 0;\n            } else {\n                return false;\n            }\n        }\n        function detectVerticalSquash(img, iw, ih) {\n            var canvas = document.createElement(\"canvas\"), sy = 0, ey = ih, py = ih, ctx, data, alpha, ratio;\n            canvas.width = 1;\n            canvas.height = ih;\n            ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(img, 0, 0);\n            data = ctx.getImageData(0, 0, 1, ih).data;\n            while (py > sy) {\n                alpha = data[(py - 1) * 4 + 3];\n                if (alpha === 0) {\n                    ey = py;\n                } else {\n                    sy = py;\n                }\n                py = ey + sy >> 1;\n            }\n            ratio = py / ih;\n            return ratio === 0 ? 1 : ratio;\n        }\n        function renderImageToDataURL(img, blob, options, doSquash) {\n            var canvas = document.createElement(\"canvas\"), mime = options.mime || \"image/jpeg\", promise = new qq.Promise();\n            renderImageToCanvas(img, blob, canvas, options, doSquash).then(function() {\n                promise.success(canvas.toDataURL(mime, options.quality || .8));\n            });\n            return promise;\n        }\n        function maybeCalculateDownsampledDimensions(spec) {\n            var maxPixels = 5241e3;\n            if (!qq.ios()) {\n                throw new qq.Error(\"Downsampled dimensions can only be reliably calculated for iOS!\");\n            }\n            if (spec.origHeight * spec.origWidth > maxPixels) {\n                return {\n                    newHeight: Math.round(Math.sqrt(maxPixels * (spec.origHeight / spec.origWidth))),\n                    newWidth: Math.round(Math.sqrt(maxPixels * (spec.origWidth / spec.origHeight)))\n                };\n            }\n        }\n        function renderImageToCanvas(img, blob, canvas, options, doSquash) {\n            var iw = img.naturalWidth, ih = img.naturalHeight, width = options.width, height = options.height, ctx = canvas.getContext(\"2d\"), promise = new qq.Promise(), modifiedDimensions;\n            ctx.save();\n            if (options.resize) {\n                return renderImageToCanvasWithCustomResizer({\n                    blob: blob,\n                    canvas: canvas,\n                    image: img,\n                    imageHeight: ih,\n                    imageWidth: iw,\n                    orientation: options.orientation,\n                    resize: options.resize,\n                    targetHeight: height,\n                    targetWidth: width\n                });\n            }\n            if (!qq.supportedFeatures.unlimitedScaledImageSize) {\n                modifiedDimensions = maybeCalculateDownsampledDimensions({\n                    origWidth: width,\n                    origHeight: height\n                });\n                if (modifiedDimensions) {\n                    qq.log(qq.format(\"Had to reduce dimensions due to device limitations from {}w / {}h to {}w / {}h\", width, height, modifiedDimensions.newWidth, modifiedDimensions.newHeight), \"warn\");\n                    width = modifiedDimensions.newWidth;\n                    height = modifiedDimensions.newHeight;\n                }\n            }\n            transformCoordinate(canvas, width, height, options.orientation);\n            if (qq.ios()) {\n                (function() {\n                    if (detectSubsampling(img)) {\n                        iw /= 2;\n                        ih /= 2;\n                    }\n                    var d = 1024, tmpCanvas = document.createElement(\"canvas\"), vertSquashRatio = doSquash ? detectVerticalSquash(img, iw, ih) : 1, dw = Math.ceil(d * width / iw), dh = Math.ceil(d * height / ih / vertSquashRatio), sy = 0, dy = 0, tmpCtx, sx, dx;\n                    tmpCanvas.width = tmpCanvas.height = d;\n                    tmpCtx = tmpCanvas.getContext(\"2d\");\n                    while (sy < ih) {\n                        sx = 0;\n                        dx = 0;\n                        while (sx < iw) {\n                            tmpCtx.clearRect(0, 0, d, d);\n                            tmpCtx.drawImage(img, -sx, -sy);\n                            ctx.drawImage(tmpCanvas, 0, 0, d, d, dx, dy, dw, dh);\n                            sx += d;\n                            dx += dw;\n                        }\n                        sy += d;\n                        dy += dh;\n                    }\n                    ctx.restore();\n                    tmpCanvas = tmpCtx = null;\n                })();\n            } else {\n                ctx.drawImage(img, 0, 0, width, height);\n            }\n            canvas.qqImageRendered && canvas.qqImageRendered();\n            promise.success();\n            return promise;\n        }\n        function renderImageToCanvasWithCustomResizer(resizeInfo) {\n            var blob = resizeInfo.blob, image = resizeInfo.image, imageHeight = resizeInfo.imageHeight, imageWidth = resizeInfo.imageWidth, orientation = resizeInfo.orientation, promise = new qq.Promise(), resize = resizeInfo.resize, sourceCanvas = document.createElement(\"canvas\"), sourceCanvasContext = sourceCanvas.getContext(\"2d\"), targetCanvas = resizeInfo.canvas, targetHeight = resizeInfo.targetHeight, targetWidth = resizeInfo.targetWidth;\n            transformCoordinate(sourceCanvas, imageWidth, imageHeight, orientation);\n            targetCanvas.height = targetHeight;\n            targetCanvas.width = targetWidth;\n            sourceCanvasContext.drawImage(image, 0, 0);\n            resize({\n                blob: blob,\n                height: targetHeight,\n                image: image,\n                sourceCanvas: sourceCanvas,\n                targetCanvas: targetCanvas,\n                width: targetWidth\n            }).then(function success() {\n                targetCanvas.qqImageRendered && targetCanvas.qqImageRendered();\n                promise.success();\n            }, promise.failure);\n            return promise;\n        }\n        function transformCoordinate(canvas, width, height, orientation) {\n            switch (orientation) {\n              case 5:\n              case 6:\n              case 7:\n              case 8:\n                canvas.width = height;\n                canvas.height = width;\n                break;\n\n              default:\n                canvas.width = width;\n                canvas.height = height;\n            }\n            var ctx = canvas.getContext(\"2d\");\n            switch (orientation) {\n              case 2:\n                ctx.translate(width, 0);\n                ctx.scale(-1, 1);\n                break;\n\n              case 3:\n                ctx.translate(width, height);\n                ctx.rotate(Math.PI);\n                break;\n\n              case 4:\n                ctx.translate(0, height);\n                ctx.scale(1, -1);\n                break;\n\n              case 5:\n                ctx.rotate(.5 * Math.PI);\n                ctx.scale(1, -1);\n                break;\n\n              case 6:\n                ctx.rotate(.5 * Math.PI);\n                ctx.translate(0, -height);\n                break;\n\n              case 7:\n                ctx.rotate(.5 * Math.PI);\n                ctx.translate(width, -height);\n                ctx.scale(-1, 1);\n                break;\n\n              case 8:\n                ctx.rotate(-.5 * Math.PI);\n                ctx.translate(-width, 0);\n                break;\n\n              default:\n                break;\n            }\n        }\n        function MegaPixImage(srcImage, errorCallback) {\n            var self = this;\n            if (window.Blob && srcImage instanceof Blob) {\n                (function() {\n                    var img = new Image(), URL = window.URL && window.URL.createObjectURL ? window.URL : window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;\n                    if (!URL) {\n                        throw Error(\"No createObjectURL function found to create blob url\");\n                    }\n                    img.src = URL.createObjectURL(srcImage);\n                    self.blob = srcImage;\n                    srcImage = img;\n                })();\n            }\n            if (!srcImage.naturalWidth && !srcImage.naturalHeight) {\n                srcImage.onload = function() {\n                    var listeners = self.imageLoadListeners;\n                    if (listeners) {\n                        self.imageLoadListeners = null;\n                        setTimeout(function() {\n                            for (var i = 0, len = listeners.length; i < len; i++) {\n                                listeners[i]();\n                            }\n                        }, 0);\n                    }\n                };\n                srcImage.onerror = errorCallback;\n                this.imageLoadListeners = [];\n            }\n            this.srcImage = srcImage;\n        }\n        MegaPixImage.prototype.render = function(target, options) {\n            options = options || {};\n            var self = this, imgWidth = this.srcImage.naturalWidth, imgHeight = this.srcImage.naturalHeight, width = options.width, height = options.height, maxWidth = options.maxWidth, maxHeight = options.maxHeight, doSquash = !this.blob || this.blob.type === \"image/jpeg\", tagName = target.tagName.toLowerCase(), opt;\n            if (this.imageLoadListeners) {\n                this.imageLoadListeners.push(function() {\n                    self.render(target, options);\n                });\n                return;\n            }\n            if (width && !height) {\n                height = imgHeight * width / imgWidth << 0;\n            } else if (height && !width) {\n                width = imgWidth * height / imgHeight << 0;\n            } else {\n                width = imgWidth;\n                height = imgHeight;\n            }\n            if (maxWidth && width > maxWidth) {\n                width = maxWidth;\n                height = imgHeight * width / imgWidth << 0;\n            }\n            if (maxHeight && height > maxHeight) {\n                height = maxHeight;\n                width = imgWidth * height / imgHeight << 0;\n            }\n            opt = {\n                width: width,\n                height: height\n            }, qq.each(options, function(optionsKey, optionsValue) {\n                opt[optionsKey] = optionsValue;\n            });\n            if (tagName === \"img\") {\n                (function() {\n                    var oldTargetSrc = target.src;\n                    renderImageToDataURL(self.srcImage, self.blob, opt, doSquash).then(function(dataUri) {\n                        target.src = dataUri;\n                        oldTargetSrc === target.src && target.onload();\n                    });\n                })();\n            } else if (tagName === \"canvas\") {\n                renderImageToCanvas(this.srcImage, this.blob, target, opt, doSquash);\n            }\n            if (typeof this.onrender === \"function\") {\n                this.onrender(target);\n            }\n        };\n        qq.MegaPixImage = MegaPixImage;\n    })();\n    qq.ImageGenerator = function(log) {\n        \"use strict\";\n        function isImg(el) {\n            return el.tagName.toLowerCase() === \"img\";\n        }\n        function isCanvas(el) {\n            return el.tagName.toLowerCase() === \"canvas\";\n        }\n        function isImgCorsSupported() {\n            return new Image().crossOrigin !== undefined;\n        }\n        function isCanvasSupported() {\n            var canvas = document.createElement(\"canvas\");\n            return canvas.getContext && canvas.getContext(\"2d\");\n        }\n        function determineMimeOfFileName(nameWithPath) {\n            var pathSegments = nameWithPath.split(\"/\"), name = pathSegments[pathSegments.length - 1].split(\"?\")[0], extension = qq.getExtension(name);\n            extension = extension && extension.toLowerCase();\n            switch (extension) {\n              case \"jpeg\":\n              case \"jpg\":\n                return \"image/jpeg\";\n\n              case \"png\":\n                return \"image/png\";\n\n              case \"bmp\":\n                return \"image/bmp\";\n\n              case \"gif\":\n                return \"image/gif\";\n\n              case \"tiff\":\n              case \"tif\":\n                return \"image/tiff\";\n            }\n        }\n        function isCrossOrigin(url) {\n            var targetAnchor = document.createElement(\"a\"), targetProtocol, targetHostname, targetPort;\n            targetAnchor.href = url;\n            targetProtocol = targetAnchor.protocol;\n            targetPort = targetAnchor.port;\n            targetHostname = targetAnchor.hostname;\n            if (targetProtocol.toLowerCase() !== window.location.protocol.toLowerCase()) {\n                return true;\n            }\n            if (targetHostname.toLowerCase() !== window.location.hostname.toLowerCase()) {\n                return true;\n            }\n            if (targetPort !== window.location.port && !qq.ie()) {\n                return true;\n            }\n            return false;\n        }\n        function registerImgLoadListeners(img, promise) {\n            img.onload = function() {\n                img.onload = null;\n                img.onerror = null;\n                promise.success(img);\n            };\n            img.onerror = function() {\n                img.onload = null;\n                img.onerror = null;\n                log(\"Problem drawing thumbnail!\", \"error\");\n                promise.failure(img, \"Problem drawing thumbnail!\");\n            };\n        }\n        function registerCanvasDrawImageListener(canvas, promise) {\n            canvas.qqImageRendered = function() {\n                promise.success(canvas);\n            };\n        }\n        function registerThumbnailRenderedListener(imgOrCanvas, promise) {\n            var registered = isImg(imgOrCanvas) || isCanvas(imgOrCanvas);\n            if (isImg(imgOrCanvas)) {\n                registerImgLoadListeners(imgOrCanvas, promise);\n            } else if (isCanvas(imgOrCanvas)) {\n                registerCanvasDrawImageListener(imgOrCanvas, promise);\n            } else {\n                promise.failure(imgOrCanvas);\n                log(qq.format(\"Element container of type {} is not supported!\", imgOrCanvas.tagName), \"error\");\n            }\n            return registered;\n        }\n        function draw(fileOrBlob, container, options) {\n            var drawPreview = new qq.Promise(), identifier = new qq.Identify(fileOrBlob, log), maxSize = options.maxSize, orient = options.orient == null ? true : options.orient, megapixErrorHandler = function() {\n                container.onerror = null;\n                container.onload = null;\n                log(\"Could not render preview, file may be too large!\", \"error\");\n                drawPreview.failure(container, \"Browser cannot render image!\");\n            };\n            identifier.isPreviewable().then(function(mime) {\n                var dummyExif = {\n                    parse: function() {\n                        return new qq.Promise().success();\n                    }\n                }, exif = orient ? new qq.Exif(fileOrBlob, log) : dummyExif, mpImg = new qq.MegaPixImage(fileOrBlob, megapixErrorHandler);\n                if (registerThumbnailRenderedListener(container, drawPreview)) {\n                    exif.parse().then(function(exif) {\n                        var orientation = exif && exif.Orientation;\n                        mpImg.render(container, {\n                            maxWidth: maxSize,\n                            maxHeight: maxSize,\n                            orientation: orientation,\n                            mime: mime,\n                            resize: options.customResizeFunction\n                        });\n                    }, function(failureMsg) {\n                        log(qq.format(\"EXIF data could not be parsed ({}).  Assuming orientation = 1.\", failureMsg));\n                        mpImg.render(container, {\n                            maxWidth: maxSize,\n                            maxHeight: maxSize,\n                            mime: mime,\n                            resize: options.customResizeFunction\n                        });\n                    });\n                }\n            }, function() {\n                log(\"Not previewable\");\n                drawPreview.failure(container, \"Not previewable\");\n            });\n            return drawPreview;\n        }\n        function drawOnCanvasOrImgFromUrl(url, canvasOrImg, draw, maxSize, customResizeFunction) {\n            var tempImg = new Image(), tempImgRender = new qq.Promise();\n            registerThumbnailRenderedListener(tempImg, tempImgRender);\n            if (isCrossOrigin(url)) {\n                tempImg.crossOrigin = \"anonymous\";\n            }\n            tempImg.src = url;\n            tempImgRender.then(function rendered() {\n                registerThumbnailRenderedListener(canvasOrImg, draw);\n                var mpImg = new qq.MegaPixImage(tempImg);\n                mpImg.render(canvasOrImg, {\n                    maxWidth: maxSize,\n                    maxHeight: maxSize,\n                    mime: determineMimeOfFileName(url),\n                    resize: customResizeFunction\n                });\n            }, draw.failure);\n        }\n        function drawOnImgFromUrlWithCssScaling(url, img, draw, maxSize) {\n            registerThumbnailRenderedListener(img, draw);\n            qq(img).css({\n                maxWidth: maxSize + \"px\",\n                maxHeight: maxSize + \"px\"\n            });\n            img.src = url;\n        }\n        function drawFromUrl(url, container, options) {\n            var draw = new qq.Promise(), scale = options.scale, maxSize = scale ? options.maxSize : null;\n            if (scale && isImg(container)) {\n                if (isCanvasSupported()) {\n                    if (isCrossOrigin(url) && !isImgCorsSupported()) {\n                        drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n                    } else {\n                        drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n                    }\n                } else {\n                    drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n                }\n            } else if (isCanvas(container)) {\n                drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n            } else if (registerThumbnailRenderedListener(container, draw)) {\n                container.src = url;\n            }\n            return draw;\n        }\n        qq.extend(this, {\n            generate: function(fileBlobOrUrl, container, options) {\n                if (qq.isString(fileBlobOrUrl)) {\n                    log(\"Attempting to update thumbnail based on server response.\");\n                    return drawFromUrl(fileBlobOrUrl, container, options || {});\n                } else {\n                    log(\"Attempting to draw client-side image preview.\");\n                    return draw(fileBlobOrUrl, container, options || {});\n                }\n            }\n        });\n        this._testing = {};\n        this._testing.isImg = isImg;\n        this._testing.isCanvas = isCanvas;\n        this._testing.isCrossOrigin = isCrossOrigin;\n        this._testing.determineMimeOfFileName = determineMimeOfFileName;\n    };\n    qq.Exif = function(fileOrBlob, log) {\n        \"use strict\";\n        var TAG_IDS = [ 274 ], TAG_INFO = {\n            274: {\n                name: \"Orientation\",\n                bytes: 2\n            }\n        };\n        function parseLittleEndian(hex) {\n            var result = 0, pow = 0;\n            while (hex.length > 0) {\n                result += parseInt(hex.substring(0, 2), 16) * Math.pow(2, pow);\n                hex = hex.substring(2, hex.length);\n                pow += 8;\n            }\n            return result;\n        }\n        function seekToApp1(offset, promise) {\n            var theOffset = offset, thePromise = promise;\n            if (theOffset === undefined) {\n                theOffset = 2;\n                thePromise = new qq.Promise();\n            }\n            qq.readBlobToHex(fileOrBlob, theOffset, 4).then(function(hex) {\n                var match = /^ffe([0-9])/.exec(hex), segmentLength;\n                if (match) {\n                    if (match[1] !== \"1\") {\n                        segmentLength = parseInt(hex.slice(4, 8), 16);\n                        seekToApp1(theOffset + segmentLength + 2, thePromise);\n                    } else {\n                        thePromise.success(theOffset);\n                    }\n                } else {\n                    thePromise.failure(\"No EXIF header to be found!\");\n                }\n            });\n            return thePromise;\n        }\n        function getApp1Offset() {\n            var promise = new qq.Promise();\n            qq.readBlobToHex(fileOrBlob, 0, 6).then(function(hex) {\n                if (hex.indexOf(\"ffd8\") !== 0) {\n                    promise.failure(\"Not a valid JPEG!\");\n                } else {\n                    seekToApp1().then(function(offset) {\n                        promise.success(offset);\n                    }, function(error) {\n                        promise.failure(error);\n                    });\n                }\n            });\n            return promise;\n        }\n        function isLittleEndian(app1Start) {\n            var promise = new qq.Promise();\n            qq.readBlobToHex(fileOrBlob, app1Start + 10, 2).then(function(hex) {\n                promise.success(hex === \"4949\");\n            });\n            return promise;\n        }\n        function getDirEntryCount(app1Start, littleEndian) {\n            var promise = new qq.Promise();\n            qq.readBlobToHex(fileOrBlob, app1Start + 18, 2).then(function(hex) {\n                if (littleEndian) {\n                    return promise.success(parseLittleEndian(hex));\n                } else {\n                    promise.success(parseInt(hex, 16));\n                }\n            });\n            return promise;\n        }\n        function getIfd(app1Start, dirEntries) {\n            var offset = app1Start + 20, bytes = dirEntries * 12;\n            return qq.readBlobToHex(fileOrBlob, offset, bytes);\n        }\n        function getDirEntries(ifdHex) {\n            var entries = [], offset = 0;\n            while (offset + 24 <= ifdHex.length) {\n                entries.push(ifdHex.slice(offset, offset + 24));\n                offset += 24;\n            }\n            return entries;\n        }\n        function getTagValues(littleEndian, dirEntries) {\n            var TAG_VAL_OFFSET = 16, tagsToFind = qq.extend([], TAG_IDS), vals = {};\n            qq.each(dirEntries, function(idx, entry) {\n                var idHex = entry.slice(0, 4), id = littleEndian ? parseLittleEndian(idHex) : parseInt(idHex, 16), tagsToFindIdx = tagsToFind.indexOf(id), tagValHex, tagName, tagValLength;\n                if (tagsToFindIdx >= 0) {\n                    tagName = TAG_INFO[id].name;\n                    tagValLength = TAG_INFO[id].bytes;\n                    tagValHex = entry.slice(TAG_VAL_OFFSET, TAG_VAL_OFFSET + tagValLength * 2);\n                    vals[tagName] = littleEndian ? parseLittleEndian(tagValHex) : parseInt(tagValHex, 16);\n                    tagsToFind.splice(tagsToFindIdx, 1);\n                }\n                if (tagsToFind.length === 0) {\n                    return false;\n                }\n            });\n            return vals;\n        }\n        qq.extend(this, {\n            parse: function() {\n                var parser = new qq.Promise(), onParseFailure = function(message) {\n                    log(qq.format(\"EXIF header parse failed: '{}' \", message));\n                    parser.failure(message);\n                };\n                getApp1Offset().then(function(app1Offset) {\n                    log(qq.format(\"Moving forward with EXIF header parsing for '{}'\", fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name));\n                    isLittleEndian(app1Offset).then(function(littleEndian) {\n                        log(qq.format(\"EXIF Byte order is {} endian\", littleEndian ? \"little\" : \"big\"));\n                        getDirEntryCount(app1Offset, littleEndian).then(function(dirEntryCount) {\n                            log(qq.format(\"Found {} APP1 directory entries\", dirEntryCount));\n                            getIfd(app1Offset, dirEntryCount).then(function(ifdHex) {\n                                var dirEntries = getDirEntries(ifdHex), tagValues = getTagValues(littleEndian, dirEntries);\n                                log(\"Successfully parsed some EXIF tags\");\n                                parser.success(tagValues);\n                            }, onParseFailure);\n                        }, onParseFailure);\n                    }, onParseFailure);\n                }, onParseFailure);\n                return parser;\n            }\n        });\n        this._testing = {};\n        this._testing.parseLittleEndian = parseLittleEndian;\n    };\n    qq.Identify = function(fileOrBlob, log) {\n        \"use strict\";\n        function isIdentifiable(magicBytes, questionableBytes) {\n            var identifiable = false, magicBytesEntries = [].concat(magicBytes);\n            qq.each(magicBytesEntries, function(idx, magicBytesArrayEntry) {\n                if (questionableBytes.indexOf(magicBytesArrayEntry) === 0) {\n                    identifiable = true;\n                    return false;\n                }\n            });\n            return identifiable;\n        }\n        qq.extend(this, {\n            isPreviewable: function() {\n                var self = this, identifier = new qq.Promise(), previewable = false, name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n                log(qq.format(\"Attempting to determine if {} can be rendered in this browser\", name));\n                log(\"First pass: check type attribute of blob object.\");\n                if (this.isPreviewableSync()) {\n                    log(\"Second pass: check for magic bytes in file header.\");\n                    qq.readBlobToHex(fileOrBlob, 0, 4).then(function(hex) {\n                        qq.each(self.PREVIEWABLE_MIME_TYPES, function(mime, bytes) {\n                            if (isIdentifiable(bytes, hex)) {\n                                if (mime !== \"image/tiff\" || qq.supportedFeatures.tiffPreviews) {\n                                    previewable = true;\n                                    identifier.success(mime);\n                                }\n                                return false;\n                            }\n                        });\n                        log(qq.format(\"'{}' is {} able to be rendered in this browser\", name, previewable ? \"\" : \"NOT\"));\n                        if (!previewable) {\n                            identifier.failure();\n                        }\n                    }, function() {\n                        log(\"Error reading file w/ name '\" + name + \"'.  Not able to be rendered in this browser.\");\n                        identifier.failure();\n                    });\n                } else {\n                    identifier.failure();\n                }\n                return identifier;\n            },\n            isPreviewableSync: function() {\n                var fileMime = fileOrBlob.type, isRecognizedImage = qq.indexOf(Object.keys(this.PREVIEWABLE_MIME_TYPES), fileMime) >= 0, previewable = false, name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n                if (isRecognizedImage) {\n                    if (fileMime === \"image/tiff\") {\n                        previewable = qq.supportedFeatures.tiffPreviews;\n                    } else {\n                        previewable = true;\n                    }\n                }\n                !previewable && log(name + \" is not previewable in this browser per the blob's type attr\");\n                return previewable;\n            }\n        });\n    };\n    qq.Identify.prototype.PREVIEWABLE_MIME_TYPES = {\n        \"image/jpeg\": \"ffd8ff\",\n        \"image/gif\": \"474946\",\n        \"image/png\": \"89504e\",\n        \"image/bmp\": \"424d\",\n        \"image/tiff\": [ \"49492a00\", \"4d4d002a\" ]\n    };\n    qq.ImageValidation = function(blob, log) {\n        \"use strict\";\n        function hasNonZeroLimits(limits) {\n            var atLeastOne = false;\n            qq.each(limits, function(limit, value) {\n                if (value > 0) {\n                    atLeastOne = true;\n                    return false;\n                }\n            });\n            return atLeastOne;\n        }\n        function getWidthHeight() {\n            var sizeDetermination = new qq.Promise();\n            new qq.Identify(blob, log).isPreviewable().then(function() {\n                var image = new Image(), url = window.URL && window.URL.createObjectURL ? window.URL : window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;\n                if (url) {\n                    image.onerror = function() {\n                        log(\"Cannot determine dimensions for image.  May be too large.\", \"error\");\n                        sizeDetermination.failure();\n                    };\n                    image.onload = function() {\n                        sizeDetermination.success({\n                            width: this.width,\n                            height: this.height\n                        });\n                    };\n                    image.src = url.createObjectURL(blob);\n                } else {\n                    log(\"No createObjectURL function available to generate image URL!\", \"error\");\n                    sizeDetermination.failure();\n                }\n            }, sizeDetermination.failure);\n            return sizeDetermination;\n        }\n        function getFailingLimit(limits, dimensions) {\n            var failingLimit;\n            qq.each(limits, function(limitName, limitValue) {\n                if (limitValue > 0) {\n                    var limitMatcher = /(max|min)(Width|Height)/.exec(limitName), dimensionPropName = limitMatcher[2].charAt(0).toLowerCase() + limitMatcher[2].slice(1), actualValue = dimensions[dimensionPropName];\n                    switch (limitMatcher[1]) {\n                      case \"min\":\n                        if (actualValue < limitValue) {\n                            failingLimit = limitName;\n                            return false;\n                        }\n                        break;\n\n                      case \"max\":\n                        if (actualValue > limitValue) {\n                            failingLimit = limitName;\n                            return false;\n                        }\n                        break;\n                    }\n                }\n            });\n            return failingLimit;\n        }\n        this.validate = function(limits) {\n            var validationEffort = new qq.Promise();\n            log(\"Attempting to validate image.\");\n            if (hasNonZeroLimits(limits)) {\n                getWidthHeight().then(function(dimensions) {\n                    var failingLimit = getFailingLimit(limits, dimensions);\n                    if (failingLimit) {\n                        validationEffort.failure(failingLimit);\n                    } else {\n                        validationEffort.success();\n                    }\n                }, validationEffort.success);\n            } else {\n                validationEffort.success();\n            }\n            return validationEffort;\n        };\n    };\n    qq.Session = function(spec) {\n        \"use strict\";\n        var options = {\n            endpoint: null,\n            params: {},\n            customHeaders: {},\n            cors: {},\n            addFileRecord: function(sessionData) {},\n            log: function(message, level) {}\n        };\n        qq.extend(options, spec, true);\n        function isJsonResponseValid(response) {\n            if (qq.isArray(response)) {\n                return true;\n            }\n            options.log(\"Session response is not an array.\", \"error\");\n        }\n        function handleFileItems(fileItems, success, xhrOrXdr, promise) {\n            var someItemsIgnored = false;\n            success = success && isJsonResponseValid(fileItems);\n            if (success) {\n                qq.each(fileItems, function(idx, fileItem) {\n                    if (fileItem.uuid == null) {\n                        someItemsIgnored = true;\n                        options.log(qq.format(\"Session response item {} did not include a valid UUID - ignoring.\", idx), \"error\");\n                    } else if (fileItem.name == null) {\n                        someItemsIgnored = true;\n                        options.log(qq.format(\"Session response item {} did not include a valid name - ignoring.\", idx), \"error\");\n                    } else {\n                        try {\n                            options.addFileRecord(fileItem);\n                            return true;\n                        } catch (err) {\n                            someItemsIgnored = true;\n                            options.log(err.message, \"error\");\n                        }\n                    }\n                    return false;\n                });\n            }\n            promise[success && !someItemsIgnored ? \"success\" : \"failure\"](fileItems, xhrOrXdr);\n        }\n        this.refresh = function() {\n            var refreshEffort = new qq.Promise(), refreshCompleteCallback = function(response, success, xhrOrXdr) {\n                handleFileItems(response, success, xhrOrXdr, refreshEffort);\n            }, requesterOptions = qq.extend({}, options), requester = new qq.SessionAjaxRequester(qq.extend(requesterOptions, {\n                onComplete: refreshCompleteCallback\n            }));\n            requester.queryServer();\n            return refreshEffort;\n        };\n    };\n    qq.SessionAjaxRequester = function(spec) {\n        \"use strict\";\n        var requester, options = {\n            endpoint: null,\n            customHeaders: {},\n            params: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            onComplete: function(response, success, xhrOrXdr) {},\n            log: function(str, level) {}\n        };\n        qq.extend(options, spec);\n        function onComplete(id, xhrOrXdr, isError) {\n            var response = null;\n            if (xhrOrXdr.responseText != null) {\n                try {\n                    response = qq.parseJson(xhrOrXdr.responseText);\n                } catch (err) {\n                    options.log(\"Problem parsing session response: \" + err.message, \"error\");\n                    isError = true;\n                }\n            }\n            options.onComplete(response, !isError, xhrOrXdr);\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            validMethods: [ \"GET\" ],\n            method: \"GET\",\n            endpointStore: {\n                get: function() {\n                    return options.endpoint;\n                }\n            },\n            customHeaders: options.customHeaders,\n            log: options.log,\n            onComplete: onComplete,\n            cors: options.cors\n        }));\n        qq.extend(this, {\n            queryServer: function() {\n                var params = qq.extend({}, options.params);\n                options.log(\"Session query request.\");\n                requester.initTransport(\"sessionRefresh\").withParams(params).withCacheBuster().send();\n            }\n        });\n    };\n    qq.Scaler = function(spec, log) {\n        \"use strict\";\n        var self = this, customResizeFunction = spec.customResizer, includeOriginal = spec.sendOriginal, orient = spec.orient, defaultType = spec.defaultType, defaultQuality = spec.defaultQuality / 100, failedToScaleText = spec.failureText, includeExif = spec.includeExif, sizes = this._getSortedSizes(spec.sizes);\n        qq.extend(this, {\n            enabled: qq.supportedFeatures.scaling && sizes.length > 0,\n            getFileRecords: function(originalFileUuid, originalFileName, originalBlobOrBlobData) {\n                var self = this, records = [], originalBlob = originalBlobOrBlobData.blob ? originalBlobOrBlobData.blob : originalBlobOrBlobData, identifier = new qq.Identify(originalBlob, log);\n                if (identifier.isPreviewableSync()) {\n                    qq.each(sizes, function(idx, sizeRecord) {\n                        var outputType = self._determineOutputType({\n                            defaultType: defaultType,\n                            requestedType: sizeRecord.type,\n                            refType: originalBlob.type\n                        });\n                        records.push({\n                            uuid: qq.getUniqueId(),\n                            name: self._getName(originalFileName, {\n                                name: sizeRecord.name,\n                                type: outputType,\n                                refType: originalBlob.type\n                            }),\n                            blob: new qq.BlobProxy(originalBlob, qq.bind(self._generateScaledImage, self, {\n                                customResizeFunction: customResizeFunction,\n                                maxSize: sizeRecord.maxSize,\n                                orient: orient,\n                                type: outputType,\n                                quality: defaultQuality,\n                                failedText: failedToScaleText,\n                                includeExif: includeExif,\n                                log: log\n                            }))\n                        });\n                    });\n                    records.push({\n                        uuid: originalFileUuid,\n                        name: originalFileName,\n                        size: originalBlob.size,\n                        blob: includeOriginal ? originalBlob : null\n                    });\n                } else {\n                    records.push({\n                        uuid: originalFileUuid,\n                        name: originalFileName,\n                        size: originalBlob.size,\n                        blob: originalBlob\n                    });\n                }\n                return records;\n            },\n            handleNewFile: function(file, name, uuid, size, fileList, batchId, uuidParamName, api) {\n                var self = this, buttonId = file.qqButtonId || file.blob && file.blob.qqButtonId, scaledIds = [], originalId = null, addFileToHandler = api.addFileToHandler, uploadData = api.uploadData, paramsStore = api.paramsStore, proxyGroupId = qq.getUniqueId();\n                qq.each(self.getFileRecords(uuid, name, file), function(idx, record) {\n                    var blobSize = record.size, id;\n                    if (record.blob instanceof qq.BlobProxy) {\n                        blobSize = -1;\n                    }\n                    id = uploadData.addFile({\n                        uuid: record.uuid,\n                        name: record.name,\n                        size: blobSize,\n                        batchId: batchId,\n                        proxyGroupId: proxyGroupId\n                    });\n                    if (record.blob instanceof qq.BlobProxy) {\n                        scaledIds.push(id);\n                    } else {\n                        originalId = id;\n                    }\n                    if (record.blob) {\n                        addFileToHandler(id, record.blob);\n                        fileList.push({\n                            id: id,\n                            file: record.blob\n                        });\n                    } else {\n                        uploadData.setStatus(id, qq.status.REJECTED);\n                    }\n                });\n                if (originalId !== null) {\n                    qq.each(scaledIds, function(idx, scaledId) {\n                        var params = {\n                            qqparentuuid: uploadData.retrieve({\n                                id: originalId\n                            }).uuid,\n                            qqparentsize: uploadData.retrieve({\n                                id: originalId\n                            }).size\n                        };\n                        params[uuidParamName] = uploadData.retrieve({\n                            id: scaledId\n                        }).uuid;\n                        uploadData.setParentId(scaledId, originalId);\n                        paramsStore.addReadOnly(scaledId, params);\n                    });\n                    if (scaledIds.length) {\n                        (function() {\n                            var param = {};\n                            param[uuidParamName] = uploadData.retrieve({\n                                id: originalId\n                            }).uuid;\n                            paramsStore.addReadOnly(originalId, param);\n                        })();\n                    }\n                }\n            }\n        });\n    };\n    qq.extend(qq.Scaler.prototype, {\n        scaleImage: function(id, specs, api) {\n            \"use strict\";\n            if (!qq.supportedFeatures.scaling) {\n                throw new qq.Error(\"Scaling is not supported in this browser!\");\n            }\n            var scalingEffort = new qq.Promise(), log = api.log, file = api.getFile(id), uploadData = api.uploadData.retrieve({\n                id: id\n            }), name = uploadData && uploadData.name, uuid = uploadData && uploadData.uuid, scalingOptions = {\n                customResizer: specs.customResizer,\n                sendOriginal: false,\n                orient: specs.orient,\n                defaultType: specs.type || null,\n                defaultQuality: specs.quality,\n                failedToScaleText: \"Unable to scale\",\n                sizes: [ {\n                    name: \"\",\n                    maxSize: specs.maxSize\n                } ]\n            }, scaler = new qq.Scaler(scalingOptions, log);\n            if (!qq.Scaler || !qq.supportedFeatures.imagePreviews || !file) {\n                scalingEffort.failure();\n                log(\"Could not generate requested scaled image for \" + id + \".  \" + \"Scaling is either not possible in this browser, or the file could not be located.\", \"error\");\n            } else {\n                qq.bind(function() {\n                    var record = scaler.getFileRecords(uuid, name, file)[0];\n                    if (record && record.blob instanceof qq.BlobProxy) {\n                        record.blob.create().then(scalingEffort.success, scalingEffort.failure);\n                    } else {\n                        log(id + \" is not a scalable image!\", \"error\");\n                        scalingEffort.failure();\n                    }\n                }, this)();\n            }\n            return scalingEffort;\n        },\n        _determineOutputType: function(spec) {\n            \"use strict\";\n            var requestedType = spec.requestedType, defaultType = spec.defaultType, referenceType = spec.refType;\n            if (!defaultType && !requestedType) {\n                if (referenceType !== \"image/jpeg\") {\n                    return \"image/png\";\n                }\n                return referenceType;\n            }\n            if (!requestedType) {\n                return defaultType;\n            }\n            if (qq.indexOf(Object.keys(qq.Identify.prototype.PREVIEWABLE_MIME_TYPES), requestedType) >= 0) {\n                if (requestedType === \"image/tiff\") {\n                    return qq.supportedFeatures.tiffPreviews ? requestedType : defaultType;\n                }\n                return requestedType;\n            }\n            return defaultType;\n        },\n        _getName: function(originalName, scaledVersionProperties) {\n            \"use strict\";\n            var startOfExt = originalName.lastIndexOf(\".\"), versionType = scaledVersionProperties.type || \"image/png\", referenceType = scaledVersionProperties.refType, scaledName = \"\", scaledExt = qq.getExtension(originalName), nameAppendage = \"\";\n            if (scaledVersionProperties.name && scaledVersionProperties.name.trim().length) {\n                nameAppendage = \" (\" + scaledVersionProperties.name + \")\";\n            }\n            if (startOfExt >= 0) {\n                scaledName = originalName.substr(0, startOfExt);\n                if (referenceType !== versionType) {\n                    scaledExt = versionType.split(\"/\")[1];\n                }\n                scaledName += nameAppendage + \".\" + scaledExt;\n            } else {\n                scaledName = originalName + nameAppendage;\n            }\n            return scaledName;\n        },\n        _getSortedSizes: function(sizes) {\n            \"use strict\";\n            sizes = qq.extend([], sizes);\n            return sizes.sort(function(a, b) {\n                if (a.maxSize > b.maxSize) {\n                    return 1;\n                }\n                if (a.maxSize < b.maxSize) {\n                    return -1;\n                }\n                return 0;\n            });\n        },\n        _generateScaledImage: function(spec, sourceFile) {\n            \"use strict\";\n            var self = this, customResizeFunction = spec.customResizeFunction, log = spec.log, maxSize = spec.maxSize, orient = spec.orient, type = spec.type, quality = spec.quality, failedText = spec.failedText, includeExif = spec.includeExif && sourceFile.type === \"image/jpeg\" && type === \"image/jpeg\", scalingEffort = new qq.Promise(), imageGenerator = new qq.ImageGenerator(log), canvas = document.createElement(\"canvas\");\n            log(\"Attempting to generate scaled version for \" + sourceFile.name);\n            imageGenerator.generate(sourceFile, canvas, {\n                maxSize: maxSize,\n                orient: orient,\n                customResizeFunction: customResizeFunction\n            }).then(function() {\n                var scaledImageDataUri = canvas.toDataURL(type, quality), signalSuccess = function() {\n                    log(\"Success generating scaled version for \" + sourceFile.name);\n                    var blob = qq.dataUriToBlob(scaledImageDataUri);\n                    scalingEffort.success(blob);\n                };\n                if (includeExif) {\n                    self._insertExifHeader(sourceFile, scaledImageDataUri, log).then(function(scaledImageDataUriWithExif) {\n                        scaledImageDataUri = scaledImageDataUriWithExif;\n                        signalSuccess();\n                    }, function() {\n                        log(\"Problem inserting EXIF header into scaled image.  Using scaled image w/out EXIF data.\", \"error\");\n                        signalSuccess();\n                    });\n                } else {\n                    signalSuccess();\n                }\n            }, function() {\n                log(\"Failed attempt to generate scaled version for \" + sourceFile.name, \"error\");\n                scalingEffort.failure(failedText);\n            });\n            return scalingEffort;\n        },\n        _insertExifHeader: function(originalImage, scaledImageDataUri, log) {\n            \"use strict\";\n            var reader = new FileReader(), insertionEffort = new qq.Promise(), originalImageDataUri = \"\";\n            reader.onload = function() {\n                originalImageDataUri = reader.result;\n                insertionEffort.success(qq.ExifRestorer.restore(originalImageDataUri, scaledImageDataUri));\n            };\n            reader.onerror = function() {\n                log(\"Problem reading \" + originalImage.name + \" during attempt to transfer EXIF data to scaled version.\", \"error\");\n                insertionEffort.failure();\n            };\n            reader.readAsDataURL(originalImage);\n            return insertionEffort;\n        },\n        _dataUriToBlob: function(dataUri) {\n            \"use strict\";\n            var byteString, mimeString, arrayBuffer, intArray;\n            if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n                byteString = atob(dataUri.split(\",\")[1]);\n            } else {\n                byteString = decodeURI(dataUri.split(\",\")[1]);\n            }\n            mimeString = dataUri.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n            arrayBuffer = new ArrayBuffer(byteString.length);\n            intArray = new Uint8Array(arrayBuffer);\n            qq.each(byteString, function(idx, character) {\n                intArray[idx] = character.charCodeAt(0);\n            });\n            return this._createBlob(arrayBuffer, mimeString);\n        },\n        _createBlob: function(data, mime) {\n            \"use strict\";\n            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, blobBuilder = BlobBuilder && new BlobBuilder();\n            if (blobBuilder) {\n                blobBuilder.append(data);\n                return blobBuilder.getBlob(mime);\n            } else {\n                return new Blob([ data ], {\n                    type: mime\n                });\n            }\n        }\n    });\n    qq.ExifRestorer = function() {\n        var ExifRestorer = {};\n        ExifRestorer.KEY_STR = \"ABCDEFGHIJKLMNOP\" + \"QRSTUVWXYZabcdef\" + \"ghijklmnopqrstuv\" + \"wxyz0123456789+/\" + \"=\";\n        ExifRestorer.encode64 = function(input) {\n            var output = \"\", chr1, chr2, chr3 = \"\", enc1, enc2, enc3, enc4 = \"\", i = 0;\n            do {\n                chr1 = input[i++];\n                chr2 = input[i++];\n                chr3 = input[i++];\n                enc1 = chr1 >> 2;\n                enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n                enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n                enc4 = chr3 & 63;\n                if (isNaN(chr2)) {\n                    enc3 = enc4 = 64;\n                } else if (isNaN(chr3)) {\n                    enc4 = 64;\n                }\n                output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);\n                chr1 = chr2 = chr3 = \"\";\n                enc1 = enc2 = enc3 = enc4 = \"\";\n            } while (i < input.length);\n            return output;\n        };\n        ExifRestorer.restore = function(origFileBase64, resizedFileBase64) {\n            var expectedBase64Header = \"data:image/jpeg;base64,\";\n            if (!origFileBase64.match(expectedBase64Header)) {\n                return resizedFileBase64;\n            }\n            var rawImage = this.decode64(origFileBase64.replace(expectedBase64Header, \"\"));\n            var segments = this.slice2Segments(rawImage);\n            var image = this.exifManipulation(resizedFileBase64, segments);\n            return expectedBase64Header + this.encode64(image);\n        };\n        ExifRestorer.exifManipulation = function(resizedFileBase64, segments) {\n            var exifArray = this.getExifArray(segments), newImageArray = this.insertExif(resizedFileBase64, exifArray), aBuffer = new Uint8Array(newImageArray);\n            return aBuffer;\n        };\n        ExifRestorer.getExifArray = function(segments) {\n            var seg;\n            for (var x = 0; x < segments.length; x++) {\n                seg = segments[x];\n                if (seg[0] == 255 & seg[1] == 225) {\n                    return seg;\n                }\n            }\n            return [];\n        };\n        ExifRestorer.insertExif = function(resizedFileBase64, exifArray) {\n            var imageData = resizedFileBase64.replace(\"data:image/jpeg;base64,\", \"\"), buf = this.decode64(imageData), separatePoint = buf.indexOf(255, 3), mae = buf.slice(0, separatePoint), ato = buf.slice(separatePoint), array = mae;\n            array = array.concat(exifArray);\n            array = array.concat(ato);\n            return array;\n        };\n        ExifRestorer.slice2Segments = function(rawImageArray) {\n            var head = 0, segments = [];\n            while (1) {\n                if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 218) {\n                    break;\n                }\n                if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 216) {\n                    head += 2;\n                } else {\n                    var length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3], endPoint = head + length + 2, seg = rawImageArray.slice(head, endPoint);\n                    segments.push(seg);\n                    head = endPoint;\n                }\n                if (head > rawImageArray.length) {\n                    break;\n                }\n            }\n            return segments;\n        };\n        ExifRestorer.decode64 = function(input) {\n            var output = \"\", chr1, chr2, chr3 = \"\", enc1, enc2, enc3, enc4 = \"\", i = 0, buf = [];\n            var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n            if (base64test.exec(input)) {\n                throw new Error(\"There were invalid base64 characters in the input text.  \" + \"Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\");\n            }\n            input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n            do {\n                enc1 = this.KEY_STR.indexOf(input.charAt(i++));\n                enc2 = this.KEY_STR.indexOf(input.charAt(i++));\n                enc3 = this.KEY_STR.indexOf(input.charAt(i++));\n                enc4 = this.KEY_STR.indexOf(input.charAt(i++));\n                chr1 = enc1 << 2 | enc2 >> 4;\n                chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n                chr3 = (enc3 & 3) << 6 | enc4;\n                buf.push(chr1);\n                if (enc3 != 64) {\n                    buf.push(chr2);\n                }\n                if (enc4 != 64) {\n                    buf.push(chr3);\n                }\n                chr1 = chr2 = chr3 = \"\";\n                enc1 = enc2 = enc3 = enc4 = \"\";\n            } while (i < input.length);\n            return buf;\n        };\n        return ExifRestorer;\n    }();\n    qq.TotalProgress = function(callback, getSize) {\n        \"use strict\";\n        var perFileProgress = {}, totalLoaded = 0, totalSize = 0, lastLoadedSent = -1, lastTotalSent = -1, callbackProxy = function(loaded, total) {\n            if (loaded !== lastLoadedSent || total !== lastTotalSent) {\n                callback(loaded, total);\n            }\n            lastLoadedSent = loaded;\n            lastTotalSent = total;\n        }, noRetryableFiles = function(failed, retryable) {\n            var none = true;\n            qq.each(failed, function(idx, failedId) {\n                if (qq.indexOf(retryable, failedId) >= 0) {\n                    none = false;\n                    return false;\n                }\n            });\n            return none;\n        }, onCancel = function(id) {\n            updateTotalProgress(id, -1, -1);\n            delete perFileProgress[id];\n        }, onAllComplete = function(successful, failed, retryable) {\n            if (failed.length === 0 || noRetryableFiles(failed, retryable)) {\n                callbackProxy(totalSize, totalSize);\n                this.reset();\n            }\n        }, onNew = function(id) {\n            var size = getSize(id);\n            if (size > 0) {\n                updateTotalProgress(id, 0, size);\n                perFileProgress[id] = {\n                    loaded: 0,\n                    total: size\n                };\n            }\n        }, updateTotalProgress = function(id, newLoaded, newTotal) {\n            var oldLoaded = perFileProgress[id] ? perFileProgress[id].loaded : 0, oldTotal = perFileProgress[id] ? perFileProgress[id].total : 0;\n            if (newLoaded === -1 && newTotal === -1) {\n                totalLoaded -= oldLoaded;\n                totalSize -= oldTotal;\n            } else {\n                if (newLoaded) {\n                    totalLoaded += newLoaded - oldLoaded;\n                }\n                if (newTotal) {\n                    totalSize += newTotal - oldTotal;\n                }\n            }\n            callbackProxy(totalLoaded, totalSize);\n        };\n        qq.extend(this, {\n            onAllComplete: onAllComplete,\n            onStatusChange: function(id, oldStatus, newStatus) {\n                if (newStatus === qq.status.CANCELED || newStatus === qq.status.REJECTED) {\n                    onCancel(id);\n                } else if (newStatus === qq.status.SUBMITTING) {\n                    onNew(id);\n                }\n            },\n            onIndividualProgress: function(id, loaded, total) {\n                updateTotalProgress(id, loaded, total);\n                perFileProgress[id] = {\n                    loaded: loaded,\n                    total: total\n                };\n            },\n            onNewSize: function(id) {\n                onNew(id);\n            },\n            reset: function() {\n                perFileProgress = {};\n                totalLoaded = 0;\n                totalSize = 0;\n            }\n        });\n    };\n    qq.PasteSupport = function(o) {\n        \"use strict\";\n        var options, detachPasteHandler;\n        options = {\n            targetElement: null,\n            callbacks: {\n                log: function(message, level) {},\n                pasteReceived: function(blob) {}\n            }\n        };\n        function isImage(item) {\n            return item.type && item.type.indexOf(\"image/\") === 0;\n        }\n        function registerPasteHandler() {\n            detachPasteHandler = qq(options.targetElement).attach(\"paste\", function(event) {\n                var clipboardData = event.clipboardData;\n                if (clipboardData) {\n                    qq.each(clipboardData.items, function(idx, item) {\n                        if (isImage(item)) {\n                            var blob = item.getAsFile();\n                            options.callbacks.pasteReceived(blob);\n                        }\n                    });\n                }\n            });\n        }\n        function unregisterPasteHandler() {\n            if (detachPasteHandler) {\n                detachPasteHandler();\n            }\n        }\n        qq.extend(options, o);\n        registerPasteHandler();\n        qq.extend(this, {\n            reset: function() {\n                unregisterPasteHandler();\n            }\n        });\n    };\n    qq.FormSupport = function(options, startUpload, log) {\n        \"use strict\";\n        var self = this, interceptSubmit = options.interceptSubmit, formEl = options.element, autoUpload = options.autoUpload;\n        qq.extend(this, {\n            newEndpoint: null,\n            newAutoUpload: autoUpload,\n            attachedToForm: false,\n            getFormInputsAsObject: function() {\n                if (formEl == null) {\n                    return null;\n                }\n                return self._form2Obj(formEl);\n            }\n        });\n        function determineNewEndpoint(formEl) {\n            if (formEl.getAttribute(\"action\")) {\n                self.newEndpoint = formEl.getAttribute(\"action\");\n            }\n        }\n        function validateForm(formEl, nativeSubmit) {\n            if (formEl.checkValidity && !formEl.checkValidity()) {\n                log(\"Form did not pass validation checks - will not upload.\", \"error\");\n                nativeSubmit();\n            } else {\n                return true;\n            }\n        }\n        function maybeUploadOnSubmit(formEl) {\n            var nativeSubmit = formEl.submit;\n            qq(formEl).attach(\"submit\", function(event) {\n                event = event || window.event;\n                if (event.preventDefault) {\n                    event.preventDefault();\n                } else {\n                    event.returnValue = false;\n                }\n                validateForm(formEl, nativeSubmit) && startUpload();\n            });\n            formEl.submit = function() {\n                validateForm(formEl, nativeSubmit) && startUpload();\n            };\n        }\n        function determineFormEl(formEl) {\n            if (formEl) {\n                if (qq.isString(formEl)) {\n                    formEl = document.getElementById(formEl);\n                }\n                if (formEl) {\n                    log(\"Attaching to form element.\");\n                    determineNewEndpoint(formEl);\n                    interceptSubmit && maybeUploadOnSubmit(formEl);\n                }\n            }\n            return formEl;\n        }\n        formEl = determineFormEl(formEl);\n        this.attachedToForm = !!formEl;\n    };\n    qq.extend(qq.FormSupport.prototype, {\n        _form2Obj: function(form) {\n            \"use strict\";\n            var obj = {}, notIrrelevantType = function(type) {\n                var irrelevantTypes = [ \"button\", \"image\", \"reset\", \"submit\" ];\n                return qq.indexOf(irrelevantTypes, type.toLowerCase()) < 0;\n            }, radioOrCheckbox = function(type) {\n                return qq.indexOf([ \"checkbox\", \"radio\" ], type.toLowerCase()) >= 0;\n            }, ignoreValue = function(el) {\n                if (radioOrCheckbox(el.type) && !el.checked) {\n                    return true;\n                }\n                return el.disabled && el.type.toLowerCase() !== \"hidden\";\n            }, selectValue = function(select) {\n                var value = null;\n                qq.each(qq(select).children(), function(idx, child) {\n                    if (child.tagName.toLowerCase() === \"option\" && child.selected) {\n                        value = child.value;\n                        return false;\n                    }\n                });\n                return value;\n            };\n            qq.each(form.elements, function(idx, el) {\n                if ((qq.isInput(el, true) || el.tagName.toLowerCase() === \"textarea\") && notIrrelevantType(el.type) && !ignoreValue(el)) {\n                    obj[el.name] = el.value;\n                } else if (el.tagName.toLowerCase() === \"select\" && !ignoreValue(el)) {\n                    var value = selectValue(el);\n                    if (value !== null) {\n                        obj[el.name] = value;\n                    }\n                }\n            });\n            return obj;\n        }\n    });\n    qq.CryptoJS = function(Math, undefined) {\n        var C = {};\n        var C_lib = C.lib = {};\n        var Base = C_lib.Base = function() {\n            function F() {}\n            return {\n                extend: function(overrides) {\n                    F.prototype = this;\n                    var subtype = new F();\n                    if (overrides) {\n                        subtype.mixIn(overrides);\n                    }\n                    if (!subtype.hasOwnProperty(\"init\")) {\n                        subtype.init = function() {\n                            subtype.$super.init.apply(this, arguments);\n                        };\n                    }\n                    subtype.init.prototype = subtype;\n                    subtype.$super = this;\n                    return subtype;\n                },\n                create: function() {\n                    var instance = this.extend();\n                    instance.init.apply(instance, arguments);\n                    return instance;\n                },\n                init: function() {},\n                mixIn: function(properties) {\n                    for (var propertyName in properties) {\n                        if (properties.hasOwnProperty(propertyName)) {\n                            this[propertyName] = properties[propertyName];\n                        }\n                    }\n                    if (properties.hasOwnProperty(\"toString\")) {\n                        this.toString = properties.toString;\n                    }\n                },\n                clone: function() {\n                    return this.init.prototype.extend(this);\n                }\n            };\n        }();\n        var WordArray = C_lib.WordArray = Base.extend({\n            init: function(words, sigBytes) {\n                words = this.words = words || [];\n                if (sigBytes != undefined) {\n                    this.sigBytes = sigBytes;\n                } else {\n                    this.sigBytes = words.length * 4;\n                }\n            },\n            toString: function(encoder) {\n                return (encoder || Hex).stringify(this);\n            },\n            concat: function(wordArray) {\n                var thisWords = this.words;\n                var thatWords = wordArray.words;\n                var thisSigBytes = this.sigBytes;\n                var thatSigBytes = wordArray.sigBytes;\n                this.clamp();\n                if (thisSigBytes % 4) {\n                    for (var i = 0; i < thatSigBytes; i++) {\n                        var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n                        thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;\n                    }\n                } else if (thatWords.length > 65535) {\n                    for (var i = 0; i < thatSigBytes; i += 4) {\n                        thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];\n                    }\n                } else {\n                    thisWords.push.apply(thisWords, thatWords);\n                }\n                this.sigBytes += thatSigBytes;\n                return this;\n            },\n            clamp: function() {\n                var words = this.words;\n                var sigBytes = this.sigBytes;\n                words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;\n                words.length = Math.ceil(sigBytes / 4);\n            },\n            clone: function() {\n                var clone = Base.clone.call(this);\n                clone.words = this.words.slice(0);\n                return clone;\n            },\n            random: function(nBytes) {\n                var words = [];\n                for (var i = 0; i < nBytes; i += 4) {\n                    words.push(Math.random() * 4294967296 | 0);\n                }\n                return new WordArray.init(words, nBytes);\n            }\n        });\n        var C_enc = C.enc = {};\n        var Hex = C_enc.Hex = {\n            stringify: function(wordArray) {\n                var words = wordArray.words;\n                var sigBytes = wordArray.sigBytes;\n                var hexChars = [];\n                for (var i = 0; i < sigBytes; i++) {\n                    var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n                    hexChars.push((bite >>> 4).toString(16));\n                    hexChars.push((bite & 15).toString(16));\n                }\n                return hexChars.join(\"\");\n            },\n            parse: function(hexStr) {\n                var hexStrLength = hexStr.length;\n                var words = [];\n                for (var i = 0; i < hexStrLength; i += 2) {\n                    words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;\n                }\n                return new WordArray.init(words, hexStrLength / 2);\n            }\n        };\n        var Latin1 = C_enc.Latin1 = {\n            stringify: function(wordArray) {\n                var words = wordArray.words;\n                var sigBytes = wordArray.sigBytes;\n                var latin1Chars = [];\n                for (var i = 0; i < sigBytes; i++) {\n                    var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n                    latin1Chars.push(String.fromCharCode(bite));\n                }\n                return latin1Chars.join(\"\");\n            },\n            parse: function(latin1Str) {\n                var latin1StrLength = latin1Str.length;\n                var words = [];\n                for (var i = 0; i < latin1StrLength; i++) {\n                    words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;\n                }\n                return new WordArray.init(words, latin1StrLength);\n            }\n        };\n        var Utf8 = C_enc.Utf8 = {\n            stringify: function(wordArray) {\n                try {\n                    return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n                } catch (e) {\n                    throw new Error(\"Malformed UTF-8 data\");\n                }\n            },\n            parse: function(utf8Str) {\n                return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n            }\n        };\n        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n            reset: function() {\n                this._data = new WordArray.init();\n                this._nDataBytes = 0;\n            },\n            _append: function(data) {\n                if (typeof data == \"string\") {\n                    data = Utf8.parse(data);\n                }\n                this._data.concat(data);\n                this._nDataBytes += data.sigBytes;\n            },\n            _process: function(doFlush) {\n                var data = this._data;\n                var dataWords = data.words;\n                var dataSigBytes = data.sigBytes;\n                var blockSize = this.blockSize;\n                var blockSizeBytes = blockSize * 4;\n                var nBlocksReady = dataSigBytes / blockSizeBytes;\n                if (doFlush) {\n                    nBlocksReady = Math.ceil(nBlocksReady);\n                } else {\n                    nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n                }\n                var nWordsReady = nBlocksReady * blockSize;\n                var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n                if (nWordsReady) {\n                    for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n                        this._doProcessBlock(dataWords, offset);\n                    }\n                    var processedWords = dataWords.splice(0, nWordsReady);\n                    data.sigBytes -= nBytesReady;\n                }\n                return new WordArray.init(processedWords, nBytesReady);\n            },\n            clone: function() {\n                var clone = Base.clone.call(this);\n                clone._data = this._data.clone();\n                return clone;\n            },\n            _minBufferSize: 0\n        });\n        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n            cfg: Base.extend(),\n            init: function(cfg) {\n                this.cfg = this.cfg.extend(cfg);\n                this.reset();\n            },\n            reset: function() {\n                BufferedBlockAlgorithm.reset.call(this);\n                this._doReset();\n            },\n            update: function(messageUpdate) {\n                this._append(messageUpdate);\n                this._process();\n                return this;\n            },\n            finalize: function(messageUpdate) {\n                if (messageUpdate) {\n                    this._append(messageUpdate);\n                }\n                var hash = this._doFinalize();\n                return hash;\n            },\n            blockSize: 512 / 32,\n            _createHelper: function(hasher) {\n                return function(message, cfg) {\n                    return new hasher.init(cfg).finalize(message);\n                };\n            },\n            _createHmacHelper: function(hasher) {\n                return function(message, key) {\n                    return new C_algo.HMAC.init(hasher, key).finalize(message);\n                };\n            }\n        });\n        var C_algo = C.algo = {};\n        return C;\n    }(Math);\n    (function() {\n        var C = qq.CryptoJS;\n        var C_lib = C.lib;\n        var WordArray = C_lib.WordArray;\n        var C_enc = C.enc;\n        var Base64 = C_enc.Base64 = {\n            stringify: function(wordArray) {\n                var words = wordArray.words;\n                var sigBytes = wordArray.sigBytes;\n                var map = this._map;\n                wordArray.clamp();\n                var base64Chars = [];\n                for (var i = 0; i < sigBytes; i += 3) {\n                    var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n                    var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;\n                    var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;\n                    var triplet = byte1 << 16 | byte2 << 8 | byte3;\n                    for (var j = 0; j < 4 && i + j * .75 < sigBytes; j++) {\n                        base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));\n                    }\n                }\n                var paddingChar = map.charAt(64);\n                if (paddingChar) {\n                    while (base64Chars.length % 4) {\n                        base64Chars.push(paddingChar);\n                    }\n                }\n                return base64Chars.join(\"\");\n            },\n            parse: function(base64Str) {\n                var base64StrLength = base64Str.length;\n                var map = this._map;\n                var paddingChar = map.charAt(64);\n                if (paddingChar) {\n                    var paddingIndex = base64Str.indexOf(paddingChar);\n                    if (paddingIndex != -1) {\n                        base64StrLength = paddingIndex;\n                    }\n                }\n                var words = [];\n                var nBytes = 0;\n                for (var i = 0; i < base64StrLength; i++) {\n                    if (i % 4) {\n                        var bits1 = map.indexOf(base64Str.charAt(i - 1)) << i % 4 * 2;\n                        var bits2 = map.indexOf(base64Str.charAt(i)) >>> 6 - i % 4 * 2;\n                        words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;\n                        nBytes++;\n                    }\n                }\n                return WordArray.create(words, nBytes);\n            },\n            _map: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\n        };\n    })();\n    (function() {\n        var C = qq.CryptoJS;\n        var C_lib = C.lib;\n        var Base = C_lib.Base;\n        var C_enc = C.enc;\n        var Utf8 = C_enc.Utf8;\n        var C_algo = C.algo;\n        var HMAC = C_algo.HMAC = Base.extend({\n            init: function(hasher, key) {\n                hasher = this._hasher = new hasher.init();\n                if (typeof key == \"string\") {\n                    key = Utf8.parse(key);\n                }\n                var hasherBlockSize = hasher.blockSize;\n                var hasherBlockSizeBytes = hasherBlockSize * 4;\n                if (key.sigBytes > hasherBlockSizeBytes) {\n                    key = hasher.finalize(key);\n                }\n                key.clamp();\n                var oKey = this._oKey = key.clone();\n                var iKey = this._iKey = key.clone();\n                var oKeyWords = oKey.words;\n                var iKeyWords = iKey.words;\n                for (var i = 0; i < hasherBlockSize; i++) {\n                    oKeyWords[i] ^= 1549556828;\n                    iKeyWords[i] ^= 909522486;\n                }\n                oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;\n                this.reset();\n            },\n            reset: function() {\n                var hasher = this._hasher;\n                hasher.reset();\n                hasher.update(this._iKey);\n            },\n            update: function(messageUpdate) {\n                this._hasher.update(messageUpdate);\n                return this;\n            },\n            finalize: function(messageUpdate) {\n                var hasher = this._hasher;\n                var innerHash = hasher.finalize(messageUpdate);\n                hasher.reset();\n                var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n                return hmac;\n            }\n        });\n    })();\n    (function() {\n        var C = qq.CryptoJS;\n        var C_lib = C.lib;\n        var WordArray = C_lib.WordArray;\n        var Hasher = C_lib.Hasher;\n        var C_algo = C.algo;\n        var W = [];\n        var SHA1 = C_algo.SHA1 = Hasher.extend({\n            _doReset: function() {\n                this._hash = new WordArray.init([ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ]);\n            },\n            _doProcessBlock: function(M, offset) {\n                var H = this._hash.words;\n                var a = H[0];\n                var b = H[1];\n                var c = H[2];\n                var d = H[3];\n                var e = H[4];\n                for (var i = 0; i < 80; i++) {\n                    if (i < 16) {\n                        W[i] = M[offset + i] | 0;\n                    } else {\n                        var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n                        W[i] = n << 1 | n >>> 31;\n                    }\n                    var t = (a << 5 | a >>> 27) + e + W[i];\n                    if (i < 20) {\n                        t += (b & c | ~b & d) + 1518500249;\n                    } else if (i < 40) {\n                        t += (b ^ c ^ d) + 1859775393;\n                    } else if (i < 60) {\n                        t += (b & c | b & d | c & d) - 1894007588;\n                    } else {\n                        t += (b ^ c ^ d) - 899497514;\n                    }\n                    e = d;\n                    d = c;\n                    c = b << 30 | b >>> 2;\n                    b = a;\n                    a = t;\n                }\n                H[0] = H[0] + a | 0;\n                H[1] = H[1] + b | 0;\n                H[2] = H[2] + c | 0;\n                H[3] = H[3] + d | 0;\n                H[4] = H[4] + e | 0;\n            },\n            _doFinalize: function() {\n                var data = this._data;\n                var dataWords = data.words;\n                var nBitsTotal = this._nDataBytes * 8;\n                var nBitsLeft = data.sigBytes * 8;\n                dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;\n                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);\n                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n                data.sigBytes = dataWords.length * 4;\n                this._process();\n                return this._hash;\n            },\n            clone: function() {\n                var clone = Hasher.clone.call(this);\n                clone._hash = this._hash.clone();\n                return clone;\n            }\n        });\n        C.SHA1 = Hasher._createHelper(SHA1);\n        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);\n    })();\n    (function(Math) {\n        var C = qq.CryptoJS;\n        var C_lib = C.lib;\n        var WordArray = C_lib.WordArray;\n        var Hasher = C_lib.Hasher;\n        var C_algo = C.algo;\n        var H = [];\n        var K = [];\n        (function() {\n            function isPrime(n) {\n                var sqrtN = Math.sqrt(n);\n                for (var factor = 2; factor <= sqrtN; factor++) {\n                    if (!(n % factor)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            function getFractionalBits(n) {\n                return (n - (n | 0)) * 4294967296 | 0;\n            }\n            var n = 2;\n            var nPrime = 0;\n            while (nPrime < 64) {\n                if (isPrime(n)) {\n                    if (nPrime < 8) {\n                        H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n                    }\n                    K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n                    nPrime++;\n                }\n                n++;\n            }\n        })();\n        var W = [];\n        var SHA256 = C_algo.SHA256 = Hasher.extend({\n            _doReset: function() {\n                this._hash = new WordArray.init(H.slice(0));\n            },\n            _doProcessBlock: function(M, offset) {\n                var H = this._hash.words;\n                var a = H[0];\n                var b = H[1];\n                var c = H[2];\n                var d = H[3];\n                var e = H[4];\n                var f = H[5];\n                var g = H[6];\n                var h = H[7];\n                for (var i = 0; i < 64; i++) {\n                    if (i < 16) {\n                        W[i] = M[offset + i] | 0;\n                    } else {\n                        var gamma0x = W[i - 15];\n                        var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n                        var gamma1x = W[i - 2];\n                        var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n                        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n                    }\n                    var ch = e & f ^ ~e & g;\n                    var maj = a & b ^ a & c ^ b & c;\n                    var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n                    var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n                    var t1 = h + sigma1 + ch + K[i] + W[i];\n                    var t2 = sigma0 + maj;\n                    h = g;\n                    g = f;\n                    f = e;\n                    e = d + t1 | 0;\n                    d = c;\n                    c = b;\n                    b = a;\n                    a = t1 + t2 | 0;\n                }\n                H[0] = H[0] + a | 0;\n                H[1] = H[1] + b | 0;\n                H[2] = H[2] + c | 0;\n                H[3] = H[3] + d | 0;\n                H[4] = H[4] + e | 0;\n                H[5] = H[5] + f | 0;\n                H[6] = H[6] + g | 0;\n                H[7] = H[7] + h | 0;\n            },\n            _doFinalize: function() {\n                var data = this._data;\n                var dataWords = data.words;\n                var nBitsTotal = this._nDataBytes * 8;\n                var nBitsLeft = data.sigBytes * 8;\n                dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;\n                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);\n                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n                data.sigBytes = dataWords.length * 4;\n                this._process();\n                return this._hash;\n            },\n            clone: function() {\n                var clone = Hasher.clone.call(this);\n                clone._hash = this._hash.clone();\n                return clone;\n            }\n        });\n        C.SHA256 = Hasher._createHelper(SHA256);\n        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n    })(Math);\n    (function() {\n        if (typeof ArrayBuffer != \"function\") {\n            return;\n        }\n        var C = qq.CryptoJS;\n        var C_lib = C.lib;\n        var WordArray = C_lib.WordArray;\n        var superInit = WordArray.init;\n        var subInit = WordArray.init = function(typedArray) {\n            if (typedArray instanceof ArrayBuffer) {\n                typedArray = new Uint8Array(typedArray);\n            }\n            if (typedArray instanceof Int8Array || typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {\n                typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n            }\n            if (typedArray instanceof Uint8Array) {\n                var typedArrayByteLength = typedArray.byteLength;\n                var words = [];\n                for (var i = 0; i < typedArrayByteLength; i++) {\n                    words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;\n                }\n                superInit.call(this, words, typedArrayByteLength);\n            } else {\n                superInit.apply(this, arguments);\n            }\n        };\n        subInit.prototype = WordArray;\n    })();\n    qq.s3 = qq.s3 || {};\n    qq.s3.util = qq.s3.util || function() {\n        \"use strict\";\n        return {\n            ALGORITHM_PARAM_NAME: \"x-amz-algorithm\",\n            AWS_PARAM_PREFIX: \"x-amz-meta-\",\n            CREDENTIAL_PARAM_NAME: \"x-amz-credential\",\n            DATE_PARAM_NAME: \"x-amz-date\",\n            REDUCED_REDUNDANCY_PARAM_NAME: \"x-amz-storage-class\",\n            REDUCED_REDUNDANCY_PARAM_VALUE: \"REDUCED_REDUNDANCY\",\n            SERVER_SIDE_ENCRYPTION_PARAM_NAME: \"x-amz-server-side-encryption\",\n            SERVER_SIDE_ENCRYPTION_PARAM_VALUE: \"AES256\",\n            SESSION_TOKEN_PARAM_NAME: \"x-amz-security-token\",\n            V4_ALGORITHM_PARAM_VALUE: \"AWS4-HMAC-SHA256\",\n            V4_SIGNATURE_PARAM_NAME: \"x-amz-signature\",\n            CASE_SENSITIVE_PARAM_NAMES: [ \"Cache-Control\", \"Content-Disposition\", \"Content-Encoding\", \"Content-MD5\" ],\n            UNSIGNABLE_REST_HEADER_NAMES: [ \"Cache-Control\", \"Content-Disposition\", \"Content-Encoding\", \"Content-MD5\" ],\n            UNPREFIXED_PARAM_NAMES: [ \"Cache-Control\", \"Content-Disposition\", \"Content-Encoding\", \"Content-MD5\", \"x-amz-server-side-encryption-customer-algorithm\", \"x-amz-server-side-encryption-customer-key\", \"x-amz-server-side-encryption-customer-key-MD5\" ],\n            getBucket: function(endpoint) {\n                var patterns = [ /^(?:https?:\\/\\/)?([a-z0-9.\\-_]+)\\.s3(?:-[a-z0-9\\-]+)?\\.amazonaws\\.com/i, /^(?:https?:\\/\\/)?s3(?:-[a-z0-9\\-]+)?\\.amazonaws\\.com\\/([a-z0-9.\\-_]+)/i, /^(?:https?:\\/\\/)?([a-z0-9.\\-_]+)/i ], bucket;\n                qq.each(patterns, function(idx, pattern) {\n                    var match = pattern.exec(endpoint);\n                    if (match) {\n                        bucket = match[1];\n                        return false;\n                    }\n                });\n                return bucket;\n            },\n            _getPrefixedParamName: function(name) {\n                if (qq.indexOf(qq.s3.util.UNPREFIXED_PARAM_NAMES, name) >= 0) {\n                    return name;\n                }\n                return qq.s3.util.AWS_PARAM_PREFIX + name;\n            },\n            getPolicy: function(spec) {\n                var policy = {}, conditions = [], bucket = spec.bucket, date = spec.date, drift = spec.clockDrift, key = spec.key, accessKey = spec.accessKey, acl = spec.acl, type = spec.type, expectedStatus = spec.expectedStatus, sessionToken = spec.sessionToken, params = spec.params, successRedirectUrl = qq.s3.util.getSuccessRedirectAbsoluteUrl(spec.successRedirectUrl), minFileSize = spec.minFileSize, maxFileSize = spec.maxFileSize, reducedRedundancy = spec.reducedRedundancy, region = spec.region, serverSideEncryption = spec.serverSideEncryption, signatureVersion = spec.signatureVersion;\n                policy.expiration = qq.s3.util.getPolicyExpirationDate(date, drift);\n                conditions.push({\n                    acl: acl\n                });\n                conditions.push({\n                    bucket: bucket\n                });\n                if (type) {\n                    conditions.push({\n                        \"Content-Type\": type\n                    });\n                }\n                if (expectedStatus) {\n                    conditions.push({\n                        success_action_status: expectedStatus.toString()\n                    });\n                }\n                if (successRedirectUrl) {\n                    conditions.push({\n                        success_action_redirect: successRedirectUrl\n                    });\n                }\n                if (reducedRedundancy) {\n                    conditions.push({});\n                    conditions[conditions.length - 1][qq.s3.util.REDUCED_REDUNDANCY_PARAM_NAME] = qq.s3.util.REDUCED_REDUNDANCY_PARAM_VALUE;\n                }\n                if (sessionToken) {\n                    conditions.push({});\n                    conditions[conditions.length - 1][qq.s3.util.SESSION_TOKEN_PARAM_NAME] = sessionToken;\n                }\n                if (serverSideEncryption) {\n                    conditions.push({});\n                    conditions[conditions.length - 1][qq.s3.util.SERVER_SIDE_ENCRYPTION_PARAM_NAME] = qq.s3.util.SERVER_SIDE_ENCRYPTION_PARAM_VALUE;\n                }\n                if (signatureVersion === 2) {\n                    conditions.push({\n                        key: key\n                    });\n                } else if (signatureVersion === 4) {\n                    conditions.push({});\n                    conditions[conditions.length - 1][qq.s3.util.ALGORITHM_PARAM_NAME] = qq.s3.util.V4_ALGORITHM_PARAM_VALUE;\n                    conditions.push({});\n                    conditions[conditions.length - 1].key = key;\n                    conditions.push({});\n                    conditions[conditions.length - 1][qq.s3.util.CREDENTIAL_PARAM_NAME] = qq.s3.util.getV4CredentialsString({\n                        date: date,\n                        key: accessKey,\n                        region: region\n                    });\n                    conditions.push({});\n                    conditions[conditions.length - 1][qq.s3.util.DATE_PARAM_NAME] = qq.s3.util.getV4PolicyDate(date, drift);\n                }\n                qq.each(params, function(name, val) {\n                    var awsParamName = qq.s3.util._getPrefixedParamName(name), param = {};\n                    if (qq.indexOf(qq.s3.util.UNPREFIXED_PARAM_NAMES, awsParamName) >= 0) {\n                        param[awsParamName] = val;\n                    } else {\n                        param[awsParamName] = encodeURIComponent(val);\n                    }\n                    conditions.push(param);\n                });\n                policy.conditions = conditions;\n                qq.s3.util.enforceSizeLimits(policy, minFileSize, maxFileSize);\n                return policy;\n            },\n            refreshPolicyCredentials: function(policy, newSessionToken) {\n                var sessionTokenFound = false;\n                qq.each(policy.conditions, function(oldCondIdx, oldCondObj) {\n                    qq.each(oldCondObj, function(oldCondName, oldCondVal) {\n                        if (oldCondName === qq.s3.util.SESSION_TOKEN_PARAM_NAME) {\n                            oldCondObj[oldCondName] = newSessionToken;\n                            sessionTokenFound = true;\n                        }\n                    });\n                });\n                if (!sessionTokenFound) {\n                    policy.conditions.push({});\n                    policy.conditions[policy.conditions.length - 1][qq.s3.util.SESSION_TOKEN_PARAM_NAME] = newSessionToken;\n                }\n            },\n            generateAwsParams: function(spec, signPolicyCallback) {\n                var awsParams = {}, customParams = spec.params, promise = new qq.Promise(), sessionToken = spec.sessionToken, drift = spec.clockDrift, type = spec.type, key = spec.key, accessKey = spec.accessKey, acl = spec.acl, expectedStatus = spec.expectedStatus, successRedirectUrl = qq.s3.util.getSuccessRedirectAbsoluteUrl(spec.successRedirectUrl), reducedRedundancy = spec.reducedRedundancy, region = spec.region, serverSideEncryption = spec.serverSideEncryption, signatureVersion = spec.signatureVersion, now = new Date(), log = spec.log, policyJson;\n                spec.date = now;\n                policyJson = qq.s3.util.getPolicy(spec);\n                awsParams.key = key;\n                if (type) {\n                    awsParams[\"Content-Type\"] = type;\n                }\n                if (expectedStatus) {\n                    awsParams.success_action_status = expectedStatus;\n                }\n                if (successRedirectUrl) {\n                    awsParams.success_action_redirect = successRedirectUrl;\n                }\n                if (reducedRedundancy) {\n                    awsParams[qq.s3.util.REDUCED_REDUNDANCY_PARAM_NAME] = qq.s3.util.REDUCED_REDUNDANCY_PARAM_VALUE;\n                }\n                if (serverSideEncryption) {\n                    awsParams[qq.s3.util.SERVER_SIDE_ENCRYPTION_PARAM_NAME] = qq.s3.util.SERVER_SIDE_ENCRYPTION_PARAM_VALUE;\n                }\n                if (sessionToken) {\n                    awsParams[qq.s3.util.SESSION_TOKEN_PARAM_NAME] = sessionToken;\n                }\n                awsParams.acl = acl;\n                qq.each(customParams, function(name, val) {\n                    var awsParamName = qq.s3.util._getPrefixedParamName(name);\n                    if (qq.indexOf(qq.s3.util.UNPREFIXED_PARAM_NAMES, awsParamName) >= 0) {\n                        awsParams[awsParamName] = val;\n                    } else {\n                        awsParams[awsParamName] = encodeURIComponent(val);\n                    }\n                });\n                if (signatureVersion === 2) {\n                    awsParams.AWSAccessKeyId = accessKey;\n                } else if (signatureVersion === 4) {\n                    awsParams[qq.s3.util.ALGORITHM_PARAM_NAME] = qq.s3.util.V4_ALGORITHM_PARAM_VALUE;\n                    awsParams[qq.s3.util.CREDENTIAL_PARAM_NAME] = qq.s3.util.getV4CredentialsString({\n                        date: now,\n                        key: accessKey,\n                        region: region\n                    });\n                    awsParams[qq.s3.util.DATE_PARAM_NAME] = qq.s3.util.getV4PolicyDate(now, drift);\n                }\n                signPolicyCallback(policyJson).then(function(policyAndSignature, updatedAccessKey, updatedSessionToken) {\n                    awsParams.policy = policyAndSignature.policy;\n                    if (spec.signatureVersion === 2) {\n                        awsParams.signature = policyAndSignature.signature;\n                        if (updatedAccessKey) {\n                            awsParams.AWSAccessKeyId = updatedAccessKey;\n                        }\n                    } else if (spec.signatureVersion === 4) {\n                        awsParams[qq.s3.util.V4_SIGNATURE_PARAM_NAME] = policyAndSignature.signature;\n                    }\n                    if (updatedSessionToken) {\n                        awsParams[qq.s3.util.SESSION_TOKEN_PARAM_NAME] = updatedSessionToken;\n                    }\n                    promise.success(awsParams);\n                }, function(errorMessage) {\n                    errorMessage = errorMessage || \"Can't continue further with request to S3 as we did not receive \" + \"a valid signature and policy from the server.\";\n                    log(\"Policy signing failed.  \" + errorMessage, \"error\");\n                    promise.failure(errorMessage);\n                });\n                return promise;\n            },\n            enforceSizeLimits: function(policy, minSize, maxSize) {\n                var adjustedMinSize = minSize < 0 ? 0 : minSize, adjustedMaxSize = maxSize <= 0 ? 9007199254740992 : maxSize;\n                if (minSize > 0 || maxSize > 0) {\n                    policy.conditions.push([ \"content-length-range\", adjustedMinSize.toString(), adjustedMaxSize.toString() ]);\n                }\n            },\n            getPolicyExpirationDate: function(date, drift) {\n                var adjustedDate = new Date(date.getTime() + drift);\n                return qq.s3.util.getPolicyDate(adjustedDate, 5);\n            },\n            getCredentialsDate: function(date) {\n                return date.getUTCFullYear() + \"\" + (\"0\" + (date.getUTCMonth() + 1)).slice(-2) + (\"0\" + date.getUTCDate()).slice(-2);\n            },\n            getPolicyDate: function(date, _minutesToAdd_) {\n                var minutesToAdd = _minutesToAdd_ || 0, pad, r;\n                date.setMinutes(date.getMinutes() + (minutesToAdd || 0));\n                if (Date.prototype.toISOString) {\n                    return date.toISOString();\n                } else {\n                    pad = function(number) {\n                        r = String(number);\n                        if (r.length === 1) {\n                            r = \"0\" + r;\n                        }\n                        return r;\n                    };\n                    return date.getUTCFullYear() + \"-\" + pad(date.getUTCMonth() + 1) + \"-\" + pad(date.getUTCDate()) + \"T\" + pad(date.getUTCHours()) + \":\" + pad(date.getUTCMinutes()) + \":\" + pad(date.getUTCSeconds()) + \".\" + String((date.getUTCMilliseconds() / 1e3).toFixed(3)).slice(2, 5) + \"Z\";\n                }\n            },\n            parseIframeResponse: function(iframe) {\n                var doc = iframe.contentDocument || iframe.contentWindow.document, queryString = doc.location.search, match = /bucket=(.+)&key=(.+)&etag=(.+)/.exec(queryString);\n                if (match) {\n                    return {\n                        bucket: match[1],\n                        key: match[2],\n                        etag: match[3].replace(/%22/g, \"\")\n                    };\n                }\n            },\n            getSuccessRedirectAbsoluteUrl: function(successRedirectUrl) {\n                if (successRedirectUrl) {\n                    var targetAnchorContainer = document.createElement(\"div\"), targetAnchor;\n                    if (qq.ie7()) {\n                        targetAnchorContainer.innerHTML = \"<a href='\" + successRedirectUrl + \"'></a>\";\n                        targetAnchor = targetAnchorContainer.firstChild;\n                        return targetAnchor.href;\n                    } else {\n                        targetAnchor = document.createElement(\"a\");\n                        targetAnchor.href = successRedirectUrl;\n                        targetAnchor.href = targetAnchor.href;\n                        return targetAnchor.href;\n                    }\n                }\n            },\n            getV4CredentialsString: function(spec) {\n                return spec.key + \"/\" + qq.s3.util.getCredentialsDate(spec.date) + \"/\" + spec.region + \"/s3/aws4_request\";\n            },\n            getV4PolicyDate: function(date, drift) {\n                var adjustedDate = new Date(date.getTime() + drift);\n                return qq.s3.util.getCredentialsDate(adjustedDate) + \"T\" + (\"0\" + adjustedDate.getUTCHours()).slice(-2) + (\"0\" + adjustedDate.getUTCMinutes()).slice(-2) + (\"0\" + adjustedDate.getUTCSeconds()).slice(-2) + \"Z\";\n            },\n            encodeQueryStringParam: function(param) {\n                var percentEncoded = encodeURIComponent(param);\n                percentEncoded = percentEncoded.replace(/[!'()]/g, escape);\n                percentEncoded = percentEncoded.replace(/\\*/g, \"%2A\");\n                return percentEncoded.replace(/%20/g, \"+\");\n            },\n            uriEscape: function(string) {\n                var output = encodeURIComponent(string);\n                output = output.replace(/[^A-Za-z0-9_.~\\-%]+/g, escape);\n                output = output.replace(/[*]/g, function(ch) {\n                    return \"%\" + ch.charCodeAt(0).toString(16).toUpperCase();\n                });\n                return output;\n            },\n            uriEscapePath: function(path) {\n                var parts = [];\n                qq.each(path.split(\"/\"), function(idx, item) {\n                    parts.push(qq.s3.util.uriEscape(item));\n                });\n                return parts.join(\"/\");\n            }\n        };\n    }();\n    (function() {\n        \"use strict\";\n        qq.nonTraditionalBasePublicApi = {\n            setUploadSuccessParams: function(params, id) {\n                this._uploadSuccessParamsStore.set(params, id);\n            },\n            setUploadSuccessEndpoint: function(endpoint, id) {\n                this._uploadSuccessEndpointStore.set(endpoint, id);\n            }\n        };\n        qq.nonTraditionalBasePrivateApi = {\n            _onComplete: function(id, name, result, xhr) {\n                var success = result.success ? true : false, self = this, onCompleteArgs = arguments, successEndpoint = this._uploadSuccessEndpointStore.get(id), successCustomHeaders = this._options.uploadSuccess.customHeaders, successMethod = this._options.uploadSuccess.method, cors = this._options.cors, promise = new qq.Promise(), uploadSuccessParams = this._uploadSuccessParamsStore.get(id), fileParams = this._paramsStore.get(id), onSuccessFromServer = function(successRequestResult) {\n                    delete self._failedSuccessRequestCallbacks[id];\n                    qq.extend(result, successRequestResult);\n                    qq.FineUploaderBasic.prototype._onComplete.apply(self, onCompleteArgs);\n                    promise.success(successRequestResult);\n                }, onFailureFromServer = function(successRequestResult) {\n                    var callback = submitSuccessRequest;\n                    qq.extend(result, successRequestResult);\n                    if (result && result.reset) {\n                        callback = null;\n                    }\n                    if (!callback) {\n                        delete self._failedSuccessRequestCallbacks[id];\n                    } else {\n                        self._failedSuccessRequestCallbacks[id] = callback;\n                    }\n                    if (!self._onAutoRetry(id, name, result, xhr, callback)) {\n                        qq.FineUploaderBasic.prototype._onComplete.apply(self, onCompleteArgs);\n                        promise.failure(successRequestResult);\n                    }\n                }, submitSuccessRequest, successAjaxRequester;\n                if (success && successEndpoint) {\n                    successAjaxRequester = new qq.UploadSuccessAjaxRequester({\n                        endpoint: successEndpoint,\n                        method: successMethod,\n                        customHeaders: successCustomHeaders,\n                        cors: cors,\n                        log: qq.bind(this.log, this)\n                    });\n                    qq.extend(uploadSuccessParams, self._getEndpointSpecificParams(id, result, xhr), true);\n                    fileParams && qq.extend(uploadSuccessParams, fileParams, true);\n                    submitSuccessRequest = qq.bind(function() {\n                        successAjaxRequester.sendSuccessRequest(id, uploadSuccessParams).then(onSuccessFromServer, onFailureFromServer);\n                    }, self);\n                    submitSuccessRequest();\n                    return promise;\n                }\n                return qq.FineUploaderBasic.prototype._onComplete.apply(this, arguments);\n            },\n            _manualRetry: function(id) {\n                var successRequestCallback = this._failedSuccessRequestCallbacks[id];\n                return qq.FineUploaderBasic.prototype._manualRetry.call(this, id, successRequestCallback);\n            }\n        };\n    })();\n    (function() {\n        \"use strict\";\n        qq.s3.FineUploaderBasic = function(o) {\n            var options = {\n                request: {\n                    accessKey: null,\n                    clockDrift: 0\n                },\n                objectProperties: {\n                    acl: \"private\",\n                    bucket: qq.bind(function(id) {\n                        return qq.s3.util.getBucket(this.getEndpoint(id));\n                    }, this),\n                    host: qq.bind(function(id) {\n                        return /(?:http|https):\\/\\/(.+)(?:\\/.+)?/.exec(this._endpointStore.get(id))[1];\n                    }, this),\n                    key: \"uuid\",\n                    reducedRedundancy: false,\n                    region: \"us-east-1\",\n                    serverSideEncryption: false\n                },\n                credentials: {\n                    accessKey: null,\n                    secretKey: null,\n                    expiration: null,\n                    sessionToken: null\n                },\n                signature: {\n                    customHeaders: {},\n                    endpoint: null,\n                    version: 2\n                },\n                uploadSuccess: {\n                    endpoint: null,\n                    method: \"POST\",\n                    params: {},\n                    customHeaders: {}\n                },\n                iframeSupport: {\n                    localBlankPagePath: null\n                },\n                chunking: {\n                    partSize: 5242880\n                },\n                cors: {\n                    allowXdr: true\n                },\n                callbacks: {\n                    onCredentialsExpired: function() {}\n                }\n            };\n            qq.extend(options, o, true);\n            if (!this.setCredentials(options.credentials, true)) {\n                this._currentCredentials.accessKey = options.request.accessKey;\n            }\n            this._aclStore = this._createStore(options.objectProperties.acl);\n            qq.FineUploaderBasic.call(this, options);\n            this._uploadSuccessParamsStore = this._createStore(this._options.uploadSuccess.params);\n            this._uploadSuccessEndpointStore = this._createStore(this._options.uploadSuccess.endpoint);\n            this._failedSuccessRequestCallbacks = {};\n            this._cannedKeys = {};\n            this._cannedBuckets = {};\n            this._buckets = {};\n            this._hosts = {};\n        };\n        qq.extend(qq.s3.FineUploaderBasic.prototype, qq.basePublicApi);\n        qq.extend(qq.s3.FineUploaderBasic.prototype, qq.basePrivateApi);\n        qq.extend(qq.s3.FineUploaderBasic.prototype, qq.nonTraditionalBasePublicApi);\n        qq.extend(qq.s3.FineUploaderBasic.prototype, qq.nonTraditionalBasePrivateApi);\n        qq.extend(qq.s3.FineUploaderBasic.prototype, {\n            getBucket: function(id) {\n                if (this._cannedBuckets[id] == null) {\n                    return this._buckets[id];\n                }\n                return this._cannedBuckets[id];\n            },\n            getKey: function(id) {\n                if (this._cannedKeys[id] == null) {\n                    return this._handler.getThirdPartyFileId(id);\n                }\n                return this._cannedKeys[id];\n            },\n            reset: function() {\n                qq.FineUploaderBasic.prototype.reset.call(this);\n                this._failedSuccessRequestCallbacks = [];\n                this._buckets = {};\n                this._hosts = {};\n            },\n            setCredentials: function(credentials, ignoreEmpty) {\n                if (credentials && credentials.secretKey) {\n                    if (!credentials.accessKey) {\n                        throw new qq.Error(\"Invalid credentials: no accessKey\");\n                    } else if (!credentials.expiration) {\n                        throw new qq.Error(\"Invalid credentials: no expiration\");\n                    } else {\n                        this._currentCredentials = qq.extend({}, credentials);\n                        if (qq.isString(credentials.expiration)) {\n                            this._currentCredentials.expiration = new Date(credentials.expiration);\n                        }\n                    }\n                    return true;\n                } else if (!ignoreEmpty) {\n                    throw new qq.Error(\"Invalid credentials parameter!\");\n                } else {\n                    this._currentCredentials = {};\n                }\n            },\n            setAcl: function(acl, id) {\n                this._aclStore.set(acl, id);\n            },\n            _createUploadHandler: function() {\n                var self = this, additionalOptions = {\n                    aclStore: this._aclStore,\n                    getBucket: qq.bind(this._determineBucket, this),\n                    getHost: qq.bind(this._determineHost, this),\n                    getKeyName: qq.bind(this._determineKeyName, this),\n                    iframeSupport: this._options.iframeSupport,\n                    objectProperties: this._options.objectProperties,\n                    signature: this._options.signature,\n                    clockDrift: this._options.request.clockDrift,\n                    validation: {\n                        minSizeLimit: this._options.validation.minSizeLimit,\n                        maxSizeLimit: this._options.validation.sizeLimit\n                    }\n                };\n                qq.override(this._endpointStore, function(super_) {\n                    return {\n                        get: function(id) {\n                            var endpoint = super_.get(id);\n                            if (endpoint.indexOf(\"http\") < 0) {\n                                return \"http://\" + endpoint;\n                            }\n                            return endpoint;\n                        }\n                    };\n                });\n                qq.override(this._paramsStore, function(super_) {\n                    return {\n                        get: function(id) {\n                            var oldParams = super_.get(id), modifiedParams = {};\n                            qq.each(oldParams, function(name, val) {\n                                var paramName = name;\n                                if (qq.indexOf(qq.s3.util.CASE_SENSITIVE_PARAM_NAMES, paramName) < 0) {\n                                    paramName = paramName.toLowerCase();\n                                }\n                                modifiedParams[paramName] = qq.isFunction(val) ? val() : val;\n                            });\n                            return modifiedParams;\n                        }\n                    };\n                });\n                additionalOptions.signature.credentialsProvider = {\n                    get: function() {\n                        return self._currentCredentials;\n                    },\n                    onExpired: function() {\n                        var updateCredentials = new qq.Promise(), callbackRetVal = self._options.callbacks.onCredentialsExpired();\n                        if (qq.isGenericPromise(callbackRetVal)) {\n                            callbackRetVal.then(function(credentials) {\n                                try {\n                                    self.setCredentials(credentials);\n                                    updateCredentials.success();\n                                } catch (error) {\n                                    self.log(\"Invalid credentials returned from onCredentialsExpired callback! (\" + error.message + \")\", \"error\");\n                                    updateCredentials.failure(\"onCredentialsExpired did not return valid credentials.\");\n                                }\n                            }, function(errorMsg) {\n                                self.log(\"onCredentialsExpired callback indicated failure! (\" + errorMsg + \")\", \"error\");\n                                updateCredentials.failure(\"onCredentialsExpired callback failed.\");\n                            });\n                        } else {\n                            self.log(\"onCredentialsExpired callback did not return a promise!\", \"error\");\n                            updateCredentials.failure(\"Unexpected return value for onCredentialsExpired.\");\n                        }\n                        return updateCredentials;\n                    }\n                };\n                return qq.FineUploaderBasic.prototype._createUploadHandler.call(this, additionalOptions, \"s3\");\n            },\n            _determineObjectPropertyValue: function(id, property) {\n                var maybe = this._options.objectProperties[property], promise = new qq.Promise(), self = this;\n                if (qq.isFunction(maybe)) {\n                    maybe = maybe(id);\n                    if (qq.isGenericPromise(maybe)) {\n                        promise = maybe;\n                    } else {\n                        promise.success(maybe);\n                    }\n                } else if (qq.isString(maybe)) {\n                    promise.success(maybe);\n                }\n                promise.then(function success(value) {\n                    self[\"_\" + property + \"s\"][id] = value;\n                }, function failure(errorMsg) {\n                    qq.log(\"Problem determining \" + property + \" for ID \" + id + \" (\" + errorMsg + \")\", \"error\");\n                });\n                return promise;\n            },\n            _determineBucket: function(id) {\n                return this._determineObjectPropertyValue(id, \"bucket\");\n            },\n            _determineHost: function(id) {\n                return this._determineObjectPropertyValue(id, \"host\");\n            },\n            _determineKeyName: function(id, filename) {\n                var promise = new qq.Promise(), keynameLogic = this._options.objectProperties.key, extension = qq.getExtension(filename), onGetKeynameFailure = promise.failure, onGetKeynameSuccess = function(keyname, extension) {\n                    var keynameToUse = keyname;\n                    if (extension !== undefined) {\n                        keynameToUse += \".\" + extension;\n                    }\n                    promise.success(keynameToUse);\n                };\n                switch (keynameLogic) {\n                  case \"uuid\":\n                    onGetKeynameSuccess(this.getUuid(id), extension);\n                    break;\n\n                  case \"filename\":\n                    onGetKeynameSuccess(filename);\n                    break;\n\n                  default:\n                    if (qq.isFunction(keynameLogic)) {\n                        this._handleKeynameFunction(keynameLogic, id, onGetKeynameSuccess, onGetKeynameFailure);\n                    } else {\n                        this.log(keynameLogic + \" is not a valid value for the s3.keyname option!\", \"error\");\n                        onGetKeynameFailure();\n                    }\n                }\n                return promise;\n            },\n            _handleKeynameFunction: function(keynameFunc, id, successCallback, failureCallback) {\n                var self = this, onSuccess = function(keyname) {\n                    successCallback(keyname);\n                }, onFailure = function(reason) {\n                    self.log(qq.format(\"Failed to retrieve key name for {}.  Reason: {}\", id, reason || \"null\"), \"error\");\n                    failureCallback(reason);\n                }, keyname = keynameFunc.call(this, id);\n                if (qq.isGenericPromise(keyname)) {\n                    keyname.then(onSuccess, onFailure);\n                } else if (keyname == null) {\n                    onFailure();\n                } else {\n                    onSuccess(keyname);\n                }\n            },\n            _getEndpointSpecificParams: function(id, response, maybeXhr) {\n                var params = {\n                    key: this.getKey(id),\n                    uuid: this.getUuid(id),\n                    name: this.getName(id),\n                    bucket: this.getBucket(id)\n                };\n                if (maybeXhr && maybeXhr.getResponseHeader(\"ETag\")) {\n                    params.etag = maybeXhr.getResponseHeader(\"ETag\");\n                } else if (response.etag) {\n                    params.etag = response.etag;\n                }\n                return params;\n            },\n            _onSubmitDelete: function(id, onSuccessCallback) {\n                var additionalMandatedParams = {\n                    key: this.getKey(id),\n                    bucket: this.getBucket(id)\n                };\n                return qq.FineUploaderBasic.prototype._onSubmitDelete.call(this, id, onSuccessCallback, additionalMandatedParams);\n            },\n            _addCannedFile: function(sessionData) {\n                var id;\n                if (sessionData.s3Key == null) {\n                    throw new qq.Error(\"Did not find s3Key property in server session response.  This is required!\");\n                } else {\n                    id = qq.FineUploaderBasic.prototype._addCannedFile.apply(this, arguments);\n                    this._cannedKeys[id] = sessionData.s3Key;\n                    this._cannedBuckets[id] = sessionData.s3Bucket;\n                }\n                return id;\n            }\n        });\n    })();\n    if (!window.Uint8ClampedArray) {\n        window.Uint8ClampedArray = function() {};\n    }\n    qq.s3.RequestSigner = function(o) {\n        \"use strict\";\n        var requester, thisSignatureRequester = this, pendingSignatures = {}, options = {\n            expectingPolicy: false,\n            method: \"POST\",\n            signatureSpec: {\n                drift: 0,\n                credentialsProvider: {},\n                endpoint: null,\n                customHeaders: {},\n                version: 2\n            },\n            maxConnections: 3,\n            endpointStore: {},\n            paramsStore: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {}\n        }, credentialsProvider, generateHeaders = function(signatureConstructor, signature, promise) {\n            var headers = signatureConstructor.getHeaders();\n            if (options.signatureSpec.version === 4) {\n                headers.Authorization = qq.s3.util.V4_ALGORITHM_PARAM_VALUE + \" Credential=\" + options.signatureSpec.credentialsProvider.get().accessKey + \"/\" + qq.s3.util.getCredentialsDate(signatureConstructor.getRequestDate()) + \"/\" + options.signatureSpec.region + \"/\" + \"s3/aws4_request,\" + \"SignedHeaders=\" + signatureConstructor.getSignedHeaders() + \",\" + \"Signature=\" + signature;\n            } else {\n                headers.Authorization = \"AWS \" + options.signatureSpec.credentialsProvider.get().accessKey + \":\" + signature;\n            }\n            promise.success(headers, signatureConstructor.getEndOfUrl());\n        }, v2 = {\n            getStringToSign: function(signatureSpec) {\n                return qq.format(\"{}\\n{}\\n{}\\n\\n{}/{}/{}\", signatureSpec.method, signatureSpec.contentMd5 || \"\", signatureSpec.contentType || \"\", signatureSpec.headersStr || \"\\n\", signatureSpec.bucket, signatureSpec.endOfUrl);\n            },\n            signApiRequest: function(signatureConstructor, headersStr, signatureEffort) {\n                var headersWordArray = qq.CryptoJS.enc.Utf8.parse(headersStr), headersHmacSha1 = qq.CryptoJS.HmacSHA1(headersWordArray, credentialsProvider.get().secretKey), headersHmacSha1Base64 = qq.CryptoJS.enc.Base64.stringify(headersHmacSha1);\n                generateHeaders(signatureConstructor, headersHmacSha1Base64, signatureEffort);\n            },\n            signPolicy: function(policy, signatureEffort, updatedAccessKey, updatedSessionToken) {\n                var policyStr = JSON.stringify(policy), policyWordArray = qq.CryptoJS.enc.Utf8.parse(policyStr), base64Policy = qq.CryptoJS.enc.Base64.stringify(policyWordArray), policyHmacSha1 = qq.CryptoJS.HmacSHA1(base64Policy, credentialsProvider.get().secretKey), policyHmacSha1Base64 = qq.CryptoJS.enc.Base64.stringify(policyHmacSha1);\n                signatureEffort.success({\n                    policy: base64Policy,\n                    signature: policyHmacSha1Base64\n                }, updatedAccessKey, updatedSessionToken);\n            }\n        }, v4 = {\n            getCanonicalQueryString: function(endOfUri) {\n                var queryParamIdx = endOfUri.indexOf(\"?\"), canonicalQueryString = \"\", encodedQueryParams, encodedQueryParamNames, queryStrings;\n                if (queryParamIdx >= 0) {\n                    encodedQueryParams = {};\n                    queryStrings = endOfUri.substr(queryParamIdx + 1).split(\"&\");\n                    qq.each(queryStrings, function(idx, queryString) {\n                        var nameAndVal = queryString.split(\"=\"), paramVal = nameAndVal[1];\n                        if (paramVal == null) {\n                            paramVal = \"\";\n                        }\n                        encodedQueryParams[encodeURIComponent(nameAndVal[0])] = encodeURIComponent(paramVal);\n                    });\n                    encodedQueryParamNames = Object.keys(encodedQueryParams).sort();\n                    encodedQueryParamNames.forEach(function(encodedQueryParamName, idx) {\n                        canonicalQueryString += encodedQueryParamName + \"=\" + encodedQueryParams[encodedQueryParamName];\n                        if (idx < encodedQueryParamNames.length - 1) {\n                            canonicalQueryString += \"&\";\n                        }\n                    });\n                }\n                return canonicalQueryString;\n            },\n            getCanonicalRequest: function(signatureSpec) {\n                return qq.format(\"{}\\n{}\\n{}\\n{}\\n{}\\n{}\", signatureSpec.method, v4.getCanonicalUri(signatureSpec.endOfUrl), v4.getCanonicalQueryString(signatureSpec.endOfUrl), signatureSpec.headersStr || \"\\n\", v4.getSignedHeaders(signatureSpec.headerNames), signatureSpec.hashedContent);\n            },\n            getCanonicalUri: function(endOfUri) {\n                var path = endOfUri, queryParamIdx = endOfUri.indexOf(\"?\");\n                if (queryParamIdx > 0) {\n                    path = endOfUri.substr(0, queryParamIdx);\n                }\n                return \"/\" + path;\n            },\n            getEncodedHashedPayload: function(body) {\n                var promise = new qq.Promise(), reader;\n                if (qq.isBlob(body)) {\n                    reader = new FileReader();\n                    reader.onloadend = function(e) {\n                        if (e.target.readyState === FileReader.DONE) {\n                            if (e.target.error) {\n                                promise.failure(e.target.error);\n                            } else {\n                                var wordArray = qq.CryptoJS.lib.WordArray.create(e.target.result);\n                                promise.success(qq.CryptoJS.SHA256(wordArray).toString());\n                            }\n                        }\n                    };\n                    reader.readAsArrayBuffer(body);\n                } else {\n                    body = body || \"\";\n                    promise.success(qq.CryptoJS.SHA256(body).toString());\n                }\n                return promise;\n            },\n            getScope: function(date, region) {\n                return qq.s3.util.getCredentialsDate(date) + \"/\" + region + \"/s3/aws4_request\";\n            },\n            getStringToSign: function(signatureSpec) {\n                var canonicalRequest = v4.getCanonicalRequest(signatureSpec), date = qq.s3.util.getV4PolicyDate(signatureSpec.date, signatureSpec.drift), hashedRequest = qq.CryptoJS.SHA256(canonicalRequest).toString(), scope = v4.getScope(signatureSpec.date, options.signatureSpec.region), stringToSignTemplate = \"AWS4-HMAC-SHA256\\n{}\\n{}\\n{}\";\n                return {\n                    hashed: qq.format(stringToSignTemplate, date, scope, hashedRequest),\n                    raw: qq.format(stringToSignTemplate, date, scope, canonicalRequest)\n                };\n            },\n            getSignedHeaders: function(headerNames) {\n                var signedHeaders = \"\";\n                headerNames.forEach(function(headerName, idx) {\n                    signedHeaders += headerName.toLowerCase();\n                    if (idx < headerNames.length - 1) {\n                        signedHeaders += \";\";\n                    }\n                });\n                return signedHeaders;\n            },\n            signApiRequest: function(signatureConstructor, headersStr, signatureEffort) {\n                var secretKey = credentialsProvider.get().secretKey, headersPattern = /.+\\n.+\\n(\\d+)\\/(.+)\\/s3\\/.+\\n(.+)/, matches = headersPattern.exec(headersStr), dateKey, dateRegionKey, dateRegionServiceKey, signingKey;\n                dateKey = qq.CryptoJS.HmacSHA256(matches[1], \"AWS4\" + secretKey);\n                dateRegionKey = qq.CryptoJS.HmacSHA256(matches[2], dateKey);\n                dateRegionServiceKey = qq.CryptoJS.HmacSHA256(\"s3\", dateRegionKey);\n                signingKey = qq.CryptoJS.HmacSHA256(\"aws4_request\", dateRegionServiceKey);\n                generateHeaders(signatureConstructor, qq.CryptoJS.HmacSHA256(headersStr, signingKey), signatureEffort);\n            },\n            signPolicy: function(policy, signatureEffort, updatedAccessKey, updatedSessionToken) {\n                var policyStr = JSON.stringify(policy), policyWordArray = qq.CryptoJS.enc.Utf8.parse(policyStr), base64Policy = qq.CryptoJS.enc.Base64.stringify(policyWordArray), secretKey = credentialsProvider.get().secretKey, credentialPattern = /.+\\/(.+)\\/(.+)\\/s3\\/aws4_request/, credentialCondition = function() {\n                    var credential = null;\n                    qq.each(policy.conditions, function(key, condition) {\n                        var val = condition[\"x-amz-credential\"];\n                        if (val) {\n                            credential = val;\n                            return false;\n                        }\n                    });\n                    return credential;\n                }(), matches, dateKey, dateRegionKey, dateRegionServiceKey, signingKey;\n                matches = credentialPattern.exec(credentialCondition);\n                dateKey = qq.CryptoJS.HmacSHA256(matches[1], \"AWS4\" + secretKey);\n                dateRegionKey = qq.CryptoJS.HmacSHA256(matches[2], dateKey);\n                dateRegionServiceKey = qq.CryptoJS.HmacSHA256(\"s3\", dateRegionKey);\n                signingKey = qq.CryptoJS.HmacSHA256(\"aws4_request\", dateRegionServiceKey);\n                signatureEffort.success({\n                    policy: base64Policy,\n                    signature: qq.CryptoJS.HmacSHA256(base64Policy, signingKey).toString()\n                }, updatedAccessKey, updatedSessionToken);\n            }\n        };\n        qq.extend(options, o, true);\n        credentialsProvider = options.signatureSpec.credentialsProvider;\n        function handleSignatureReceived(id, xhrOrXdr, isError) {\n            var responseJson = xhrOrXdr.responseText, pendingSignatureData = pendingSignatures[id], promise = pendingSignatureData.promise, signatureConstructor = pendingSignatureData.signatureConstructor, errorMessage, response;\n            delete pendingSignatures[id];\n            if (responseJson) {\n                try {\n                    response = qq.parseJson(responseJson);\n                } catch (error) {\n                    options.log(\"Error attempting to parse signature response: \" + error, \"error\");\n                }\n            }\n            if (response && response.error) {\n                isError = true;\n                errorMessage = response.error;\n            } else if (response && response.invalid) {\n                isError = true;\n                errorMessage = \"Invalid policy document or request headers!\";\n            } else if (response) {\n                if (options.expectingPolicy && !response.policy) {\n                    isError = true;\n                    errorMessage = \"Response does not include the base64 encoded policy!\";\n                } else if (!response.signature) {\n                    isError = true;\n                    errorMessage = \"Response does not include the signature!\";\n                }\n            } else {\n                isError = true;\n                errorMessage = \"Received an empty or invalid response from the server!\";\n            }\n            if (isError) {\n                if (errorMessage) {\n                    options.log(errorMessage, \"error\");\n                }\n                promise.failure(errorMessage);\n            } else if (signatureConstructor) {\n                generateHeaders(signatureConstructor, response.signature, promise);\n            } else {\n                promise.success(response);\n            }\n        }\n        function getStringToSignArtifacts(id, version, requestInfo) {\n            var promise = new qq.Promise(), method = \"POST\", headerNames = [], headersStr = \"\", now = new Date(), endOfUrl, signatureSpec, toSign, generateStringToSign = function(requestInfo) {\n                var contentMd5, headerIndexesToRemove = [];\n                qq.each(requestInfo.headers, function(name) {\n                    headerNames.push(name);\n                });\n                headerNames.sort();\n                qq.each(headerNames, function(idx, headerName) {\n                    if (qq.indexOf(qq.s3.util.UNSIGNABLE_REST_HEADER_NAMES, headerName) < 0) {\n                        headersStr += headerName.toLowerCase() + \":\" + requestInfo.headers[headerName].trim() + \"\\n\";\n                    } else if (headerName === \"Content-MD5\") {\n                        contentMd5 = requestInfo.headers[headerName];\n                    } else {\n                        headerIndexesToRemove.unshift(idx);\n                    }\n                });\n                qq.each(headerIndexesToRemove, function(idx, headerIdx) {\n                    headerNames.splice(headerIdx, 1);\n                });\n                signatureSpec = {\n                    bucket: requestInfo.bucket,\n                    contentMd5: contentMd5,\n                    contentType: requestInfo.contentType,\n                    date: now,\n                    drift: options.signatureSpec.drift,\n                    endOfUrl: endOfUrl,\n                    hashedContent: requestInfo.hashedContent,\n                    headerNames: headerNames,\n                    headersStr: headersStr,\n                    method: method\n                };\n                toSign = version === 2 ? v2.getStringToSign(signatureSpec) : v4.getStringToSign(signatureSpec);\n                return {\n                    date: now,\n                    endOfUrl: endOfUrl,\n                    signedHeaders: version === 4 ? v4.getSignedHeaders(signatureSpec.headerNames) : null,\n                    toSign: version === 4 ? toSign.hashed : toSign,\n                    toSignRaw: version === 4 ? toSign.raw : toSign\n                };\n            };\n            switch (requestInfo.type) {\n              case thisSignatureRequester.REQUEST_TYPE.MULTIPART_ABORT:\n                method = \"DELETE\";\n                endOfUrl = qq.format(\"uploadId={}\", requestInfo.uploadId);\n                break;\n\n              case thisSignatureRequester.REQUEST_TYPE.MULTIPART_INITIATE:\n                endOfUrl = \"uploads\";\n                break;\n\n              case thisSignatureRequester.REQUEST_TYPE.MULTIPART_COMPLETE:\n                endOfUrl = qq.format(\"uploadId={}\", requestInfo.uploadId);\n                break;\n\n              case thisSignatureRequester.REQUEST_TYPE.MULTIPART_UPLOAD:\n                method = \"PUT\";\n                endOfUrl = qq.format(\"partNumber={}&uploadId={}\", requestInfo.partNum, requestInfo.uploadId);\n                break;\n            }\n            endOfUrl = requestInfo.key + \"?\" + endOfUrl;\n            if (version === 4) {\n                v4.getEncodedHashedPayload(requestInfo.content).then(function(hashedContent) {\n                    requestInfo.headers[\"x-amz-content-sha256\"] = hashedContent;\n                    requestInfo.headers.Host = requestInfo.host;\n                    requestInfo.headers[\"x-amz-date\"] = qq.s3.util.getV4PolicyDate(now, options.signatureSpec.drift);\n                    requestInfo.hashedContent = hashedContent;\n                    promise.success(generateStringToSign(requestInfo));\n                }, function(err) {\n                    promise.failure(err);\n                });\n            } else {\n                promise.success(generateStringToSign(requestInfo));\n            }\n            return promise;\n        }\n        function determineSignatureClientSide(id, toBeSigned, signatureEffort, updatedAccessKey, updatedSessionToken) {\n            var updatedHeaders;\n            if (toBeSigned.signatureConstructor) {\n                if (updatedSessionToken) {\n                    updatedHeaders = toBeSigned.signatureConstructor.getHeaders();\n                    updatedHeaders[qq.s3.util.SESSION_TOKEN_PARAM_NAME] = updatedSessionToken;\n                    toBeSigned.signatureConstructor.withHeaders(updatedHeaders);\n                }\n                toBeSigned.signatureConstructor.getToSign(id).then(function(signatureArtifacts) {\n                    signApiRequest(toBeSigned.signatureConstructor, signatureArtifacts.stringToSign, signatureEffort);\n                }, function(err) {\n                    signatureEffort.failure(err);\n                });\n            } else {\n                updatedSessionToken && qq.s3.util.refreshPolicyCredentials(toBeSigned, updatedSessionToken);\n                signPolicy(toBeSigned, signatureEffort, updatedAccessKey, updatedSessionToken);\n            }\n        }\n        function signPolicy(policy, signatureEffort, updatedAccessKey, updatedSessionToken) {\n            if (options.signatureSpec.version === 4) {\n                v4.signPolicy(policy, signatureEffort, updatedAccessKey, updatedSessionToken);\n            } else {\n                v2.signPolicy(policy, signatureEffort, updatedAccessKey, updatedSessionToken);\n            }\n        }\n        function signApiRequest(signatureConstructor, headersStr, signatureEffort) {\n            if (options.signatureSpec.version === 4) {\n                v4.signApiRequest(signatureConstructor, headersStr, signatureEffort);\n            } else {\n                v2.signApiRequest(signatureConstructor, headersStr, signatureEffort);\n            }\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            method: options.method,\n            contentType: \"application/json; charset=utf-8\",\n            endpointStore: {\n                get: function() {\n                    return options.signatureSpec.endpoint;\n                }\n            },\n            paramsStore: options.paramsStore,\n            maxConnections: options.maxConnections,\n            customHeaders: options.signatureSpec.customHeaders,\n            log: options.log,\n            onComplete: handleSignatureReceived,\n            cors: options.cors\n        }));\n        qq.extend(this, {\n            getSignature: function(id, toBeSigned) {\n                var params = toBeSigned, signatureConstructor = toBeSigned.signatureConstructor, signatureEffort = new qq.Promise(), queryParams;\n                if (options.signatureSpec.version === 4) {\n                    queryParams = {\n                        v4: true\n                    };\n                }\n                if (credentialsProvider.get().secretKey && qq.CryptoJS) {\n                    if (credentialsProvider.get().expiration.getTime() > Date.now()) {\n                        determineSignatureClientSide(id, toBeSigned, signatureEffort);\n                    } else {\n                        credentialsProvider.onExpired().then(function() {\n                            determineSignatureClientSide(id, toBeSigned, signatureEffort, credentialsProvider.get().accessKey, credentialsProvider.get().sessionToken);\n                        }, function(errorMsg) {\n                            options.log(\"Attempt to update expired credentials apparently failed! Unable to sign request.  \", \"error\");\n                            signatureEffort.failure(\"Unable to sign request - expired credentials.\");\n                        });\n                    }\n                } else {\n                    options.log(\"Submitting S3 signature request for \" + id);\n                    if (signatureConstructor) {\n                        signatureConstructor.getToSign(id).then(function(signatureArtifacts) {\n                            params = {\n                                headers: signatureArtifacts.stringToSignRaw\n                            };\n                            requester.initTransport(id).withParams(params).withQueryParams(queryParams).send();\n                        }, function(err) {\n                            options.log(\"Failed to construct signature. \", \"error\");\n                            signatureEffort.failure(\"Failed to construct signature.\");\n                        });\n                    } else {\n                        requester.initTransport(id).withParams(params).withQueryParams(queryParams).send();\n                    }\n                    pendingSignatures[id] = {\n                        promise: signatureEffort,\n                        signatureConstructor: signatureConstructor\n                    };\n                }\n                return signatureEffort;\n            },\n            constructStringToSign: function(type, bucket, host, key) {\n                var headers = {}, uploadId, content, contentType, partNum, artifacts;\n                return {\n                    withHeaders: function(theHeaders) {\n                        headers = theHeaders;\n                        return this;\n                    },\n                    withUploadId: function(theUploadId) {\n                        uploadId = theUploadId;\n                        return this;\n                    },\n                    withContent: function(theContent) {\n                        content = theContent;\n                        return this;\n                    },\n                    withContentType: function(theContentType) {\n                        contentType = theContentType;\n                        return this;\n                    },\n                    withPartNum: function(thePartNum) {\n                        partNum = thePartNum;\n                        return this;\n                    },\n                    getToSign: function(id) {\n                        var sessionToken = credentialsProvider.get().sessionToken, promise = new qq.Promise(), adjustedDate = new Date(Date.now() + options.signatureSpec.drift);\n                        headers[\"x-amz-date\"] = adjustedDate.toUTCString();\n                        if (sessionToken) {\n                            headers[qq.s3.util.SESSION_TOKEN_PARAM_NAME] = sessionToken;\n                        }\n                        getStringToSignArtifacts(id, options.signatureSpec.version, {\n                            bucket: bucket,\n                            content: content,\n                            contentType: contentType,\n                            headers: headers,\n                            host: host,\n                            key: key,\n                            partNum: partNum,\n                            type: type,\n                            uploadId: uploadId\n                        }).then(function(_artifacts_) {\n                            artifacts = _artifacts_;\n                            promise.success({\n                                headers: function() {\n                                    if (contentType) {\n                                        headers[\"Content-Type\"] = contentType;\n                                    }\n                                    delete headers.Host;\n                                    return headers;\n                                }(),\n                                date: artifacts.date,\n                                endOfUrl: artifacts.endOfUrl,\n                                signedHeaders: artifacts.signedHeaders,\n                                stringToSign: artifacts.toSign,\n                                stringToSignRaw: artifacts.toSignRaw\n                            });\n                        }, function(err) {\n                            promise.failure(err);\n                        });\n                        return promise;\n                    },\n                    getHeaders: function() {\n                        return qq.extend({}, headers);\n                    },\n                    getEndOfUrl: function() {\n                        return artifacts && artifacts.endOfUrl;\n                    },\n                    getRequestDate: function() {\n                        return artifacts && artifacts.date;\n                    },\n                    getSignedHeaders: function() {\n                        return artifacts && artifacts.signedHeaders;\n                    }\n                };\n            }\n        });\n    };\n    qq.s3.RequestSigner.prototype.REQUEST_TYPE = {\n        MULTIPART_INITIATE: \"multipart_initiate\",\n        MULTIPART_COMPLETE: \"multipart_complete\",\n        MULTIPART_ABORT: \"multipart_abort\",\n        MULTIPART_UPLOAD: \"multipart_upload\"\n    };\n    qq.UploadSuccessAjaxRequester = function(o) {\n        \"use strict\";\n        var requester, pendingRequests = [], options = {\n            method: \"POST\",\n            endpoint: null,\n            maxConnections: 3,\n            customHeaders: {},\n            paramsStore: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {}\n        };\n        qq.extend(options, o);\n        function handleSuccessResponse(id, xhrOrXdr, isError) {\n            var promise = pendingRequests[id], responseJson = xhrOrXdr.responseText, successIndicator = {\n                success: true\n            }, failureIndicator = {\n                success: false\n            }, parsedResponse;\n            delete pendingRequests[id];\n            options.log(qq.format(\"Received the following response body to an upload success request for id {}: {}\", id, responseJson));\n            try {\n                parsedResponse = qq.parseJson(responseJson);\n                if (isError || parsedResponse && (parsedResponse.error || parsedResponse.success === false)) {\n                    options.log(\"Upload success request was rejected by the server.\", \"error\");\n                    promise.failure(qq.extend(parsedResponse, failureIndicator));\n                } else {\n                    options.log(\"Upload success was acknowledged by the server.\");\n                    promise.success(qq.extend(parsedResponse, successIndicator));\n                }\n            } catch (error) {\n                if (isError) {\n                    options.log(qq.format(\"Your server indicated failure in its upload success request response for id {}!\", id), \"error\");\n                    promise.failure(failureIndicator);\n                } else {\n                    options.log(\"Upload success was acknowledged by the server.\");\n                    promise.success(successIndicator);\n                }\n            }\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            method: options.method,\n            endpointStore: {\n                get: function() {\n                    return options.endpoint;\n                }\n            },\n            paramsStore: options.paramsStore,\n            maxConnections: options.maxConnections,\n            customHeaders: options.customHeaders,\n            log: options.log,\n            onComplete: handleSuccessResponse,\n            cors: options.cors\n        }));\n        qq.extend(this, {\n            sendSuccessRequest: function(id, spec) {\n                var promise = new qq.Promise();\n                options.log(\"Submitting upload success request/notification for \" + id);\n                requester.initTransport(id).withParams(spec).send();\n                pendingRequests[id] = promise;\n                return promise;\n            }\n        });\n    };\n    qq.s3.InitiateMultipartAjaxRequester = function(o) {\n        \"use strict\";\n        var requester, pendingInitiateRequests = {}, options = {\n            filenameParam: \"qqfilename\",\n            method: \"POST\",\n            endpointStore: null,\n            paramsStore: null,\n            signatureSpec: null,\n            aclStore: null,\n            reducedRedundancy: false,\n            serverSideEncryption: false,\n            maxConnections: 3,\n            getContentType: function(id) {},\n            getBucket: function(id) {},\n            getHost: function(id) {},\n            getKey: function(id) {},\n            getName: function(id) {},\n            log: function(str, level) {}\n        }, getSignatureAjaxRequester;\n        qq.extend(options, o);\n        getSignatureAjaxRequester = new qq.s3.RequestSigner({\n            endpointStore: options.endpointStore,\n            signatureSpec: options.signatureSpec,\n            cors: options.cors,\n            log: options.log\n        });\n        function getHeaders(id) {\n            var bucket = options.getBucket(id), host = options.getHost(id), headers = {}, promise = new qq.Promise(), key = options.getKey(id), signatureConstructor;\n            headers[\"x-amz-acl\"] = options.aclStore.get(id);\n            if (options.reducedRedundancy) {\n                headers[qq.s3.util.REDUCED_REDUNDANCY_PARAM_NAME] = qq.s3.util.REDUCED_REDUNDANCY_PARAM_VALUE;\n            }\n            if (options.serverSideEncryption) {\n                headers[qq.s3.util.SERVER_SIDE_ENCRYPTION_PARAM_NAME] = qq.s3.util.SERVER_SIDE_ENCRYPTION_PARAM_VALUE;\n            }\n            headers[qq.s3.util.AWS_PARAM_PREFIX + options.filenameParam] = encodeURIComponent(options.getName(id));\n            qq.each(options.paramsStore.get(id), function(name, val) {\n                if (qq.indexOf(qq.s3.util.UNPREFIXED_PARAM_NAMES, name) >= 0) {\n                    headers[name] = val;\n                } else {\n                    headers[qq.s3.util.AWS_PARAM_PREFIX + name] = encodeURIComponent(val);\n                }\n            });\n            signatureConstructor = getSignatureAjaxRequester.constructStringToSign(getSignatureAjaxRequester.REQUEST_TYPE.MULTIPART_INITIATE, bucket, host, key).withContentType(options.getContentType(id)).withHeaders(headers);\n            getSignatureAjaxRequester.getSignature(id, {\n                signatureConstructor: signatureConstructor\n            }).then(promise.success, promise.failure);\n            return promise;\n        }\n        function handleInitiateRequestComplete(id, xhr, isError) {\n            var promise = pendingInitiateRequests[id], domParser = new DOMParser(), responseDoc = domParser.parseFromString(xhr.responseText, \"application/xml\"), uploadIdElements, messageElements, uploadId, errorMessage, status;\n            delete pendingInitiateRequests[id];\n            if (isError) {\n                status = xhr.status;\n                messageElements = responseDoc.getElementsByTagName(\"Message\");\n                if (messageElements.length > 0) {\n                    errorMessage = messageElements[0].textContent;\n                }\n            } else {\n                uploadIdElements = responseDoc.getElementsByTagName(\"UploadId\");\n                if (uploadIdElements.length > 0) {\n                    uploadId = uploadIdElements[0].textContent;\n                } else {\n                    errorMessage = \"Upload ID missing from request\";\n                }\n            }\n            if (uploadId === undefined) {\n                if (errorMessage) {\n                    options.log(qq.format(\"Specific problem detected initiating multipart upload request for {}: '{}'.\", id, errorMessage), \"error\");\n                } else {\n                    options.log(qq.format(\"Unexplained error with initiate multipart upload request for {}.  Status code {}.\", id, status), \"error\");\n                }\n                promise.failure(\"Problem initiating upload request.\", xhr);\n            } else {\n                options.log(qq.format(\"Initiate multipart upload request successful for {}.  Upload ID is {}\", id, uploadId));\n                promise.success(uploadId, xhr);\n            }\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            method: options.method,\n            contentType: null,\n            endpointStore: options.endpointStore,\n            maxConnections: options.maxConnections,\n            allowXRequestedWithAndCacheControl: false,\n            log: options.log,\n            onComplete: handleInitiateRequestComplete,\n            successfulResponseCodes: {\n                POST: [ 200 ]\n            }\n        }));\n        qq.extend(this, {\n            send: function(id) {\n                var promise = new qq.Promise();\n                getHeaders(id).then(function(headers, endOfUrl) {\n                    options.log(\"Submitting S3 initiate multipart upload request for \" + id);\n                    pendingInitiateRequests[id] = promise;\n                    requester.initTransport(id).withPath(endOfUrl).withHeaders(headers).send();\n                }, promise.failure);\n                return promise;\n            }\n        });\n    };\n    qq.s3.CompleteMultipartAjaxRequester = function(o) {\n        \"use strict\";\n        var requester, pendingCompleteRequests = {}, options = {\n            method: \"POST\",\n            contentType: \"text/xml\",\n            endpointStore: null,\n            signatureSpec: null,\n            maxConnections: 3,\n            getBucket: function(id) {},\n            getHost: function(id) {},\n            getKey: function(id) {},\n            log: function(str, level) {}\n        }, getSignatureAjaxRequester;\n        qq.extend(options, o);\n        getSignatureAjaxRequester = new qq.s3.RequestSigner({\n            endpointStore: options.endpointStore,\n            signatureSpec: options.signatureSpec,\n            cors: options.cors,\n            log: options.log\n        });\n        function getHeaders(id, uploadId, body) {\n            var headers = {}, promise = new qq.Promise(), bucket = options.getBucket(id), host = options.getHost(id), signatureConstructor = getSignatureAjaxRequester.constructStringToSign(getSignatureAjaxRequester.REQUEST_TYPE.MULTIPART_COMPLETE, bucket, host, options.getKey(id)).withUploadId(uploadId).withContent(body).withContentType(\"application/xml; charset=UTF-8\");\n            getSignatureAjaxRequester.getSignature(id, {\n                signatureConstructor: signatureConstructor\n            }).then(promise.success, promise.failure);\n            return promise;\n        }\n        function handleCompleteRequestComplete(id, xhr, isError) {\n            var promise = pendingCompleteRequests[id], domParser = new DOMParser(), bucket = options.getBucket(id), key = options.getKey(id), responseDoc = domParser.parseFromString(xhr.responseText, \"application/xml\"), bucketEls = responseDoc.getElementsByTagName(\"Bucket\"), keyEls = responseDoc.getElementsByTagName(\"Key\");\n            delete pendingCompleteRequests[id];\n            options.log(qq.format(\"Complete response status {}, body = {}\", xhr.status, xhr.responseText));\n            if (isError) {\n                options.log(qq.format(\"Complete Multipart Upload request for {} failed with status {}.\", id, xhr.status), \"error\");\n            } else {\n                if (bucketEls.length && keyEls.length) {\n                    if (bucketEls[0].textContent !== bucket) {\n                        isError = true;\n                        options.log(qq.format(\"Wrong bucket in response to Complete Multipart Upload request for {}.\", id), \"error\");\n                    }\n                } else {\n                    isError = true;\n                    options.log(qq.format(\"Missing bucket and/or key in response to Complete Multipart Upload request for {}.\", id), \"error\");\n                }\n            }\n            if (isError) {\n                promise.failure(\"Problem combining the file parts!\", xhr);\n            } else {\n                promise.success({}, xhr);\n            }\n        }\n        function getCompleteRequestBody(etagEntries) {\n            var doc = document.implementation.createDocument(null, \"CompleteMultipartUpload\", null);\n            etagEntries.sort(function(a, b) {\n                return a.part - b.part;\n            });\n            qq.each(etagEntries, function(idx, etagEntry) {\n                var part = etagEntry.part, etag = etagEntry.etag, partEl = doc.createElement(\"Part\"), partNumEl = doc.createElement(\"PartNumber\"), partNumTextEl = doc.createTextNode(part), etagTextEl = doc.createTextNode(etag), etagEl = doc.createElement(\"ETag\");\n                etagEl.appendChild(etagTextEl);\n                partNumEl.appendChild(partNumTextEl);\n                partEl.appendChild(partNumEl);\n                partEl.appendChild(etagEl);\n                qq(doc).children()[0].appendChild(partEl);\n            });\n            return new XMLSerializer().serializeToString(doc);\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            method: options.method,\n            contentType: \"application/xml; charset=UTF-8\",\n            endpointStore: options.endpointStore,\n            maxConnections: options.maxConnections,\n            allowXRequestedWithAndCacheControl: false,\n            log: options.log,\n            onComplete: handleCompleteRequestComplete,\n            successfulResponseCodes: {\n                POST: [ 200 ]\n            }\n        }));\n        qq.extend(this, {\n            send: function(id, uploadId, etagEntries) {\n                var promise = new qq.Promise(), body = getCompleteRequestBody(etagEntries);\n                getHeaders(id, uploadId, body).then(function(headers, endOfUrl) {\n                    options.log(\"Submitting S3 complete multipart upload request for \" + id);\n                    pendingCompleteRequests[id] = promise;\n                    delete headers[\"Content-Type\"];\n                    requester.initTransport(id).withPath(endOfUrl).withHeaders(headers).withPayload(body).send();\n                }, promise.failure);\n                return promise;\n            }\n        });\n    };\n    qq.s3.AbortMultipartAjaxRequester = function(o) {\n        \"use strict\";\n        var requester, options = {\n            method: \"DELETE\",\n            endpointStore: null,\n            signatureSpec: null,\n            maxConnections: 3,\n            getBucket: function(id) {},\n            getHost: function(id) {},\n            getKey: function(id) {},\n            log: function(str, level) {}\n        }, getSignatureAjaxRequester;\n        qq.extend(options, o);\n        getSignatureAjaxRequester = new qq.s3.RequestSigner({\n            endpointStore: options.endpointStore,\n            signatureSpec: options.signatureSpec,\n            cors: options.cors,\n            log: options.log\n        });\n        function getHeaders(id, uploadId) {\n            var headers = {}, promise = new qq.Promise(), bucket = options.getBucket(id), host = options.getHost(id), signatureConstructor = getSignatureAjaxRequester.constructStringToSign(getSignatureAjaxRequester.REQUEST_TYPE.MULTIPART_ABORT, bucket, host, options.getKey(id)).withUploadId(uploadId);\n            getSignatureAjaxRequester.getSignature(id, {\n                signatureConstructor: signatureConstructor\n            }).then(promise.success, promise.failure);\n            return promise;\n        }\n        function handleAbortRequestComplete(id, xhr, isError) {\n            var domParser = new DOMParser(), responseDoc = domParser.parseFromString(xhr.responseText, \"application/xml\"), errorEls = responseDoc.getElementsByTagName(\"Error\"), awsErrorMsg;\n            options.log(qq.format(\"Abort response status {}, body = {}\", xhr.status, xhr.responseText));\n            if (isError) {\n                options.log(qq.format(\"Abort Multipart Upload request for {} failed with status {}.\", id, xhr.status), \"error\");\n            } else {\n                if (errorEls.length) {\n                    isError = true;\n                    awsErrorMsg = responseDoc.getElementsByTagName(\"Message\")[0].textContent;\n                    options.log(qq.format(\"Failed to Abort Multipart Upload request for {}.  Error: {}\", id, awsErrorMsg), \"error\");\n                } else {\n                    options.log(qq.format(\"Abort MPU request succeeded for file ID {}.\", id));\n                }\n            }\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            validMethods: [ \"DELETE\" ],\n            method: options.method,\n            contentType: null,\n            endpointStore: options.endpointStore,\n            maxConnections: options.maxConnections,\n            allowXRequestedWithAndCacheControl: false,\n            log: options.log,\n            onComplete: handleAbortRequestComplete,\n            successfulResponseCodes: {\n                DELETE: [ 204 ]\n            }\n        }));\n        qq.extend(this, {\n            send: function(id, uploadId) {\n                getHeaders(id, uploadId).then(function(headers, endOfUrl) {\n                    options.log(\"Submitting S3 Abort multipart upload request for \" + id);\n                    requester.initTransport(id).withPath(endOfUrl).withHeaders(headers).send();\n                });\n            }\n        });\n    };\n    qq.s3.XhrUploadHandler = function(spec, proxy) {\n        \"use strict\";\n        var getName = proxy.getName, log = proxy.log, clockDrift = spec.clockDrift, expectedStatus = 200, onGetBucket = spec.getBucket, onGetHost = spec.getHost, onGetKeyName = spec.getKeyName, filenameParam = spec.filenameParam, paramsStore = spec.paramsStore, endpointStore = spec.endpointStore, aclStore = spec.aclStore, reducedRedundancy = spec.objectProperties.reducedRedundancy, region = spec.objectProperties.region, serverSideEncryption = spec.objectProperties.serverSideEncryption, validation = spec.validation, signature = qq.extend({\n            region: region,\n            drift: clockDrift\n        }, spec.signature), handler = this, credentialsProvider = spec.signature.credentialsProvider, chunked = {\n            combine: function(id) {\n                var uploadId = handler._getPersistableData(id).uploadId, etagMap = handler._getPersistableData(id).etags, result = new qq.Promise();\n                requesters.completeMultipart.send(id, uploadId, etagMap).then(result.success, function failure(reason, xhr) {\n                    result.failure(upload.done(id, xhr).response, xhr);\n                });\n                return result;\n            },\n            done: function(id, xhr, chunkIdx) {\n                var response = upload.response.parse(id, xhr), etag;\n                if (response.success) {\n                    etag = xhr.getResponseHeader(\"ETag\");\n                    if (!handler._getPersistableData(id).etags) {\n                        handler._getPersistableData(id).etags = [];\n                    }\n                    handler._getPersistableData(id).etags.push({\n                        part: chunkIdx + 1,\n                        etag: etag\n                    });\n                }\n            },\n            initHeaders: function(id, chunkIdx, blob) {\n                var headers = {}, bucket = upload.bucket.getName(id), host = upload.host.getName(id), key = upload.key.urlSafe(id), promise = new qq.Promise(), signatureConstructor = requesters.restSignature.constructStringToSign(requesters.restSignature.REQUEST_TYPE.MULTIPART_UPLOAD, bucket, host, key).withPartNum(chunkIdx + 1).withContent(blob).withUploadId(handler._getPersistableData(id).uploadId);\n                requesters.restSignature.getSignature(id + \".\" + chunkIdx, {\n                    signatureConstructor: signatureConstructor\n                }).then(promise.success, promise.failure);\n                return promise;\n            },\n            put: function(id, chunkIdx) {\n                var xhr = handler._createXhr(id, chunkIdx), chunkData = handler._getChunkData(id, chunkIdx), domain = spec.endpointStore.get(id), promise = new qq.Promise();\n                chunked.initHeaders(id, chunkIdx, chunkData.blob).then(function(headers, endOfUrl) {\n                    if (xhr._cancelled) {\n                        log(qq.format(\"Upload of item {}.{} cancelled. Upload will not start after successful signature request.\", id, chunkIdx));\n                        promise.failure({\n                            error: \"Chunk upload cancelled\"\n                        });\n                    } else {\n                        var url = domain + \"/\" + endOfUrl;\n                        handler._registerProgressHandler(id, chunkIdx, chunkData.size);\n                        upload.track(id, xhr, chunkIdx).then(promise.success, promise.failure);\n                        xhr.open(\"PUT\", url, true);\n                        qq.each(headers, function(name, val) {\n                            xhr.setRequestHeader(name, val);\n                        });\n                        xhr.send(chunkData.blob);\n                    }\n                }, function() {\n                    promise.failure({\n                        error: \"Problem signing the chunk!\"\n                    }, xhr);\n                });\n                return promise;\n            },\n            send: function(id, chunkIdx) {\n                var promise = new qq.Promise();\n                chunked.setup(id).then(function() {\n                    chunked.put(id, chunkIdx).then(promise.success, promise.failure);\n                }, function(errorMessage, xhr) {\n                    promise.failure({\n                        error: errorMessage\n                    }, xhr);\n                });\n                return promise;\n            },\n            setup: function(id) {\n                var promise = new qq.Promise(), uploadId = handler._getPersistableData(id).uploadId, uploadIdPromise = new qq.Promise();\n                if (!uploadId) {\n                    handler._getPersistableData(id).uploadId = uploadIdPromise;\n                    requesters.initiateMultipart.send(id).then(function(uploadId) {\n                        handler._getPersistableData(id).uploadId = uploadId;\n                        uploadIdPromise.success(uploadId);\n                        promise.success(uploadId);\n                    }, function(errorMsg, xhr) {\n                        handler._getPersistableData(id).uploadId = null;\n                        promise.failure(errorMsg, xhr);\n                        uploadIdPromise.failure(errorMsg, xhr);\n                    });\n                } else if (uploadId instanceof qq.Promise) {\n                    uploadId.then(function(uploadId) {\n                        promise.success(uploadId);\n                    });\n                } else {\n                    promise.success(uploadId);\n                }\n                return promise;\n            }\n        }, requesters = {\n            abortMultipart: new qq.s3.AbortMultipartAjaxRequester({\n                endpointStore: endpointStore,\n                signatureSpec: signature,\n                cors: spec.cors,\n                log: log,\n                getBucket: function(id) {\n                    return upload.bucket.getName(id);\n                },\n                getHost: function(id) {\n                    return upload.host.getName(id);\n                },\n                getKey: function(id) {\n                    return upload.key.urlSafe(id);\n                }\n            }),\n            completeMultipart: new qq.s3.CompleteMultipartAjaxRequester({\n                endpointStore: endpointStore,\n                signatureSpec: signature,\n                cors: spec.cors,\n                log: log,\n                getBucket: function(id) {\n                    return upload.bucket.getName(id);\n                },\n                getHost: function(id) {\n                    return upload.host.getName(id);\n                },\n                getKey: function(id) {\n                    return upload.key.urlSafe(id);\n                }\n            }),\n            initiateMultipart: new qq.s3.InitiateMultipartAjaxRequester({\n                filenameParam: filenameParam,\n                endpointStore: endpointStore,\n                paramsStore: paramsStore,\n                signatureSpec: signature,\n                aclStore: aclStore,\n                reducedRedundancy: reducedRedundancy,\n                serverSideEncryption: serverSideEncryption,\n                cors: spec.cors,\n                log: log,\n                getContentType: function(id) {\n                    return handler._getMimeType(id);\n                },\n                getBucket: function(id) {\n                    return upload.bucket.getName(id);\n                },\n                getHost: function(id) {\n                    return upload.host.getName(id);\n                },\n                getKey: function(id) {\n                    return upload.key.urlSafe(id);\n                },\n                getName: function(id) {\n                    return getName(id);\n                }\n            }),\n            policySignature: new qq.s3.RequestSigner({\n                expectingPolicy: true,\n                signatureSpec: signature,\n                cors: spec.cors,\n                log: log\n            }),\n            restSignature: new qq.s3.RequestSigner({\n                endpointStore: endpointStore,\n                signatureSpec: signature,\n                cors: spec.cors,\n                log: log\n            })\n        }, simple = {\n            initParams: function(id) {\n                var customParams = paramsStore.get(id);\n                customParams[filenameParam] = getName(id);\n                return qq.s3.util.generateAwsParams({\n                    endpoint: endpointStore.get(id),\n                    clockDrift: clockDrift,\n                    params: customParams,\n                    type: handler._getMimeType(id),\n                    bucket: upload.bucket.getName(id),\n                    key: handler.getThirdPartyFileId(id),\n                    accessKey: credentialsProvider.get().accessKey,\n                    sessionToken: credentialsProvider.get().sessionToken,\n                    acl: aclStore.get(id),\n                    expectedStatus: expectedStatus,\n                    minFileSize: validation.minSizeLimit,\n                    maxFileSize: validation.maxSizeLimit,\n                    reducedRedundancy: reducedRedundancy,\n                    region: region,\n                    serverSideEncryption: serverSideEncryption,\n                    signatureVersion: signature.version,\n                    log: log\n                }, qq.bind(requesters.policySignature.getSignature, this, id));\n            },\n            send: function(id) {\n                var promise = new qq.Promise(), xhr = handler._createXhr(id), fileOrBlob = handler.getFile(id);\n                handler._registerProgressHandler(id);\n                upload.track(id, xhr).then(promise.success, promise.failure);\n                simple.setup(id, xhr, fileOrBlob).then(function(toSend) {\n                    log(\"Sending upload request for \" + id);\n                    xhr.send(toSend);\n                }, promise.failure);\n                return promise;\n            },\n            setup: function(id, xhr, fileOrBlob) {\n                var formData = new FormData(), endpoint = endpointStore.get(id), url = endpoint, promise = new qq.Promise();\n                simple.initParams(id).then(function(awsParams) {\n                    xhr.open(\"POST\", url, true);\n                    qq.obj2FormData(awsParams, formData);\n                    formData.append(\"file\", fileOrBlob);\n                    promise.success(formData);\n                }, function(errorMessage) {\n                    promise.failure({\n                        error: errorMessage\n                    });\n                });\n                return promise;\n            }\n        }, upload = {\n            bucket: {\n                promise: function(id) {\n                    var promise = new qq.Promise(), cachedBucket = handler._getFileState(id).bucket;\n                    if (cachedBucket) {\n                        promise.success(cachedBucket);\n                    } else {\n                        onGetBucket(id).then(function(bucket) {\n                            handler._getFileState(id).bucket = bucket;\n                            promise.success(bucket);\n                        }, promise.failure);\n                    }\n                    return promise;\n                },\n                getName: function(id) {\n                    return handler._getFileState(id).bucket;\n                }\n            },\n            host: {\n                promise: function(id) {\n                    var promise = new qq.Promise(), cachedHost = handler._getFileState(id).host;\n                    if (cachedHost) {\n                        promise.success(cachedHost);\n                    } else {\n                        onGetHost(id).then(function(host) {\n                            handler._getFileState(id).host = host;\n                            promise.success(host);\n                        }, promise.failure);\n                    }\n                    return promise;\n                },\n                getName: function(id) {\n                    return handler._getFileState(id).host;\n                }\n            },\n            done: function(id, xhr) {\n                var response = upload.response.parse(id, xhr), isError = response.success !== true;\n                if (isError && upload.response.shouldReset(response.code)) {\n                    log(\"This is an unrecoverable error, we must restart the upload entirely on the next retry attempt.\", \"error\");\n                    response.reset = true;\n                }\n                return {\n                    success: !isError,\n                    response: response\n                };\n            },\n            key: {\n                promise: function(id) {\n                    var promise = new qq.Promise(), key = handler.getThirdPartyFileId(id);\n                    if (key == null) {\n                        handler._setThirdPartyFileId(id, promise);\n                        onGetKeyName(id, getName(id)).then(function(keyName) {\n                            handler._setThirdPartyFileId(id, keyName);\n                            promise.success(keyName);\n                        }, function(errorReason) {\n                            handler._setThirdPartyFileId(id, null);\n                            promise.failure(errorReason);\n                        });\n                    } else if (qq.isGenericPromise(key)) {\n                        key.then(promise.success, promise.failure);\n                    } else {\n                        promise.success(key);\n                    }\n                    return promise;\n                },\n                urlSafe: function(id) {\n                    var encodedKey = handler.getThirdPartyFileId(id);\n                    return qq.s3.util.uriEscapePath(encodedKey);\n                }\n            },\n            response: {\n                parse: function(id, xhr) {\n                    var response = {}, parsedErrorProps;\n                    try {\n                        log(qq.format(\"Received response status {} with body: {}\", xhr.status, xhr.responseText));\n                        if (xhr.status === expectedStatus) {\n                            response.success = true;\n                        } else {\n                            parsedErrorProps = upload.response.parseError(xhr.responseText);\n                            if (parsedErrorProps) {\n                                response.error = parsedErrorProps.message;\n                                response.code = parsedErrorProps.code;\n                            }\n                        }\n                    } catch (error) {\n                        log(\"Error when attempting to parse xhr response text (\" + error.message + \")\", \"error\");\n                    }\n                    return response;\n                },\n                parseError: function(awsResponseXml) {\n                    var parser = new DOMParser(), parsedDoc = parser.parseFromString(awsResponseXml, \"application/xml\"), errorEls = parsedDoc.getElementsByTagName(\"Error\"), errorDetails = {}, codeEls, messageEls;\n                    if (errorEls.length) {\n                        codeEls = parsedDoc.getElementsByTagName(\"Code\");\n                        messageEls = parsedDoc.getElementsByTagName(\"Message\");\n                        if (messageEls.length) {\n                            errorDetails.message = messageEls[0].textContent;\n                        }\n                        if (codeEls.length) {\n                            errorDetails.code = codeEls[0].textContent;\n                        }\n                        return errorDetails;\n                    }\n                },\n                shouldReset: function(errorCode) {\n                    return errorCode === \"EntityTooSmall\" || errorCode === \"InvalidPart\" || errorCode === \"InvalidPartOrder\" || errorCode === \"NoSuchUpload\";\n                }\n            },\n            start: function(id, optChunkIdx) {\n                var promise = new qq.Promise();\n                upload.key.promise(id).then(function() {\n                    upload.bucket.promise(id).then(function() {\n                        upload.host.promise(id).then(function() {\n                            if (optChunkIdx == null) {\n                                simple.send(id).then(promise.success, promise.failure);\n                            } else {\n                                chunked.send(id, optChunkIdx).then(promise.success, promise.failure);\n                            }\n                        });\n                    });\n                }, function(errorReason) {\n                    promise.failure({\n                        error: errorReason\n                    });\n                });\n                return promise;\n            },\n            track: function(id, xhr, optChunkIdx) {\n                var promise = new qq.Promise();\n                xhr.onreadystatechange = function() {\n                    if (xhr.readyState === 4) {\n                        var result;\n                        if (optChunkIdx == null) {\n                            result = upload.done(id, xhr);\n                            promise[result.success ? \"success\" : \"failure\"](result.response, xhr);\n                        } else {\n                            chunked.done(id, xhr, optChunkIdx);\n                            result = upload.done(id, xhr);\n                            promise[result.success ? \"success\" : \"failure\"](result.response, xhr);\n                        }\n                    }\n                };\n                return promise;\n            }\n        };\n        qq.extend(this, {\n            uploadChunk: upload.start,\n            uploadFile: upload.start\n        });\n        qq.extend(this, new qq.XhrUploadHandler({\n            options: qq.extend({\n                namespace: \"s3\"\n            }, spec),\n            proxy: qq.extend({\n                getEndpoint: spec.endpointStore.get\n            }, proxy)\n        }));\n        qq.override(this, function(super_) {\n            return {\n                expunge: function(id) {\n                    var uploadId = handler._getPersistableData(id) && handler._getPersistableData(id).uploadId, existedInLocalStorage = handler._maybeDeletePersistedChunkData(id);\n                    if (uploadId !== undefined && existedInLocalStorage) {\n                        requesters.abortMultipart.send(id, uploadId);\n                    }\n                    super_.expunge(id);\n                },\n                finalizeChunks: function(id) {\n                    return chunked.combine(id);\n                },\n                _getLocalStorageId: function(id) {\n                    var baseStorageId = super_._getLocalStorageId(id), bucketName = upload.bucket.getName(id);\n                    return baseStorageId + \"-\" + bucketName;\n                }\n            };\n        });\n    };\n    qq.s3.FormUploadHandler = function(options, proxy) {\n        \"use strict\";\n        var handler = this, clockDrift = options.clockDrift, onUuidChanged = proxy.onUuidChanged, getName = proxy.getName, getUuid = proxy.getUuid, log = proxy.log, onGetBucket = options.getBucket, onGetKeyName = options.getKeyName, filenameParam = options.filenameParam, paramsStore = options.paramsStore, endpointStore = options.endpointStore, aclStore = options.aclStore, reducedRedundancy = options.objectProperties.reducedRedundancy, region = options.objectProperties.region, serverSideEncryption = options.objectProperties.serverSideEncryption, validation = options.validation, signature = options.signature, successRedirectUrl = options.iframeSupport.localBlankPagePath, credentialsProvider = options.signature.credentialsProvider, getSignatureAjaxRequester = new qq.s3.RequestSigner({\n            signatureSpec: signature,\n            cors: options.cors,\n            log: log\n        });\n        if (successRedirectUrl === undefined) {\n            throw new Error(\"successRedirectEndpoint MUST be defined if you intend to use browsers that do not support the File API!\");\n        }\n        function isValidResponse(id, iframe) {\n            var response, endpoint = options.endpointStore.get(id), bucket = handler._getFileState(id).bucket, doc, innerHtml, responseData;\n            try {\n                doc = iframe.contentDocument || iframe.contentWindow.document;\n                innerHtml = doc.body.innerHTML;\n                responseData = qq.s3.util.parseIframeResponse(iframe);\n                if (responseData.bucket === bucket && responseData.key === qq.s3.util.encodeQueryStringParam(handler.getThirdPartyFileId(id))) {\n                    return true;\n                }\n                log(\"Response from AWS included an unexpected bucket or key name.\", \"error\");\n            } catch (error) {\n                log(\"Error when attempting to parse form upload response (\" + error.message + \")\", \"error\");\n            }\n            return false;\n        }\n        function generateAwsParams(id) {\n            var customParams = paramsStore.get(id);\n            customParams[filenameParam] = getName(id);\n            return qq.s3.util.generateAwsParams({\n                endpoint: endpointStore.get(id),\n                clockDrift: clockDrift,\n                params: customParams,\n                bucket: handler._getFileState(id).bucket,\n                key: handler.getThirdPartyFileId(id),\n                accessKey: credentialsProvider.get().accessKey,\n                sessionToken: credentialsProvider.get().sessionToken,\n                acl: aclStore.get(id),\n                minFileSize: validation.minSizeLimit,\n                maxFileSize: validation.maxSizeLimit,\n                successRedirectUrl: successRedirectUrl,\n                reducedRedundancy: reducedRedundancy,\n                region: region,\n                serverSideEncryption: serverSideEncryption,\n                signatureVersion: signature.version,\n                log: log\n            }, qq.bind(getSignatureAjaxRequester.getSignature, this, id));\n        }\n        function createForm(id, iframe) {\n            var promise = new qq.Promise(), method = \"POST\", endpoint = options.endpointStore.get(id), fileName = getName(id);\n            generateAwsParams(id).then(function(params) {\n                var form = handler._initFormForUpload({\n                    method: method,\n                    endpoint: endpoint,\n                    params: params,\n                    paramsInBody: true,\n                    targetName: iframe.name\n                });\n                promise.success(form);\n            }, function(errorMessage) {\n                promise.failure(errorMessage);\n                handleFinishedUpload(id, iframe, fileName, {\n                    error: errorMessage\n                });\n            });\n            return promise;\n        }\n        function handleUpload(id) {\n            var iframe = handler._createIframe(id), input = handler.getInput(id), promise = new qq.Promise();\n            createForm(id, iframe).then(function(form) {\n                form.appendChild(input);\n                handler._attachLoadEvent(iframe, function(response) {\n                    log(\"iframe loaded\");\n                    if (response) {\n                        if (response.success === false) {\n                            log(\"Amazon likely rejected the upload request\", \"error\");\n                            promise.failure(response);\n                        }\n                    } else {\n                        response = {};\n                        response.success = isValidResponse(id, iframe);\n                        if (response.success === false) {\n                            log(\"A success response was received by Amazon, but it was invalid in some way.\", \"error\");\n                            promise.failure(response);\n                        } else {\n                            qq.extend(response, qq.s3.util.parseIframeResponse(iframe));\n                            promise.success(response);\n                        }\n                    }\n                    handleFinishedUpload(id, iframe);\n                });\n                log(\"Sending upload request for \" + id);\n                form.submit();\n                qq(form).remove();\n            }, promise.failure);\n            return promise;\n        }\n        function handleFinishedUpload(id, iframe) {\n            handler._detachLoadEvent(id);\n            iframe && qq(iframe).remove();\n        }\n        qq.extend(this, new qq.FormUploadHandler({\n            options: {\n                isCors: false,\n                inputName: \"file\"\n            },\n            proxy: {\n                onCancel: options.onCancel,\n                onUuidChanged: onUuidChanged,\n                getName: getName,\n                getUuid: getUuid,\n                log: log\n            }\n        }));\n        qq.extend(this, {\n            uploadFile: function(id) {\n                var name = getName(id), promise = new qq.Promise();\n                if (handler.getThirdPartyFileId(id)) {\n                    if (handler._getFileState(id).bucket) {\n                        handleUpload(id).then(promise.success, promise.failure);\n                    } else {\n                        onGetBucket(id).then(function(bucket) {\n                            handler._getFileState(id).bucket = bucket;\n                            handleUpload(id).then(promise.success, promise.failure);\n                        });\n                    }\n                } else {\n                    onGetKeyName(id, name).then(function(key) {\n                        onGetBucket(id).then(function(bucket) {\n                            handler._getFileState(id).bucket = bucket;\n                            handler._setThirdPartyFileId(id, key);\n                            handleUpload(id).then(promise.success, promise.failure);\n                        }, function(errorReason) {\n                            promise.failure({\n                                error: errorReason\n                            });\n                        });\n                    }, function(errorReason) {\n                        promise.failure({\n                            error: errorReason\n                        });\n                    });\n                }\n                return promise;\n            }\n        });\n    };\n    qq.DragAndDrop = function(o) {\n        \"use strict\";\n        var options, HIDE_ZONES_EVENT_NAME = \"qq-hidezones\", HIDE_BEFORE_ENTER_ATTR = \"qq-hide-dropzone\", uploadDropZones = [], droppedFiles = [], disposeSupport = new qq.DisposeSupport();\n        options = {\n            dropZoneElements: [],\n            allowMultipleItems: true,\n            classes: {\n                dropActive: null\n            },\n            callbacks: new qq.DragAndDrop.callbacks()\n        };\n        qq.extend(options, o, true);\n        function uploadDroppedFiles(files, uploadDropZone) {\n            var filesAsArray = Array.prototype.slice.call(files);\n            options.callbacks.dropLog(\"Grabbed \" + files.length + \" dropped files.\");\n            uploadDropZone.dropDisabled(false);\n            options.callbacks.processingDroppedFilesComplete(filesAsArray, uploadDropZone.getElement());\n        }\n        function traverseFileTree(entry) {\n            var parseEntryPromise = new qq.Promise();\n            if (entry.isFile) {\n                entry.file(function(file) {\n                    var name = entry.name, fullPath = entry.fullPath, indexOfNameInFullPath = fullPath.indexOf(name);\n                    fullPath = fullPath.substr(0, indexOfNameInFullPath);\n                    if (fullPath.charAt(0) === \"/\") {\n                        fullPath = fullPath.substr(1);\n                    }\n                    file.qqPath = fullPath;\n                    droppedFiles.push(file);\n                    parseEntryPromise.success();\n                }, function(fileError) {\n                    options.callbacks.dropLog(\"Problem parsing '\" + entry.fullPath + \"'.  FileError code \" + fileError.code + \".\", \"error\");\n                    parseEntryPromise.failure();\n                });\n            } else if (entry.isDirectory) {\n                getFilesInDirectory(entry).then(function allEntriesRead(entries) {\n                    var entriesLeft = entries.length;\n                    qq.each(entries, function(idx, entry) {\n                        traverseFileTree(entry).done(function() {\n                            entriesLeft -= 1;\n                            if (entriesLeft === 0) {\n                                parseEntryPromise.success();\n                            }\n                        });\n                    });\n                    if (!entries.length) {\n                        parseEntryPromise.success();\n                    }\n                }, function readFailure(fileError) {\n                    options.callbacks.dropLog(\"Problem parsing '\" + entry.fullPath + \"'.  FileError code \" + fileError.code + \".\", \"error\");\n                    parseEntryPromise.failure();\n                });\n            }\n            return parseEntryPromise;\n        }\n        function getFilesInDirectory(entry, reader, accumEntries, existingPromise) {\n            var promise = existingPromise || new qq.Promise(), dirReader = reader || entry.createReader();\n            dirReader.readEntries(function readSuccess(entries) {\n                var newEntries = accumEntries ? accumEntries.concat(entries) : entries;\n                if (entries.length) {\n                    setTimeout(function() {\n                        getFilesInDirectory(entry, dirReader, newEntries, promise);\n                    }, 0);\n                } else {\n                    promise.success(newEntries);\n                }\n            }, promise.failure);\n            return promise;\n        }\n        function handleDataTransfer(dataTransfer, uploadDropZone) {\n            var pendingFolderPromises = [], handleDataTransferPromise = new qq.Promise();\n            options.callbacks.processingDroppedFiles();\n            uploadDropZone.dropDisabled(true);\n            if (dataTransfer.files.length > 1 && !options.allowMultipleItems) {\n                options.callbacks.processingDroppedFilesComplete([]);\n                options.callbacks.dropError(\"tooManyFilesError\", \"\");\n                uploadDropZone.dropDisabled(false);\n                handleDataTransferPromise.failure();\n            } else {\n                droppedFiles = [];\n                if (qq.isFolderDropSupported(dataTransfer)) {\n                    qq.each(dataTransfer.items, function(idx, item) {\n                        var entry = item.webkitGetAsEntry();\n                        if (entry) {\n                            if (entry.isFile) {\n                                droppedFiles.push(item.getAsFile());\n                            } else {\n                                pendingFolderPromises.push(traverseFileTree(entry).done(function() {\n                                    pendingFolderPromises.pop();\n                                    if (pendingFolderPromises.length === 0) {\n                                        handleDataTransferPromise.success();\n                                    }\n                                }));\n                            }\n                        }\n                    });\n                } else {\n                    droppedFiles = dataTransfer.files;\n                }\n                if (pendingFolderPromises.length === 0) {\n                    handleDataTransferPromise.success();\n                }\n            }\n            return handleDataTransferPromise;\n        }\n        function setupDropzone(dropArea) {\n            var dropZone = new qq.UploadDropZone({\n                HIDE_ZONES_EVENT_NAME: HIDE_ZONES_EVENT_NAME,\n                element: dropArea,\n                onEnter: function(e) {\n                    qq(dropArea).addClass(options.classes.dropActive);\n                    e.stopPropagation();\n                },\n                onLeaveNotDescendants: function(e) {\n                    qq(dropArea).removeClass(options.classes.dropActive);\n                },\n                onDrop: function(e) {\n                    handleDataTransfer(e.dataTransfer, dropZone).then(function() {\n                        uploadDroppedFiles(droppedFiles, dropZone);\n                    }, function() {\n                        options.callbacks.dropLog(\"Drop event DataTransfer parsing failed.  No files will be uploaded.\", \"error\");\n                    });\n                }\n            });\n            disposeSupport.addDisposer(function() {\n                dropZone.dispose();\n            });\n            qq(dropArea).hasAttribute(HIDE_BEFORE_ENTER_ATTR) && qq(dropArea).hide();\n            uploadDropZones.push(dropZone);\n            return dropZone;\n        }\n        function isFileDrag(dragEvent) {\n            var fileDrag;\n            qq.each(dragEvent.dataTransfer.types, function(key, val) {\n                if (val === \"Files\") {\n                    fileDrag = true;\n                    return false;\n                }\n            });\n            return fileDrag;\n        }\n        function leavingDocumentOut(e) {\n            if (qq.firefox()) {\n                return !e.relatedTarget;\n            }\n            if (qq.safari()) {\n                return e.x < 0 || e.y < 0;\n            }\n            return e.x === 0 && e.y === 0;\n        }\n        function setupDragDrop() {\n            var dropZones = options.dropZoneElements, maybeHideDropZones = function() {\n                setTimeout(function() {\n                    qq.each(dropZones, function(idx, dropZone) {\n                        qq(dropZone).hasAttribute(HIDE_BEFORE_ENTER_ATTR) && qq(dropZone).hide();\n                        qq(dropZone).removeClass(options.classes.dropActive);\n                    });\n                }, 10);\n            };\n            qq.each(dropZones, function(idx, dropZone) {\n                var uploadDropZone = setupDropzone(dropZone);\n                if (dropZones.length && qq.supportedFeatures.fileDrop) {\n                    disposeSupport.attach(document, \"dragenter\", function(e) {\n                        if (!uploadDropZone.dropDisabled() && isFileDrag(e)) {\n                            qq.each(dropZones, function(idx, dropZone) {\n                                if (dropZone instanceof HTMLElement && qq(dropZone).hasAttribute(HIDE_BEFORE_ENTER_ATTR)) {\n                                    qq(dropZone).css({\n                                        display: \"block\"\n                                    });\n                                }\n                            });\n                        }\n                    });\n                }\n            });\n            disposeSupport.attach(document, \"dragleave\", function(e) {\n                if (leavingDocumentOut(e)) {\n                    maybeHideDropZones();\n                }\n            });\n            disposeSupport.attach(qq(document).children()[0], \"mouseenter\", function(e) {\n                maybeHideDropZones();\n            });\n            disposeSupport.attach(document, \"drop\", function(e) {\n                e.preventDefault();\n                maybeHideDropZones();\n            });\n            disposeSupport.attach(document, HIDE_ZONES_EVENT_NAME, maybeHideDropZones);\n        }\n        setupDragDrop();\n        qq.extend(this, {\n            setupExtraDropzone: function(element) {\n                options.dropZoneElements.push(element);\n                setupDropzone(element);\n            },\n            removeDropzone: function(element) {\n                var i, dzs = options.dropZoneElements;\n                for (i in dzs) {\n                    if (dzs[i] === element) {\n                        return dzs.splice(i, 1);\n                    }\n                }\n            },\n            dispose: function() {\n                disposeSupport.dispose();\n                qq.each(uploadDropZones, function(idx, dropZone) {\n                    dropZone.dispose();\n                });\n            }\n        });\n    };\n    qq.DragAndDrop.callbacks = function() {\n        \"use strict\";\n        return {\n            processingDroppedFiles: function() {},\n            processingDroppedFilesComplete: function(files, targetEl) {},\n            dropError: function(code, errorSpecifics) {\n                qq.log(\"Drag & drop error code '\" + code + \" with these specifics: '\" + errorSpecifics + \"'\", \"error\");\n            },\n            dropLog: function(message, level) {\n                qq.log(message, level);\n            }\n        };\n    };\n    qq.UploadDropZone = function(o) {\n        \"use strict\";\n        var disposeSupport = new qq.DisposeSupport(), options, element, preventDrop, dropOutsideDisabled;\n        options = {\n            element: null,\n            onEnter: function(e) {},\n            onLeave: function(e) {},\n            onLeaveNotDescendants: function(e) {},\n            onDrop: function(e) {}\n        };\n        qq.extend(options, o);\n        element = options.element;\n        function dragoverShouldBeCanceled() {\n            return qq.safari() || qq.firefox() && qq.windows();\n        }\n        function disableDropOutside(e) {\n            if (!dropOutsideDisabled) {\n                if (dragoverShouldBeCanceled) {\n                    disposeSupport.attach(document, \"dragover\", function(e) {\n                        e.preventDefault();\n                    });\n                } else {\n                    disposeSupport.attach(document, \"dragover\", function(e) {\n                        if (e.dataTransfer) {\n                            e.dataTransfer.dropEffect = \"none\";\n                            e.preventDefault();\n                        }\n                    });\n                }\n                dropOutsideDisabled = true;\n            }\n        }\n        function isValidFileDrag(e) {\n            if (!qq.supportedFeatures.fileDrop) {\n                return false;\n            }\n            var effectTest, dt = e.dataTransfer, isSafari = qq.safari();\n            effectTest = qq.ie() && qq.supportedFeatures.fileDrop ? true : dt.effectAllowed !== \"none\";\n            return dt && effectTest && (dt.files || !isSafari && dt.types.contains && dt.types.contains(\"Files\"));\n        }\n        function isOrSetDropDisabled(isDisabled) {\n            if (isDisabled !== undefined) {\n                preventDrop = isDisabled;\n            }\n            return preventDrop;\n        }\n        function triggerHidezonesEvent() {\n            var hideZonesEvent;\n            function triggerUsingOldApi() {\n                hideZonesEvent = document.createEvent(\"Event\");\n                hideZonesEvent.initEvent(options.HIDE_ZONES_EVENT_NAME, true, true);\n            }\n            if (window.CustomEvent) {\n                try {\n                    hideZonesEvent = new CustomEvent(options.HIDE_ZONES_EVENT_NAME);\n                } catch (err) {\n                    triggerUsingOldApi();\n                }\n            } else {\n                triggerUsingOldApi();\n            }\n            document.dispatchEvent(hideZonesEvent);\n        }\n        function attachEvents() {\n            disposeSupport.attach(element, \"dragover\", function(e) {\n                if (!isValidFileDrag(e)) {\n                    return;\n                }\n                var effect = qq.ie() && qq.supportedFeatures.fileDrop ? null : e.dataTransfer.effectAllowed;\n                if (effect === \"move\" || effect === \"linkMove\") {\n                    e.dataTransfer.dropEffect = \"move\";\n                } else {\n                    e.dataTransfer.dropEffect = \"copy\";\n                }\n                e.stopPropagation();\n                e.preventDefault();\n            });\n            disposeSupport.attach(element, \"dragenter\", function(e) {\n                if (!isOrSetDropDisabled()) {\n                    if (!isValidFileDrag(e)) {\n                        return;\n                    }\n                    options.onEnter(e);\n                }\n            });\n            disposeSupport.attach(element, \"dragleave\", function(e) {\n                if (!isValidFileDrag(e)) {\n                    return;\n                }\n                options.onLeave(e);\n                var relatedTarget = document.elementFromPoint(e.clientX, e.clientY);\n                if (qq(this).contains(relatedTarget)) {\n                    return;\n                }\n                options.onLeaveNotDescendants(e);\n            });\n            disposeSupport.attach(element, \"drop\", function(e) {\n                if (!isOrSetDropDisabled()) {\n                    if (!isValidFileDrag(e)) {\n                        return;\n                    }\n                    e.preventDefault();\n                    e.stopPropagation();\n                    options.onDrop(e);\n                    triggerHidezonesEvent();\n                }\n            });\n        }\n        disableDropOutside();\n        attachEvents();\n        qq.extend(this, {\n            dropDisabled: function(isDisabled) {\n                return isOrSetDropDisabled(isDisabled);\n            },\n            dispose: function() {\n                disposeSupport.dispose();\n            },\n            getElement: function() {\n                return element;\n            }\n        });\n    };\n    (function() {\n        \"use strict\";\n        qq.uiPublicApi = {\n            addInitialFiles: function(cannedFileList) {\n                this._parent.prototype.addInitialFiles.apply(this, arguments);\n                this._templating.addCacheToDom();\n            },\n            clearStoredFiles: function() {\n                this._parent.prototype.clearStoredFiles.apply(this, arguments);\n                this._templating.clearFiles();\n            },\n            addExtraDropzone: function(element) {\n                this._dnd && this._dnd.setupExtraDropzone(element);\n            },\n            removeExtraDropzone: function(element) {\n                if (this._dnd) {\n                    return this._dnd.removeDropzone(element);\n                }\n            },\n            getItemByFileId: function(id) {\n                if (!this._templating.isHiddenForever(id)) {\n                    return this._templating.getFileContainer(id);\n                }\n            },\n            reset: function() {\n                this._parent.prototype.reset.apply(this, arguments);\n                this._templating.reset();\n                if (!this._options.button && this._templating.getButton()) {\n                    this._defaultButtonId = this._createUploadButton({\n                        element: this._templating.getButton(),\n                        title: this._options.text.fileInputTitle\n                    }).getButtonId();\n                }\n                if (this._dnd) {\n                    this._dnd.dispose();\n                    this._dnd = this._setupDragAndDrop();\n                }\n                this._totalFilesInBatch = 0;\n                this._filesInBatchAddedToUi = 0;\n                this._setupClickAndEditEventHandlers();\n            },\n            setName: function(id, newName) {\n                var formattedFilename = this._options.formatFileName(newName);\n                this._parent.prototype.setName.apply(this, arguments);\n                this._templating.updateFilename(id, formattedFilename);\n            },\n            pauseUpload: function(id) {\n                var paused = this._parent.prototype.pauseUpload.apply(this, arguments);\n                paused && this._templating.uploadPaused(id);\n                return paused;\n            },\n            continueUpload: function(id) {\n                var continued = this._parent.prototype.continueUpload.apply(this, arguments);\n                continued && this._templating.uploadContinued(id);\n                return continued;\n            },\n            getId: function(fileContainerOrChildEl) {\n                return this._templating.getFileId(fileContainerOrChildEl);\n            },\n            getDropTarget: function(fileId) {\n                var file = this.getFile(fileId);\n                return file.qqDropTarget;\n            }\n        };\n        qq.uiPrivateApi = {\n            _getButton: function(buttonId) {\n                var button = this._parent.prototype._getButton.apply(this, arguments);\n                if (!button) {\n                    if (buttonId === this._defaultButtonId) {\n                        button = this._templating.getButton();\n                    }\n                }\n                return button;\n            },\n            _removeFileItem: function(fileId) {\n                this._templating.removeFile(fileId);\n            },\n            _setupClickAndEditEventHandlers: function() {\n                this._fileButtonsClickHandler = qq.FileButtonsClickHandler && this._bindFileButtonsClickEvent();\n                this._focusinEventSupported = !qq.firefox();\n                if (this._isEditFilenameEnabled()) {\n                    this._filenameClickHandler = this._bindFilenameClickEvent();\n                    this._filenameInputFocusInHandler = this._bindFilenameInputFocusInEvent();\n                    this._filenameInputFocusHandler = this._bindFilenameInputFocusEvent();\n                }\n            },\n            _setupDragAndDrop: function() {\n                var self = this, dropZoneElements = this._options.dragAndDrop.extraDropzones, templating = this._templating, defaultDropZone = templating.getDropZone();\n                defaultDropZone && dropZoneElements.push(defaultDropZone);\n                return new qq.DragAndDrop({\n                    dropZoneElements: dropZoneElements,\n                    allowMultipleItems: this._options.multiple,\n                    classes: {\n                        dropActive: this._options.classes.dropActive\n                    },\n                    callbacks: {\n                        processingDroppedFiles: function() {\n                            templating.showDropProcessing();\n                        },\n                        processingDroppedFilesComplete: function(files, targetEl) {\n                            templating.hideDropProcessing();\n                            qq.each(files, function(idx, file) {\n                                file.qqDropTarget = targetEl;\n                            });\n                            if (files.length) {\n                                self.addFiles(files, null, null);\n                            }\n                        },\n                        dropError: function(code, errorData) {\n                            self._itemError(code, errorData);\n                        },\n                        dropLog: function(message, level) {\n                            self.log(message, level);\n                        }\n                    }\n                });\n            },\n            _bindFileButtonsClickEvent: function() {\n                var self = this;\n                return new qq.FileButtonsClickHandler({\n                    templating: this._templating,\n                    log: function(message, lvl) {\n                        self.log(message, lvl);\n                    },\n                    onDeleteFile: function(fileId) {\n                        self.deleteFile(fileId);\n                    },\n                    onCancel: function(fileId) {\n                        self.cancel(fileId);\n                    },\n                    onRetry: function(fileId) {\n                        self.retry(fileId);\n                    },\n                    onPause: function(fileId) {\n                        self.pauseUpload(fileId);\n                    },\n                    onContinue: function(fileId) {\n                        self.continueUpload(fileId);\n                    },\n                    onGetName: function(fileId) {\n                        return self.getName(fileId);\n                    }\n                });\n            },\n            _isEditFilenameEnabled: function() {\n                return this._templating.isEditFilenamePossible() && !this._options.autoUpload && qq.FilenameClickHandler && qq.FilenameInputFocusHandler && qq.FilenameInputFocusHandler;\n            },\n            _filenameEditHandler: function() {\n                var self = this, templating = this._templating;\n                return {\n                    templating: templating,\n                    log: function(message, lvl) {\n                        self.log(message, lvl);\n                    },\n                    onGetUploadStatus: function(fileId) {\n                        return self.getUploads({\n                            id: fileId\n                        }).status;\n                    },\n                    onGetName: function(fileId) {\n                        return self.getName(fileId);\n                    },\n                    onSetName: function(id, newName) {\n                        self.setName(id, newName);\n                    },\n                    onEditingStatusChange: function(id, isEditing) {\n                        var qqInput = qq(templating.getEditInput(id)), qqFileContainer = qq(templating.getFileContainer(id));\n                        if (isEditing) {\n                            qqInput.addClass(\"qq-editing\");\n                            templating.hideFilename(id);\n                            templating.hideEditIcon(id);\n                        } else {\n                            qqInput.removeClass(\"qq-editing\");\n                            templating.showFilename(id);\n                            templating.showEditIcon(id);\n                        }\n                        qqFileContainer.addClass(\"qq-temp\").removeClass(\"qq-temp\");\n                    }\n                };\n            },\n            _onUploadStatusChange: function(id, oldStatus, newStatus) {\n                this._parent.prototype._onUploadStatusChange.apply(this, arguments);\n                if (this._isEditFilenameEnabled()) {\n                    if (this._templating.getFileContainer(id) && newStatus !== qq.status.SUBMITTED) {\n                        this._templating.markFilenameEditable(id);\n                        this._templating.hideEditIcon(id);\n                    }\n                }\n                if (oldStatus === qq.status.UPLOAD_RETRYING && newStatus === qq.status.UPLOADING) {\n                    this._templating.hideRetry(id);\n                    this._templating.setStatusText(id);\n                    qq(this._templating.getFileContainer(id)).removeClass(this._classes.retrying);\n                } else if (newStatus === qq.status.UPLOAD_FAILED) {\n                    this._templating.hidePause(id);\n                }\n            },\n            _bindFilenameInputFocusInEvent: function() {\n                var spec = qq.extend({}, this._filenameEditHandler());\n                return new qq.FilenameInputFocusInHandler(spec);\n            },\n            _bindFilenameInputFocusEvent: function() {\n                var spec = qq.extend({}, this._filenameEditHandler());\n                return new qq.FilenameInputFocusHandler(spec);\n            },\n            _bindFilenameClickEvent: function() {\n                var spec = qq.extend({}, this._filenameEditHandler());\n                return new qq.FilenameClickHandler(spec);\n            },\n            _storeForLater: function(id) {\n                this._parent.prototype._storeForLater.apply(this, arguments);\n                this._templating.hideSpinner(id);\n            },\n            _onAllComplete: function(successful, failed) {\n                this._parent.prototype._onAllComplete.apply(this, arguments);\n                this._templating.resetTotalProgress();\n            },\n            _onSubmit: function(id, name) {\n                var file = this.getFile(id);\n                if (file && file.qqPath && this._options.dragAndDrop.reportDirectoryPaths) {\n                    this._paramsStore.addReadOnly(id, {\n                        qqpath: file.qqPath\n                    });\n                }\n                this._parent.prototype._onSubmit.apply(this, arguments);\n                this._addToList(id, name);\n            },\n            _onSubmitted: function(id) {\n                if (this._isEditFilenameEnabled()) {\n                    this._templating.markFilenameEditable(id);\n                    this._templating.showEditIcon(id);\n                    if (!this._focusinEventSupported) {\n                        this._filenameInputFocusHandler.addHandler(this._templating.getEditInput(id));\n                    }\n                }\n            },\n            _onProgress: function(id, name, loaded, total) {\n                this._parent.prototype._onProgress.apply(this, arguments);\n                this._templating.updateProgress(id, loaded, total);\n                if (total === 0 || Math.round(loaded / total * 100) === 100) {\n                    this._templating.hideCancel(id);\n                    this._templating.hidePause(id);\n                    this._templating.hideProgress(id);\n                    this._templating.setStatusText(id, this._options.text.waitingForResponse);\n                    this._displayFileSize(id);\n                } else {\n                    this._displayFileSize(id, loaded, total);\n                }\n            },\n            _onTotalProgress: function(loaded, total) {\n                this._parent.prototype._onTotalProgress.apply(this, arguments);\n                this._templating.updateTotalProgress(loaded, total);\n            },\n            _onComplete: function(id, name, result, xhr) {\n                var parentRetVal = this._parent.prototype._onComplete.apply(this, arguments), templating = this._templating, fileContainer = templating.getFileContainer(id), self = this;\n                function completeUpload(result) {\n                    if (!fileContainer) {\n                        return;\n                    }\n                    templating.setStatusText(id);\n                    qq(fileContainer).removeClass(self._classes.retrying);\n                    templating.hideProgress(id);\n                    if (self.getUploads({\n                        id: id\n                    }).status !== qq.status.UPLOAD_FAILED) {\n                        templating.hideCancel(id);\n                    }\n                    templating.hideSpinner(id);\n                    if (result.success) {\n                        self._markFileAsSuccessful(id);\n                    } else {\n                        qq(fileContainer).addClass(self._classes.fail);\n                        templating.showCancel(id);\n                        if (templating.isRetryPossible() && !self._preventRetries[id]) {\n                            qq(fileContainer).addClass(self._classes.retryable);\n                            templating.showRetry(id);\n                        }\n                        self._controlFailureTextDisplay(id, result);\n                    }\n                }\n                if (parentRetVal instanceof qq.Promise) {\n                    parentRetVal.done(function(newResult) {\n                        completeUpload(newResult);\n                    });\n                } else {\n                    completeUpload(result);\n                }\n                return parentRetVal;\n            },\n            _markFileAsSuccessful: function(id) {\n                var templating = this._templating;\n                if (this._isDeletePossible()) {\n                    templating.showDeleteButton(id);\n                }\n                qq(templating.getFileContainer(id)).addClass(this._classes.success);\n                this._maybeUpdateThumbnail(id);\n            },\n            _onUploadPrep: function(id) {\n                this._parent.prototype._onUploadPrep.apply(this, arguments);\n                this._templating.showSpinner(id);\n            },\n            _onUpload: function(id, name) {\n                var parentRetVal = this._parent.prototype._onUpload.apply(this, arguments);\n                this._templating.showSpinner(id);\n                return parentRetVal;\n            },\n            _onUploadChunk: function(id, chunkData) {\n                this._parent.prototype._onUploadChunk.apply(this, arguments);\n                if (chunkData.partIndex > 0 && this._handler.isResumable(id)) {\n                    this._templating.allowPause(id);\n                }\n            },\n            _onCancel: function(id, name) {\n                this._parent.prototype._onCancel.apply(this, arguments);\n                this._removeFileItem(id);\n                if (this._getNotFinished() === 0) {\n                    this._templating.resetTotalProgress();\n                }\n            },\n            _onBeforeAutoRetry: function(id) {\n                var retryNumForDisplay, maxAuto, retryNote;\n                this._parent.prototype._onBeforeAutoRetry.apply(this, arguments);\n                this._showCancelLink(id);\n                if (this._options.retry.showAutoRetryNote) {\n                    retryNumForDisplay = this._autoRetries[id];\n                    maxAuto = this._options.retry.maxAutoAttempts;\n                    retryNote = this._options.retry.autoRetryNote.replace(/\\{retryNum\\}/g, retryNumForDisplay);\n                    retryNote = retryNote.replace(/\\{maxAuto\\}/g, maxAuto);\n                    this._templating.setStatusText(id, retryNote);\n                    qq(this._templating.getFileContainer(id)).addClass(this._classes.retrying);\n                }\n            },\n            _onBeforeManualRetry: function(id) {\n                if (this._parent.prototype._onBeforeManualRetry.apply(this, arguments)) {\n                    this._templating.resetProgress(id);\n                    qq(this._templating.getFileContainer(id)).removeClass(this._classes.fail);\n                    this._templating.setStatusText(id);\n                    this._templating.showSpinner(id);\n                    this._showCancelLink(id);\n                    return true;\n                } else {\n                    qq(this._templating.getFileContainer(id)).addClass(this._classes.retryable);\n                    this._templating.showRetry(id);\n                    return false;\n                }\n            },\n            _onSubmitDelete: function(id) {\n                var onSuccessCallback = qq.bind(this._onSubmitDeleteSuccess, this);\n                this._parent.prototype._onSubmitDelete.call(this, id, onSuccessCallback);\n            },\n            _onSubmitDeleteSuccess: function(id, uuid, additionalMandatedParams) {\n                if (this._options.deleteFile.forceConfirm) {\n                    this._showDeleteConfirm.apply(this, arguments);\n                } else {\n                    this._sendDeleteRequest.apply(this, arguments);\n                }\n            },\n            _onDeleteComplete: function(id, xhr, isError) {\n                this._parent.prototype._onDeleteComplete.apply(this, arguments);\n                this._templating.hideSpinner(id);\n                if (isError) {\n                    this._templating.setStatusText(id, this._options.deleteFile.deletingFailedText);\n                    this._templating.showDeleteButton(id);\n                } else {\n                    this._removeFileItem(id);\n                }\n            },\n            _sendDeleteRequest: function(id, uuid, additionalMandatedParams) {\n                this._templating.hideDeleteButton(id);\n                this._templating.showSpinner(id);\n                this._templating.setStatusText(id, this._options.deleteFile.deletingStatusText);\n                this._deleteHandler.sendDelete.apply(this, arguments);\n            },\n            _showDeleteConfirm: function(id, uuid, mandatedParams) {\n                var fileName = this.getName(id), confirmMessage = this._options.deleteFile.confirmMessage.replace(/\\{filename\\}/g, fileName), uuid = this.getUuid(id), deleteRequestArgs = arguments, self = this, retVal;\n                retVal = this._options.showConfirm(confirmMessage);\n                if (qq.isGenericPromise(retVal)) {\n                    retVal.then(function() {\n                        self._sendDeleteRequest.apply(self, deleteRequestArgs);\n                    });\n                } else if (retVal !== false) {\n                    self._sendDeleteRequest.apply(self, deleteRequestArgs);\n                }\n            },\n            _addToList: function(id, name, canned) {\n                var prependData, prependIndex = 0, dontDisplay = this._handler.isProxied(id) && this._options.scaling.hideScaled, record;\n                if (this._options.display.prependFiles) {\n                    if (this._totalFilesInBatch > 1 && this._filesInBatchAddedToUi > 0) {\n                        prependIndex = this._filesInBatchAddedToUi - 1;\n                    }\n                    prependData = {\n                        index: prependIndex\n                    };\n                }\n                if (!canned) {\n                    if (this._options.disableCancelForFormUploads && !qq.supportedFeatures.ajaxUploading) {\n                        this._templating.disableCancel();\n                    }\n                    if (!this._options.multiple) {\n                        record = this.getUploads({\n                            id: id\n                        });\n                        this._handledProxyGroup = this._handledProxyGroup || record.proxyGroupId;\n                        if (record.proxyGroupId !== this._handledProxyGroup || !record.proxyGroupId) {\n                            this._handler.cancelAll();\n                            this._clearList();\n                            this._handledProxyGroup = null;\n                        }\n                    }\n                }\n                if (canned) {\n                    this._templating.addFileToCache(id, this._options.formatFileName(name), prependData, dontDisplay);\n                    this._templating.updateThumbnail(id, this._thumbnailUrls[id], true, this._options.thumbnails.customResizer);\n                } else {\n                    this._templating.addFile(id, this._options.formatFileName(name), prependData, dontDisplay);\n                    this._templating.generatePreview(id, this.getFile(id), this._options.thumbnails.customResizer);\n                }\n                this._filesInBatchAddedToUi += 1;\n                if (canned || this._options.display.fileSizeOnSubmit && qq.supportedFeatures.ajaxUploading) {\n                    this._displayFileSize(id);\n                }\n            },\n            _clearList: function() {\n                this._templating.clearFiles();\n                this.clearStoredFiles();\n            },\n            _displayFileSize: function(id, loadedSize, totalSize) {\n                var size = this.getSize(id), sizeForDisplay = this._formatSize(size);\n                if (size >= 0) {\n                    if (loadedSize !== undefined && totalSize !== undefined) {\n                        sizeForDisplay = this._formatProgress(loadedSize, totalSize);\n                    }\n                    this._templating.updateSize(id, sizeForDisplay);\n                }\n            },\n            _formatProgress: function(uploadedSize, totalSize) {\n                var message = this._options.text.formatProgress;\n                function r(name, replacement) {\n                    message = message.replace(name, replacement);\n                }\n                r(\"{percent}\", Math.round(uploadedSize / totalSize * 100));\n                r(\"{total_size}\", this._formatSize(totalSize));\n                return message;\n            },\n            _controlFailureTextDisplay: function(id, response) {\n                var mode, responseProperty, failureReason;\n                mode = this._options.failedUploadTextDisplay.mode;\n                responseProperty = this._options.failedUploadTextDisplay.responseProperty;\n                if (mode === \"custom\") {\n                    failureReason = response[responseProperty];\n                    if (!failureReason) {\n                        failureReason = this._options.text.failUpload;\n                    }\n                    this._templating.setStatusText(id, failureReason);\n                    if (this._options.failedUploadTextDisplay.enableTooltip) {\n                        this._showTooltip(id, failureReason);\n                    }\n                } else if (mode === \"default\") {\n                    this._templating.setStatusText(id, this._options.text.failUpload);\n                } else if (mode !== \"none\") {\n                    this.log(\"failedUploadTextDisplay.mode value of '\" + mode + \"' is not valid\", \"warn\");\n                }\n            },\n            _showTooltip: function(id, text) {\n                this._templating.getFileContainer(id).title = text;\n            },\n            _showCancelLink: function(id) {\n                if (!this._options.disableCancelForFormUploads || qq.supportedFeatures.ajaxUploading) {\n                    this._templating.showCancel(id);\n                }\n            },\n            _itemError: function(code, name, item) {\n                var message = this._parent.prototype._itemError.apply(this, arguments);\n                this._options.showMessage(message);\n            },\n            _batchError: function(message) {\n                this._parent.prototype._batchError.apply(this, arguments);\n                this._options.showMessage(message);\n            },\n            _setupPastePrompt: function() {\n                var self = this;\n                this._options.callbacks.onPasteReceived = function() {\n                    var message = self._options.paste.namePromptMessage, defaultVal = self._options.paste.defaultName;\n                    return self._options.showPrompt(message, defaultVal);\n                };\n            },\n            _fileOrBlobRejected: function(id, name) {\n                this._totalFilesInBatch -= 1;\n                this._parent.prototype._fileOrBlobRejected.apply(this, arguments);\n            },\n            _prepareItemsForUpload: function(items, params, endpoint) {\n                this._totalFilesInBatch = items.length;\n                this._filesInBatchAddedToUi = 0;\n                this._parent.prototype._prepareItemsForUpload.apply(this, arguments);\n            },\n            _maybeUpdateThumbnail: function(fileId) {\n                var thumbnailUrl = this._thumbnailUrls[fileId], fileStatus = this.getUploads({\n                    id: fileId\n                }).status;\n                if (fileStatus !== qq.status.DELETED && (thumbnailUrl || this._options.thumbnails.placeholders.waitUntilResponse || !qq.supportedFeatures.imagePreviews)) {\n                    this._templating.updateThumbnail(fileId, thumbnailUrl, this._options.thumbnails.customResizer);\n                }\n            },\n            _addCannedFile: function(sessionData) {\n                var id = this._parent.prototype._addCannedFile.apply(this, arguments);\n                this._addToList(id, this.getName(id), true);\n                this._templating.hideSpinner(id);\n                this._templating.hideCancel(id);\n                this._markFileAsSuccessful(id);\n                return id;\n            },\n            _setSize: function(id, newSize) {\n                this._parent.prototype._setSize.apply(this, arguments);\n                this._templating.updateSize(id, this._formatSize(newSize));\n            },\n            _sessionRequestComplete: function() {\n                this._templating.addCacheToDom();\n                this._parent.prototype._sessionRequestComplete.apply(this, arguments);\n            }\n        };\n    })();\n    qq.FineUploader = function(o, namespace) {\n        \"use strict\";\n        var self = this;\n        this._parent = namespace ? qq[namespace].FineUploaderBasic : qq.FineUploaderBasic;\n        this._parent.apply(this, arguments);\n        qq.extend(this._options, {\n            element: null,\n            button: null,\n            listElement: null,\n            dragAndDrop: {\n                extraDropzones: [],\n                reportDirectoryPaths: false\n            },\n            text: {\n                formatProgress: \"{percent}% of {total_size}\",\n                failUpload: \"Upload failed\",\n                waitingForResponse: \"Processing...\",\n                paused: \"Paused\"\n            },\n            template: \"qq-template\",\n            classes: {\n                retrying: \"qq-upload-retrying\",\n                retryable: \"qq-upload-retryable\",\n                success: \"qq-upload-success\",\n                fail: \"qq-upload-fail\",\n                editable: \"qq-editable\",\n                hide: \"qq-hide\",\n                dropActive: \"qq-upload-drop-area-active\"\n            },\n            failedUploadTextDisplay: {\n                mode: \"default\",\n                responseProperty: \"error\",\n                enableTooltip: true\n            },\n            messages: {\n                tooManyFilesError: \"You may only drop one file\",\n                unsupportedBrowser: \"Unrecoverable error - this browser does not permit file uploading of any kind.\"\n            },\n            retry: {\n                showAutoRetryNote: true,\n                autoRetryNote: \"Retrying {retryNum}/{maxAuto}...\"\n            },\n            deleteFile: {\n                forceConfirm: false,\n                confirmMessage: \"Are you sure you want to delete {filename}?\",\n                deletingStatusText: \"Deleting...\",\n                deletingFailedText: \"Delete failed\"\n            },\n            display: {\n                fileSizeOnSubmit: false,\n                prependFiles: false\n            },\n            paste: {\n                promptForName: false,\n                namePromptMessage: \"Please name this image\"\n            },\n            thumbnails: {\n                customResizer: null,\n                maxCount: 0,\n                placeholders: {\n                    waitUntilResponse: false,\n                    notAvailablePath: null,\n                    waitingPath: null\n                },\n                timeBetweenThumbs: 750\n            },\n            scaling: {\n                hideScaled: false\n            },\n            showMessage: function(message) {\n                if (self._templating.hasDialog(\"alert\")) {\n                    return self._templating.showDialog(\"alert\", message);\n                } else {\n                    setTimeout(function() {\n                        window.alert(message);\n                    }, 0);\n                }\n            },\n            showConfirm: function(message) {\n                if (self._templating.hasDialog(\"confirm\")) {\n                    return self._templating.showDialog(\"confirm\", message);\n                } else {\n                    return window.confirm(message);\n                }\n            },\n            showPrompt: function(message, defaultValue) {\n                if (self._templating.hasDialog(\"prompt\")) {\n                    return self._templating.showDialog(\"prompt\", message, defaultValue);\n                } else {\n                    return window.prompt(message, defaultValue);\n                }\n            }\n        }, true);\n        qq.extend(this._options, o, true);\n        this._templating = new qq.Templating({\n            log: qq.bind(this.log, this),\n            templateIdOrEl: this._options.template,\n            containerEl: this._options.element,\n            fileContainerEl: this._options.listElement,\n            button: this._options.button,\n            imageGenerator: this._imageGenerator,\n            classes: {\n                hide: this._options.classes.hide,\n                editable: this._options.classes.editable\n            },\n            limits: {\n                maxThumbs: this._options.thumbnails.maxCount,\n                timeBetweenThumbs: this._options.thumbnails.timeBetweenThumbs\n            },\n            placeholders: {\n                waitUntilUpdate: this._options.thumbnails.placeholders.waitUntilResponse,\n                thumbnailNotAvailable: this._options.thumbnails.placeholders.notAvailablePath,\n                waitingForThumbnail: this._options.thumbnails.placeholders.waitingPath\n            },\n            text: this._options.text\n        });\n        if (this._options.workarounds.ios8SafariUploads && qq.ios800() && qq.iosSafari()) {\n            this._templating.renderFailure(this._options.messages.unsupportedBrowserIos8Safari);\n        } else if (!qq.supportedFeatures.uploading || this._options.cors.expected && !qq.supportedFeatures.uploadCors) {\n            this._templating.renderFailure(this._options.messages.unsupportedBrowser);\n        } else {\n            this._wrapCallbacks();\n            this._templating.render();\n            this._classes = this._options.classes;\n            if (!this._options.button && this._templating.getButton()) {\n                this._defaultButtonId = this._createUploadButton({\n                    element: this._templating.getButton(),\n                    title: this._options.text.fileInputTitle\n                }).getButtonId();\n            }\n            this._setupClickAndEditEventHandlers();\n            if (qq.DragAndDrop && qq.supportedFeatures.fileDrop) {\n                this._dnd = this._setupDragAndDrop();\n            }\n            if (this._options.paste.targetElement && this._options.paste.promptForName) {\n                if (qq.PasteSupport) {\n                    this._setupPastePrompt();\n                } else {\n                    this.log(\"Paste support module not found.\", \"error\");\n                }\n            }\n            this._totalFilesInBatch = 0;\n            this._filesInBatchAddedToUi = 0;\n        }\n    };\n    qq.extend(qq.FineUploader.prototype, qq.basePublicApi);\n    qq.extend(qq.FineUploader.prototype, qq.basePrivateApi);\n    qq.extend(qq.FineUploader.prototype, qq.uiPublicApi);\n    qq.extend(qq.FineUploader.prototype, qq.uiPrivateApi);\n    qq.Templating = function(spec) {\n        \"use strict\";\n        var FILE_ID_ATTR = \"qq-file-id\", FILE_CLASS_PREFIX = \"qq-file-id-\", THUMBNAIL_MAX_SIZE_ATTR = \"qq-max-size\", THUMBNAIL_SERVER_SCALE_ATTR = \"qq-server-scale\", HIDE_DROPZONE_ATTR = \"qq-hide-dropzone\", DROPZPONE_TEXT_ATTR = \"qq-drop-area-text\", IN_PROGRESS_CLASS = \"qq-in-progress\", HIDDEN_FOREVER_CLASS = \"qq-hidden-forever\", fileBatch = {\n            content: document.createDocumentFragment(),\n            map: {}\n        }, isCancelDisabled = false, generatedThumbnails = 0, thumbnailQueueMonitorRunning = false, thumbGenerationQueue = [], thumbnailMaxSize = -1, options = {\n            log: null,\n            limits: {\n                maxThumbs: 0,\n                timeBetweenThumbs: 750\n            },\n            templateIdOrEl: \"qq-template\",\n            containerEl: null,\n            fileContainerEl: null,\n            button: null,\n            imageGenerator: null,\n            classes: {\n                hide: \"qq-hide\",\n                editable: \"qq-editable\"\n            },\n            placeholders: {\n                waitUntilUpdate: false,\n                thumbnailNotAvailable: null,\n                waitingForThumbnail: null\n            },\n            text: {\n                paused: \"Paused\"\n            }\n        }, selectorClasses = {\n            button: \"qq-upload-button-selector\",\n            alertDialog: \"qq-alert-dialog-selector\",\n            dialogCancelButton: \"qq-cancel-button-selector\",\n            confirmDialog: \"qq-confirm-dialog-selector\",\n            dialogMessage: \"qq-dialog-message-selector\",\n            dialogOkButton: \"qq-ok-button-selector\",\n            promptDialog: \"qq-prompt-dialog-selector\",\n            uploader: \"qq-uploader-selector\",\n            drop: \"qq-upload-drop-area-selector\",\n            list: \"qq-upload-list-selector\",\n            progressBarContainer: \"qq-progress-bar-container-selector\",\n            progressBar: \"qq-progress-bar-selector\",\n            totalProgressBarContainer: \"qq-total-progress-bar-container-selector\",\n            totalProgressBar: \"qq-total-progress-bar-selector\",\n            file: \"qq-upload-file-selector\",\n            spinner: \"qq-upload-spinner-selector\",\n            size: \"qq-upload-size-selector\",\n            cancel: \"qq-upload-cancel-selector\",\n            pause: \"qq-upload-pause-selector\",\n            continueButton: \"qq-upload-continue-selector\",\n            deleteButton: \"qq-upload-delete-selector\",\n            retry: \"qq-upload-retry-selector\",\n            statusText: \"qq-upload-status-text-selector\",\n            editFilenameInput: \"qq-edit-filename-selector\",\n            editNameIcon: \"qq-edit-filename-icon-selector\",\n            dropText: \"qq-upload-drop-area-text-selector\",\n            dropProcessing: \"qq-drop-processing-selector\",\n            dropProcessingSpinner: \"qq-drop-processing-spinner-selector\",\n            thumbnail: \"qq-thumbnail-selector\"\n        }, previewGeneration = {}, cachedThumbnailNotAvailableImg = new qq.Promise(), cachedWaitingForThumbnailImg = new qq.Promise(), log, isEditElementsExist, isRetryElementExist, templateHtml, container, fileList, showThumbnails, serverScale, cacheThumbnailPlaceholders = function() {\n            var notAvailableUrl = options.placeholders.thumbnailNotAvailable, waitingUrl = options.placeholders.waitingForThumbnail, spec = {\n                maxSize: thumbnailMaxSize,\n                scale: serverScale\n            };\n            if (showThumbnails) {\n                if (notAvailableUrl) {\n                    options.imageGenerator.generate(notAvailableUrl, new Image(), spec).then(function(updatedImg) {\n                        cachedThumbnailNotAvailableImg.success(updatedImg);\n                    }, function() {\n                        cachedThumbnailNotAvailableImg.failure();\n                        log(\"Problem loading 'not available' placeholder image at \" + notAvailableUrl, \"error\");\n                    });\n                } else {\n                    cachedThumbnailNotAvailableImg.failure();\n                }\n                if (waitingUrl) {\n                    options.imageGenerator.generate(waitingUrl, new Image(), spec).then(function(updatedImg) {\n                        cachedWaitingForThumbnailImg.success(updatedImg);\n                    }, function() {\n                        cachedWaitingForThumbnailImg.failure();\n                        log(\"Problem loading 'waiting for thumbnail' placeholder image at \" + waitingUrl, \"error\");\n                    });\n                } else {\n                    cachedWaitingForThumbnailImg.failure();\n                }\n            }\n        }, displayWaitingImg = function(thumbnail) {\n            var waitingImgPlacement = new qq.Promise();\n            cachedWaitingForThumbnailImg.then(function(img) {\n                maybeScalePlaceholderViaCss(img, thumbnail);\n                if (!thumbnail.src) {\n                    thumbnail.src = img.src;\n                    thumbnail.onload = function() {\n                        thumbnail.onload = null;\n                        show(thumbnail);\n                        waitingImgPlacement.success();\n                    };\n                } else {\n                    waitingImgPlacement.success();\n                }\n            }, function() {\n                hide(thumbnail);\n                waitingImgPlacement.success();\n            });\n            return waitingImgPlacement;\n        }, generateNewPreview = function(id, blob, spec) {\n            var thumbnail = getThumbnail(id);\n            log(\"Generating new thumbnail for \" + id);\n            blob.qqThumbnailId = id;\n            return options.imageGenerator.generate(blob, thumbnail, spec).then(function() {\n                generatedThumbnails++;\n                show(thumbnail);\n                previewGeneration[id].success();\n            }, function() {\n                previewGeneration[id].failure();\n                if (!options.placeholders.waitUntilUpdate) {\n                    maybeSetDisplayNotAvailableImg(id, thumbnail);\n                }\n            });\n        }, generateNextQueuedPreview = function() {\n            if (thumbGenerationQueue.length) {\n                thumbnailQueueMonitorRunning = true;\n                var queuedThumbRequest = thumbGenerationQueue.shift();\n                if (queuedThumbRequest.update) {\n                    processUpdateQueuedPreviewRequest(queuedThumbRequest);\n                } else {\n                    processNewQueuedPreviewRequest(queuedThumbRequest);\n                }\n            } else {\n                thumbnailQueueMonitorRunning = false;\n            }\n        }, getCancel = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.cancel);\n        }, getContinue = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.continueButton);\n        }, getDialog = function(type) {\n            return getTemplateEl(container, selectorClasses[type + \"Dialog\"]);\n        }, getDelete = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.deleteButton);\n        }, getDropProcessing = function() {\n            return getTemplateEl(container, selectorClasses.dropProcessing);\n        }, getEditIcon = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.editNameIcon);\n        }, getFile = function(id) {\n            return fileBatch.map[id] || qq(fileList).getFirstByClass(FILE_CLASS_PREFIX + id);\n        }, getFilename = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.file);\n        }, getPause = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.pause);\n        }, getProgress = function(id) {\n            if (id == null) {\n                return getTemplateEl(container, selectorClasses.totalProgressBarContainer) || getTemplateEl(container, selectorClasses.totalProgressBar);\n            }\n            return getTemplateEl(getFile(id), selectorClasses.progressBarContainer) || getTemplateEl(getFile(id), selectorClasses.progressBar);\n        }, getRetry = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.retry);\n        }, getSize = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.size);\n        }, getSpinner = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.spinner);\n        }, getTemplateEl = function(context, cssClass) {\n            return context && qq(context).getFirstByClass(cssClass);\n        }, getThumbnail = function(id) {\n            return showThumbnails && getTemplateEl(getFile(id), selectorClasses.thumbnail);\n        }, hide = function(el) {\n            el && qq(el).addClass(options.classes.hide);\n        }, maybeScalePlaceholderViaCss = function(placeholder, thumbnail) {\n            var maxWidth = placeholder.style.maxWidth, maxHeight = placeholder.style.maxHeight;\n            if (maxHeight && maxWidth && !thumbnail.style.maxWidth && !thumbnail.style.maxHeight) {\n                qq(thumbnail).css({\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight\n                });\n            }\n        }, maybeSetDisplayNotAvailableImg = function(id, thumbnail) {\n            var previewing = previewGeneration[id] || new qq.Promise().failure(), notAvailableImgPlacement = new qq.Promise();\n            cachedThumbnailNotAvailableImg.then(function(img) {\n                previewing.then(function() {\n                    notAvailableImgPlacement.success();\n                }, function() {\n                    maybeScalePlaceholderViaCss(img, thumbnail);\n                    thumbnail.onload = function() {\n                        thumbnail.onload = null;\n                        notAvailableImgPlacement.success();\n                    };\n                    thumbnail.src = img.src;\n                    show(thumbnail);\n                });\n            });\n            return notAvailableImgPlacement;\n        }, parseAndGetTemplate = function() {\n            var scriptEl, scriptHtml, fileListNode, tempTemplateEl, fileListHtml, defaultButton, dropArea, thumbnail, dropProcessing, dropTextEl, uploaderEl;\n            log(\"Parsing template\");\n            if (options.templateIdOrEl == null) {\n                throw new Error(\"You MUST specify either a template element or ID!\");\n            }\n            if (qq.isString(options.templateIdOrEl)) {\n                scriptEl = document.getElementById(options.templateIdOrEl);\n                if (scriptEl === null) {\n                    throw new Error(qq.format(\"Cannot find template script at ID '{}'!\", options.templateIdOrEl));\n                }\n                scriptHtml = scriptEl.innerHTML;\n            } else {\n                if (options.templateIdOrEl.innerHTML === undefined) {\n                    throw new Error(\"You have specified an invalid value for the template option!  \" + \"It must be an ID or an Element.\");\n                }\n                scriptHtml = options.templateIdOrEl.innerHTML;\n            }\n            scriptHtml = qq.trimStr(scriptHtml);\n            tempTemplateEl = document.createElement(\"div\");\n            tempTemplateEl.appendChild(qq.toElement(scriptHtml));\n            uploaderEl = qq(tempTemplateEl).getFirstByClass(selectorClasses.uploader);\n            if (options.button) {\n                defaultButton = qq(tempTemplateEl).getFirstByClass(selectorClasses.button);\n                if (defaultButton) {\n                    qq(defaultButton).remove();\n                }\n            }\n            if (!qq.DragAndDrop || !qq.supportedFeatures.fileDrop) {\n                dropProcessing = qq(tempTemplateEl).getFirstByClass(selectorClasses.dropProcessing);\n                if (dropProcessing) {\n                    qq(dropProcessing).remove();\n                }\n            }\n            dropArea = qq(tempTemplateEl).getFirstByClass(selectorClasses.drop);\n            if (dropArea && !qq.DragAndDrop) {\n                log(\"DnD module unavailable.\", \"info\");\n                qq(dropArea).remove();\n            }\n            if (!qq.supportedFeatures.fileDrop) {\n                uploaderEl.removeAttribute(DROPZPONE_TEXT_ATTR);\n                if (dropArea && qq(dropArea).hasAttribute(HIDE_DROPZONE_ATTR)) {\n                    qq(dropArea).css({\n                        display: \"none\"\n                    });\n                }\n            } else if (qq(uploaderEl).hasAttribute(DROPZPONE_TEXT_ATTR) && dropArea) {\n                dropTextEl = qq(dropArea).getFirstByClass(selectorClasses.dropText);\n                dropTextEl && qq(dropTextEl).remove();\n            }\n            thumbnail = qq(tempTemplateEl).getFirstByClass(selectorClasses.thumbnail);\n            if (!showThumbnails) {\n                thumbnail && qq(thumbnail).remove();\n            } else if (thumbnail) {\n                thumbnailMaxSize = parseInt(thumbnail.getAttribute(THUMBNAIL_MAX_SIZE_ATTR));\n                thumbnailMaxSize = thumbnailMaxSize > 0 ? thumbnailMaxSize : null;\n                serverScale = qq(thumbnail).hasAttribute(THUMBNAIL_SERVER_SCALE_ATTR);\n            }\n            showThumbnails = showThumbnails && thumbnail;\n            isEditElementsExist = qq(tempTemplateEl).getByClass(selectorClasses.editFilenameInput).length > 0;\n            isRetryElementExist = qq(tempTemplateEl).getByClass(selectorClasses.retry).length > 0;\n            fileListNode = qq(tempTemplateEl).getFirstByClass(selectorClasses.list);\n            if (fileListNode == null) {\n                throw new Error(\"Could not find the file list container in the template!\");\n            }\n            fileListHtml = fileListNode.innerHTML;\n            fileListNode.innerHTML = \"\";\n            if (tempTemplateEl.getElementsByTagName(\"DIALOG\").length) {\n                document.createElement(\"dialog\");\n            }\n            log(\"Template parsing complete\");\n            return {\n                template: qq.trimStr(tempTemplateEl.innerHTML),\n                fileTemplate: qq.trimStr(fileListHtml)\n            };\n        }, prependFile = function(el, index, fileList) {\n            var parentEl = fileList, beforeEl = parentEl.firstChild;\n            if (index > 0) {\n                beforeEl = qq(parentEl).children()[index].nextSibling;\n            }\n            parentEl.insertBefore(el, beforeEl);\n        }, processNewQueuedPreviewRequest = function(queuedThumbRequest) {\n            var id = queuedThumbRequest.id, optFileOrBlob = queuedThumbRequest.optFileOrBlob, relatedThumbnailId = optFileOrBlob && optFileOrBlob.qqThumbnailId, thumbnail = getThumbnail(id), spec = {\n                customResizeFunction: queuedThumbRequest.customResizeFunction,\n                maxSize: thumbnailMaxSize,\n                orient: true,\n                scale: true\n            };\n            if (qq.supportedFeatures.imagePreviews) {\n                if (thumbnail) {\n                    if (options.limits.maxThumbs && options.limits.maxThumbs <= generatedThumbnails) {\n                        maybeSetDisplayNotAvailableImg(id, thumbnail);\n                        generateNextQueuedPreview();\n                    } else {\n                        displayWaitingImg(thumbnail).done(function() {\n                            previewGeneration[id] = new qq.Promise();\n                            previewGeneration[id].done(function() {\n                                setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);\n                            });\n                            if (relatedThumbnailId != null) {\n                                useCachedPreview(id, relatedThumbnailId);\n                            } else {\n                                generateNewPreview(id, optFileOrBlob, spec);\n                            }\n                        });\n                    }\n                } else {\n                    generateNextQueuedPreview();\n                }\n            } else if (thumbnail) {\n                displayWaitingImg(thumbnail);\n                generateNextQueuedPreview();\n            }\n        }, processUpdateQueuedPreviewRequest = function(queuedThumbRequest) {\n            var id = queuedThumbRequest.id, thumbnailUrl = queuedThumbRequest.thumbnailUrl, showWaitingImg = queuedThumbRequest.showWaitingImg, thumbnail = getThumbnail(id), spec = {\n                customResizeFunction: queuedThumbRequest.customResizeFunction,\n                scale: serverScale,\n                maxSize: thumbnailMaxSize\n            };\n            if (thumbnail) {\n                if (thumbnailUrl) {\n                    if (options.limits.maxThumbs && options.limits.maxThumbs <= generatedThumbnails) {\n                        maybeSetDisplayNotAvailableImg(id, thumbnail);\n                        generateNextQueuedPreview();\n                    } else {\n                        if (showWaitingImg) {\n                            displayWaitingImg(thumbnail);\n                        }\n                        return options.imageGenerator.generate(thumbnailUrl, thumbnail, spec).then(function() {\n                            show(thumbnail);\n                            generatedThumbnails++;\n                            setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);\n                        }, function() {\n                            maybeSetDisplayNotAvailableImg(id, thumbnail);\n                            setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);\n                        });\n                    }\n                } else {\n                    maybeSetDisplayNotAvailableImg(id, thumbnail);\n                    generateNextQueuedPreview();\n                }\n            }\n        }, setProgressBarWidth = function(id, percent) {\n            var bar = getProgress(id), progressBarSelector = id == null ? selectorClasses.totalProgressBar : selectorClasses.progressBar;\n            if (bar && !qq(bar).hasClass(progressBarSelector)) {\n                bar = qq(bar).getFirstByClass(progressBarSelector);\n            }\n            if (bar) {\n                qq(bar).css({\n                    width: percent + \"%\"\n                });\n                bar.setAttribute(\"aria-valuenow\", percent);\n            }\n        }, show = function(el) {\n            el && qq(el).removeClass(options.classes.hide);\n        }, useCachedPreview = function(targetThumbnailId, cachedThumbnailId) {\n            var targetThumbnail = getThumbnail(targetThumbnailId), cachedThumbnail = getThumbnail(cachedThumbnailId);\n            log(qq.format(\"ID {} is the same file as ID {}.  Will use generated thumbnail from ID {} instead.\", targetThumbnailId, cachedThumbnailId, cachedThumbnailId));\n            previewGeneration[cachedThumbnailId].then(function() {\n                generatedThumbnails++;\n                previewGeneration[targetThumbnailId].success();\n                log(qq.format(\"Now using previously generated thumbnail created for ID {} on ID {}.\", cachedThumbnailId, targetThumbnailId));\n                targetThumbnail.src = cachedThumbnail.src;\n                show(targetThumbnail);\n            }, function() {\n                previewGeneration[targetThumbnailId].failure();\n                if (!options.placeholders.waitUntilUpdate) {\n                    maybeSetDisplayNotAvailableImg(targetThumbnailId, targetThumbnail);\n                }\n            });\n        };\n        qq.extend(options, spec);\n        log = options.log;\n        if (!qq.supportedFeatures.imagePreviews) {\n            options.limits.timeBetweenThumbs = 0;\n            options.limits.maxThumbs = 0;\n        }\n        container = options.containerEl;\n        showThumbnails = options.imageGenerator !== undefined;\n        templateHtml = parseAndGetTemplate();\n        cacheThumbnailPlaceholders();\n        qq.extend(this, {\n            render: function() {\n                log(\"Rendering template in DOM.\");\n                generatedThumbnails = 0;\n                container.innerHTML = templateHtml.template;\n                hide(getDropProcessing());\n                this.hideTotalProgress();\n                fileList = options.fileContainerEl || getTemplateEl(container, selectorClasses.list);\n                log(\"Template rendering complete\");\n            },\n            renderFailure: function(message) {\n                var cantRenderEl = qq.toElement(message);\n                container.innerHTML = \"\";\n                container.appendChild(cantRenderEl);\n            },\n            reset: function() {\n                this.render();\n            },\n            clearFiles: function() {\n                fileList.innerHTML = \"\";\n            },\n            disableCancel: function() {\n                isCancelDisabled = true;\n            },\n            addFile: function(id, name, prependInfo, hideForever, batch) {\n                var fileEl = qq.toElement(templateHtml.fileTemplate), fileNameEl = getTemplateEl(fileEl, selectorClasses.file), uploaderEl = getTemplateEl(container, selectorClasses.uploader), fileContainer = batch ? fileBatch.content : fileList, thumb;\n                if (batch) {\n                    fileBatch.map[id] = fileEl;\n                }\n                qq(fileEl).addClass(FILE_CLASS_PREFIX + id);\n                uploaderEl.removeAttribute(DROPZPONE_TEXT_ATTR);\n                if (fileNameEl) {\n                    qq(fileNameEl).setText(name);\n                    fileNameEl.setAttribute(\"title\", name);\n                }\n                fileEl.setAttribute(FILE_ID_ATTR, id);\n                if (prependInfo) {\n                    prependFile(fileEl, prependInfo.index, fileContainer);\n                } else {\n                    fileContainer.appendChild(fileEl);\n                }\n                if (hideForever) {\n                    fileEl.style.display = \"none\";\n                    qq(fileEl).addClass(HIDDEN_FOREVER_CLASS);\n                } else {\n                    hide(getProgress(id));\n                    hide(getSize(id));\n                    hide(getDelete(id));\n                    hide(getRetry(id));\n                    hide(getPause(id));\n                    hide(getContinue(id));\n                    if (isCancelDisabled) {\n                        this.hideCancel(id);\n                    }\n                    thumb = getThumbnail(id);\n                    if (thumb && !thumb.src) {\n                        cachedWaitingForThumbnailImg.then(function(waitingImg) {\n                            thumb.src = waitingImg.src;\n                            if (waitingImg.style.maxHeight && waitingImg.style.maxWidth) {\n                                qq(thumb).css({\n                                    maxHeight: waitingImg.style.maxHeight,\n                                    maxWidth: waitingImg.style.maxWidth\n                                });\n                            }\n                            show(thumb);\n                        });\n                    }\n                }\n            },\n            addFileToCache: function(id, name, prependInfo, hideForever) {\n                this.addFile(id, name, prependInfo, hideForever, true);\n            },\n            addCacheToDom: function() {\n                fileList.appendChild(fileBatch.content);\n                fileBatch.content = document.createDocumentFragment();\n                fileBatch.map = {};\n            },\n            removeFile: function(id) {\n                qq(getFile(id)).remove();\n            },\n            getFileId: function(el) {\n                var currentNode = el;\n                if (currentNode) {\n                    while (currentNode.getAttribute(FILE_ID_ATTR) == null) {\n                        currentNode = currentNode.parentNode;\n                    }\n                    return parseInt(currentNode.getAttribute(FILE_ID_ATTR));\n                }\n            },\n            getFileList: function() {\n                return fileList;\n            },\n            markFilenameEditable: function(id) {\n                var filename = getFilename(id);\n                filename && qq(filename).addClass(options.classes.editable);\n            },\n            updateFilename: function(id, name) {\n                var filenameEl = getFilename(id);\n                if (filenameEl) {\n                    qq(filenameEl).setText(name);\n                    filenameEl.setAttribute(\"title\", name);\n                }\n            },\n            hideFilename: function(id) {\n                hide(getFilename(id));\n            },\n            showFilename: function(id) {\n                show(getFilename(id));\n            },\n            isFileName: function(el) {\n                return qq(el).hasClass(selectorClasses.file);\n            },\n            getButton: function() {\n                return options.button || getTemplateEl(container, selectorClasses.button);\n            },\n            hideDropProcessing: function() {\n                hide(getDropProcessing());\n            },\n            showDropProcessing: function() {\n                show(getDropProcessing());\n            },\n            getDropZone: function() {\n                return getTemplateEl(container, selectorClasses.drop);\n            },\n            isEditFilenamePossible: function() {\n                return isEditElementsExist;\n            },\n            hideRetry: function(id) {\n                hide(getRetry(id));\n            },\n            isRetryPossible: function() {\n                return isRetryElementExist;\n            },\n            showRetry: function(id) {\n                show(getRetry(id));\n            },\n            getFileContainer: function(id) {\n                return getFile(id);\n            },\n            showEditIcon: function(id) {\n                var icon = getEditIcon(id);\n                icon && qq(icon).addClass(options.classes.editable);\n            },\n            isHiddenForever: function(id) {\n                return qq(getFile(id)).hasClass(HIDDEN_FOREVER_CLASS);\n            },\n            hideEditIcon: function(id) {\n                var icon = getEditIcon(id);\n                icon && qq(icon).removeClass(options.classes.editable);\n            },\n            isEditIcon: function(el) {\n                return qq(el).hasClass(selectorClasses.editNameIcon, true);\n            },\n            getEditInput: function(id) {\n                return getTemplateEl(getFile(id), selectorClasses.editFilenameInput);\n            },\n            isEditInput: function(el) {\n                return qq(el).hasClass(selectorClasses.editFilenameInput, true);\n            },\n            updateProgress: function(id, loaded, total) {\n                var bar = getProgress(id), percent;\n                if (bar && total > 0) {\n                    percent = Math.round(loaded / total * 100);\n                    if (percent === 100) {\n                        hide(bar);\n                    } else {\n                        show(bar);\n                    }\n                    setProgressBarWidth(id, percent);\n                }\n            },\n            updateTotalProgress: function(loaded, total) {\n                this.updateProgress(null, loaded, total);\n            },\n            hideProgress: function(id) {\n                var bar = getProgress(id);\n                bar && hide(bar);\n            },\n            hideTotalProgress: function() {\n                this.hideProgress();\n            },\n            resetProgress: function(id) {\n                setProgressBarWidth(id, 0);\n                this.hideTotalProgress(id);\n            },\n            resetTotalProgress: function() {\n                this.resetProgress();\n            },\n            showCancel: function(id) {\n                if (!isCancelDisabled) {\n                    var cancel = getCancel(id);\n                    cancel && qq(cancel).removeClass(options.classes.hide);\n                }\n            },\n            hideCancel: function(id) {\n                hide(getCancel(id));\n            },\n            isCancel: function(el) {\n                return qq(el).hasClass(selectorClasses.cancel, true);\n            },\n            allowPause: function(id) {\n                show(getPause(id));\n                hide(getContinue(id));\n            },\n            uploadPaused: function(id) {\n                this.setStatusText(id, options.text.paused);\n                this.allowContinueButton(id);\n                hide(getSpinner(id));\n            },\n            hidePause: function(id) {\n                hide(getPause(id));\n            },\n            isPause: function(el) {\n                return qq(el).hasClass(selectorClasses.pause, true);\n            },\n            isContinueButton: function(el) {\n                return qq(el).hasClass(selectorClasses.continueButton, true);\n            },\n            allowContinueButton: function(id) {\n                show(getContinue(id));\n                hide(getPause(id));\n            },\n            uploadContinued: function(id) {\n                this.setStatusText(id, \"\");\n                this.allowPause(id);\n                show(getSpinner(id));\n            },\n            showDeleteButton: function(id) {\n                show(getDelete(id));\n            },\n            hideDeleteButton: function(id) {\n                hide(getDelete(id));\n            },\n            isDeleteButton: function(el) {\n                return qq(el).hasClass(selectorClasses.deleteButton, true);\n            },\n            isRetry: function(el) {\n                return qq(el).hasClass(selectorClasses.retry, true);\n            },\n            updateSize: function(id, text) {\n                var size = getSize(id);\n                if (size) {\n                    show(size);\n                    qq(size).setText(text);\n                }\n            },\n            setStatusText: function(id, text) {\n                var textEl = getTemplateEl(getFile(id), selectorClasses.statusText);\n                if (textEl) {\n                    if (text == null) {\n                        qq(textEl).clearText();\n                    } else {\n                        qq(textEl).setText(text);\n                    }\n                }\n            },\n            hideSpinner: function(id) {\n                qq(getFile(id)).removeClass(IN_PROGRESS_CLASS);\n                hide(getSpinner(id));\n            },\n            showSpinner: function(id) {\n                qq(getFile(id)).addClass(IN_PROGRESS_CLASS);\n                show(getSpinner(id));\n            },\n            generatePreview: function(id, optFileOrBlob, customResizeFunction) {\n                if (!this.isHiddenForever(id)) {\n                    thumbGenerationQueue.push({\n                        id: id,\n                        customResizeFunction: customResizeFunction,\n                        optFileOrBlob: optFileOrBlob\n                    });\n                    !thumbnailQueueMonitorRunning && generateNextQueuedPreview();\n                }\n            },\n            updateThumbnail: function(id, thumbnailUrl, showWaitingImg, customResizeFunction) {\n                if (!this.isHiddenForever(id)) {\n                    thumbGenerationQueue.push({\n                        customResizeFunction: customResizeFunction,\n                        update: true,\n                        id: id,\n                        thumbnailUrl: thumbnailUrl,\n                        showWaitingImg: showWaitingImg\n                    });\n                    !thumbnailQueueMonitorRunning && generateNextQueuedPreview();\n                }\n            },\n            hasDialog: function(type) {\n                return qq.supportedFeatures.dialogElement && !!getDialog(type);\n            },\n            showDialog: function(type, message, defaultValue) {\n                var dialog = getDialog(type), messageEl = getTemplateEl(dialog, selectorClasses.dialogMessage), inputEl = dialog.getElementsByTagName(\"INPUT\")[0], cancelBtn = getTemplateEl(dialog, selectorClasses.dialogCancelButton), okBtn = getTemplateEl(dialog, selectorClasses.dialogOkButton), promise = new qq.Promise(), closeHandler = function() {\n                    cancelBtn.removeEventListener(\"click\", cancelClickHandler);\n                    okBtn && okBtn.removeEventListener(\"click\", okClickHandler);\n                    promise.failure();\n                }, cancelClickHandler = function() {\n                    cancelBtn.removeEventListener(\"click\", cancelClickHandler);\n                    dialog.close();\n                }, okClickHandler = function() {\n                    dialog.removeEventListener(\"close\", closeHandler);\n                    okBtn.removeEventListener(\"click\", okClickHandler);\n                    dialog.close();\n                    promise.success(inputEl && inputEl.value);\n                };\n                dialog.addEventListener(\"close\", closeHandler);\n                cancelBtn.addEventListener(\"click\", cancelClickHandler);\n                okBtn && okBtn.addEventListener(\"click\", okClickHandler);\n                if (inputEl) {\n                    inputEl.value = defaultValue;\n                }\n                messageEl.textContent = message;\n                dialog.showModal();\n                return promise;\n            }\n        });\n    };\n    qq.UiEventHandler = function(s, protectedApi) {\n        \"use strict\";\n        var disposer = new qq.DisposeSupport(), spec = {\n            eventType: \"click\",\n            attachTo: null,\n            onHandled: function(target, event) {}\n        };\n        qq.extend(this, {\n            addHandler: function(element) {\n                addHandler(element);\n            },\n            dispose: function() {\n                disposer.dispose();\n            }\n        });\n        function addHandler(element) {\n            disposer.attach(element, spec.eventType, function(event) {\n                event = event || window.event;\n                var target = event.target || event.srcElement;\n                spec.onHandled(target, event);\n            });\n        }\n        qq.extend(protectedApi, {\n            getFileIdFromItem: function(item) {\n                return item.qqFileId;\n            },\n            getDisposeSupport: function() {\n                return disposer;\n            }\n        });\n        qq.extend(spec, s);\n        if (spec.attachTo) {\n            addHandler(spec.attachTo);\n        }\n    };\n    qq.FileButtonsClickHandler = function(s) {\n        \"use strict\";\n        var inheritedInternalApi = {}, spec = {\n            templating: null,\n            log: function(message, lvl) {},\n            onDeleteFile: function(fileId) {},\n            onCancel: function(fileId) {},\n            onRetry: function(fileId) {},\n            onPause: function(fileId) {},\n            onContinue: function(fileId) {},\n            onGetName: function(fileId) {}\n        }, buttonHandlers = {\n            cancel: function(id) {\n                spec.onCancel(id);\n            },\n            retry: function(id) {\n                spec.onRetry(id);\n            },\n            deleteButton: function(id) {\n                spec.onDeleteFile(id);\n            },\n            pause: function(id) {\n                spec.onPause(id);\n            },\n            continueButton: function(id) {\n                spec.onContinue(id);\n            }\n        };\n        function examineEvent(target, event) {\n            qq.each(buttonHandlers, function(buttonType, handler) {\n                var firstLetterCapButtonType = buttonType.charAt(0).toUpperCase() + buttonType.slice(1), fileId;\n                if (spec.templating[\"is\" + firstLetterCapButtonType](target)) {\n                    fileId = spec.templating.getFileId(target);\n                    qq.preventDefault(event);\n                    spec.log(qq.format(\"Detected valid file button click event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n                    handler(fileId);\n                    return false;\n                }\n            });\n        }\n        qq.extend(spec, s);\n        spec.eventType = \"click\";\n        spec.onHandled = examineEvent;\n        spec.attachTo = spec.templating.getFileList();\n        qq.extend(this, new qq.UiEventHandler(spec, inheritedInternalApi));\n    };\n    qq.FilenameClickHandler = function(s) {\n        \"use strict\";\n        var inheritedInternalApi = {}, spec = {\n            templating: null,\n            log: function(message, lvl) {},\n            classes: {\n                file: \"qq-upload-file\",\n                editNameIcon: \"qq-edit-filename-icon\"\n            },\n            onGetUploadStatus: function(fileId) {},\n            onGetName: function(fileId) {}\n        };\n        qq.extend(spec, s);\n        function examineEvent(target, event) {\n            if (spec.templating.isFileName(target) || spec.templating.isEditIcon(target)) {\n                var fileId = spec.templating.getFileId(target), status = spec.onGetUploadStatus(fileId);\n                if (status === qq.status.SUBMITTED) {\n                    spec.log(qq.format(\"Detected valid filename click event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n                    qq.preventDefault(event);\n                    inheritedInternalApi.handleFilenameEdit(fileId, target, true);\n                }\n            }\n        }\n        spec.eventType = \"click\";\n        spec.onHandled = examineEvent;\n        qq.extend(this, new qq.FilenameEditHandler(spec, inheritedInternalApi));\n    };\n    qq.FilenameInputFocusInHandler = function(s, inheritedInternalApi) {\n        \"use strict\";\n        var spec = {\n            templating: null,\n            onGetUploadStatus: function(fileId) {},\n            log: function(message, lvl) {}\n        };\n        if (!inheritedInternalApi) {\n            inheritedInternalApi = {};\n        }\n        function handleInputFocus(target, event) {\n            if (spec.templating.isEditInput(target)) {\n                var fileId = spec.templating.getFileId(target), status = spec.onGetUploadStatus(fileId);\n                if (status === qq.status.SUBMITTED) {\n                    spec.log(qq.format(\"Detected valid filename input focus event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n                    inheritedInternalApi.handleFilenameEdit(fileId, target);\n                }\n            }\n        }\n        spec.eventType = \"focusin\";\n        spec.onHandled = handleInputFocus;\n        qq.extend(spec, s);\n        qq.extend(this, new qq.FilenameEditHandler(spec, inheritedInternalApi));\n    };\n    qq.FilenameInputFocusHandler = function(spec) {\n        \"use strict\";\n        spec.eventType = \"focus\";\n        spec.attachTo = null;\n        qq.extend(this, new qq.FilenameInputFocusInHandler(spec, {}));\n    };\n    qq.FilenameEditHandler = function(s, inheritedInternalApi) {\n        \"use strict\";\n        var spec = {\n            templating: null,\n            log: function(message, lvl) {},\n            onGetUploadStatus: function(fileId) {},\n            onGetName: function(fileId) {},\n            onSetName: function(fileId, newName) {},\n            onEditingStatusChange: function(fileId, isEditing) {}\n        };\n        function getFilenameSansExtension(fileId) {\n            var filenameSansExt = spec.onGetName(fileId), extIdx = filenameSansExt.lastIndexOf(\".\");\n            if (extIdx > 0) {\n                filenameSansExt = filenameSansExt.substr(0, extIdx);\n            }\n            return filenameSansExt;\n        }\n        function getOriginalExtension(fileId) {\n            var origName = spec.onGetName(fileId);\n            return qq.getExtension(origName);\n        }\n        function handleNameUpdate(newFilenameInputEl, fileId) {\n            var newName = newFilenameInputEl.value, origExtension;\n            if (newName !== undefined && qq.trimStr(newName).length > 0) {\n                origExtension = getOriginalExtension(fileId);\n                if (origExtension !== undefined) {\n                    newName = newName + \".\" + origExtension;\n                }\n                spec.onSetName(fileId, newName);\n            }\n            spec.onEditingStatusChange(fileId, false);\n        }\n        function registerInputBlurHandler(inputEl, fileId) {\n            inheritedInternalApi.getDisposeSupport().attach(inputEl, \"blur\", function() {\n                handleNameUpdate(inputEl, fileId);\n            });\n        }\n        function registerInputEnterKeyHandler(inputEl, fileId) {\n            inheritedInternalApi.getDisposeSupport().attach(inputEl, \"keyup\", function(event) {\n                var code = event.keyCode || event.which;\n                if (code === 13) {\n                    handleNameUpdate(inputEl, fileId);\n                }\n            });\n        }\n        qq.extend(spec, s);\n        spec.attachTo = spec.templating.getFileList();\n        qq.extend(this, new qq.UiEventHandler(spec, inheritedInternalApi));\n        qq.extend(inheritedInternalApi, {\n            handleFilenameEdit: function(id, target, focusInput) {\n                var newFilenameInputEl = spec.templating.getEditInput(id);\n                spec.onEditingStatusChange(id, true);\n                newFilenameInputEl.value = getFilenameSansExtension(id);\n                if (focusInput) {\n                    newFilenameInputEl.focus();\n                }\n                registerInputBlurHandler(newFilenameInputEl, id);\n                registerInputEnterKeyHandler(newFilenameInputEl, id);\n            }\n        });\n    };\n    (function() {\n        \"use strict\";\n        qq.s3.FineUploader = function(o) {\n            var options = {\n                failedUploadTextDisplay: {\n                    mode: \"custom\"\n                }\n            };\n            qq.extend(options, o, true);\n            qq.FineUploader.call(this, options, \"s3\");\n            if (!qq.supportedFeatures.ajaxUploading && options.iframeSupport.localBlankPagePath === undefined) {\n                this._options.element.innerHTML = \"<div>You MUST set the <code>localBlankPagePath</code> property \" + \"of the <code>iframeSupport</code> option since this browser does not support the File API!</div>\";\n            }\n        };\n        qq.extend(qq.s3.FineUploader.prototype, qq.s3.FineUploaderBasic.prototype);\n        qq.extend(qq.s3.FineUploader.prototype, qq.uiPublicApi);\n        qq.extend(qq.s3.FineUploader.prototype, qq.uiPrivateApi);\n    })();\n})(window);\n//# sourceMappingURL=s3.fine-uploader.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZpbmUtdXBsb2FkZXIvczMuZmluZS11cGxvYWRlci9zMy5maW5lLXVwbG9hZGVyLmpzPzk1OTYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRmluZSBVcGxvYWRlciA1LjEzLjAgLSAoYykgMjAxMy1wcmVzZW50IFdpZGVuIEVudGVycHJpc2VzLCBJbmMuIE1JVCBsaWNlbnNlZC4gaHR0cDovL2ZpbmV1cGxvYWRlci5jb21cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgICB2YXIgcXEgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXR0YWNoOiBmdW5jdGlvbih0eXBlLCBmbikge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoXCJvblwiICsgdHlwZSwgZm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHFxKGVsZW1lbnQpLmRldGFjaCh0eXBlLCBmbik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5kZXRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBmbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBmdW5jdGlvbihkZXNjZW5kYW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXNjZW5kYW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IGRlc2NlbmRhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNvbnRhaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmNvbnRhaW5zKGRlc2NlbmRhbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIShkZXNjZW5kYW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQpICYgOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24oZWxlbWVudEIpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Qi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBlbGVtZW50Qik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3NzOiBmdW5jdGlvbihzdHlsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdHlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBxcS5FcnJvcihcIkNhbid0IGFwcGx5IHN0eWxlIHRvIG5vZGUgYXMgaXQgaXMgbm90IG9uIHRoZSBIVE1MRWxlbWVudCBwcm90b3R5cGUgY2hhaW4hXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVzLm9wYWNpdHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQuc3R5bGUub3BhY2l0eSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZWxlbWVudC5maWx0ZXJzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXMuZmlsdGVyID0gXCJhbHBoYShvcGFjaXR5PVwiICsgTWF0aC5yb3VuZCgxMDAgKiBzdHlsZXMub3BhY2l0eSkgKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxcS5leHRlbmQoZWxlbWVudC5zdHlsZSwgc3R5bGVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXNDbGFzczogZnVuY3Rpb24obmFtZSwgY29uc2lkZXJQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiKF58IClcIiArIG5hbWUgKyBcIiggfCQpXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZS50ZXN0KGVsZW1lbnQuY2xhc3NOYW1lKSB8fCAhIShjb25zaWRlclBhcmVudCAmJiByZS50ZXN0KGVsZW1lbnQucGFyZW50Tm9kZS5jbGFzc05hbWUpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRDbGFzczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghcXEoZWxlbWVudCkuaGFzQ2xhc3MobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgKz0gXCIgXCIgKyBuYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAoXCIoXnwgKVwiICsgbmFtZSArIFwiKCB8JClcIik7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKHJlLCBcIiBcIikucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0QnlDbGFzczogZnVuY3Rpb24oY2xhc3NOYW1lLCBmaXJzdCkge1xuICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGVzLCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3QgJiYgZWxlbWVudC5xdWVyeVNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuXCIgKyBjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIik7XG4gICAgICAgICAgICAgICAgcXEuZWFjaChjYW5kaWRhdGVzLCBmdW5jdGlvbihpZHgsIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXEodmFsKS5oYXNDbGFzcyhjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0ID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEZpcnN0QnlDbGFzczogZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHFxKGVsZW1lbnQpLmdldEJ5Q2xhc3MoY2xhc3NOYW1lLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW10sIGNoaWxkID0gZWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRUZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5pbm5lclRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsZWFyVGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHFxKGVsZW1lbnQpLnNldFRleHQoXCJcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzQXR0cmlidXRlOiBmdW5jdGlvbihhdHRyTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAvXmZhbHNlJC9pLmV4ZWMoZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpKSA9PSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJWYWwgPSBlbGVtZW50W2F0dHJOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJWYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAvXmZhbHNlJC9pLmV4ZWMoYXR0clZhbCkgPT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBxcS5jYW52YXNUb0Jsb2IgPSBmdW5jdGlvbihjYW52YXMsIG1pbWUsIHF1YWxpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBxcS5kYXRhVXJpVG9CbG9iKGNhbnZhcy50b0RhdGFVUkwobWltZSwgcXVhbGl0eSkpO1xuICAgICAgICB9O1xuICAgICAgICBxcS5kYXRhVXJpVG9CbG9iID0gZnVuY3Rpb24oZGF0YVVyaSkge1xuICAgICAgICAgICAgdmFyIGFycmF5QnVmZmVyLCBieXRlU3RyaW5nLCBjcmVhdGVCbG9iID0gZnVuY3Rpb24oZGF0YSwgbWltZSkge1xuICAgICAgICAgICAgICAgIHZhciBCbG9iQnVpbGRlciA9IHdpbmRvdy5CbG9iQnVpbGRlciB8fCB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1vekJsb2JCdWlsZGVyIHx8IHdpbmRvdy5NU0Jsb2JCdWlsZGVyLCBibG9iQnVpbGRlciA9IEJsb2JCdWlsZGVyICYmIG5ldyBCbG9iQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgIGlmIChibG9iQnVpbGRlcikge1xuICAgICAgICAgICAgICAgICAgICBibG9iQnVpbGRlci5hcHBlbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibG9iQnVpbGRlci5nZXRCbG9iKG1pbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmxvYihbIGRhdGEgXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbWltZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBpbnRBcnJheSwgbWltZVN0cmluZztcbiAgICAgICAgICAgIGlmIChkYXRhVXJpLnNwbGl0KFwiLFwiKVswXS5pbmRleE9mKFwiYmFzZTY0XCIpID49IDApIHtcbiAgICAgICAgICAgICAgICBieXRlU3RyaW5nID0gYXRvYihkYXRhVXJpLnNwbGl0KFwiLFwiKVsxXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ5dGVTdHJpbmcgPSBkZWNvZGVVUkkoZGF0YVVyaS5zcGxpdChcIixcIilbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWltZVN0cmluZyA9IGRhdGFVcmkuc3BsaXQoXCIsXCIpWzBdLnNwbGl0KFwiOlwiKVsxXS5zcGxpdChcIjtcIilbMF07XG4gICAgICAgICAgICBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlU3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICBpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgIHFxLmVhY2goYnl0ZVN0cmluZywgZnVuY3Rpb24oaWR4LCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICBpbnRBcnJheVtpZHhdID0gY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVCbG9iKGFycmF5QnVmZmVyLCBtaW1lU3RyaW5nKTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEubG9nID0gZnVuY3Rpb24obWVzc2FnZSwgbGV2ZWwpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgICAgICAgICAgIGlmICghbGV2ZWwgfHwgbGV2ZWwgPT09IFwiaW5mb1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LmNvbnNvbGVbbGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZVtsZXZlbF0obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coXCI8XCIgKyBsZXZlbCArIFwiPiBcIiArIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBxcS5pc09iamVjdCA9IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFyaWFibGUgJiYgIXZhcmlhYmxlLm5vZGVUeXBlICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YXJpYWJsZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YXJpYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YXJpYWJsZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICB9O1xuICAgICAgICBxcS5pc0FycmF5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgQXJyYXldXCIgfHwgdmFsdWUgJiYgd2luZG93LkFycmF5QnVmZmVyICYmIHZhbHVlLmJ1ZmZlciAmJiB2YWx1ZS5idWZmZXIuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyO1xuICAgICAgICB9O1xuICAgICAgICBxcS5pc0l0ZW1MaXN0ID0gZnVuY3Rpb24obWF5YmVJdGVtTGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXliZUl0ZW1MaXN0KSA9PT0gXCJbb2JqZWN0IERhdGFUcmFuc2Zlckl0ZW1MaXN0XVwiO1xuICAgICAgICB9O1xuICAgICAgICBxcS5pc05vZGVMaXN0ID0gZnVuY3Rpb24obWF5YmVOb2RlTGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXliZU5vZGVMaXN0KSA9PT0gXCJbb2JqZWN0IE5vZGVMaXN0XVwiIHx8IG1heWJlTm9kZUxpc3QuaXRlbSAmJiBtYXliZU5vZGVMaXN0Lm5hbWVkSXRlbTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuaXNTdHJpbmcgPSBmdW5jdGlvbihtYXliZVN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXliZVN0cmluZykgPT09IFwiW29iamVjdCBTdHJpbmddXCI7XG4gICAgICAgIH07XG4gICAgICAgIHFxLnRyaW1TdHIgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChTdHJpbmcucHJvdG90eXBlLnRyaW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIik7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmZvcm1hdCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBuZXdTdHIgPSBzdHIsIG5leHRJZHhUb1JlcGxhY2UgPSBuZXdTdHIuaW5kZXhPZihcInt9XCIpO1xuICAgICAgICAgICAgcXEuZWFjaChhcmdzLCBmdW5jdGlvbihpZHgsIHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHJCZWZvcmUgPSBuZXdTdHIuc3Vic3RyaW5nKDAsIG5leHRJZHhUb1JlcGxhY2UpLCBzdHJBZnRlciA9IG5ld1N0ci5zdWJzdHJpbmcobmV4dElkeFRvUmVwbGFjZSArIDIpO1xuICAgICAgICAgICAgICAgIG5ld1N0ciA9IHN0ckJlZm9yZSArIHZhbCArIHN0ckFmdGVyO1xuICAgICAgICAgICAgICAgIG5leHRJZHhUb1JlcGxhY2UgPSBuZXdTdHIuaW5kZXhPZihcInt9XCIsIG5leHRJZHhUb1JlcGxhY2UgKyB2YWwubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dElkeFRvUmVwbGFjZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1N0cjtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuaXNGaWxlID0gZnVuY3Rpb24obWF5YmVGaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LkZpbGUgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1heWJlRmlsZSkgPT09IFwiW29iamVjdCBGaWxlXVwiO1xuICAgICAgICB9O1xuICAgICAgICBxcS5pc0ZpbGVMaXN0ID0gZnVuY3Rpb24obWF5YmVGaWxlTGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5GaWxlTGlzdCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWF5YmVGaWxlTGlzdCkgPT09IFwiW29iamVjdCBGaWxlTGlzdF1cIjtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuaXNGaWxlT3JJbnB1dCA9IGZ1bmN0aW9uKG1heWJlRmlsZU9ySW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBxcS5pc0ZpbGUobWF5YmVGaWxlT3JJbnB1dCkgfHwgcXEuaXNJbnB1dChtYXliZUZpbGVPcklucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuaXNJbnB1dCA9IGZ1bmN0aW9uKG1heWJlSW5wdXQsIG5vdEZpbGUpIHtcbiAgICAgICAgICAgIHZhciBldmFsdWF0ZVR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRUeXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChub3RGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkVHlwZSAhPT0gXCJmaWxlXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkVHlwZSA9PT0gXCJmaWxlXCI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5IVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXliZUlucHV0KSA9PT0gXCJbb2JqZWN0IEhUTUxJbnB1dEVsZW1lbnRdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlSW5wdXQudHlwZSAmJiBldmFsdWF0ZVR5cGUobWF5YmVJbnB1dC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF5YmVJbnB1dC50YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heWJlSW5wdXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlSW5wdXQudHlwZSAmJiBldmFsdWF0ZVR5cGUobWF5YmVJbnB1dC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmlzQmxvYiA9IGZ1bmN0aW9uKG1heWJlQmxvYikge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5CbG9iICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXliZUJsb2IpID09PSBcIltvYmplY3QgQmxvYl1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBxcS5pc1hoclVwbG9hZFN1cHBvcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgaW5wdXQudHlwZSA9IFwiZmlsZVwiO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm11bHRpcGxlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIEZpbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBxcS5jcmVhdGVYaHJJbnN0YW5jZSgpLnVwbG9hZCAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuY3JlYXRlWGhySW5zdGFuY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1TWE1MMi5YTUxIVFRQLjMuMFwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcXEubG9nKFwiTmVpdGhlciBYSFIgb3IgQWN0aXZlWCBhcmUgc3VwcG9ydGVkIVwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBxcS5pc0ZvbGRlckRyb3BTdXBwb3J0ZWQgPSBmdW5jdGlvbihkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhVHJhbnNmZXIuaXRlbXMgJiYgZGF0YVRyYW5zZmVyLml0ZW1zLmxlbmd0aCA+IDAgJiYgZGF0YVRyYW5zZmVyLml0ZW1zWzBdLndlYmtpdEdldEFzRW50cnk7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmlzRmlsZUNodW5raW5nU3VwcG9ydGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gIXFxLmFuZHJvaWRTdG9jaygpICYmIHFxLmlzWGhyVXBsb2FkU3VwcG9ydGVkKCkgJiYgKEZpbGUucHJvdG90eXBlLnNsaWNlICE9PSB1bmRlZmluZWQgfHwgRmlsZS5wcm90b3R5cGUud2Via2l0U2xpY2UgIT09IHVuZGVmaW5lZCB8fCBGaWxlLnByb3RvdHlwZS5tb3pTbGljZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuc2xpY2VCbG9iID0gZnVuY3Rpb24oZmlsZU9yQmxvYiwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgdmFyIHNsaWNlciA9IGZpbGVPckJsb2Iuc2xpY2UgfHwgZmlsZU9yQmxvYi5tb3pTbGljZSB8fCBmaWxlT3JCbG9iLndlYmtpdFNsaWNlO1xuICAgICAgICAgICAgcmV0dXJuIHNsaWNlci5jYWxsKGZpbGVPckJsb2IsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9O1xuICAgICAgICBxcS5hcnJheUJ1ZmZlclRvSGV4ID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZXNBc0hleCA9IFwiXCIsIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgIHFxLmVhY2goYnl0ZXMsIGZ1bmN0aW9uKGlkeCwgYnl0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGVBc0hleFN0ciA9IGJ5dC50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVBc0hleFN0ci5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVBc0hleFN0ciA9IFwiMFwiICsgYnl0ZUFzSGV4U3RyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBieXRlc0FzSGV4ICs9IGJ5dGVBc0hleFN0cjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzQXNIZXg7XG4gICAgICAgIH07XG4gICAgICAgIHFxLnJlYWRCbG9iVG9IZXggPSBmdW5jdGlvbihibG9iLCBzdGFydE9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbEJsb2IgPSBxcS5zbGljZUJsb2IoYmxvYiwgc3RhcnRPZmZzZXQsIHN0YXJ0T2Zmc2V0ICsgbGVuZ3RoKSwgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCksIHByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3MocXEuYXJyYXlCdWZmZXJUb0hleChmaWxlUmVhZGVyLnJlc3VsdCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZpbGVSZWFkZXIub25lcnJvciA9IHByb21pc2UuZmFpbHVyZTtcbiAgICAgICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoaW5pdGlhbEJsb2IpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmV4dGVuZCA9IGZ1bmN0aW9uKGZpcnN0LCBzZWNvbmQsIGV4dGVuZE5lc3RlZCkge1xuICAgICAgICAgICAgcXEuZWFjaChzZWNvbmQsIGZ1bmN0aW9uKHByb3AsIHZhbCkge1xuICAgICAgICAgICAgICAgIGlmIChleHRlbmROZXN0ZWQgJiYgcXEuaXNPYmplY3QodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBxcS5leHRlbmQoZmlyc3RbcHJvcF0sIHZhbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3Q7XG4gICAgICAgIH07XG4gICAgICAgIHFxLm92ZXJyaWRlID0gZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2VGbikge1xuICAgICAgICAgICAgdmFyIHN1cGVyXyA9IHt9LCBzb3VyY2UgPSBzb3VyY2VGbihzdXBlcl8pO1xuICAgICAgICAgICAgcXEuZWFjaChzb3VyY2UsIGZ1bmN0aW9uKHNyY1Byb3BOYW1lLCBzcmNQcm9wVmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFtzcmNQcm9wTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlcl9bc3JjUHJvcE5hbWVdID0gdGFyZ2V0W3NyY1Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3NyY1Byb3BOYW1lXSA9IHNyY1Byb3BWYWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmluZGV4T2YgPSBmdW5jdGlvbihhcnIsIGVsdCwgZnJvbSkge1xuICAgICAgICAgICAgaWYgKGFyci5pbmRleE9mKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyci5pbmRleE9mKGVsdCwgZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tID0gZnJvbSB8fCAwO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgICAgICAgICBmcm9tICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoO2Zyb20gPCBsZW47IGZyb20gKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChhcnIuaGFzT3duUHJvcGVydHkoZnJvbSkgJiYgYXJyW2Zyb21dID09PSBlbHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyb207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgICAgICBxcS5nZXRVbmlxdWVJZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwieHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4XCIucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLCB2ID0gYyA9PSBcInhcIiA/IHIgOiByICYgMyB8IDg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmllID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRVwiKSAhPT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiVHJpZGVudFwiKSAhPT0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmllNyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1TSUUgN1wiKSAhPT0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmllOCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1TSUUgOFwiKSAhPT0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmllMTAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNU0lFIDEwXCIpICE9PSAtMTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuaWUxMSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHFxLmllKCkgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwicnY6MTFcIikgIT09IC0xO1xuICAgICAgICB9O1xuICAgICAgICBxcS5lZGdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRWRnZVwiKSA+PSAwO1xuICAgICAgICB9O1xuICAgICAgICBxcS5zYWZhcmkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IudmVuZG9yICE9PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnZlbmRvci5pbmRleE9mKFwiQXBwbGVcIikgIT09IC0xO1xuICAgICAgICB9O1xuICAgICAgICBxcS5jaHJvbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IudmVuZG9yICE9PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnZlbmRvci5pbmRleE9mKFwiR29vZ2xlXCIpICE9PSAtMTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEub3BlcmEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IudmVuZG9yICE9PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnZlbmRvci5pbmRleE9mKFwiT3BlcmFcIikgIT09IC0xO1xuICAgICAgICB9O1xuICAgICAgICBxcS5maXJlZm94ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gIXFxLmVkZ2UoKSAmJiAhcXEuaWUxMSgpICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1vemlsbGFcIikgIT09IC0xICYmIG5hdmlnYXRvci52ZW5kb3IgIT09IHVuZGVmaW5lZCAmJiBuYXZpZ2F0b3IudmVuZG9yID09PSBcIlwiO1xuICAgICAgICB9O1xuICAgICAgICBxcS53aW5kb3dzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLnBsYXRmb3JtID09PSBcIldpbjMyXCI7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmFuZHJvaWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImFuZHJvaWRcIikgIT09IC0xO1xuICAgICAgICB9O1xuICAgICAgICBxcS5hbmRyb2lkU3RvY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBxcS5hbmRyb2lkKCkgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJjaHJvbWVcIikgPCAwO1xuICAgICAgICB9O1xuICAgICAgICBxcS5pb3M2ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcXEuaW9zKCkgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiIE9TIDZfXCIpICE9PSAtMTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuaW9zNyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHFxLmlvcygpICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIiBPUyA3X1wiKSAhPT0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmlvczggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBxcS5pb3MoKSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCIgT1MgOF9cIikgIT09IC0xO1xuICAgICAgICB9O1xuICAgICAgICBxcS5pb3M4MDAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBxcS5pb3MoKSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCIgT1MgOF8wIFwiKSAhPT0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmlvcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcImlQYWRcIikgIT09IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcImlQb2RcIikgIT09IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcImlQaG9uZVwiKSAhPT0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmlvc0Nocm9tZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHFxLmlvcygpICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkNyaU9TXCIpICE9PSAtMTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuaW9zU2FmYXJpID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcXEuaW9zKCkgJiYgIXFxLmlvc0Nocm9tZSgpICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIlNhZmFyaVwiKSAhPT0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmlvc1NhZmFyaVdlYlZpZXcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBxcS5pb3MoKSAmJiAhcXEuaW9zQ2hyb21lKCkgJiYgIXFxLmlvc1NhZmFyaSgpO1xuICAgICAgICB9O1xuICAgICAgICBxcS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHFxLnRvRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZGl2LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgZGl2LnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuICAgICAgICBxcS5lYWNoID0gZnVuY3Rpb24oaXRlcmFibGVJdGVtLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGtleU9ySW5kZXgsIHJldFZhbDtcbiAgICAgICAgICAgIGlmIChpdGVyYWJsZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LlN0b3JhZ2UgJiYgaXRlcmFibGVJdGVtLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuU3RvcmFnZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleU9ySW5kZXggPSAwOyBrZXlPckluZGV4IDwgaXRlcmFibGVJdGVtLmxlbmd0aDsga2V5T3JJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRWYWwgPSBjYWxsYmFjayhpdGVyYWJsZUl0ZW0ua2V5KGtleU9ySW5kZXgpLCBpdGVyYWJsZUl0ZW0uZ2V0SXRlbShpdGVyYWJsZUl0ZW0ua2V5KGtleU9ySW5kZXgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0VmFsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxcS5pc0FycmF5KGl0ZXJhYmxlSXRlbSkgfHwgcXEuaXNJdGVtTGlzdChpdGVyYWJsZUl0ZW0pIHx8IHFxLmlzTm9kZUxpc3QoaXRlcmFibGVJdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleU9ySW5kZXggPSAwOyBrZXlPckluZGV4IDwgaXRlcmFibGVJdGVtLmxlbmd0aDsga2V5T3JJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRWYWwgPSBjYWxsYmFjayhrZXlPckluZGV4LCBpdGVyYWJsZUl0ZW1ba2V5T3JJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldFZhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocXEuaXNTdHJpbmcoaXRlcmFibGVJdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleU9ySW5kZXggPSAwOyBrZXlPckluZGV4IDwgaXRlcmFibGVJdGVtLmxlbmd0aDsga2V5T3JJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRWYWwgPSBjYWxsYmFjayhrZXlPckluZGV4LCBpdGVyYWJsZUl0ZW0uY2hhckF0KGtleU9ySW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRWYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleU9ySW5kZXggaW4gaXRlcmFibGVJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGl0ZXJhYmxlSXRlbSwga2V5T3JJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRWYWwgPSBjYWxsYmFjayhrZXlPckluZGV4LCBpdGVyYWJsZUl0ZW1ba2V5T3JJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRWYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcXEuYmluZCA9IGZ1bmN0aW9uKG9sZEZ1bmMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChxcS5pc0Z1bmN0aW9uKG9sZEZ1bmMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0FyZ3MgPSBxcS5leHRlbmQoW10sIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QXJncyA9IG5ld0FyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvbGRGdW5jLmFwcGx5KGNvbnRleHQsIG5ld0FyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEub2JqMnVybCA9IGZ1bmN0aW9uKG9iaiwgdGVtcCwgcHJlZml4RG9uZSkge1xuICAgICAgICAgICAgdmFyIHVyaXN0cmluZ3MgPSBbXSwgcHJlZml4ID0gXCImXCIsIGFkZCA9IGZ1bmN0aW9uKG5leHRPYmosIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFRlbXAgPSB0ZW1wID8gL1xcW1xcXSQvLnRlc3QodGVtcCkgPyB0ZW1wIDogdGVtcCArIFwiW1wiICsgaSArIFwiXVwiIDogaTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFRlbXAgIT09IFwidW5kZWZpbmVkXCIgJiYgaSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICB1cmlzdHJpbmdzLnB1c2godHlwZW9mIG5leHRPYmogPT09IFwib2JqZWN0XCIgPyBxcS5vYmoydXJsKG5leHRPYmosIG5leHRUZW1wLCB0cnVlKSA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXh0T2JqKSA9PT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiID8gZW5jb2RlVVJJQ29tcG9uZW50KG5leHRUZW1wKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KG5leHRPYmooKSkgOiBlbmNvZGVVUklDb21wb25lbnQobmV4dFRlbXApICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQobmV4dE9iaikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXByZWZpeERvbmUgJiYgdGVtcCkge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IC9cXD8vLnRlc3QodGVtcCkgPyAvXFw/JC8udGVzdCh0ZW1wKSA/IFwiXCIgOiBcIiZcIiA6IFwiP1wiO1xuICAgICAgICAgICAgICAgIHVyaXN0cmluZ3MucHVzaCh0ZW1wKTtcbiAgICAgICAgICAgICAgICB1cmlzdHJpbmdzLnB1c2gocXEub2JqMnVybChvYmopKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIiAmJiB0eXBlb2Ygb2JqICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcXEuZWFjaChvYmosIGZ1bmN0aW9uKGlkeCwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZCh2YWwsIGlkeCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBxcS5lYWNoKG9iaiwgZnVuY3Rpb24ocHJvcCwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZCh2YWwsIHByb3ApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmlzdHJpbmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHRlbXApICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGVtcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cmlzdHJpbmdzLmpvaW4ocHJlZml4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVyaXN0cmluZ3Muam9pbihwcmVmaXgpLnJlcGxhY2UoL14mLywgXCJcIikucmVwbGFjZSgvJTIwL2csIFwiK1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcXEub2JqMkZvcm1EYXRhID0gZnVuY3Rpb24ob2JqLCBmb3JtRGF0YSwgYXJyYXlLZXlOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHFxLmVhY2gob2JqLCBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgICAgICAgICAgIGtleSA9IGFycmF5S2V5TmFtZSA/IGFycmF5S2V5TmFtZSArIFwiW1wiICsga2V5ICsgXCJdXCIgOiBrZXk7XG4gICAgICAgICAgICAgICAgaWYgKHFxLmlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEub2JqMkZvcm1EYXRhKHZhbCwgZm9ybURhdGEsIGtleSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxcS5pc0Z1bmN0aW9uKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgdmFsKCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZm9ybURhdGE7XG4gICAgICAgIH07XG4gICAgICAgIHFxLm9iajJJbnB1dHMgPSBmdW5jdGlvbihvYmosIGZvcm0pIHtcbiAgICAgICAgICAgIHZhciBpbnB1dDtcbiAgICAgICAgICAgIGlmICghZm9ybSkge1xuICAgICAgICAgICAgICAgIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHFxLm9iajJGb3JtRGF0YShvYmosIHtcbiAgICAgICAgICAgICAgICBhcHBlbmQ6IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZvcm07XG4gICAgICAgIH07XG4gICAgICAgIHFxLnBhcnNlSnNvbiA9IGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuSlNPTiAmJiBxcS5pc0Z1bmN0aW9uKEpTT04ucGFyc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmFsKFwiKFwiICsganNvbiArIFwiKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcXEuZ2V0RXh0ZW5zaW9uID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIHZhciBleHRJZHggPSBmaWxlbmFtZS5sYXN0SW5kZXhPZihcIi5cIikgKyAxO1xuICAgICAgICAgICAgaWYgKGV4dElkeCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZW5hbWUuc3Vic3RyKGV4dElkeCwgZmlsZW5hbWUubGVuZ3RoIC0gZXh0SWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcXEuZ2V0RmlsZW5hbWUgPSBmdW5jdGlvbihibG9iT3JGaWxlSW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChxcS5pc0lucHV0KGJsb2JPckZpbGVJbnB1dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvYk9yRmlsZUlucHV0LnZhbHVlLnJlcGxhY2UoLy4qKFxcL3xcXFxcKS8sIFwiXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChxcS5pc0ZpbGUoYmxvYk9yRmlsZUlucHV0KSkge1xuICAgICAgICAgICAgICAgIGlmIChibG9iT3JGaWxlSW5wdXQuZmlsZU5hbWUgIT09IG51bGwgJiYgYmxvYk9yRmlsZUlucHV0LmZpbGVOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2JPckZpbGVJbnB1dC5maWxlTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmxvYk9yRmlsZUlucHV0Lm5hbWU7XG4gICAgICAgIH07XG4gICAgICAgIHFxLkRpc3Bvc2VTdXBwb3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGlzcG9zZXJzID0gW107XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzcG9zZXI7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VyID0gZGlzcG9zZXJzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzcG9zZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwb3NlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChkaXNwb3Nlcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhdHRhY2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGREaXNwb3NlcihxcShhcmdzWzBdKS5hdHRhY2guYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWRkRGlzcG9zZXI6IGZ1bmN0aW9uKGRpc3Bvc2VGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlcnMucHVzaChkaXNwb3NlRnVuY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHFxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLnFxID0gcXE7XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHFxLkVycm9yID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJbRmluZSBVcGxvYWRlciBcIiArIHFxLnZlcnNpb24gKyBcIl0gXCIgKyBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBxcS5FcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICB9KSgpO1xuICAgIHFxLnZlcnNpb24gPSBcIjUuMTMuMFwiO1xuICAgIHFxLnN1cHBvcnRlZEZlYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgc3VwcG9ydHNVcGxvYWRpbmcsIHN1cHBvcnRzVXBsb2FkaW5nQmxvYnMsIHN1cHBvcnRzRmlsZURyb3AsIHN1cHBvcnRzQWpheEZpbGVVcGxvYWRpbmcsIHN1cHBvcnRzRm9sZGVyRHJvcCwgc3VwcG9ydHNDaHVua2luZywgc3VwcG9ydHNSZXN1bWUsIHN1cHBvcnRzVXBsb2FkVmlhUGFzdGUsIHN1cHBvcnRzVXBsb2FkQ29ycywgc3VwcG9ydHNEZWxldGVGaWxlWGRyLCBzdXBwb3J0c0RlbGV0ZUZpbGVDb3JzWGhyLCBzdXBwb3J0c0RlbGV0ZUZpbGVDb3JzLCBzdXBwb3J0c0ZvbGRlclNlbGVjdGlvbiwgc3VwcG9ydHNJbWFnZVByZXZpZXdzLCBzdXBwb3J0c1VwbG9hZFByb2dyZXNzO1xuICAgICAgICBmdW5jdGlvbiB0ZXN0U3VwcG9ydHNGaWxlSW5wdXRFbGVtZW50KCkge1xuICAgICAgICAgICAgdmFyIHN1cHBvcnRlZCA9IHRydWUsIHRlbXBJbnB1dDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGVtcElucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgICAgIHRlbXBJbnB1dC50eXBlID0gXCJmaWxlXCI7XG4gICAgICAgICAgICAgICAgcXEodGVtcElucHV0KS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRlbXBJbnB1dC5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0Nocm9tZTIxT3JIaWdoZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHFxLmNocm9tZSgpIHx8IHFxLm9wZXJhKCkpICYmIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcL1syXVsxLTldfENocm9tZVxcL1szLTldWzAtOV0vKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzQ2hyb21lMTRPckhpZ2hlcigpIHtcbiAgICAgICAgICAgIHJldHVybiAocXEuY2hyb21lKCkgfHwgcXEub3BlcmEoKSkgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvWzFdWzQtOV18Q2hyb21lXFwvWzItOV1bMC05XS8pICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNDcm9zc09yaWdpblhoclN1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgeGhyID0gcXEuY3JlYXRlWGhySW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geGhyLndpdGhDcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzWGRyU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5YRG9tYWluUmVxdWVzdCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzQ3Jvc3NPcmlnaW5BamF4U3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgaWYgKGlzQ3Jvc3NPcmlnaW5YaHJTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzWGRyU3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNGb2xkZXJTZWxlY3Rpb25TdXBwb3J0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLndlYmtpdGRpcmVjdG9yeSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzTG9jYWxTdG9yYWdlU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISF3aW5kb3cubG9jYWxTdG9yYWdlICYmIHFxLmlzRnVuY3Rpb24od2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRHJhZ0FuZERyb3BTdXBwb3J0ZWQoKSB7XG4gICAgICAgICAgICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIChcImRyYWdnYWJsZVwiIGluIHNwYW4gfHwgXCJvbmRyYWdzdGFydFwiIGluIHNwYW4gJiYgXCJvbmRyb3BcIiBpbiBzcGFuKSAmJiAhcXEuYW5kcm9pZCgpICYmICFxcS5pb3MoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBwb3J0c1VwbG9hZGluZyA9IHRlc3RTdXBwb3J0c0ZpbGVJbnB1dEVsZW1lbnQoKTtcbiAgICAgICAgc3VwcG9ydHNBamF4RmlsZVVwbG9hZGluZyA9IHN1cHBvcnRzVXBsb2FkaW5nICYmIHFxLmlzWGhyVXBsb2FkU3VwcG9ydGVkKCk7XG4gICAgICAgIHN1cHBvcnRzVXBsb2FkaW5nQmxvYnMgPSBzdXBwb3J0c0FqYXhGaWxlVXBsb2FkaW5nICYmICFxcS5hbmRyb2lkU3RvY2soKTtcbiAgICAgICAgc3VwcG9ydHNGaWxlRHJvcCA9IHN1cHBvcnRzQWpheEZpbGVVcGxvYWRpbmcgJiYgaXNEcmFnQW5kRHJvcFN1cHBvcnRlZCgpO1xuICAgICAgICBzdXBwb3J0c0ZvbGRlckRyb3AgPSBzdXBwb3J0c0ZpbGVEcm9wICYmIGlzQ2hyb21lMjFPckhpZ2hlcigpO1xuICAgICAgICBzdXBwb3J0c0NodW5raW5nID0gc3VwcG9ydHNBamF4RmlsZVVwbG9hZGluZyAmJiBxcS5pc0ZpbGVDaHVua2luZ1N1cHBvcnRlZCgpO1xuICAgICAgICBzdXBwb3J0c1Jlc3VtZSA9IHN1cHBvcnRzQWpheEZpbGVVcGxvYWRpbmcgJiYgc3VwcG9ydHNDaHVua2luZyAmJiBpc0xvY2FsU3RvcmFnZVN1cHBvcnRlZCgpO1xuICAgICAgICBzdXBwb3J0c1VwbG9hZFZpYVBhc3RlID0gc3VwcG9ydHNBamF4RmlsZVVwbG9hZGluZyAmJiBpc0Nocm9tZTE0T3JIaWdoZXIoKTtcbiAgICAgICAgc3VwcG9ydHNVcGxvYWRDb3JzID0gc3VwcG9ydHNVcGxvYWRpbmcgJiYgKHdpbmRvdy5wb3N0TWVzc2FnZSAhPT0gdW5kZWZpbmVkIHx8IHN1cHBvcnRzQWpheEZpbGVVcGxvYWRpbmcpO1xuICAgICAgICBzdXBwb3J0c0RlbGV0ZUZpbGVDb3JzWGhyID0gaXNDcm9zc09yaWdpblhoclN1cHBvcnRlZCgpO1xuICAgICAgICBzdXBwb3J0c0RlbGV0ZUZpbGVYZHIgPSBpc1hkclN1cHBvcnRlZCgpO1xuICAgICAgICBzdXBwb3J0c0RlbGV0ZUZpbGVDb3JzID0gaXNDcm9zc09yaWdpbkFqYXhTdXBwb3J0ZWQoKTtcbiAgICAgICAgc3VwcG9ydHNGb2xkZXJTZWxlY3Rpb24gPSBpc0ZvbGRlclNlbGVjdGlvblN1cHBvcnRlZCgpO1xuICAgICAgICBzdXBwb3J0c0ltYWdlUHJldmlld3MgPSBzdXBwb3J0c0FqYXhGaWxlVXBsb2FkaW5nICYmIHdpbmRvdy5GaWxlUmVhZGVyICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHN1cHBvcnRzVXBsb2FkUHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c0FqYXhGaWxlVXBsb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFxcS5hbmRyb2lkU3RvY2soKSAmJiAhcXEuaW9zQ2hyb21lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFqYXhVcGxvYWRpbmc6IHN1cHBvcnRzQWpheEZpbGVVcGxvYWRpbmcsXG4gICAgICAgICAgICBibG9iVXBsb2FkaW5nOiBzdXBwb3J0c1VwbG9hZGluZ0Jsb2JzLFxuICAgICAgICAgICAgY2FuRGV0ZXJtaW5lU2l6ZTogc3VwcG9ydHNBamF4RmlsZVVwbG9hZGluZyxcbiAgICAgICAgICAgIGNodW5raW5nOiBzdXBwb3J0c0NodW5raW5nLFxuICAgICAgICAgICAgZGVsZXRlRmlsZUNvcnM6IHN1cHBvcnRzRGVsZXRlRmlsZUNvcnMsXG4gICAgICAgICAgICBkZWxldGVGaWxlQ29yc1hkcjogc3VwcG9ydHNEZWxldGVGaWxlWGRyLFxuICAgICAgICAgICAgZGVsZXRlRmlsZUNvcnNYaHI6IHN1cHBvcnRzRGVsZXRlRmlsZUNvcnNYaHIsXG4gICAgICAgICAgICBkaWFsb2dFbGVtZW50OiAhIXdpbmRvdy5IVE1MRGlhbG9nRWxlbWVudCxcbiAgICAgICAgICAgIGZpbGVEcm9wOiBzdXBwb3J0c0ZpbGVEcm9wLFxuICAgICAgICAgICAgZm9sZGVyRHJvcDogc3VwcG9ydHNGb2xkZXJEcm9wLFxuICAgICAgICAgICAgZm9sZGVyU2VsZWN0aW9uOiBzdXBwb3J0c0ZvbGRlclNlbGVjdGlvbixcbiAgICAgICAgICAgIGltYWdlUHJldmlld3M6IHN1cHBvcnRzSW1hZ2VQcmV2aWV3cyxcbiAgICAgICAgICAgIGltYWdlVmFsaWRhdGlvbjogc3VwcG9ydHNJbWFnZVByZXZpZXdzLFxuICAgICAgICAgICAgaXRlbVNpemVWYWxpZGF0aW9uOiBzdXBwb3J0c0FqYXhGaWxlVXBsb2FkaW5nLFxuICAgICAgICAgICAgcGF1c2U6IHN1cHBvcnRzQ2h1bmtpbmcsXG4gICAgICAgICAgICBwcm9ncmVzc0Jhcjogc3VwcG9ydHNVcGxvYWRQcm9ncmVzcyxcbiAgICAgICAgICAgIHJlc3VtZTogc3VwcG9ydHNSZXN1bWUsXG4gICAgICAgICAgICBzY2FsaW5nOiBzdXBwb3J0c0ltYWdlUHJldmlld3MgJiYgc3VwcG9ydHNVcGxvYWRpbmdCbG9icyxcbiAgICAgICAgICAgIHRpZmZQcmV2aWV3czogcXEuc2FmYXJpKCksXG4gICAgICAgICAgICB1bmxpbWl0ZWRTY2FsZWRJbWFnZVNpemU6ICFxcS5pb3MoKSxcbiAgICAgICAgICAgIHVwbG9hZGluZzogc3VwcG9ydHNVcGxvYWRpbmcsXG4gICAgICAgICAgICB1cGxvYWRDb3JzOiBzdXBwb3J0c1VwbG9hZENvcnMsXG4gICAgICAgICAgICB1cGxvYWRDdXN0b21IZWFkZXJzOiBzdXBwb3J0c0FqYXhGaWxlVXBsb2FkaW5nLFxuICAgICAgICAgICAgdXBsb2FkTm9uTXVsdGlwYXJ0OiBzdXBwb3J0c0FqYXhGaWxlVXBsb2FkaW5nLFxuICAgICAgICAgICAgdXBsb2FkVmlhUGFzdGU6IHN1cHBvcnRzVXBsb2FkVmlhUGFzdGVcbiAgICAgICAgfTtcbiAgICB9KCk7XG4gICAgcXEuaXNHZW5lcmljUHJvbWlzZSA9IGZ1bmN0aW9uKG1heWJlUHJvbWlzZSkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgcmV0dXJuICEhKG1heWJlUHJvbWlzZSAmJiBtYXliZVByb21pc2UudGhlbiAmJiBxcS5pc0Z1bmN0aW9uKG1heWJlUHJvbWlzZS50aGVuKSk7XG4gICAgfTtcbiAgICBxcS5Qcm9taXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgc3VjY2Vzc0FyZ3MsIGZhaWx1cmVBcmdzLCBzdWNjZXNzQ2FsbGJhY2tzID0gW10sIGZhaWx1cmVDYWxsYmFja3MgPSBbXSwgZG9uZUNhbGxiYWNrcyA9IFtdLCBzdGF0ZSA9IDA7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICB0aGVuOiBmdW5jdGlvbihvblN1Y2Nlc3MsIG9uRmFpbHVyZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob25TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2tzLnB1c2gob25TdWNjZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob25GYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlQ2FsbGJhY2tzLnB1c2gob25GYWlsdXJlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRmFpbHVyZSAmJiBvbkZhaWx1cmUuYXBwbHkobnVsbCwgZmFpbHVyZUFyZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob25TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzcy5hcHBseShudWxsLCBzdWNjZXNzQXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgZmFpbHVyZUFyZ3MgPT09IHVuZGVmaW5lZCA/IHN1Y2Nlc3NBcmdzIDogZmFpbHVyZUFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc0FyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3NDYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHFxLmVhY2goc3VjY2Vzc0NhbGxiYWNrcywgZnVuY3Rpb24oaWR4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgc3VjY2Vzc0FyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRvbmVDYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHFxLmVhY2goZG9uZUNhbGxiYWNrcywgZnVuY3Rpb24oaWR4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgc3VjY2Vzc0FyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmFpbHVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSAtMTtcbiAgICAgICAgICAgICAgICBmYWlsdXJlQXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICBpZiAoZmFpbHVyZUNhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChmYWlsdXJlQ2FsbGJhY2tzLCBmdW5jdGlvbihpZHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBmYWlsdXJlQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZG9uZUNhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChkb25lQ2FsbGJhY2tzLCBmdW5jdGlvbihpZHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBmYWlsdXJlQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBxcS5CbG9iUHJveHkgPSBmdW5jdGlvbihyZWZlcmVuY2VCbG9iLCBvbkNyZWF0ZSkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZUJsb2I6IHJlZmVyZW5jZUJsb2IsXG4gICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbkNyZWF0ZShyZWZlcmVuY2VCbG9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBxcS5VcGxvYWRCdXR0b24gPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGRpc3Bvc2VTdXBwb3J0ID0gbmV3IHFxLkRpc3Bvc2VTdXBwb3J0KCksIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhY2NlcHRGaWxlczogbnVsbCxcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICBmb2N1c0NsYXNzOiBcInFxLXVwbG9hZC1idXR0b24tZm9jdXNcIixcbiAgICAgICAgICAgIGZvbGRlcnM6IGZhbHNlLFxuICAgICAgICAgICAgaG92ZXJDbGFzczogXCJxcS11cGxvYWQtYnV0dG9uLWhvdmVyXCIsXG4gICAgICAgICAgICBpb3M4QnJvd3NlckNyYXNoV29ya2Fyb3VuZDogZmFsc2UsXG4gICAgICAgICAgICBtdWx0aXBsZTogZmFsc2UsXG4gICAgICAgICAgICBuYW1lOiBcInFxZmlsZVwiLFxuICAgICAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKGlucHV0KSB7fSxcbiAgICAgICAgICAgIHRpdGxlOiBudWxsXG4gICAgICAgIH0sIGlucHV0LCBidXR0b25JZDtcbiAgICAgICAgcXEuZXh0ZW5kKG9wdGlvbnMsIG8pO1xuICAgICAgICBidXR0b25JZCA9IHFxLmdldFVuaXF1ZUlkKCk7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUlucHV0KCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKHFxLlVwbG9hZEJ1dHRvbi5CVVRUT05fSURfQVRUUl9OQU1FLCBidXR0b25JZCk7XG4gICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCBvcHRpb25zLnRpdGxlKTtcbiAgICAgICAgICAgIHNlbGYuc2V0TXVsdGlwbGUob3B0aW9ucy5tdWx0aXBsZSwgaW5wdXQpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZm9sZGVycyAmJiBxcS5zdXBwb3J0ZWRGZWF0dXJlcy5mb2xkZXJTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJ3ZWJraXRkaXJlY3RvcnlcIiwgXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hY2NlcHRGaWxlcykge1xuICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcImFjY2VwdFwiLCBvcHRpb25zLmFjY2VwdEZpbGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJmaWxlXCIpO1xuICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBvcHRpb25zLm5hbWUpO1xuICAgICAgICAgICAgcXEoaW5wdXQpLmNzcyh7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseTogXCJBcmlhbFwiLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiBxcS5pZSgpICYmICFxcS5pZTgoKSA/IFwiMzUwMHB4XCIgOiBcIjExOHB4XCIsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICFxcS5pZTcoKSAmJiBxcShpbnB1dCkuY3NzKHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9wdGlvbnMuZWxlbWVudC5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgICAgICBkaXNwb3NlU3VwcG9ydC5hdHRhY2goaW5wdXQsIFwiY2hhbmdlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub25DaGFuZ2UoaW5wdXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXNwb3NlU3VwcG9ydC5hdHRhY2goaW5wdXQsIFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHFxKG9wdGlvbnMuZWxlbWVudCkuYWRkQ2xhc3Mob3B0aW9ucy5ob3ZlckNsYXNzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlzcG9zZVN1cHBvcnQuYXR0YWNoKGlucHV0LCBcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHFxKG9wdGlvbnMuZWxlbWVudCkucmVtb3ZlQ2xhc3Mob3B0aW9ucy5ob3ZlckNsYXNzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlzcG9zZVN1cHBvcnQuYXR0YWNoKGlucHV0LCBcImZvY3VzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHFxKG9wdGlvbnMuZWxlbWVudCkuYWRkQ2xhc3Mob3B0aW9ucy5mb2N1c0NsYXNzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlzcG9zZVN1cHBvcnQuYXR0YWNoKGlucHV0LCBcImJsdXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcXEob3B0aW9ucy5lbGVtZW50KS5yZW1vdmVDbGFzcyhvcHRpb25zLmZvY3VzQ2xhc3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcXEob3B0aW9ucy5lbGVtZW50KS5jc3Moe1xuICAgICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBcImx0clwiXG4gICAgICAgIH0pO1xuICAgICAgICBxcS5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgZ2V0SW5wdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRCdXR0b25JZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbklkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldE11bHRpcGxlOiBmdW5jdGlvbihpc011bHRpcGxlLCBvcHRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IG9wdElucHV0IHx8IHRoaXMuZ2V0SW5wdXQoKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5pb3M4QnJvd3NlckNyYXNoV29ya2Fyb3VuZCAmJiBxcS5pb3M4KCkgJiYgKHFxLmlvc0Nocm9tZSgpIHx8IHFxLmlvc1NhZmFyaVdlYlZpZXcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKFwibXVsdGlwbGVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0QWNjZXB0RmlsZXM6IGZ1bmN0aW9uKGFjY2VwdEZpbGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjY2VwdEZpbGVzICE9PSBvcHRpb25zLmFjY2VwdEZpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcImFjY2VwdFwiLCBhY2NlcHRGaWxlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBxcShpbnB1dCkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHFxKG9wdGlvbnMuZWxlbWVudCkucmVtb3ZlQ2xhc3Mob3B0aW9ucy5mb2N1c0NsYXNzKTtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBjcmVhdGVJbnB1dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaW5wdXQgPSBjcmVhdGVJbnB1dCgpO1xuICAgIH07XG4gICAgcXEuVXBsb2FkQnV0dG9uLkJVVFRPTl9JRF9BVFRSX05BTUUgPSBcInFxLWJ1dHRvbi1pZFwiO1xuICAgIHFxLlVwbG9hZERhdGEgPSBmdW5jdGlvbih1cGxvYWRlclByb3h5KSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgZGF0YSA9IFtdLCBieVV1aWQgPSB7fSwgYnlTdGF0dXMgPSB7fSwgYnlQcm94eUdyb3VwSWQgPSB7fSwgYnlCYXRjaElkID0ge307XG4gICAgICAgIGZ1bmN0aW9uIGdldERhdGFCeUlkcyhpZE9ySWRzKSB7XG4gICAgICAgICAgICBpZiAocXEuaXNBcnJheShpZE9ySWRzKSkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgICAgICAgICAgICAgcXEuZWFjaChpZE9ySWRzLCBmdW5jdGlvbihpZHgsIGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaChkYXRhW2lkXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YVtpZE9ySWRzXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXREYXRhQnlVdWlkcyh1dWlkcykge1xuICAgICAgICAgICAgaWYgKHFxLmlzQXJyYXkodXVpZHMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBxcS5lYWNoKHV1aWRzLCBmdW5jdGlvbihpZHgsIHV1aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKGRhdGFbYnlVdWlkW3V1aWRdXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YVtieVV1aWRbdXVpZHNdXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXREYXRhQnlTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgICAgICB2YXIgc3RhdHVzUmVzdWx0cyA9IFtdLCBzdGF0dXNlcyA9IFtdLmNvbmNhdChzdGF0dXMpO1xuICAgICAgICAgICAgcXEuZWFjaChzdGF0dXNlcywgZnVuY3Rpb24oaW5kZXgsIHN0YXR1c0VudW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzUmVzdWx0SW5kZXhlcyA9IGJ5U3RhdHVzW3N0YXR1c0VudW1dO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNSZXN1bHRJbmRleGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChzdGF0dXNSZXN1bHRJbmRleGVzLCBmdW5jdGlvbihpLCBkYXRhSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1Jlc3VsdHMucHVzaChkYXRhW2RhdGFJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0dXNSZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBhZGRGaWxlOiBmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHNwZWMuc3RhdHVzIHx8IHFxLnN0YXR1cy5TVUJNSVRUSU5HLCBpZCA9IGRhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHNwZWMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxOYW1lOiBzcGVjLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHV1aWQ6IHNwZWMudXVpZCxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogc3BlYy5zaXplID09IG51bGwgPyAtMSA6IHNwZWMuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXNcbiAgICAgICAgICAgICAgICB9KSAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWMuYmF0Y2hJZCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2lkXS5iYXRjaElkID0gc3BlYy5iYXRjaElkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnlCYXRjaElkW3NwZWMuYmF0Y2hJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnlCYXRjaElkW3NwZWMuYmF0Y2hJZF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBieUJhdGNoSWRbc3BlYy5iYXRjaElkXS5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNwZWMucHJveHlHcm91cElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaWRdLnByb3h5R3JvdXBJZCA9IHNwZWMucHJveHlHcm91cElkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnlQcm94eUdyb3VwSWRbc3BlYy5wcm94eUdyb3VwSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5UHJveHlHcm91cElkW3NwZWMucHJveHlHcm91cElkXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJ5UHJveHlHcm91cElkW3NwZWMucHJveHlHcm91cElkXS5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YVtpZF0uaWQgPSBpZDtcbiAgICAgICAgICAgICAgICBieVV1aWRbc3BlYy51dWlkXSA9IGlkO1xuICAgICAgICAgICAgICAgIGlmIChieVN0YXR1c1tzdGF0dXNdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnlTdGF0dXNbc3RhdHVzXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBieVN0YXR1c1tzdGF0dXNdLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgIHVwbG9hZGVyUHJveHkub25TdGF0dXNDaGFuZ2UoaWQsIG51bGwsIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldHJpZXZlOiBmdW5jdGlvbihvcHRpb25hbEZpbHRlcikge1xuICAgICAgICAgICAgICAgIGlmIChxcS5pc09iamVjdChvcHRpb25hbEZpbHRlcikgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsRmlsdGVyLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXREYXRhQnlJZHMob3B0aW9uYWxGaWx0ZXIuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbmFsRmlsdGVyLnV1aWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldERhdGFCeVV1aWRzKG9wdGlvbmFsRmlsdGVyLnV1aWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbmFsRmlsdGVyLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldERhdGFCeVN0YXR1cyhvcHRpb25hbEZpbHRlci5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHFxLmV4dGVuZChbXSwgZGF0YSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gW107XG4gICAgICAgICAgICAgICAgYnlVdWlkID0ge307XG4gICAgICAgICAgICAgICAgYnlTdGF0dXMgPSB7fTtcbiAgICAgICAgICAgICAgICBieUJhdGNoSWQgPSB7fTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRTdGF0dXM6IGZ1bmN0aW9uKGlkLCBuZXdTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkU3RhdHVzID0gZGF0YVtpZF0uc3RhdHVzLCBieVN0YXR1c09sZFN0YXR1c0luZGV4ID0gcXEuaW5kZXhPZihieVN0YXR1c1tvbGRTdGF0dXNdLCBpZCk7XG4gICAgICAgICAgICAgICAgYnlTdGF0dXNbb2xkU3RhdHVzXS5zcGxpY2UoYnlTdGF0dXNPbGRTdGF0dXNJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgZGF0YVtpZF0uc3RhdHVzID0gbmV3U3RhdHVzO1xuICAgICAgICAgICAgICAgIGlmIChieVN0YXR1c1tuZXdTdGF0dXNdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnlTdGF0dXNbbmV3U3RhdHVzXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBieVN0YXR1c1tuZXdTdGF0dXNdLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgIHVwbG9hZGVyUHJveHkub25TdGF0dXNDaGFuZ2UoaWQsIG9sZFN0YXR1cywgbmV3U3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1dWlkQ2hhbmdlZDogZnVuY3Rpb24oaWQsIG5ld1V1aWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVXVpZCA9IGRhdGFbaWRdLnV1aWQ7XG4gICAgICAgICAgICAgICAgZGF0YVtpZF0udXVpZCA9IG5ld1V1aWQ7XG4gICAgICAgICAgICAgICAgYnlVdWlkW25ld1V1aWRdID0gaWQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGJ5VXVpZFtvbGRVdWlkXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVOYW1lOiBmdW5jdGlvbihpZCwgbmV3TmFtZSkge1xuICAgICAgICAgICAgICAgIGRhdGFbaWRdLm5hbWUgPSBuZXdOYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZVNpemU6IGZ1bmN0aW9uKGlkLCBuZXdTaXplKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtpZF0uc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0UGFyZW50SWQ6IGZ1bmN0aW9uKHRhcmdldElkLCBwYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgIGRhdGFbdGFyZ2V0SWRdLnBhcmVudElkID0gcGFyZW50SWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SWRzSW5Qcm94eUdyb3VwOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciBwcm94eUdyb3VwSWQgPSBkYXRhW2lkXS5wcm94eUdyb3VwSWQ7XG4gICAgICAgICAgICAgICAgaWYgKHByb3h5R3JvdXBJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnlQcm94eUdyb3VwSWRbcHJveHlHcm91cElkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldElkc0luQmF0Y2g6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhdGNoSWQgPSBkYXRhW2lkXS5iYXRjaElkO1xuICAgICAgICAgICAgICAgIHJldHVybiBieUJhdGNoSWRbYmF0Y2hJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcXEuc3RhdHVzID0ge1xuICAgICAgICBTVUJNSVRUSU5HOiBcInN1Ym1pdHRpbmdcIixcbiAgICAgICAgU1VCTUlUVEVEOiBcInN1Ym1pdHRlZFwiLFxuICAgICAgICBSRUpFQ1RFRDogXCJyZWplY3RlZFwiLFxuICAgICAgICBRVUVVRUQ6IFwicXVldWVkXCIsXG4gICAgICAgIENBTkNFTEVEOiBcImNhbmNlbGVkXCIsXG4gICAgICAgIFBBVVNFRDogXCJwYXVzZWRcIixcbiAgICAgICAgVVBMT0FESU5HOiBcInVwbG9hZGluZ1wiLFxuICAgICAgICBVUExPQURfUkVUUllJTkc6IFwicmV0cnlpbmcgdXBsb2FkXCIsXG4gICAgICAgIFVQTE9BRF9TVUNDRVNTRlVMOiBcInVwbG9hZCBzdWNjZXNzZnVsXCIsXG4gICAgICAgIFVQTE9BRF9GQUlMRUQ6IFwidXBsb2FkIGZhaWxlZFwiLFxuICAgICAgICBERUxFVEVfRkFJTEVEOiBcImRlbGV0ZSBmYWlsZWRcIixcbiAgICAgICAgREVMRVRJTkc6IFwiZGVsZXRpbmdcIixcbiAgICAgICAgREVMRVRFRDogXCJkZWxldGVkXCJcbiAgICB9O1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHFxLmJhc2VQdWJsaWNBcGkgPSB7XG4gICAgICAgICAgICBhZGRCbG9iczogZnVuY3Rpb24oYmxvYkRhdGFPckFycmF5LCBwYXJhbXMsIGVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRGaWxlcyhibG9iRGF0YU9yQXJyYXksIHBhcmFtcywgZW5kcG9pbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZEluaXRpYWxGaWxlczogZnVuY3Rpb24oY2FubmVkRmlsZUxpc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcXEuZWFjaChjYW5uZWRGaWxlTGlzdCwgZnVuY3Rpb24oaW5kZXgsIGNhbm5lZEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkQ2FubmVkRmlsZShjYW5uZWRGaWxlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRGaWxlczogZnVuY3Rpb24oZGF0YSwgcGFyYW1zLCBlbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21heWJlSGFuZGxlSW9zOFNhZmFyaVdvcmthcm91bmQoKTtcbiAgICAgICAgICAgICAgICB2YXIgYmF0Y2hJZCA9IHRoaXMuX3N0b3JlZElkcy5sZW5ndGggPT09IDAgPyBxcS5nZXRVbmlxdWVJZCgpIDogdGhpcy5fY3VycmVudEJhdGNoSWQsIHByb2Nlc3NCbG9iID0gcXEuYmluZChmdW5jdGlvbihibG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZU5ld0ZpbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvYjogYmxvYixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuX29wdGlvbnMuYmxvYnMuZGVmYXVsdE5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSwgYmF0Y2hJZCwgdmVyaWZpZWRGaWxlcyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyksIHByb2Nlc3NCbG9iRGF0YSA9IHFxLmJpbmQoZnVuY3Rpb24oYmxvYkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlTmV3RmlsZShibG9iRGF0YSwgYmF0Y2hJZCwgdmVyaWZpZWRGaWxlcyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyksIHByb2Nlc3NDYW52YXMgPSBxcS5iaW5kKGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvYiA9IHFxLmNhbnZhc1RvQmxvYihjYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVOZXdGaWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2I6IGJsb2IsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLl9vcHRpb25zLmJsb2JzLmRlZmF1bHROYW1lICsgXCIucG5nXCJcbiAgICAgICAgICAgICAgICAgICAgfSwgYmF0Y2hJZCwgdmVyaWZpZWRGaWxlcyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyksIHByb2Nlc3NDYW52YXNEYXRhID0gcXEuYmluZChmdW5jdGlvbihjYW52YXNEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkUXVhbGl0eSA9IGNhbnZhc0RhdGEucXVhbGl0eSAmJiBjYW52YXNEYXRhLnF1YWxpdHkgLyAxMDAsIGJsb2IgPSBxcS5jYW52YXNUb0Jsb2IoY2FudmFzRGF0YS5jYW52YXMsIGNhbnZhc0RhdGEudHlwZSwgbm9ybWFsaXplZFF1YWxpdHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVOZXdGaWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2I6IGJsb2IsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBjYW52YXNEYXRhLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSwgYmF0Y2hJZCwgdmVyaWZpZWRGaWxlcyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyksIHByb2Nlc3NGaWxlT3JJbnB1dCA9IHFxLmJpbmQoZnVuY3Rpb24oZmlsZU9ySW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHFxLmlzSW5wdXQoZmlsZU9ySW5wdXQpICYmIHFxLnN1cHBvcnRlZEZlYXR1cmVzLmFqYXhVcGxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZpbGVPcklucHV0LmZpbGVzKSwgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBxcS5lYWNoKGZpbGVzLCBmdW5jdGlvbihpZHgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9oYW5kbGVOZXdGaWxlKGZpbGUsIGJhdGNoSWQsIHZlcmlmaWVkRmlsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVOZXdGaWxlKGZpbGVPcklucHV0LCBiYXRjaElkLCB2ZXJpZmllZEZpbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpLCBub3JtYWxpemVEYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxcS5pc0ZpbGVMaXN0KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFtdLmNvbmNhdChkYXRhKTtcbiAgICAgICAgICAgICAgICB9LCBzZWxmID0gdGhpcywgdmVyaWZpZWRGaWxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRCYXRjaElkID0gYmF0Y2hJZDtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIHFxLmVhY2goZGF0YSwgZnVuY3Rpb24oaWR4LCBmaWxlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXEuaXNGaWxlT3JJbnB1dChmaWxlQ29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NGaWxlT3JJbnB1dChmaWxlQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocXEuaXNCbG9iKGZpbGVDb250YWluZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Jsb2IoZmlsZUNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHFxLmlzT2JqZWN0KGZpbGVDb250YWluZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVDb250YWluZXIuYmxvYiAmJiBmaWxlQ29udGFpbmVyLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Jsb2JEYXRhKGZpbGVDb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsZUNvbnRhaW5lci5jYW52YXMgJiYgZmlsZUNvbnRhaW5lci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NDYW52YXNEYXRhKGZpbGVDb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsZUNvbnRhaW5lci50YWdOYW1lICYmIGZpbGVDb250YWluZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImNhbnZhc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NhbnZhcyhmaWxlQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2coZmlsZUNvbnRhaW5lciArIFwiIGlzIG5vdCBhIHZhbGlkIGZpbGUgY29udGFpbmVyISAgSWdub3JpbmchXCIsIFwid2FyblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiUmVjZWl2ZWQgXCIgKyB2ZXJpZmllZEZpbGVzLmxlbmd0aCArIFwiIGZpbGVzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlcGFyZUl0ZW1zRm9yVXBsb2FkKHZlcmlmaWVkRmlsZXMsIHBhcmFtcywgZW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlci5jYW5jZWwoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbmNlbEFsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3JlZElkc0NvcHkgPSBbXSwgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcXEuZXh0ZW5kKHN0b3JlZElkc0NvcHksIHRoaXMuX3N0b3JlZElkcyk7XG4gICAgICAgICAgICAgICAgcXEuZWFjaChzdG9yZWRJZHNDb3B5LCBmdW5jdGlvbihpZHgsIHN0b3JlZEZpbGVJZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbmNlbChzdG9yZWRGaWxlSWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIuY2FuY2VsQWxsKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYXJTdG9yZWRGaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcmVkSWRzID0gW107XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGludWVVcGxvYWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVwbG9hZERhdGEgPSB0aGlzLl91cGxvYWREYXRhLnJldHJpZXZlKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFxcS5zdXBwb3J0ZWRGZWF0dXJlcy5wYXVzZSB8fCAhdGhpcy5fb3B0aW9ucy5jaHVua2luZy5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVwbG9hZERhdGEuc3RhdHVzID09PSBxcS5zdGF0dXMuUEFVU0VEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKHFxLmZvcm1hdChcIlBhdXNlZCBmaWxlIElEIHt9ICh7fSkgd2lsbCBiZSBjb250aW51ZWQuICBOb3QgcGF1c2VkLlwiLCBpZCwgdGhpcy5nZXROYW1lKGlkKSkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWRGaWxlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cocXEuZm9ybWF0KFwiSWdub3JpbmcgY29udGludWUgZm9yIGZpbGUgSUQge30gKHt9KS4gIE5vdCBwYXVzZWQuXCIsIGlkLCB0aGlzLmdldE5hbWUoaWQpKSwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlbGV0ZUZpbGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uU3VibWl0RGVsZXRlKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb2VzRXhpc3Q6IGZ1bmN0aW9uKGZpbGVPckJsb2JJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVyLmlzVmFsaWQoZmlsZU9yQmxvYklkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkcmF3VGh1bWJuYWlsOiBmdW5jdGlvbihmaWxlSWQsIGltZ09yQ2FudmFzLCBtYXhTaXplLCBmcm9tU2VydmVyLCBjdXN0b21SZXNpemVGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlVG9SZXR1cm4gPSBuZXcgcXEuUHJvbWlzZSgpLCBmaWxlT3JVcmwsIG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ltYWdlR2VuZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVPclVybCA9IHRoaXMuX3RodW1ibmFpbFVybHNbZmlsZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbVJlc2l6ZUZ1bmN0aW9uOiBjdXN0b21SZXNpemVGdW5jdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFNpemU6IG1heFNpemUgPiAwID8gbWF4U2l6ZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogbWF4U2l6ZSA+IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmcm9tU2VydmVyICYmIHFxLnN1cHBvcnRlZEZlYXR1cmVzLmltYWdlUHJldmlld3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVPclVybCA9IHRoaXMuZ2V0RmlsZShmaWxlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlT3JVcmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVRvUmV0dXJuLmZhaWx1cmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogaW1nT3JDYW52YXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFwiRmlsZSBvciBVUkwgbm90IGZvdW5kLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlR2VuZXJhdG9yLmdlbmVyYXRlKGZpbGVPclVybCwgaW1nT3JDYW52YXMsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gc3VjY2Vzcyhtb2RpZmllZENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VUb1JldHVybi5zdWNjZXNzKG1vZGlmaWVkQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIGZhaWx1cmUoY29udGFpbmVyLCByZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlVG9SZXR1cm4uZmFpbHVyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogcmVhc29uIHx8IFwiUHJvYmxlbSBnZW5lcmF0aW5nIHRodW1ibmFpbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VUb1JldHVybi5mYWlsdXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogaW1nT3JDYW52YXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogXCJNaXNzaW5nIGltYWdlIGdlbmVyYXRvciBtb2R1bGVcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VUb1JldHVybjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRCdXR0b246IGZ1bmN0aW9uKGZpbGVJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRCdXR0b24odGhpcy5fYnV0dG9uSWRzRm9yRmlsZUlkc1tmaWxlSWRdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRFbmRwb2ludDogZnVuY3Rpb24oZmlsZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VuZHBvaW50U3RvcmUuZ2V0KGZpbGVJZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RmlsZTogZnVuY3Rpb24oZmlsZU9yQmxvYklkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZXIuZ2V0RmlsZShmaWxlT3JCbG9iSWQpIHx8IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SW5Qcm9ncmVzczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwbG9hZERhdGEucmV0cmlldmUoe1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFsgcXEuc3RhdHVzLlVQTE9BRElORywgcXEuc3RhdHVzLlVQTE9BRF9SRVRSWUlORywgcXEuc3RhdHVzLlFVRVVFRCBdXG4gICAgICAgICAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldE5hbWU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwbG9hZERhdGEucmV0cmlldmUoe1xuICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICB9KS5uYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFBhcmVudElkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciB1cGxvYWREYXRhRW50cnkgPSB0aGlzLmdldFVwbG9hZHMoe1xuICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICB9KSwgcGFyZW50SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh1cGxvYWREYXRhRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwbG9hZERhdGFFbnRyeS5wYXJlbnRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZCA9IHVwbG9hZERhdGFFbnRyeS5wYXJlbnRJZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50SWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UmVzdW1hYmxlRmlsZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlci5nZXRSZXN1bWFibGVGaWxlc0RhdGEoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRTaXplOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl91cGxvYWREYXRhLnJldHJpZXZlKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICAgICAgfSkuc2l6ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXROZXRVcGxvYWRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbmV0VXBsb2FkZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UmVtYWluaW5nQWxsb3dlZEl0ZW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWxsb3dlZEl0ZW1zID0gdGhpcy5fY3VycmVudEl0ZW1MaW1pdDtcbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dlZEl0ZW1zID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsb3dlZEl0ZW1zIC0gdGhpcy5fbmV0VXBsb2FkZWRPclF1ZXVlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0VXBsb2FkczogZnVuY3Rpb24ob3B0aW9uYWxGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdXBsb2FkRGF0YS5yZXRyaWV2ZShvcHRpb25hbEZpbHRlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0VXVpZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdXBsb2FkRGF0YS5yZXRyaWV2ZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgIH0pLnV1aWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9nOiBmdW5jdGlvbihzdHIsIGxldmVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZGVidWcgJiYgKCFsZXZlbCB8fCBsZXZlbCA9PT0gXCJpbmZvXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHFxLmxvZyhcIltGaW5lIFVwbG9hZGVyIFwiICsgcXEudmVyc2lvbiArIFwiXSBcIiArIHN0cik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZXZlbCAmJiBsZXZlbCAhPT0gXCJpbmZvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEubG9nKFwiW0ZpbmUgVXBsb2FkZXIgXCIgKyBxcS52ZXJzaW9uICsgXCJdIFwiICsgc3RyLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdXNlVXBsb2FkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciB1cGxvYWREYXRhID0gdGhpcy5fdXBsb2FkRGF0YS5yZXRyaWV2ZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghcXEuc3VwcG9ydGVkRmVhdHVyZXMucGF1c2UgfHwgIXRoaXMuX29wdGlvbnMuY2h1bmtpbmcuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChxcS5pbmRleE9mKFsgcXEuc3RhdHVzLlVQTE9BRElORywgcXEuc3RhdHVzLlVQTE9BRF9SRVRSWUlORyBdLCB1cGxvYWREYXRhLnN0YXR1cykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlci5wYXVzZShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwbG9hZERhdGEuc2V0U3RhdHVzKGlkLCBxcS5zdGF0dXMuUEFVU0VEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cocXEuZm9ybWF0KFwiVW5hYmxlIHRvIHBhdXNlIGZpbGUgSUQge30gKHt9KS5cIiwgaWQsIHRoaXMuZ2V0TmFtZShpZCkpLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cocXEuZm9ybWF0KFwiSWdub3JpbmcgcGF1c2UgZm9yIGZpbGUgSUQge30gKHt9KS4gIE5vdCBpbiBwcm9ncmVzcy5cIiwgaWQsIHRoaXMuZ2V0TmFtZShpZCkpLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiUmVzZXR0aW5nIHVwbG9hZGVyLi4uXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9yZWRJZHMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdXRvUmV0cmllcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JldHJ5VGltZW91dHMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2ZW50UmV0cmllcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RodW1ibmFpbFVybHMgPSBbXTtcbiAgICAgICAgICAgICAgICBxcS5lYWNoKHRoaXMuX2J1dHRvbnMsIGZ1bmN0aW9uKGlkeCwgYnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5yZXNldCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtc1N0b3JlLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kcG9pbnRTdG9yZS5yZXNldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX25ldFVwbG9hZGVkT3JRdWV1ZWQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX25ldFVwbG9hZGVkID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWREYXRhLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnV0dG9uSWRzRm9yRmlsZUlkcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bhc3RlSGFuZGxlciAmJiB0aGlzLl9wYXN0ZUhhbmRsZXIucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLnNlc3Npb24ucmVmcmVzaE9uUmVzZXQgJiYgdGhpcy5fcmVmcmVzaFNlc3Npb25EYXRhKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3VjY2VlZGVkU2luY2VMYXN0QWxsQ29tcGxldGUgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9mYWlsZWRTaW5jZUxhc3RBbGxDb21wbGV0ZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvdGFsUHJvZ3Jlc3MgJiYgdGhpcy5fdG90YWxQcm9ncmVzcy5yZXNldCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldHJ5OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYW51YWxSZXRyeShpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NhbGVJbWFnZTogZnVuY3Rpb24oaWQsIHNwZWNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBxcS5TY2FsZXIucHJvdG90eXBlLnNjYWxlSW1hZ2UoaWQsIHNwZWNzLCB7XG4gICAgICAgICAgICAgICAgICAgIGxvZzogcXEuYmluZChzZWxmLmxvZywgc2VsZiksXG4gICAgICAgICAgICAgICAgICAgIGdldEZpbGU6IHFxLmJpbmQoc2VsZi5nZXRGaWxlLCBzZWxmKSxcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkRGF0YTogc2VsZi5fdXBsb2FkRGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldEN1c3RvbUhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlcnMsIGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VzdG9tSGVhZGVyc1N0b3JlLnNldChoZWFkZXJzLCBpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0RGVsZXRlRmlsZUN1c3RvbUhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlcnMsIGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVsZXRlRmlsZUN1c3RvbUhlYWRlcnNTdG9yZS5zZXQoaGVhZGVycywgaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldERlbGV0ZUZpbGVFbmRwb2ludDogZnVuY3Rpb24oZW5kcG9pbnQsIGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVsZXRlRmlsZUVuZHBvaW50U3RvcmUuc2V0KGVuZHBvaW50LCBpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0RGVsZXRlRmlsZVBhcmFtczogZnVuY3Rpb24ocGFyYW1zLCBpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlbGV0ZUZpbGVQYXJhbXNTdG9yZS5zZXQocGFyYW1zLCBpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0RW5kcG9pbnQ6IGZ1bmN0aW9uKGVuZHBvaW50LCBpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZHBvaW50U3RvcmUuc2V0KGVuZHBvaW50LCBpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0Rm9ybTogZnVuY3Rpb24oZWxlbWVudE9ySWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVGb3JtU3VwcG9ydEFuZFBhcmFtcyhlbGVtZW50T3JJZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0SXRlbUxpbWl0OiBmdW5jdGlvbihuZXdJdGVtTGltaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SXRlbUxpbWl0ID0gbmV3SXRlbUxpbWl0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldE5hbWU6IGZ1bmN0aW9uKGlkLCBuZXdOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkRGF0YS51cGRhdGVOYW1lKGlkLCBuZXdOYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRQYXJhbXM6IGZ1bmN0aW9uKHBhcmFtcywgaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXNTdG9yZS5zZXQocGFyYW1zLCBpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0VXVpZDogZnVuY3Rpb24oaWQsIG5ld1V1aWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdXBsb2FkRGF0YS51dWlkQ2hhbmdlZChpZCwgbmV3VXVpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBsb2FkU3RvcmVkRmlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdG9yZWRJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1FcnJvcihcIm5vRmlsZXNFcnJvclwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWRTdG9yZWRGaWxlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcXEuYmFzZVByaXZhdGVBcGkgPSB7XG4gICAgICAgICAgICBfYWRkQ2FubmVkRmlsZTogZnVuY3Rpb24oc2Vzc2lvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLl91cGxvYWREYXRhLmFkZEZpbGUoe1xuICAgICAgICAgICAgICAgICAgICB1dWlkOiBzZXNzaW9uRGF0YS51dWlkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzZXNzaW9uRGF0YS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBzZXNzaW9uRGF0YS5zaXplLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHFxLnN0YXR1cy5VUExPQURfU1VDQ0VTU0ZVTFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlc3Npb25EYXRhLmRlbGV0ZUZpbGVFbmRwb2ludCAmJiB0aGlzLnNldERlbGV0ZUZpbGVFbmRwb2ludChzZXNzaW9uRGF0YS5kZWxldGVGaWxlRW5kcG9pbnQsIGlkKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uRGF0YS5kZWxldGVGaWxlUGFyYW1zICYmIHRoaXMuc2V0RGVsZXRlRmlsZVBhcmFtcyhzZXNzaW9uRGF0YS5kZWxldGVGaWxlUGFyYW1zLCBpZCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25EYXRhLnRodW1ibmFpbFVybCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aHVtYm5haWxVcmxzW2lkXSA9IHNlc3Npb25EYXRhLnRodW1ibmFpbFVybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV0VXBsb2FkZWQrKztcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXRVcGxvYWRlZE9yUXVldWVkKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9hbm5vdGF0ZVdpdGhCdXR0b25JZDogZnVuY3Rpb24oZmlsZSwgYXNzb2NpYXRlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHFxLmlzRmlsZShmaWxlKSkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlLnFxQnV0dG9uSWQgPSB0aGlzLl9nZXRCdXR0b25JZChhc3NvY2lhdGVkSW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYmF0Y2hFcnJvcjogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLm9uRXJyb3IobnVsbCwgbnVsbCwgbWVzc2FnZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY3JlYXRlRGVsZXRlSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcXEuRGVsZXRlRmlsZUFqYXhSZXF1ZXN0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMuX29wdGlvbnMuZGVsZXRlRmlsZS5tZXRob2QudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4Q29ubmVjdGlvbnM6IHRoaXMuX29wdGlvbnMubWF4Q29ubmVjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHV1aWRQYXJhbU5hbWU6IHRoaXMuX29wdGlvbnMucmVxdWVzdC51dWlkTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tSGVhZGVyczogdGhpcy5fZGVsZXRlRmlsZUN1c3RvbUhlYWRlcnNTdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zU3RvcmU6IHRoaXMuX2RlbGV0ZUZpbGVQYXJhbXNTdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRTdG9yZTogdGhpcy5fZGVsZXRlRmlsZUVuZHBvaW50U3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIGNvcnM6IHRoaXMuX29wdGlvbnMuY29ycyxcbiAgICAgICAgICAgICAgICAgICAgbG9nOiBxcS5iaW5kKHNlbGYubG9nLCBzZWxmKSxcbiAgICAgICAgICAgICAgICAgICAgb25EZWxldGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vbkRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vcHRpb25zLmNhbGxiYWNrcy5vbkRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uRGVsZXRlQ29tcGxldGU6IGZ1bmN0aW9uKGlkLCB4aHJPclhkciwgaXNFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25EZWxldGVDb21wbGV0ZShpZCwgeGhyT3JYZHIsIGlzRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb3B0aW9ucy5jYWxsYmFja3Mub25EZWxldGVDb21wbGV0ZShpZCwgeGhyT3JYZHIsIGlzRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NyZWF0ZVBhc3RlSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcXEuUGFzdGVTdXBwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudDogdGhpcy5fb3B0aW9ucy5wYXN0ZS50YXJnZXRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZzogcXEuYmluZChzZWxmLmxvZywgc2VsZiksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXN0ZVJlY2VpdmVkOiBmdW5jdGlvbihibG9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5faGFuZGxlQ2hlY2tlZENhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJvblBhc3RlUmVjZWl2ZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHFxLmJpbmQoc2VsZi5fb3B0aW9ucy5jYWxsYmFja3Mub25QYXN0ZVJlY2VpdmVkLCBzZWxmLCBibG9iKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBxcS5iaW5kKHNlbGYuX2hhbmRsZVBhc3RlU3VjY2Vzcywgc2VsZiwgYmxvYiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IFwicGFzdGVkIGltYWdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jcmVhdGVTdG9yZTogZnVuY3Rpb24oaW5pdGlhbFZhbHVlLCBfcmVhZE9ubHlWYWx1ZXNfKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3JlID0ge30sIGNhdGNoYWxsID0gaW5pdGlhbFZhbHVlLCBwZXJJZFJlYWRPbmx5VmFsdWVzID0ge30sIHJlYWRPbmx5VmFsdWVzID0gX3JlYWRPbmx5VmFsdWVzXywgY29weSA9IGZ1bmN0aW9uKG9yaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHFxLmlzT2JqZWN0KG9yaWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXEuZXh0ZW5kKHt9LCBvcmlnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZztcbiAgICAgICAgICAgICAgICB9LCBnZXRSZWFkT25seVZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXEuaXNGdW5jdGlvbihyZWFkT25seVZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkT25seVZhbHVlcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkT25seVZhbHVlcztcbiAgICAgICAgICAgICAgICB9LCBpbmNsdWRlUmVhZE9ubHlWYWx1ZXMgPSBmdW5jdGlvbihpZCwgZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWRPbmx5VmFsdWVzICYmIHFxLmlzT2JqZWN0KGV4aXN0aW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXEuZXh0ZW5kKGV4aXN0aW5nLCBnZXRSZWFkT25seVZhbHVlcygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGVySWRSZWFkT25seVZhbHVlc1tpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFxLmV4dGVuZChleGlzdGluZywgcGVySWRSZWFkT25seVZhbHVlc1tpZF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCwgaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaGFsbCA9IGNvcHkodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVbaWRdID0gY29weSh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkICE9IG51bGwgJiYgc3RvcmVbaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gc3RvcmVbaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBjb3B5KGNhdGNoYWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVSZWFkT25seVZhbHVlcyhpZCwgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3B5KHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFkZFJlYWRPbmx5OiBmdW5jdGlvbihpZCwgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXEuaXNPYmplY3Qoc3RvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxcS5pc0Z1bmN0aW9uKHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5VmFsdWVzID0gdmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZE9ubHlWYWx1ZXMgPSByZWFkT25seVZhbHVlcyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFxLmV4dGVuZChyZWFkT25seVZhbHVlcywgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcklkUmVhZE9ubHlWYWx1ZXNbaWRdID0gcGVySWRSZWFkT25seVZhbHVlc1tpZF0gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFxLmV4dGVuZChwZXJJZFJlYWRPbmx5VmFsdWVzW2lkXSwgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oZmlsZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlIHN0b3JlW2ZpbGVJZF07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJJZFJlYWRPbmx5VmFsdWVzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaGFsbCA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NyZWF0ZVVwbG9hZERhdGFUcmFja2VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBxcS5VcGxvYWREYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0TmFtZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldE5hbWUoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRVdWlkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0VXVpZChpZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldFNpemU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRTaXplKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25TdGF0dXNDaGFuZ2U6IGZ1bmN0aW9uKGlkLCBvbGRTdGF0dXMsIG5ld1N0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25VcGxvYWRTdGF0dXNDaGFuZ2UoaWQsIG9sZFN0YXR1cywgbmV3U3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29wdGlvbnMuY2FsbGJhY2tzLm9uU3RhdHVzQ2hhbmdlKGlkLCBvbGRTdGF0dXMsIG5ld1N0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9tYXliZUFsbENvbXBsZXRlKGlkLCBuZXdTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX3RvdGFsUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl90b3RhbFByb2dyZXNzLm9uU3RhdHVzQ2hhbmdlKGlkLCBvbGRTdGF0dXMsIG5ld1N0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY3JlYXRlVXBsb2FkQnV0dG9uOiBmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBhY2NlcHRGaWxlcyA9IHNwZWMuYWNjZXB0IHx8IHRoaXMuX29wdGlvbnMudmFsaWRhdGlvbi5hY2NlcHRGaWxlcywgYWxsb3dlZEV4dGVuc2lvbnMgPSBzcGVjLmFsbG93ZWRFeHRlbnNpb25zIHx8IHRoaXMuX29wdGlvbnMudmFsaWRhdGlvbi5hbGxvd2VkRXh0ZW5zaW9ucywgYnV0dG9uO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFsbG93TXVsdGlwbGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxcS5zdXBwb3J0ZWRGZWF0dXJlcy5hamF4VXBsb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fb3B0aW9ucy53b3JrYXJvdW5kcy5pb3NFbXB0eVZpZGVvcyAmJiBxcS5pb3MoKSAmJiAhcXEuaW9zNigpICYmIHNlbGYuX2lzQWxsb3dlZEV4dGVuc2lvbihhbGxvd2VkRXh0ZW5zaW9ucywgXCIubW92XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWMubXVsdGlwbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9vcHRpb25zLm11bHRpcGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwZWMubXVsdGlwbGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidXR0b24gPSBuZXcgcXEuVXBsb2FkQnV0dG9uKHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXB0RmlsZXM6IGFjY2VwdEZpbGVzLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBzcGVjLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzQ2xhc3M6IHRoaXMuX29wdGlvbnMuY2xhc3Nlcy5idXR0b25Gb2N1cyxcbiAgICAgICAgICAgICAgICAgICAgZm9sZGVyczogc3BlYy5mb2xkZXJzLFxuICAgICAgICAgICAgICAgICAgICBob3ZlckNsYXNzOiB0aGlzLl9vcHRpb25zLmNsYXNzZXMuYnV0dG9uSG92ZXIsXG4gICAgICAgICAgICAgICAgICAgIGlvczhCcm93c2VyQ3Jhc2hXb3JrYXJvdW5kOiB0aGlzLl9vcHRpb25zLndvcmthcm91bmRzLmlvczhCcm93c2VyQ3Jhc2gsXG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxlOiBhbGxvd011bHRpcGxlKCksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuX29wdGlvbnMucmVxdWVzdC5pbnB1dE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25JbnB1dENoYW5nZShpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBzcGVjLnRpdGxlID09IG51bGwgPyB0aGlzLl9vcHRpb25zLnRleHQuZmlsZUlucHV0VGl0bGUgOiBzcGVjLnRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZVN1cHBvcnQuYWRkRGlzcG9zZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VsZi5fYnV0dG9ucy5wdXNoKGJ1dHRvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY3JlYXRlVXBsb2FkSGFuZGxlcjogZnVuY3Rpb24oYWRkaXRpb25hbE9wdGlvbnMsIG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcywgbGFzdE9uUHJvZ3Jlc3MgPSB7fSwgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWc6IHRoaXMuX29wdGlvbnMuZGVidWcsXG4gICAgICAgICAgICAgICAgICAgIG1heENvbm5lY3Rpb25zOiB0aGlzLl9vcHRpb25zLm1heENvbm5lY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICBjb3JzOiB0aGlzLl9vcHRpb25zLmNvcnMsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1N0b3JlOiB0aGlzLl9wYXJhbXNTdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRTdG9yZTogdGhpcy5fZW5kcG9pbnRTdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtpbmc6IHRoaXMuX29wdGlvbnMuY2h1bmtpbmcsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VtZTogdGhpcy5fb3B0aW9ucy5yZXN1bWUsXG4gICAgICAgICAgICAgICAgICAgIGJsb2JzOiB0aGlzLl9vcHRpb25zLmJsb2JzLFxuICAgICAgICAgICAgICAgICAgICBsb2c6IHFxLmJpbmQoc2VsZi5sb2csIHNlbGYpLFxuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50UmV0cnlQYXJhbTogdGhpcy5fb3B0aW9ucy5yZXRyeS5wcmV2ZW50UmV0cnlSZXNwb25zZVByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBvblByb2dyZXNzOiBmdW5jdGlvbihpZCwgbmFtZSwgbG9hZGVkLCB0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvYWRlZCA8IDAgfHwgdG90YWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RPblByb2dyZXNzW2lkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0T25Qcm9ncmVzc1tpZF0ubG9hZGVkICE9PSBsb2FkZWQgfHwgbGFzdE9uUHJvZ3Jlc3NbaWRdLnRvdGFsICE9PSB0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vblByb2dyZXNzKGlkLCBuYW1lLCBsb2FkZWQsIHRvdGFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb3B0aW9ucy5jYWxsYmFja3Mub25Qcm9ncmVzcyhpZCwgbmFtZSwgbG9hZGVkLCB0b3RhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vblByb2dyZXNzKGlkLCBuYW1lLCBsb2FkZWQsIHRvdGFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vcHRpb25zLmNhbGxiYWNrcy5vblByb2dyZXNzKGlkLCBuYW1lLCBsb2FkZWQsIHRvdGFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RPblByb2dyZXNzW2lkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkZWQ6IGxvYWRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbDogdG90YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKGlkLCBuYW1lLCByZXN1bHQsIHhocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxhc3RPblByb2dyZXNzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSBzZWxmLmdldFVwbG9hZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuc3RhdHVzLCByZXRWYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSBxcS5zdGF0dXMuVVBMT0FEX1NVQ0NFU1NGVUwgfHwgc3RhdHVzID09PSBxcS5zdGF0dXMuVVBMT0FEX0ZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldFZhbCA9IHNlbGYuX29uQ29tcGxldGUoaWQsIG5hbWUsIHJlc3VsdCwgeGhyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRWYWwgaW5zdGFuY2VvZiBxcS5Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0VmFsLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29wdGlvbnMuY2FsbGJhY2tzLm9uQ29tcGxldGUoaWQsIG5hbWUsIHJlc3VsdCwgeGhyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb3B0aW9ucy5jYWxsYmFja3Mub25Db21wbGV0ZShpZCwgbmFtZSwgcmVzdWx0LCB4aHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkNhbmNlbDogZnVuY3Rpb24oaWQsIG5hbWUsIGNhbmNlbEZpbmFsaXphdGlvbkVmZm9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5faGFuZGxlQ2hlY2tlZENhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm9uQ2FuY2VsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHFxLmJpbmQoc2VsZi5fb3B0aW9ucy5jYWxsYmFja3Mub25DYW5jZWwsIHNlbGYsIGlkLCBuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkZhaWx1cmU6IHByb21pc2UuZmFpbHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxGaW5hbGl6YXRpb25FZmZvcnQudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uQ2FuY2VsKGlkLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2Uuc3VjY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uVXBsb2FkUHJlcDogcXEuYmluZCh0aGlzLl9vblVwbG9hZFByZXAsIHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBvblVwbG9hZDogZnVuY3Rpb24oaWQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uVXBsb2FkKGlkLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29wdGlvbnMuY2FsbGJhY2tzLm9uVXBsb2FkKGlkLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25VcGxvYWRDaHVuazogZnVuY3Rpb24oaWQsIG5hbWUsIGNodW5rRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25VcGxvYWRDaHVuayhpZCwgY2h1bmtEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29wdGlvbnMuY2FsbGJhY2tzLm9uVXBsb2FkQ2h1bmsoaWQsIG5hbWUsIGNodW5rRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uVXBsb2FkQ2h1bmtTdWNjZXNzOiBmdW5jdGlvbihpZCwgY2h1bmtEYXRhLCByZXN1bHQsIHhocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb3B0aW9ucy5jYWxsYmFja3Mub25VcGxvYWRDaHVua1N1Y2Nlc3MuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25SZXN1bWU6IGZ1bmN0aW9uKGlkLCBuYW1lLCBjaHVua0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9vcHRpb25zLmNhbGxiYWNrcy5vblJlc3VtZShpZCwgbmFtZSwgY2h1bmtEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25BdXRvUmV0cnk6IGZ1bmN0aW9uKGlkLCBuYW1lLCByZXNwb25zZUpTT04sIHhocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX29uQXV0b1JldHJ5LmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uVXVpZENoYW5nZWQ6IGZ1bmN0aW9uKGlkLCBuZXdVdWlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZyhcIlNlcnZlciByZXF1ZXN0ZWQgVVVJRCBjaGFuZ2UgZnJvbSAnXCIgKyBzZWxmLmdldFV1aWQoaWQpICsgXCInIHRvICdcIiArIG5ld1V1aWQgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNldFV1aWQoaWQsIG5ld1V1aWQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXROYW1lOiBxcS5iaW5kKHNlbGYuZ2V0TmFtZSwgc2VsZiksXG4gICAgICAgICAgICAgICAgICAgIGdldFV1aWQ6IHFxLmJpbmQoc2VsZi5nZXRVdWlkLCBzZWxmKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0U2l6ZTogcXEuYmluZChzZWxmLmdldFNpemUsIHNlbGYpLFxuICAgICAgICAgICAgICAgICAgICBzZXRTaXplOiBxcS5iaW5kKHNlbGYuX3NldFNpemUsIHNlbGYpLFxuICAgICAgICAgICAgICAgICAgICBnZXREYXRhQnlVdWlkOiBmdW5jdGlvbih1dWlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRVcGxvYWRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dWlkOiB1dWlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaXNRdWV1ZWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gc2VsZi5nZXRVcGxvYWRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0dXMgPT09IHFxLnN0YXR1cy5RVUVVRUQgfHwgc3RhdHVzID09PSBxcS5zdGF0dXMuU1VCTUlUVEVEIHx8IHN0YXR1cyA9PT0gcXEuc3RhdHVzLlVQTE9BRF9SRVRSWUlORyB8fCBzdGF0dXMgPT09IHFxLnN0YXR1cy5QQVVTRUQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldElkc0luUHJveHlHcm91cDogc2VsZi5fdXBsb2FkRGF0YS5nZXRJZHNJblByb3h5R3JvdXAsXG4gICAgICAgICAgICAgICAgICAgIGdldElkc0luQmF0Y2g6IHNlbGYuX3VwbG9hZERhdGEuZ2V0SWRzSW5CYXRjaFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcXEuZWFjaCh0aGlzLl9vcHRpb25zLnJlcXVlc3QsIGZ1bmN0aW9uKHByb3AsIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY3VzdG9tSGVhZGVycyA9IHRoaXMuX2N1c3RvbUhlYWRlcnNTdG9yZTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChhZGRpdGlvbmFsT3B0aW9ucywgZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcXEuVXBsb2FkSGFuZGxlckNvbnRyb2xsZXIob3B0aW9ucywgbmFtZXNwYWNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZmlsZU9yQmxvYlJlamVjdGVkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25ldFVwbG9hZGVkT3JRdWV1ZWQtLTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWREYXRhLnNldFN0YXR1cyhpZCwgcXEuc3RhdHVzLlJFSkVDVEVEKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZm9ybWF0U2l6ZTogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ5dGVzICsgdGhpcy5fb3B0aW9ucy50ZXh0LnNpemVTeW1ib2xzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSBieXRlcyAvIDFlMztcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGJ5dGVzID4gOTk5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoYnl0ZXMsIC4xKS50b0ZpeGVkKDEpICsgdGhpcy5fb3B0aW9ucy50ZXh0LnNpemVTeW1ib2xzW2ldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZW5lcmF0ZUV4dHJhQnV0dG9uU3BlY3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLl9leHRyYUJ1dHRvblNwZWNzID0ge307XG4gICAgICAgICAgICAgICAgcXEuZWFjaCh0aGlzLl9vcHRpb25zLmV4dHJhQnV0dG9ucywgZnVuY3Rpb24oaWR4LCBleHRyYUJ1dHRvbk9wdGlvbkVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsZSA9IGV4dHJhQnV0dG9uT3B0aW9uRW50cnkubXVsdGlwbGUsIHZhbGlkYXRpb24gPSBxcS5leHRlbmQoe30sIHNlbGYuX29wdGlvbnMudmFsaWRhdGlvbiwgdHJ1ZSksIGV4dHJhQnV0dG9uU3BlYyA9IHFxLmV4dGVuZCh7fSwgZXh0cmFCdXR0b25PcHRpb25FbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aXBsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZSA9IHNlbGYuX29wdGlvbnMubXVsdGlwbGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhQnV0dG9uU3BlYy52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxcS5leHRlbmQodmFsaWRhdGlvbiwgZXh0cmFCdXR0b25PcHRpb25FbnRyeS52YWxpZGF0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBxcS5leHRlbmQoZXh0cmFCdXR0b25TcGVjLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZTogbXVsdGlwbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9pbml0RXh0cmFCdXR0b24oZXh0cmFCdXR0b25TcGVjKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZ2V0QnV0dG9uOiBmdW5jdGlvbihidXR0b25JZCkge1xuICAgICAgICAgICAgICAgIHZhciBleHRyYUJ1dHRvbnNTcGVjID0gdGhpcy5fZXh0cmFCdXR0b25TcGVjc1tidXR0b25JZF07XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhQnV0dG9uc1NwZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhQnV0dG9uc1NwZWMuZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJ1dHRvbklkID09PSB0aGlzLl9kZWZhdWx0QnV0dG9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuYnV0dG9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZ2V0QnV0dG9uSWQ6IGZ1bmN0aW9uKGJ1dHRvbk9yRmlsZUlucHV0T3JGaWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0cywgZmlsZUlucHV0LCBmaWxlQmxvYk9ySW5wdXQgPSBidXR0b25PckZpbGVJbnB1dE9yRmlsZTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZUJsb2JPcklucHV0IGluc3RhbmNlb2YgcXEuQmxvYlByb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVCbG9iT3JJbnB1dCA9IGZpbGVCbG9iT3JJbnB1dC5yZWZlcmVuY2VCbG9iO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlsZUJsb2JPcklucHV0ICYmICFxcS5pc0Jsb2IoZmlsZUJsb2JPcklucHV0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXEuaXNGaWxlKGZpbGVCbG9iT3JJbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlQmxvYk9ySW5wdXQucXFCdXR0b25JZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxlQmxvYk9ySW5wdXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiYgZmlsZUJsb2JPcklucHV0LnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlQmxvYk9ySW5wdXQuZ2V0QXR0cmlidXRlKHFxLlVwbG9hZEJ1dHRvbi5CVVRUT05fSURfQVRUUl9OQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnB1dHMgPSBmaWxlQmxvYk9ySW5wdXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChpbnB1dHMsIGZ1bmN0aW9uKGlkeCwgaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09PSBcImZpbGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVJbnB1dCA9IGlucHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlSW5wdXQuZ2V0QXR0cmlidXRlKHFxLlVwbG9hZEJ1dHRvbi5CVVRUT05fSURfQVRUUl9OQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZ2V0Tm90RmluaXNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl91cGxvYWREYXRhLnJldHJpZXZlKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBbIHFxLnN0YXR1cy5VUExPQURJTkcsIHFxLnN0YXR1cy5VUExPQURfUkVUUllJTkcsIHFxLnN0YXR1cy5RVUVVRUQsIHFxLnN0YXR1cy5TVUJNSVRUSU5HLCBxcS5zdGF0dXMuU1VCTUlUVEVELCBxcS5zdGF0dXMuUEFVU0VEIF1cbiAgICAgICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldFZhbGlkYXRpb25CYXNlOiBmdW5jdGlvbihidXR0b25JZCkge1xuICAgICAgICAgICAgICAgIHZhciBleHRyYUJ1dHRvblNwZWMgPSB0aGlzLl9leHRyYUJ1dHRvblNwZWNzW2J1dHRvbklkXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0cmFCdXR0b25TcGVjID8gZXh0cmFCdXR0b25TcGVjLnZhbGlkYXRpb24gOiB0aGlzLl9vcHRpb25zLnZhbGlkYXRpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldFZhbGlkYXRpb25EZXNjcmlwdG9yOiBmdW5jdGlvbihmaWxlV3JhcHBlcikge1xuICAgICAgICAgICAgICAgIGlmIChmaWxlV3JhcHBlci5maWxlIGluc3RhbmNlb2YgcXEuQmxvYlByb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBxcS5nZXRGaWxlbmFtZShmaWxlV3JhcHBlci5maWxlLnJlZmVyZW5jZUJsb2IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogZmlsZVdyYXBwZXIuZmlsZS5yZWZlcmVuY2VCbG9iLnNpemVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5nZXRVcGxvYWRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBmaWxlV3JhcHBlci5pZFxuICAgICAgICAgICAgICAgICAgICB9KS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiB0aGlzLmdldFVwbG9hZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGZpbGVXcmFwcGVyLmlkXG4gICAgICAgICAgICAgICAgICAgIH0pLnNpemVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXRWYWxpZGF0aW9uRGVzY3JpcHRvcnM6IGZ1bmN0aW9uKGZpbGVXcmFwcGVycykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcywgZmlsZURlc2NyaXB0b3JzID0gW107XG4gICAgICAgICAgICAgICAgcXEuZWFjaChmaWxlV3JhcHBlcnMsIGZ1bmN0aW9uKGlkeCwgZmlsZVdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZURlc2NyaXB0b3JzLnB1c2goc2VsZi5fZ2V0VmFsaWRhdGlvbkRlc2NyaXB0b3IoZmlsZVdyYXBwZXIpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZURlc2NyaXB0b3JzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9oYW5kbGVDYW1lcmFBY2Nlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmNhbWVyYS5pb3MgJiYgcXEuaW9zKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjY2VwdElvc0NhbWVyYSA9IFwiaW1hZ2UvKjtjYXB0dXJlPWNhbWVyYVwiLCBidXR0b24gPSB0aGlzLl9vcHRpb25zLmNhbWVyYS5idXR0b24sIGJ1dHRvbklkID0gYnV0dG9uID8gdGhpcy5fZ2V0QnV0dG9uSWQoYnV0dG9uKSA6IHRoaXMuX2RlZmF1bHRCdXR0b25JZCwgb3B0aW9uUm9vdCA9IHRoaXMuX29wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25JZCAmJiBidXR0b25JZCAhPT0gdGhpcy5fZGVmYXVsdEJ1dHRvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25Sb290ID0gdGhpcy5fZXh0cmFCdXR0b25TcGVjc1tidXR0b25JZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uUm9vdC5tdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uUm9vdC52YWxpZGF0aW9uLmFjY2VwdEZpbGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25Sb290LnZhbGlkYXRpb24uYWNjZXB0RmlsZXMgPSBhY2NlcHRJb3NDYW1lcmE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25Sb290LnZhbGlkYXRpb24uYWNjZXB0RmlsZXMgKz0gXCIsXCIgKyBhY2NlcHRJb3NDYW1lcmE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaCh0aGlzLl9idXR0b25zLCBmdW5jdGlvbihpZHgsIGJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1dHRvbi5nZXRCdXR0b25JZCgpID09PSBidXR0b25JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRNdWx0aXBsZShvcHRpb25Sb290Lm11bHRpcGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uc2V0QWNjZXB0RmlsZXMob3B0aW9uUm9vdC5hY2NlcHRGaWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2hhbmRsZUNoZWNrZWRDYWxsYmFjazogZnVuY3Rpb24oZGV0YWlscykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcywgY2FsbGJhY2tSZXRWYWwgPSBkZXRhaWxzLmNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgaWYgKHFxLmlzR2VuZXJpY1Byb21pc2UoY2FsbGJhY2tSZXRWYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKGRldGFpbHMubmFtZSArIFwiIC0gd2FpdGluZyBmb3IgXCIgKyBkZXRhaWxzLm5hbWUgKyBcIiBwcm9taXNlIHRvIGJlIGZ1bGZpbGxlZCBmb3IgXCIgKyBkZXRhaWxzLmlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2tSZXRWYWwudGhlbihmdW5jdGlvbihzdWNjZXNzUGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9nKGRldGFpbHMubmFtZSArIFwiIHByb21pc2Ugc3VjY2VzcyBmb3IgXCIgKyBkZXRhaWxzLmlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5vblN1Y2Nlc3Moc3VjY2Vzc1BhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGV0YWlscy5vbkZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZyhkZXRhaWxzLm5hbWUgKyBcIiBwcm9taXNlIGZhaWx1cmUgZm9yIFwiICsgZGV0YWlscy5pZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLm9uRmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZyhkZXRhaWxzLm5hbWUgKyBcIiBwcm9taXNlIGZhaWx1cmUgZm9yIFwiICsgZGV0YWlscy5pZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja1JldFZhbCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5vblN1Y2Nlc3MoY2FsbGJhY2tSZXRWYWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXRhaWxzLm9uRmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coZGV0YWlscy5uYW1lICsgXCIgLSByZXR1cm4gdmFsdWUgd2FzICdmYWxzZScgZm9yIFwiICsgZGV0YWlscy5pZGVudGlmaWVyICsgXCIuICBJbnZva2luZyBmYWlsdXJlIGNhbGxiYWNrLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMub25GYWlsdXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhkZXRhaWxzLm5hbWUgKyBcIiAtIHJldHVybiB2YWx1ZSB3YXMgJ2ZhbHNlJyBmb3IgXCIgKyBkZXRhaWxzLmlkZW50aWZpZXIgKyBcIi4gIFdpbGwgbm90IHByb2NlZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFja1JldFZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaGFuZGxlTmV3RmlsZTogZnVuY3Rpb24oZmlsZSwgYmF0Y2hJZCwgbmV3RmlsZVdyYXBwZXJMaXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCB1dWlkID0gcXEuZ2V0VW5pcXVlSWQoKSwgc2l6ZSA9IC0xLCBuYW1lID0gcXEuZ2V0RmlsZW5hbWUoZmlsZSksIGFjdHVhbEZpbGUgPSBmaWxlLmJsb2IgfHwgZmlsZSwgaGFuZGxlciA9IHRoaXMuX2N1c3RvbU5ld0ZpbGVIYW5kbGVyID8gdGhpcy5fY3VzdG9tTmV3RmlsZUhhbmRsZXIgOiBxcS5iaW5kKHNlbGYuX2hhbmRsZU5ld0ZpbGVHZW5lcmljLCBzZWxmKTtcbiAgICAgICAgICAgICAgICBpZiAoIXFxLmlzSW5wdXQoYWN0dWFsRmlsZSkgJiYgYWN0dWFsRmlsZS5zaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IGFjdHVhbEZpbGUuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFuZGxlcihhY3R1YWxGaWxlLCBuYW1lLCB1dWlkLCBzaXplLCBuZXdGaWxlV3JhcHBlckxpc3QsIGJhdGNoSWQsIHRoaXMuX29wdGlvbnMucmVxdWVzdC51dWlkTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWREYXRhOiBzZWxmLl91cGxvYWREYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNTdG9yZTogc2VsZi5fcGFyYW1zU3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIGFkZEZpbGVUb0hhbmRsZXI6IGZ1bmN0aW9uKGlkLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9oYW5kbGVyLmFkZChpZCwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9uZXRVcGxvYWRlZE9yUXVldWVkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl90cmFja0J1dHRvbihpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaGFuZGxlTmV3RmlsZUdlbmVyaWM6IGZ1bmN0aW9uKGZpbGUsIG5hbWUsIHV1aWQsIHNpemUsIGZpbGVMaXN0LCBiYXRjaElkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5fdXBsb2FkRGF0YS5hZGRGaWxlKHtcbiAgICAgICAgICAgICAgICAgICAgdXVpZDogdXVpZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2hJZDogYmF0Y2hJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIuYWRkKGlkLCBmaWxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFja0J1dHRvbihpZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV0VXBsb2FkZWRPclF1ZXVlZCsrO1xuICAgICAgICAgICAgICAgIGZpbGVMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbGU6IGZpbGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaGFuZGxlUGFzdGVTdWNjZXNzOiBmdW5jdGlvbihibG9iLCBleHRTdXBwbGllZE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gYmxvYi50eXBlLnNwbGl0KFwiL1wiKVsxXSwgbmFtZSA9IGV4dFN1cHBsaWVkTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzLl9vcHRpb25zLnBhc3RlLmRlZmF1bHROYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuYW1lICs9IFwiLlwiICsgZXh0ZW5zaW9uO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRmlsZXMoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBibG9iOiBibG9iXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2luaXRFeHRyYUJ1dHRvbjogZnVuY3Rpb24oc3BlYykge1xuICAgICAgICAgICAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVVcGxvYWRCdXR0b24oe1xuICAgICAgICAgICAgICAgICAgICBhY2NlcHQ6IHNwZWMudmFsaWRhdGlvbi5hY2NlcHRGaWxlcyxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZEV4dGVuc2lvbnM6IHNwZWMudmFsaWRhdGlvbi5hbGxvd2VkRXh0ZW5zaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogc3BlYy5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBmb2xkZXJzOiBzcGVjLmZvbGRlcnMsXG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxlOiBzcGVjLm11bHRpcGxlLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogc3BlYy5maWxlSW5wdXRUaXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4dHJhQnV0dG9uU3BlY3NbYnV0dG9uLmdldEJ1dHRvbklkKCldID0gc3BlYztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaW5pdEZvcm1TdXBwb3J0QW5kUGFyYW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb3JtU3VwcG9ydCA9IHFxLkZvcm1TdXBwb3J0ICYmIG5ldyBxcS5Gb3JtU3VwcG9ydCh0aGlzLl9vcHRpb25zLmZvcm0sIHFxLmJpbmQodGhpcy51cGxvYWRTdG9yZWRGaWxlcywgdGhpcyksIHFxLmJpbmQodGhpcy5sb2csIHRoaXMpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZm9ybVN1cHBvcnQgJiYgdGhpcy5fZm9ybVN1cHBvcnQuYXR0YWNoZWRUb0Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zU3RvcmUgPSB0aGlzLl9jcmVhdGVTdG9yZSh0aGlzLl9vcHRpb25zLnJlcXVlc3QucGFyYW1zLCB0aGlzLl9mb3JtU3VwcG9ydC5nZXRGb3JtSW5wdXRzQXNPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmF1dG9VcGxvYWQgPSB0aGlzLl9mb3JtU3VwcG9ydC5uZXdBdXRvVXBsb2FkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZm9ybVN1cHBvcnQubmV3RW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMucmVxdWVzdC5lbmRwb2ludCA9IHRoaXMuX2Zvcm1TdXBwb3J0Lm5ld0VuZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zU3RvcmUgPSB0aGlzLl9jcmVhdGVTdG9yZSh0aGlzLl9vcHRpb25zLnJlcXVlc3QucGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2lzRGVsZXRlUG9zc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghcXEuRGVsZXRlRmlsZUFqYXhSZXF1ZXN0ZXIgfHwgIXRoaXMuX29wdGlvbnMuZGVsZXRlRmlsZS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuY29ycy5leHBlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXEuc3VwcG9ydGVkRmVhdHVyZXMuZGVsZXRlRmlsZUNvcnNYaHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChxcS5zdXBwb3J0ZWRGZWF0dXJlcy5kZWxldGVGaWxlQ29yc1hkciAmJiB0aGlzLl9vcHRpb25zLmNvcnMuYWxsb3dYZHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2lzQWxsb3dlZEV4dGVuc2lvbjogZnVuY3Rpb24oYWxsb3dlZCwgZmlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbG93ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxcS5lYWNoKGFsbG93ZWQsIGZ1bmN0aW9uKGlkeCwgYWxsb3dlZEV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXEuaXNTdHJpbmcoYWxsb3dlZEV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHRSZWdleCA9IG5ldyBSZWdFeHAoXCJcXFxcLlwiICsgYWxsb3dlZEV4dCArIFwiJFwiLCBcImlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZU5hbWUubWF0Y2goZXh0UmVnZXgpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pdGVtRXJyb3I6IGZ1bmN0aW9uKGNvZGUsIG1heWJlTmFtZU9yTmFtZXMsIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuX29wdGlvbnMubWVzc2FnZXNbY29kZV0sIGFsbG93ZWRFeHRlbnNpb25zID0gW10sIG5hbWVzID0gW10uY29uY2F0KG1heWJlTmFtZU9yTmFtZXMpLCBuYW1lID0gbmFtZXNbMF0sIGJ1dHRvbklkID0gdGhpcy5fZ2V0QnV0dG9uSWQoaXRlbSksIHZhbGlkYXRpb25CYXNlID0gdGhpcy5fZ2V0VmFsaWRhdGlvbkJhc2UoYnV0dG9uSWQpLCBleHRlbnNpb25zRm9yTWVzc2FnZSwgcGxhY2Vob2xkZXJNYXRjaDtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByKG5hbWUsIHJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UobmFtZSwgcmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxcS5lYWNoKHZhbGlkYXRpb25CYXNlLmFsbG93ZWRFeHRlbnNpb25zLCBmdW5jdGlvbihpZHgsIGFsbG93ZWRFeHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHFxLmlzU3RyaW5nKGFsbG93ZWRFeHRlbnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2VkRXh0ZW5zaW9ucy5wdXNoKGFsbG93ZWRFeHRlbnNpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uc0Zvck1lc3NhZ2UgPSBhbGxvd2VkRXh0ZW5zaW9ucy5qb2luKFwiLCBcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICByKFwie2ZpbGV9XCIsIHRoaXMuX29wdGlvbnMuZm9ybWF0RmlsZU5hbWUobmFtZSkpO1xuICAgICAgICAgICAgICAgIHIoXCJ7ZXh0ZW5zaW9uc31cIiwgZXh0ZW5zaW9uc0Zvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHIoXCJ7c2l6ZUxpbWl0fVwiLCB0aGlzLl9mb3JtYXRTaXplKHZhbGlkYXRpb25CYXNlLnNpemVMaW1pdCkpO1xuICAgICAgICAgICAgICAgIHIoXCJ7bWluU2l6ZUxpbWl0fVwiLCB0aGlzLl9mb3JtYXRTaXplKHZhbGlkYXRpb25CYXNlLm1pblNpemVMaW1pdCkpO1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyTWF0Y2ggPSBtZXNzYWdlLm1hdGNoKC8oXFx7XFx3K1xcfSkvZyk7XG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChwbGFjZWhvbGRlck1hdGNoLCBmdW5jdGlvbihpZHgsIHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByKHBsYWNlaG9sZGVyLCBuYW1lc1tpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLm9uRXJyb3IobnVsbCwgbmFtZSwgbWVzc2FnZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWFudWFsUmV0cnk6IGZ1bmN0aW9uKGlkLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vbkJlZm9yZU1hbnVhbFJldHJ5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXRVcGxvYWRlZE9yUXVldWVkKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwbG9hZERhdGEuc2V0U3RhdHVzKGlkLCBxcS5zdGF0dXMuVVBMT0FEX1JFVFJZSU5HKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhpZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyLnJldHJ5KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX21heWJlQWxsQ29tcGxldGU6IGZ1bmN0aW9uKGlkLCBzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIG5vdEZpbmlzaGVkID0gdGhpcy5fZ2V0Tm90RmluaXNoZWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSBxcS5zdGF0dXMuVVBMT0FEX1NVQ0NFU1NGVUwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3VjY2VlZGVkU2luY2VMYXN0QWxsQ29tcGxldGUucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IHFxLnN0YXR1cy5VUExPQURfRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZhaWxlZFNpbmNlTGFzdEFsbENvbXBsZXRlLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm90RmluaXNoZWQgPT09IDAgJiYgKHRoaXMuX3N1Y2NlZWRlZFNpbmNlTGFzdEFsbENvbXBsZXRlLmxlbmd0aCB8fCB0aGlzLl9mYWlsZWRTaW5jZUxhc3RBbGxDb21wbGV0ZS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vbkFsbENvbXBsZXRlKHNlbGYuX3N1Y2NlZWRlZFNpbmNlTGFzdEFsbENvbXBsZXRlLCBzZWxmLl9mYWlsZWRTaW5jZUxhc3RBbGxDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWF5YmVIYW5kbGVJb3M4U2FmYXJpV29ya2Fyb3VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLndvcmthcm91bmRzLmlvczhTYWZhcmlVcGxvYWRzICYmIHFxLmlvczgwMCgpICYmIHFxLmlvc1NhZmFyaSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWxlcnQoc2VsZi5fb3B0aW9ucy5tZXNzYWdlcy51bnN1cHBvcnRlZEJyb3dzZXJJb3M4U2FmYXJpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBxcS5FcnJvcih0aGlzLl9vcHRpb25zLm1lc3NhZ2VzLnVuc3VwcG9ydGVkQnJvd3NlcklvczhTYWZhcmkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWF5YmVQYXJzZUFuZFNlbmRVcGxvYWRFcnJvcjogZnVuY3Rpb24oaWQsIG5hbWUsIHJlc3BvbnNlLCB4aHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhociAmJiB4aHIuc3RhdHVzICE9PSAyMDAgJiYgIXJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5vbkVycm9yKGlkLCBuYW1lLCBcIlhIUiByZXR1cm5lZCByZXNwb25zZSBjb2RlIFwiICsgeGhyLnN0YXR1cywgeGhyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvclJlYXNvbiA9IHJlc3BvbnNlLmVycm9yID8gcmVzcG9uc2UuZXJyb3IgOiB0aGlzLl9vcHRpb25zLnRleHQuZGVmYXVsdFJlc3BvbnNlRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5vbkVycm9yKGlkLCBuYW1lLCBlcnJvclJlYXNvbiwgeGhyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWF5YmVQcm9jZXNzTmV4dEl0ZW1BZnRlck9uVmFsaWRhdGVDYWxsYmFjazogZnVuY3Rpb24odmFsaWRJdGVtLCBpdGVtcywgaW5kZXgsIHBhcmFtcywgZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZEl0ZW0gfHwgIXRoaXMuX29wdGlvbnMudmFsaWRhdGlvbi5zdG9wT25GaXJzdEludmFsaWRGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0aW9uRGVzY3JpcHRvciA9IHNlbGYuX2dldFZhbGlkYXRpb25EZXNjcmlwdG9yKGl0ZW1zW2luZGV4XSksIGJ1dHRvbklkID0gc2VsZi5fZ2V0QnV0dG9uSWQoaXRlbXNbaW5kZXhdLmZpbGUpLCBidXR0b24gPSBzZWxmLl9nZXRCdXR0b24oYnV0dG9uSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2hhbmRsZUNoZWNrZWRDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwib25WYWxpZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogcXEuYmluZChzZWxmLl9vcHRpb25zLmNhbGxiYWNrcy5vblZhbGlkYXRlLCBzZWxmLCB2YWxpZGF0aW9uRGVzY3JpcHRvciwgYnV0dG9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBxcS5iaW5kKHNlbGYuX29uVmFsaWRhdGVDYWxsYmFja1N1Y2Nlc3MsIHNlbGYsIGl0ZW1zLCBpbmRleCwgcGFyYW1zLCBlbmRwb2ludCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRmFpbHVyZTogcXEuYmluZChzZWxmLl9vblZhbGlkYXRlQ2FsbGJhY2tGYWlsdXJlLCBzZWxmLCBpdGVtcywgaW5kZXgsIHBhcmFtcywgZW5kcG9pbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBcIkl0ZW0gJ1wiICsgdmFsaWRhdGlvbkRlc2NyaXB0b3IubmFtZSArIFwiJywgc2l6ZTogXCIgKyB2YWxpZGF0aW9uRGVzY3JpcHRvci5zaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdmFsaWRJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDtpbmRleCA8IGl0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2ZpbGVPckJsb2JSZWplY3RlZChpdGVtc1tpbmRleF0uaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkFsbENvbXBsZXRlOiBmdW5jdGlvbihzdWNjZXNzZnVsLCBmYWlsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3RhbFByb2dyZXNzICYmIHRoaXMuX3RvdGFsUHJvZ3Jlc3Mub25BbGxDb21wbGV0ZShzdWNjZXNzZnVsLCBmYWlsZWQsIHRoaXMuX3ByZXZlbnRSZXRyaWVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5vbkFsbENvbXBsZXRlKHFxLmV4dGVuZChbXSwgc3VjY2Vzc2Z1bCksIHFxLmV4dGVuZChbXSwgZmFpbGVkKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3VjY2VlZGVkU2luY2VMYXN0QWxsQ29tcGxldGUgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9mYWlsZWRTaW5jZUxhc3RBbGxDb21wbGV0ZSA9IFtdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkF1dG9SZXRyeTogZnVuY3Rpb24oaWQsIG5hbWUsIHJlc3BvbnNlSlNPTiwgeGhyLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBzZWxmLl9wcmV2ZW50UmV0cmllc1tpZF0gPSByZXNwb25zZUpTT05bc2VsZi5fb3B0aW9ucy5yZXRyeS5wcmV2ZW50UmV0cnlSZXNwb25zZVByb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fc2hvdWxkQXV0b1JldHJ5KGlkLCBuYW1lLCByZXNwb25zZUpTT04pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXRyeVdhaXRQZXJpb2QgPSBzZWxmLl9vcHRpb25zLnJldHJ5LmF1dG9BdHRlbXB0RGVsYXkgKiAxZTM7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX21heWJlUGFyc2VBbmRTZW5kVXBsb2FkRXJyb3IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fb3B0aW9ucy5jYWxsYmFja3Mub25BdXRvUmV0cnkoaWQsIG5hbWUsIHNlbGYuX2F1dG9SZXRyaWVzW2lkXSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX29uQmVmb3JlQXV0b1JldHJ5KGlkLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fdXBsb2FkRGF0YS5zZXRTdGF0dXMoaWQsIHFxLnN0YXR1cy5VUExPQURfUkVUUllJTkcpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9yZXRyeVRpbWVvdXRzW2lkXSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZyhcIlN0YXJ0aW5nIHJldHJ5IGZvciBcIiArIG5hbWUgKyBcIi4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5faGFuZGxlci5yZXRyeShpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHJldHJ5V2FpdFBlcmlvZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25CZWZvcmVBdXRvUmV0cnk6IGZ1bmN0aW9uKGlkLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coXCJXYWl0aW5nIFwiICsgdGhpcy5fb3B0aW9ucy5yZXRyeS5hdXRvQXR0ZW1wdERlbGF5ICsgXCIgc2Vjb25kcyBiZWZvcmUgcmV0cnlpbmcgXCIgKyBuYW1lICsgXCIuLi5cIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uQmVmb3JlTWFudWFsUmV0cnk6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1MaW1pdCA9IHRoaXMuX2N1cnJlbnRJdGVtTGltaXQsIGZpbGVOYW1lO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcmV2ZW50UmV0cmllc1tpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coXCJSZXRyaWVzIGFyZSBmb3JiaWRkZW4gZm9yIGlkIFwiICsgaWQsIFwid2FyblwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5faGFuZGxlci5pc1ZhbGlkKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZSA9IHRoaXMuZ2V0TmFtZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5vbk1hbnVhbFJldHJ5KGlkLCBmaWxlTmFtZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1MaW1pdCA+IDAgJiYgdGhpcy5fbmV0VXBsb2FkZWRPclF1ZXVlZCArIDEgPiBpdGVtTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1FcnJvcihcInJldHJ5RmFpbFRvb01hbnlJdGVtc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcIlJldHJ5aW5nIHVwbG9hZCBmb3IgJ1wiICsgZmlsZU5hbWUgKyBcIicgKGlkOiBcIiArIGlkICsgXCIpLi4uXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcIidcIiArIGlkICsgXCInIGlzIG5vdCBhIHZhbGlkIGZpbGUgSURcIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25DYW5jZWw6IGZ1bmN0aW9uKGlkLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV0VXBsb2FkZWRPclF1ZXVlZC0tO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZXRyeVRpbWVvdXRzW2lkXSk7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3JlZEl0ZW1JbmRleCA9IHFxLmluZGV4T2YodGhpcy5fc3RvcmVkSWRzLCBpZCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmF1dG9VcGxvYWQgJiYgc3RvcmVkSXRlbUluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcmVkSWRzLnNwbGljZShzdG9yZWRJdGVtSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWREYXRhLnNldFN0YXR1cyhpZCwgcXEuc3RhdHVzLkNBTkNFTEVEKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25Db21wbGV0ZTogZnVuY3Rpb24oaWQsIG5hbWUsIHJlc3VsdCwgeGhyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXRVcGxvYWRlZE9yUXVldWVkLS07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwbG9hZERhdGEuc2V0U3RhdHVzKGlkLCBxcS5zdGF0dXMuVVBMT0FEX0ZBSUxFRCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbdGhpcy5fb3B0aW9ucy5yZXRyeS5wcmV2ZW50UmV0cnlSZXNwb25zZVByb3BlcnR5XSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJldmVudFJldHJpZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudGh1bWJuYWlsVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90aHVtYm5haWxVcmxzW2lkXSA9IHJlc3VsdC50aHVtYm5haWxVcmw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV0VXBsb2FkZWQrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkRGF0YS5zZXRTdGF0dXMoaWQsIHFxLnN0YXR1cy5VUExPQURfU1VDQ0VTU0ZVTCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX21heWJlUGFyc2VBbmRTZW5kVXBsb2FkRXJyb3IoaWQsIG5hbWUsIHJlc3VsdCwgeGhyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3MgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uRGVsZXRlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwbG9hZERhdGEuc2V0U3RhdHVzKGlkLCBxcS5zdGF0dXMuREVMRVRJTkcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkRlbGV0ZUNvbXBsZXRlOiBmdW5jdGlvbihpZCwgeGhyT3JYZHIsIGlzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZ2V0TmFtZShpZCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkRGF0YS5zZXRTdGF0dXMoaWQsIHFxLnN0YXR1cy5ERUxFVEVfRkFJTEVEKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coXCJEZWxldGUgcmVxdWVzdCBmb3IgJ1wiICsgbmFtZSArIFwiJyBoYXMgZmFpbGVkLlwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyT3JYZHIud2l0aENyZWRlbnRpYWxzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLm9uRXJyb3IoaWQsIG5hbWUsIFwiRGVsZXRlIHJlcXVlc3QgZmFpbGVkXCIsIHhock9yWGRyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLm9uRXJyb3IoaWQsIG5hbWUsIFwiRGVsZXRlIHJlcXVlc3QgZmFpbGVkIHdpdGggcmVzcG9uc2UgY29kZSBcIiArIHhock9yWGRyLnN0YXR1cywgeGhyT3JYZHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV0VXBsb2FkZWRPclF1ZXVlZC0tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXRVcGxvYWRlZC0tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyLmV4cHVuZ2UoaWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWREYXRhLnNldFN0YXR1cyhpZCwgcXEuc3RhdHVzLkRFTEVURUQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcIkRlbGV0ZSByZXF1ZXN0IGZvciAnXCIgKyBuYW1lICsgXCInIGhhcyBzdWNjZWVkZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25JbnB1dENoYW5nZTogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZUluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChxcS5zdXBwb3J0ZWRGZWF0dXJlcy5hamF4VXBsb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoZmlsZUluZGV4ID0gMDsgZmlsZUluZGV4IDwgaW5wdXQuZmlsZXMubGVuZ3RoOyBmaWxlSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5ub3RhdGVXaXRoQnV0dG9uSWQoaW5wdXQuZmlsZXNbZmlsZUluZGV4XSwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRmlsZXMoaW5wdXQuZmlsZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEZpbGVzKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXEuZWFjaCh0aGlzLl9idXR0b25zLCBmdW5jdGlvbihpZHgsIGJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICBidXR0b24ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25Qcm9ncmVzczogZnVuY3Rpb24oaWQsIG5hbWUsIGxvYWRlZCwgdG90YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3RhbFByb2dyZXNzICYmIHRoaXMuX3RvdGFsUHJvZ3Jlc3Mub25JbmRpdmlkdWFsUHJvZ3Jlc3MoaWQsIGxvYWRlZCwgdG90YWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblN1Ym1pdDogZnVuY3Rpb24oaWQsIG5hbWUpIHt9LFxuICAgICAgICAgICAgX29uU3VibWl0Q2FsbGJhY2tTdWNjZXNzOiBmdW5jdGlvbihpZCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3VibWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkRGF0YS5zZXRTdGF0dXMoaWQsIHFxLnN0YXR1cy5TVUJNSVRURUQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3VibWl0dGVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuYXV0b1VwbG9hZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5vblN1Ym1pdHRlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWRGaWxlKGlkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9yZUZvckxhdGVyKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5jYWxsYmFja3Mub25TdWJtaXR0ZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uU3VibWl0RGVsZXRlOiBmdW5jdGlvbihpZCwgb25TdWNjZXNzQ2FsbGJhY2ssIGFkZGl0aW9uYWxNYW5kYXRlZFBhcmFtcykge1xuICAgICAgICAgICAgICAgIHZhciB1dWlkID0gdGhpcy5nZXRVdWlkKGlkKSwgYWRqdXN0ZWRPblN1Y2Nlc3NDYWxsYmFjaztcbiAgICAgICAgICAgICAgICBpZiAob25TdWNjZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0ZWRPblN1Y2Nlc3NDYWxsYmFjayA9IHFxLmJpbmQob25TdWNjZXNzQ2FsbGJhY2ssIHRoaXMsIGlkLCB1dWlkLCBhZGRpdGlvbmFsTWFuZGF0ZWRQYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNEZWxldGVQb3NzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUNoZWNrZWRDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm9uU3VibWl0RGVsZXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogcXEuYmluZCh0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5vblN1Ym1pdERlbGV0ZSwgdGhpcywgaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBhZGp1c3RlZE9uU3VjY2Vzc0NhbGxiYWNrIHx8IHFxLmJpbmQodGhpcy5fZGVsZXRlSGFuZGxlci5zZW5kRGVsZXRlLCB0aGlzLCBpZCwgdXVpZCwgYWRkaXRpb25hbE1hbmRhdGVkUGFyYW1zKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGlkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcIkRlbGV0ZSByZXF1ZXN0IGlnbm9yZWQgZm9yIElEIFwiICsgaWQgKyBcIiwgZGVsZXRlIGZlYXR1cmUgaXMgZGlzYWJsZWQgb3IgcmVxdWVzdCBub3QgcG9zc2libGUgXCIgKyBcImR1ZSB0byBDT1JTIG9uIGEgdXNlciBhZ2VudCB0aGF0IGRvZXMgbm90IHN1cHBvcnQgcHJlLWZsaWdodGluZy5cIiwgXCJ3YXJuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblN1Ym1pdHRlZDogZnVuY3Rpb24oaWQpIHt9LFxuICAgICAgICAgICAgX29uVG90YWxQcm9ncmVzczogZnVuY3Rpb24obG9hZGVkLCB0b3RhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLm9uVG90YWxQcm9ncmVzcyhsb2FkZWQsIHRvdGFsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25VcGxvYWRQcmVwOiBmdW5jdGlvbihpZCkge30sXG4gICAgICAgICAgICBfb25VcGxvYWQ6IGZ1bmN0aW9uKGlkLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkRGF0YS5zZXRTdGF0dXMoaWQsIHFxLnN0YXR1cy5VUExPQURJTkcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblVwbG9hZENodW5rOiBmdW5jdGlvbihpZCwgY2h1bmtEYXRhKSB7fSxcbiAgICAgICAgICAgIF9vblVwbG9hZFN0YXR1c0NoYW5nZTogZnVuY3Rpb24oaWQsIG9sZFN0YXR1cywgbmV3U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXR1cyA9PT0gcXEuc3RhdHVzLlBBVVNFRCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmV0cnlUaW1lb3V0c1tpZF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25WYWxpZGF0ZUJhdGNoQ2FsbGJhY2tGYWlsdXJlOiBmdW5jdGlvbihmaWxlV3JhcHBlcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcXEuZWFjaChmaWxlV3JhcHBlcnMsIGZ1bmN0aW9uKGlkeCwgZmlsZVdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZmlsZU9yQmxvYlJlamVjdGVkKGZpbGVXcmFwcGVyLmlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25WYWxpZGF0ZUJhdGNoQ2FsbGJhY2tTdWNjZXNzOiBmdW5jdGlvbih2YWxpZGF0aW9uRGVzY3JpcHRvcnMsIGl0ZW1zLCBwYXJhbXMsIGVuZHBvaW50LCBidXR0b24pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlLCBpdGVtTGltaXQgPSB0aGlzLl9jdXJyZW50SXRlbUxpbWl0LCBwcm9wb3NlZE5ldEZpbGVzVXBsb2FkZWRPclF1ZXVlZCA9IHRoaXMuX25ldFVwbG9hZGVkT3JRdWV1ZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1MaW1pdCA9PT0gMCB8fCBwcm9wb3NlZE5ldEZpbGVzVXBsb2FkZWRPclF1ZXVlZCA8PSBpdGVtTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUNoZWNrZWRDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJvblZhbGlkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHFxLmJpbmQodGhpcy5fb3B0aW9ucy5jYWxsYmFja3Mub25WYWxpZGF0ZSwgdGhpcywgdmFsaWRhdGlvbkRlc2NyaXB0b3JzWzBdLCBidXR0b24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzczogcXEuYmluZCh0aGlzLl9vblZhbGlkYXRlQ2FsbGJhY2tTdWNjZXNzLCB0aGlzLCBpdGVtcywgMCwgcGFyYW1zLCBlbmRwb2ludCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25GYWlsdXJlOiBxcS5iaW5kKHRoaXMuX29uVmFsaWRhdGVDYWxsYmFja0ZhaWx1cmUsIHRoaXMsIGl0ZW1zLCAwLCBwYXJhbXMsIGVuZHBvaW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBcIkl0ZW0gJ1wiICsgaXRlbXNbMF0uZmlsZS5uYW1lICsgXCInLCBzaXplOiBcIiArIGl0ZW1zWzBdLmZpbGUuc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtRXJyb3IoXCJub0ZpbGVzRXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblZhbGlkYXRlQmF0Y2hDYWxsYmFja0ZhaWx1cmUoaXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSB0aGlzLl9vcHRpb25zLm1lc3NhZ2VzLnRvb01hbnlJdGVtc0Vycm9yLnJlcGxhY2UoL1xce25ldEl0ZW1zXFx9L2csIHByb3Bvc2VkTmV0RmlsZXNVcGxvYWRlZE9yUXVldWVkKS5yZXBsYWNlKC9cXHtpdGVtTGltaXRcXH0vZywgaXRlbUxpbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmF0Y2hFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25WYWxpZGF0ZUNhbGxiYWNrRmFpbHVyZTogZnVuY3Rpb24oaXRlbXMsIGluZGV4LCBwYXJhbXMsIGVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxlT3JCbG9iUmVqZWN0ZWQoaXRlbXNbaW5kZXhdLmlkLCBpdGVtc1tpbmRleF0uZmlsZS5uYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXliZVByb2Nlc3NOZXh0SXRlbUFmdGVyT25WYWxpZGF0ZUNhbGxiYWNrKGZhbHNlLCBpdGVtcywgbmV4dEluZGV4LCBwYXJhbXMsIGVuZHBvaW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25WYWxpZGF0ZUNhbGxiYWNrU3VjY2VzczogZnVuY3Rpb24oaXRlbXMsIGluZGV4LCBwYXJhbXMsIGVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBuZXh0SW5kZXggPSBpbmRleCArIDEsIHZhbGlkYXRpb25EZXNjcmlwdG9yID0gdGhpcy5fZ2V0VmFsaWRhdGlvbkRlc2NyaXB0b3IoaXRlbXNbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0ZUZpbGVPckJsb2JEYXRhKGl0ZW1zW2luZGV4XSwgdmFsaWRhdGlvbkRlc2NyaXB0b3IpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3VwbG9hZChpdGVtc1tpbmRleF0uaWQsIHBhcmFtcywgZW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9tYXliZVByb2Nlc3NOZXh0SXRlbUFmdGVyT25WYWxpZGF0ZUNhbGxiYWNrKHRydWUsIGl0ZW1zLCBuZXh0SW5kZXgsIHBhcmFtcywgZW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9tYXliZVByb2Nlc3NOZXh0SXRlbUFmdGVyT25WYWxpZGF0ZUNhbGxiYWNrKGZhbHNlLCBpdGVtcywgbmV4dEluZGV4LCBwYXJhbXMsIGVuZHBvaW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcHJlcGFyZUl0ZW1zRm9yVXBsb2FkOiBmdW5jdGlvbihpdGVtcywgcGFyYW1zLCBlbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXRlbUVycm9yKFwibm9GaWxlc0Vycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0aW9uRGVzY3JpcHRvcnMgPSB0aGlzLl9nZXRWYWxpZGF0aW9uRGVzY3JpcHRvcnMoaXRlbXMpLCBidXR0b25JZCA9IHRoaXMuX2dldEJ1dHRvbklkKGl0ZW1zWzBdLmZpbGUpLCBidXR0b24gPSB0aGlzLl9nZXRCdXR0b24oYnV0dG9uSWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUNoZWNrZWRDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwib25WYWxpZGF0ZUJhdGNoXCIsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBxcS5iaW5kKHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLm9uVmFsaWRhdGVCYXRjaCwgdGhpcywgdmFsaWRhdGlvbkRlc2NyaXB0b3JzLCBidXR0b24pLFxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHFxLmJpbmQodGhpcy5fb25WYWxpZGF0ZUJhdGNoQ2FsbGJhY2tTdWNjZXNzLCB0aGlzLCB2YWxpZGF0aW9uRGVzY3JpcHRvcnMsIGl0ZW1zLCBwYXJhbXMsIGVuZHBvaW50LCBidXR0b24pLFxuICAgICAgICAgICAgICAgICAgICBvbkZhaWx1cmU6IHFxLmJpbmQodGhpcy5fb25WYWxpZGF0ZUJhdGNoQ2FsbGJhY2tGYWlsdXJlLCB0aGlzLCBpdGVtcyksXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IFwiYmF0Y2ggdmFsaWRhdGlvblwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3ByZXZlbnRMZWF2ZUluUHJvZ3Jlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwb3NlU3VwcG9ydC5hdHRhY2god2luZG93LCBcImJlZm9yZXVubG9hZFwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmdldEluUHJvZ3Jlc3MoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IHNlbGYuX29wdGlvbnMubWVzc2FnZXMub25MZWF2ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9vcHRpb25zLm1lc3NhZ2VzLm9uTGVhdmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVmcmVzaFNlc3Npb25EYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zLnNlc3Npb247XG4gICAgICAgICAgICAgICAgaWYgKHFxLlNlc3Npb24gJiYgdGhpcy5fb3B0aW9ucy5zZXNzaW9uLmVuZHBvaW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxcS5leHRlbmQob3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcnM6IHRoaXMuX29wdGlvbnMuY29yc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvZyA9IHFxLmJpbmQodGhpcy5sb2csIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5hZGRGaWxlUmVjb3JkID0gcXEuYmluZCh0aGlzLl9hZGRDYW5uZWRGaWxlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nlc3Npb24gPSBuZXcgcXEuU2Vzc2lvbihvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fc2Vzc2lvbi5yZWZyZXNoKCkudGhlbihmdW5jdGlvbihyZXNwb25zZSwgeGhyT3JYZHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zZXNzaW9uUmVxdWVzdENvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb3B0aW9ucy5jYWxsYmFja3Mub25TZXNzaW9uUmVxdWVzdENvbXBsZXRlKHJlc3BvbnNlLCB0cnVlLCB4aHJPclhkcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihyZXNwb25zZSwgeGhyT3JYZHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vcHRpb25zLmNhbGxiYWNrcy5vblNlc3Npb25SZXF1ZXN0Q29tcGxldGUocmVzcG9uc2UsIGZhbHNlLCB4aHJPclhkcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zZXNzaW9uUmVxdWVzdENvbXBsZXRlOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgX3NldFNpemU6IGZ1bmN0aW9uKGlkLCBuZXdTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkRGF0YS51cGRhdGVTaXplKGlkLCBuZXdTaXplKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3RhbFByb2dyZXNzICYmIHRoaXMuX3RvdGFsUHJvZ3Jlc3Mub25OZXdTaXplKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2hvdWxkQXV0b1JldHJ5OiBmdW5jdGlvbihpZCwgbmFtZSwgcmVzcG9uc2VKU09OKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVwbG9hZERhdGEgPSB0aGlzLl91cGxvYWREYXRhLnJldHJpZXZlKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9wcmV2ZW50UmV0cmllc1tpZF0gJiYgdGhpcy5fb3B0aW9ucy5yZXRyeS5lbmFibGVBdXRvICYmIHVwbG9hZERhdGEuc3RhdHVzICE9PSBxcS5zdGF0dXMuUEFVU0VEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdXRvUmV0cmllc1tpZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0b1JldHJpZXNbaWRdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXV0b1JldHJpZXNbaWRdIDwgdGhpcy5fb3B0aW9ucy5yZXRyeS5tYXhBdXRvQXR0ZW1wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dG9SZXRyaWVzW2lkXSArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zdG9yZUZvckxhdGVyOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3JlZElkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdHJhY2tCdXR0b246IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1dHRvbklkO1xuICAgICAgICAgICAgICAgIGlmIChxcS5zdXBwb3J0ZWRGZWF0dXJlcy5hamF4VXBsb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbklkID0gdGhpcy5faGFuZGxlci5nZXRGaWxlKGlkKS5xcUJ1dHRvbklkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbklkID0gdGhpcy5fZ2V0QnV0dG9uSWQodGhpcy5faGFuZGxlci5nZXRJbnB1dChpZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYnV0dG9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnV0dG9uSWRzRm9yRmlsZUlkc1tpZF0gPSBidXR0b25JZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3VwZGF0ZUZvcm1TdXBwb3J0QW5kUGFyYW1zOiBmdW5jdGlvbihmb3JtRWxlbWVudE9ySWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmZvcm0uZWxlbWVudCA9IGZvcm1FbGVtZW50T3JJZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb3JtU3VwcG9ydCA9IHFxLkZvcm1TdXBwb3J0ICYmIG5ldyBxcS5Gb3JtU3VwcG9ydCh0aGlzLl9vcHRpb25zLmZvcm0sIHFxLmJpbmQodGhpcy51cGxvYWRTdG9yZWRGaWxlcywgdGhpcyksIHFxLmJpbmQodGhpcy5sb2csIHRoaXMpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZm9ybVN1cHBvcnQgJiYgdGhpcy5fZm9ybVN1cHBvcnQuYXR0YWNoZWRUb0Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zU3RvcmUuYWRkUmVhZE9ubHkobnVsbCwgdGhpcy5fZm9ybVN1cHBvcnQuZ2V0Rm9ybUlucHV0c0FzT2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5hdXRvVXBsb2FkID0gdGhpcy5fZm9ybVN1cHBvcnQubmV3QXV0b1VwbG9hZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Zvcm1TdXBwb3J0Lm5ld0VuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEVuZHBvaW50KHRoaXMuX2Zvcm1TdXBwb3J0Lm5ld0VuZHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdXBsb2FkOiBmdW5jdGlvbihpZCwgcGFyYW1zLCBlbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5nZXROYW1lKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1zKHBhcmFtcywgaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRFbmRwb2ludChlbmRwb2ludCwgaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVDaGVja2VkQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm9uU3VibWl0XCIsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBxcS5iaW5kKHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLm9uU3VibWl0LCB0aGlzLCBpZCwgbmFtZSksXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzczogcXEuYmluZCh0aGlzLl9vblN1Ym1pdENhbGxiYWNrU3VjY2VzcywgdGhpcywgaWQsIG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBvbkZhaWx1cmU6IHFxLmJpbmQodGhpcy5fZmlsZU9yQmxvYlJlamVjdGVkLCB0aGlzLCBpZCwgbmFtZSksXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3VwbG9hZEZpbGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVyLnVwbG9hZChpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkRGF0YS5zZXRTdGF0dXMoaWQsIHFxLnN0YXR1cy5RVUVVRUQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdXBsb2FkU3RvcmVkRmlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBpZFRvVXBsb2FkLCBzdGlsbFN1Ym1pdHRpbmcsIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLl9zdG9yZWRJZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkVG9VcGxvYWQgPSB0aGlzLl9zdG9yZWRJZHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkRmlsZShpZFRvVXBsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RpbGxTdWJtaXR0aW5nID0gdGhpcy5nZXRVcGxvYWRzKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBxcS5zdGF0dXMuU1VCTUlUVElOR1xuICAgICAgICAgICAgICAgIH0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoc3RpbGxTdWJtaXR0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHFxLmxvZyhcIlN0aWxsIHdhaXRpbmcgZm9yIFwiICsgc3RpbGxTdWJtaXR0aW5nICsgXCIgZmlsZXMgdG8gY2xlYXIgc3VibWl0IHF1ZXVlLiBXaWxsIHJlLXBhcnNlIHN0b3JlZCBJRHMgYXJyYXkgc2hvcnRseS5cIik7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl91cGxvYWRTdG9yZWRGaWxlcygpO1xuICAgICAgICAgICAgICAgICAgICB9LCAxZTMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdmFsaWRhdGVGaWxlT3JCbG9iRGF0YTogZnVuY3Rpb24oZmlsZVdyYXBwZXIsIHZhbGlkYXRpb25EZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBmaWxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlV3JhcHBlci5maWxlIGluc3RhbmNlb2YgcXEuQmxvYlByb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZVdyYXBwZXIuZmlsZS5yZWZlcmVuY2VCbG9iO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlV3JhcHBlci5maWxlO1xuICAgICAgICAgICAgICAgIH0oKSwgbmFtZSA9IHZhbGlkYXRpb25EZXNjcmlwdG9yLm5hbWUsIHNpemUgPSB2YWxpZGF0aW9uRGVzY3JpcHRvci5zaXplLCBidXR0b25JZCA9IHRoaXMuX2dldEJ1dHRvbklkKGZpbGVXcmFwcGVyLmZpbGUpLCB2YWxpZGF0aW9uQmFzZSA9IHRoaXMuX2dldFZhbGlkYXRpb25CYXNlKGJ1dHRvbklkKSwgdmFsaWRpdHlDaGVja2VyID0gbmV3IHFxLlByb21pc2UoKTtcbiAgICAgICAgICAgICAgICB2YWxpZGl0eUNoZWNrZXIudGhlbihmdW5jdGlvbigpIHt9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZmlsZU9yQmxvYlJlamVjdGVkKGZpbGVXcmFwcGVyLmlkLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocXEuaXNGaWxlT3JJbnB1dChmaWxlKSAmJiAhdGhpcy5faXNBbGxvd2VkRXh0ZW5zaW9uKHZhbGlkYXRpb25CYXNlLmFsbG93ZWRFeHRlbnNpb25zLCBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtRXJyb3IoXCJ0eXBlRXJyb3JcIiwgbmFtZSwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGl0eUNoZWNrZXIuZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMudmFsaWRhdGlvbi5hbGxvd0VtcHR5ICYmIHNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXRlbUVycm9yKFwiZW1wdHlFcnJvclwiLCBuYW1lLCBmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkaXR5Q2hlY2tlci5mYWlsdXJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaXplID4gMCAmJiB2YWxpZGF0aW9uQmFzZS5zaXplTGltaXQgJiYgc2l6ZSA+IHZhbGlkYXRpb25CYXNlLnNpemVMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtRXJyb3IoXCJzaXplRXJyb3JcIiwgbmFtZSwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGl0eUNoZWNrZXIuZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDAgJiYgc2l6ZSA8IHZhbGlkYXRpb25CYXNlLm1pblNpemVMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtRXJyb3IoXCJtaW5TaXplRXJyb3JcIiwgbmFtZSwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGl0eUNoZWNrZXIuZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocXEuSW1hZ2VWYWxpZGF0aW9uICYmIHFxLnN1cHBvcnRlZEZlYXR1cmVzLmltYWdlUHJldmlld3MgJiYgcXEuaXNGaWxlKGZpbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBxcS5JbWFnZVZhbGlkYXRpb24oZmlsZSwgcXEuYmluZChzZWxmLmxvZywgc2VsZikpLnZhbGlkYXRlKHZhbGlkYXRpb25CYXNlLmltYWdlKS50aGVuKHZhbGlkaXR5Q2hlY2tlci5zdWNjZXNzLCBmdW5jdGlvbihlcnJvckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2l0ZW1FcnJvcihlcnJvckNvZGUgKyBcIkltYWdlRXJyb3JcIiwgbmFtZSwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGl0eUNoZWNrZXIuZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGl0eUNoZWNrZXIuc3VjY2VzcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRpdHlDaGVja2VyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF93cmFwQ2FsbGJhY2tzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiwgc2FmZUNhbGxiYWNrLCBwcm9wO1xuICAgICAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHNhZmVDYWxsYmFjayA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvck1zZztcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1zZyA9IGV4Y2VwdGlvbi5tZXNzYWdlIHx8IGV4Y2VwdGlvbi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2coXCJDYXVnaHQgZXhjZXB0aW9uIGluICdcIiArIG5hbWUgKyBcIicgY2FsbGJhY2sgLSBcIiArIGVycm9yTXNnLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmb3IgKHByb3AgaW4gdGhpcy5fb3B0aW9ucy5jYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrTmFtZSwgY2FsbGJhY2tGdW5jO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tOYW1lID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrRnVuYyA9IHNlbGYuX29wdGlvbnMuY2FsbGJhY2tzW2NhbGxiYWNrTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vcHRpb25zLmNhbGxiYWNrc1tjYWxsYmFja05hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNhZmVDYWxsYmFjayhjYWxsYmFja05hbWUsIGNhbGxiYWNrRnVuYywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgcXEuRmluZVVwbG9hZGVyQmFzaWMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBidXR0b246IG51bGwsXG4gICAgICAgICAgICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICAgICAgICAgICAgbWF4Q29ubmVjdGlvbnM6IDMsXG4gICAgICAgICAgICAgICAgZGlzYWJsZUNhbmNlbEZvckZvcm1VcGxvYWRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhdXRvVXBsb2FkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tSGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiBcIi9zZXJ2ZXIvdXBsb2FkXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lUGFyYW06IFwicXFmaWxlbmFtZVwiLFxuICAgICAgICAgICAgICAgICAgICBmb3JjZU11bHRpcGFydDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXROYW1lOiBcInFxZmlsZVwiLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNJbkJvZHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsRmlsZVNpemVOYW1lOiBcInFxdG90YWxmaWxlc2l6ZVwiLFxuICAgICAgICAgICAgICAgICAgICB1dWlkTmFtZTogXCJxcXV1aWRcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd2VkRXh0ZW5zaW9uczogW10sXG4gICAgICAgICAgICAgICAgICAgIHNpemVMaW1pdDogMCxcbiAgICAgICAgICAgICAgICAgICAgbWluU2l6ZUxpbWl0OiAwLFxuICAgICAgICAgICAgICAgICAgICBpdGVtTGltaXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHN0b3BPbkZpcnN0SW52YWxpZEZpbGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdEZpbGVzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5IZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogMFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0VtcHR5OiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgICAgICAgICAgIG9uU3VibWl0OiBmdW5jdGlvbihpZCwgbmFtZSkge30sXG4gICAgICAgICAgICAgICAgICAgIG9uU3VibWl0dGVkOiBmdW5jdGlvbihpZCwgbmFtZSkge30sXG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKGlkLCBuYW1lLCByZXNwb25zZUpTT04sIG1heWJlWGhyKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25BbGxDb21wbGV0ZTogZnVuY3Rpb24oc3VjY2Vzc2Z1bCwgZmFpbGVkKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25DYW5jZWw6IGZ1bmN0aW9uKGlkLCBuYW1lKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25VcGxvYWQ6IGZ1bmN0aW9uKGlkLCBuYW1lKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25VcGxvYWRDaHVuazogZnVuY3Rpb24oaWQsIG5hbWUsIGNodW5rRGF0YSkge30sXG4gICAgICAgICAgICAgICAgICAgIG9uVXBsb2FkQ2h1bmtTdWNjZXNzOiBmdW5jdGlvbihpZCwgY2h1bmtEYXRhLCByZXNwb25zZUpTT04sIHhocikge30sXG4gICAgICAgICAgICAgICAgICAgIG9uUmVzdW1lOiBmdW5jdGlvbihpZCwgZmlsZU5hbWUsIGNodW5rRGF0YSkge30sXG4gICAgICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3M6IGZ1bmN0aW9uKGlkLCBuYW1lLCBsb2FkZWQsIHRvdGFsKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25Ub3RhbFByb2dyZXNzOiBmdW5jdGlvbihsb2FkZWQsIHRvdGFsKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZnVuY3Rpb24oaWQsIG5hbWUsIHJlYXNvbiwgbWF5YmVYaHJPclhkcikge30sXG4gICAgICAgICAgICAgICAgICAgIG9uQXV0b1JldHJ5OiBmdW5jdGlvbihpZCwgbmFtZSwgYXR0ZW1wdE51bWJlcikge30sXG4gICAgICAgICAgICAgICAgICAgIG9uTWFudWFsUmV0cnk6IGZ1bmN0aW9uKGlkLCBuYW1lKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25WYWxpZGF0ZUJhdGNoOiBmdW5jdGlvbihmaWxlT3JCbG9iRGF0YSkge30sXG4gICAgICAgICAgICAgICAgICAgIG9uVmFsaWRhdGU6IGZ1bmN0aW9uKGZpbGVPckJsb2JEYXRhKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25TdWJtaXREZWxldGU6IGZ1bmN0aW9uKGlkKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25EZWxldGU6IGZ1bmN0aW9uKGlkKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25EZWxldGVDb21wbGV0ZTogZnVuY3Rpb24oaWQsIHhock9yWGRyLCBpc0Vycm9yKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25QYXN0ZVJlY2VpdmVkOiBmdW5jdGlvbihibG9iKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25TdGF0dXNDaGFuZ2U6IGZ1bmN0aW9uKGlkLCBvbGRTdGF0dXMsIG5ld1N0YXR1cykge30sXG4gICAgICAgICAgICAgICAgICAgIG9uU2Vzc2lvblJlcXVlc3RDb21wbGV0ZTogZnVuY3Rpb24ocmVzcG9uc2UsIHN1Y2Nlc3MsIHhock9yWGRyKSB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZUVycm9yOiBcIntmaWxlfSBoYXMgYW4gaW52YWxpZCBleHRlbnNpb24uIFZhbGlkIGV4dGVuc2lvbihzKToge2V4dGVuc2lvbnN9LlwiLFxuICAgICAgICAgICAgICAgICAgICBzaXplRXJyb3I6IFwie2ZpbGV9IGlzIHRvbyBsYXJnZSwgbWF4aW11bSBmaWxlIHNpemUgaXMge3NpemVMaW1pdH0uXCIsXG4gICAgICAgICAgICAgICAgICAgIG1pblNpemVFcnJvcjogXCJ7ZmlsZX0gaXMgdG9vIHNtYWxsLCBtaW5pbXVtIGZpbGUgc2l6ZSBpcyB7bWluU2l6ZUxpbWl0fS5cIixcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlFcnJvcjogXCJ7ZmlsZX0gaXMgZW1wdHksIHBsZWFzZSBzZWxlY3QgZmlsZXMgYWdhaW4gd2l0aG91dCBpdC5cIixcbiAgICAgICAgICAgICAgICAgICAgbm9GaWxlc0Vycm9yOiBcIk5vIGZpbGVzIHRvIHVwbG9hZC5cIixcbiAgICAgICAgICAgICAgICAgICAgdG9vTWFueUl0ZW1zRXJyb3I6IFwiVG9vIG1hbnkgaXRlbXMgKHtuZXRJdGVtc30pIHdvdWxkIGJlIHVwbG9hZGVkLiAgSXRlbSBsaW1pdCBpcyB7aXRlbUxpbWl0fS5cIixcbiAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0SW1hZ2VFcnJvcjogXCJJbWFnZSBpcyB0b28gdGFsbC5cIixcbiAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGhJbWFnZUVycm9yOiBcIkltYWdlIGlzIHRvbyB3aWRlLlwiLFxuICAgICAgICAgICAgICAgICAgICBtaW5IZWlnaHRJbWFnZUVycm9yOiBcIkltYWdlIGlzIG5vdCB0YWxsIGVub3VnaC5cIixcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGhJbWFnZUVycm9yOiBcIkltYWdlIGlzIG5vdCB3aWRlIGVub3VnaC5cIixcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlGYWlsVG9vTWFueUl0ZW1zOiBcIlJldHJ5IGZhaWxlZCAtIHlvdSBoYXZlIHJlYWNoZWQgeW91ciBmaWxlIGxpbWl0LlwiLFxuICAgICAgICAgICAgICAgICAgICBvbkxlYXZlOiBcIlRoZSBmaWxlcyBhcmUgYmVpbmcgdXBsb2FkZWQsIGlmIHlvdSBsZWF2ZSBub3cgdGhlIHVwbG9hZCB3aWxsIGJlIGNhbmNlbGVkLlwiLFxuICAgICAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZEJyb3dzZXJJb3M4U2FmYXJpOiBcIlVucmVjb3ZlcmFibGUgZXJyb3IgLSB0aGlzIGJyb3dzZXIgZG9lcyBub3QgcGVybWl0IGZpbGUgdXBsb2FkaW5nIG9mIGFueSBraW5kIGR1ZSB0byBzZXJpb3VzIGJ1Z3MgaW4gaU9TOCBTYWZhcmkuICBQbGVhc2UgdXNlIGlPUzggQ2hyb21lIHVudGlsIEFwcGxlIGZpeGVzIHRoZXNlIGlzc3Vlcy5cIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmV0cnk6IHtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlQXV0bzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1heEF1dG9BdHRlbXB0czogMyxcbiAgICAgICAgICAgICAgICAgICAgYXV0b0F0dGVtcHREZWxheTogNSxcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudFJldHJ5UmVzcG9uc2VQcm9wZXJ0eTogXCJwcmV2ZW50UmV0cnlcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2xhc3Nlczoge1xuICAgICAgICAgICAgICAgICAgICBidXR0b25Ib3ZlcjogXCJxcS11cGxvYWQtYnV0dG9uLWhvdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkZvY3VzOiBcInFxLXVwbG9hZC1idXR0b24tZm9jdXNcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2h1bmtpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmN1cnJlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1hbmRhdG9yeTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRJbmRleDogXCJxcXBhcnRpbmRleFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydEJ5dGVPZmZzZXQ6IFwicXFwYXJ0Ynl0ZW9mZnNldFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtTaXplOiBcInFxY2h1bmtzaXplXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbEZpbGVTaXplOiBcInFxdG90YWxmaWxlc2l6ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxQYXJ0czogXCJxcXRvdGFscGFydHNcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJ0U2l6ZTogMmU2LFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXN1bWU6IHtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZHNFeHBpcmVJbjogNyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdW1pbmc6IFwicXFyZXN1bWVcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmb3JtYXRGaWxlTmFtZTogZnVuY3Rpb24oZmlsZU9yQmxvYk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVPckJsb2JOYW1lO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UmVzcG9uc2VFcnJvcjogXCJVcGxvYWQgZmFpbHVyZSByZWFzb24gdW5rbm93blwiLFxuICAgICAgICAgICAgICAgICAgICBmaWxlSW5wdXRUaXRsZTogXCJmaWxlIGlucHV0XCIsXG4gICAgICAgICAgICAgICAgICAgIHNpemVTeW1ib2xzOiBbIFwia0JcIiwgXCJNQlwiLCBcIkdCXCIsIFwiVEJcIiwgXCJQQlwiLCBcIkVCXCIgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZXRlRmlsZToge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogXCIvc2VydmVyL3VwbG9hZFwiLFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21IZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29yczoge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHNlbmRDcmVkZW50aWFsczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93WGRyOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmxvYnM6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE5hbWU6IFwibWlzY19kYXRhXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhc3RlOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHROYW1lOiBcInBhc3RlZF9pbWFnZVwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYW1lcmE6IHtcbiAgICAgICAgICAgICAgICAgICAgaW9zOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uOiBudWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHRyYUJ1dHRvbnM6IFtdLFxuICAgICAgICAgICAgICAgIHNlc3Npb246IHtcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczoge30sXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoT25SZXNldDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZm9ybToge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBcInFxLWZvcm1cIixcbiAgICAgICAgICAgICAgICAgICAgYXV0b1VwbG9hZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGludGVyY2VwdFN1Ym1pdDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2NhbGluZzoge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21SZXNpemVyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzZW5kT3JpZ2luYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9yaWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRRdWFsaXR5OiA4MCxcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZVRleHQ6IFwiRmFpbGVkIHRvIHNjYWxlXCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGVFeGlmOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZXM6IFtdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3b3JrYXJvdW5kczoge1xuICAgICAgICAgICAgICAgICAgICBpb3NFbXB0eVZpZGVvczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW9zOFNhZmFyaVVwbG9hZHM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlvczhCcm93c2VyQ3Jhc2g6IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHFxLmV4dGVuZCh0aGlzLl9vcHRpb25zLCBvLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX2J1dHRvbnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2V4dHJhQnV0dG9uU3BlY3MgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX2J1dHRvbklkc0ZvckZpbGVJZHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3dyYXBDYWxsYmFja3MoKTtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VTdXBwb3J0ID0gbmV3IHFxLkRpc3Bvc2VTdXBwb3J0KCk7XG4gICAgICAgICAgICB0aGlzLl9zdG9yZWRJZHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2F1dG9SZXRyaWVzID0gW107XG4gICAgICAgICAgICB0aGlzLl9yZXRyeVRpbWVvdXRzID0gW107XG4gICAgICAgICAgICB0aGlzLl9wcmV2ZW50UmV0cmllcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fdGh1bWJuYWlsVXJscyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbmV0VXBsb2FkZWRPclF1ZXVlZCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9uZXRVcGxvYWRlZCA9IDA7XG4gICAgICAgICAgICB0aGlzLl91cGxvYWREYXRhID0gdGhpcy5fY3JlYXRlVXBsb2FkRGF0YVRyYWNrZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRGb3JtU3VwcG9ydEFuZFBhcmFtcygpO1xuICAgICAgICAgICAgdGhpcy5fY3VzdG9tSGVhZGVyc1N0b3JlID0gdGhpcy5fY3JlYXRlU3RvcmUodGhpcy5fb3B0aW9ucy5yZXF1ZXN0LmN1c3RvbUhlYWRlcnMpO1xuICAgICAgICAgICAgdGhpcy5fZGVsZXRlRmlsZUN1c3RvbUhlYWRlcnNTdG9yZSA9IHRoaXMuX2NyZWF0ZVN0b3JlKHRoaXMuX29wdGlvbnMuZGVsZXRlRmlsZS5jdXN0b21IZWFkZXJzKTtcbiAgICAgICAgICAgIHRoaXMuX2RlbGV0ZUZpbGVQYXJhbXNTdG9yZSA9IHRoaXMuX2NyZWF0ZVN0b3JlKHRoaXMuX29wdGlvbnMuZGVsZXRlRmlsZS5wYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5fZW5kcG9pbnRTdG9yZSA9IHRoaXMuX2NyZWF0ZVN0b3JlKHRoaXMuX29wdGlvbnMucmVxdWVzdC5lbmRwb2ludCk7XG4gICAgICAgICAgICB0aGlzLl9kZWxldGVGaWxlRW5kcG9pbnRTdG9yZSA9IHRoaXMuX2NyZWF0ZVN0b3JlKHRoaXMuX29wdGlvbnMuZGVsZXRlRmlsZS5lbmRwb2ludCk7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyID0gdGhpcy5fY3JlYXRlVXBsb2FkSGFuZGxlcigpO1xuICAgICAgICAgICAgdGhpcy5fZGVsZXRlSGFuZGxlciA9IHFxLkRlbGV0ZUZpbGVBamF4UmVxdWVzdGVyICYmIHRoaXMuX2NyZWF0ZURlbGV0ZUhhbmRsZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmJ1dHRvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRCdXR0b25JZCA9IHRoaXMuX2NyZWF0ZVVwbG9hZEJ1dHRvbih7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuX29wdGlvbnMuYnV0dG9uLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGhpcy5fb3B0aW9ucy50ZXh0LmZpbGVJbnB1dFRpdGxlXG4gICAgICAgICAgICAgICAgfSkuZ2V0QnV0dG9uSWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlRXh0cmFCdXR0b25TcGVjcygpO1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlQ2FtZXJhQWNjZXNzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5wYXN0ZS50YXJnZXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHFxLlBhc3RlU3VwcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXN0ZUhhbmRsZXIgPSB0aGlzLl9jcmVhdGVQYXN0ZUhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcIlBhc3RlIHN1cHBvcnQgbW9kdWxlIG5vdCBmb3VuZFwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByZXZlbnRMZWF2ZUluUHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlR2VuZXJhdG9yID0gcXEuSW1hZ2VHZW5lcmF0b3IgJiYgbmV3IHFxLkltYWdlR2VuZXJhdG9yKHFxLmJpbmQodGhpcy5sb2csIHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hTZXNzaW9uRGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5fc3VjY2VlZGVkU2luY2VMYXN0QWxsQ29tcGxldGUgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2ZhaWxlZFNpbmNlTGFzdEFsbENvbXBsZXRlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zY2FsZXIgPSBxcS5TY2FsZXIgJiYgbmV3IHFxLlNjYWxlcih0aGlzLl9vcHRpb25zLnNjYWxpbmcsIHFxLmJpbmQodGhpcy5sb2csIHRoaXMpKSB8fCB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2FsZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1c3RvbU5ld0ZpbGVIYW5kbGVyID0gcXEuYmluZCh0aGlzLl9zY2FsZXIuaGFuZGxlTmV3RmlsZSwgdGhpcy5fc2NhbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxcS5Ub3RhbFByb2dyZXNzICYmIHFxLnN1cHBvcnRlZEZlYXR1cmVzLnByb2dyZXNzQmFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG90YWxQcm9ncmVzcyA9IG5ldyBxcS5Ub3RhbFByb2dyZXNzKHFxLmJpbmQodGhpcy5fb25Ub3RhbFByb2dyZXNzLCB0aGlzKSwgZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc2VsZi5fdXBsb2FkRGF0YS5yZXRyaWV2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS5zaXplIHx8IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SXRlbUxpbWl0ID0gdGhpcy5fb3B0aW9ucy52YWxpZGF0aW9uLml0ZW1MaW1pdDtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuRmluZVVwbG9hZGVyQmFzaWMucHJvdG90eXBlID0gcXEuYmFzZVB1YmxpY0FwaTtcbiAgICAgICAgcXEuZXh0ZW5kKHFxLkZpbmVVcGxvYWRlckJhc2ljLnByb3RvdHlwZSwgcXEuYmFzZVByaXZhdGVBcGkpO1xuICAgIH0pKCk7XG4gICAgcXEuQWpheFJlcXVlc3RlciA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBsb2csIHNob3VsZFBhcmFtc0JlSW5RdWVyeVN0cmluZywgcXVldWUgPSBbXSwgcmVxdWVzdERhdGEgPSB7fSwgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFjY2VwdEhlYWRlcjogbnVsbCxcbiAgICAgICAgICAgIHZhbGlkTWV0aG9kczogWyBcIlBBVENIXCIsIFwiUE9TVFwiLCBcIlBVVFwiIF0sXG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gICAgICAgICAgICBtYXhDb25uZWN0aW9uczogMyxcbiAgICAgICAgICAgIGN1c3RvbUhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgZW5kcG9pbnRTdG9yZToge30sXG4gICAgICAgICAgICBwYXJhbXNTdG9yZToge30sXG4gICAgICAgICAgICBtYW5kYXRlZFBhcmFtczoge30sXG4gICAgICAgICAgICBhbGxvd1hSZXF1ZXN0ZWRXaXRoQW5kQ2FjaGVDb250cm9sOiB0cnVlLFxuICAgICAgICAgICAgc3VjY2Vzc2Z1bFJlc3BvbnNlQ29kZXM6IHtcbiAgICAgICAgICAgICAgICBERUxFVEU6IFsgMjAwLCAyMDIsIDIwNCBdLFxuICAgICAgICAgICAgICAgIFBBVENIOiBbIDIwMCwgMjAxLCAyMDIsIDIwMywgMjA0IF0sXG4gICAgICAgICAgICAgICAgUE9TVDogWyAyMDAsIDIwMSwgMjAyLCAyMDMsIDIwNCBdLFxuICAgICAgICAgICAgICAgIFBVVDogWyAyMDAsIDIwMSwgMjAyLCAyMDMsIDIwNCBdLFxuICAgICAgICAgICAgICAgIEdFVDogWyAyMDAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvcnM6IHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VuZENyZWRlbnRpYWxzOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvZzogZnVuY3Rpb24oc3RyLCBsZXZlbCkge30sXG4gICAgICAgICAgICBvblNlbmQ6IGZ1bmN0aW9uKGlkKSB7fSxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKGlkLCB4aHJPclhkciwgaXNFcnJvcikge30sXG4gICAgICAgICAgICBvblByb2dyZXNzOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHFxLmV4dGVuZChvcHRpb25zLCBvKTtcbiAgICAgICAgbG9nID0gb3B0aW9ucy5sb2c7XG4gICAgICAgIGlmIChxcS5pbmRleE9mKG9wdGlvbnMudmFsaWRNZXRob2RzLCBvcHRpb25zLm1ldGhvZCkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInXCIgKyBvcHRpb25zLm1ldGhvZCArIFwiJyBpcyBub3QgYSBzdXBwb3J0ZWQgbWV0aG9kIGZvciB0aGlzIHR5cGUgb2YgcmVxdWVzdCFcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNTaW1wbGVNZXRob2QoKSB7XG4gICAgICAgICAgICByZXR1cm4gcXEuaW5kZXhPZihbIFwiR0VUXCIsIFwiUE9TVFwiLCBcIkhFQURcIiBdLCBvcHRpb25zLm1ldGhvZCkgPj0gMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb250YWluc05vblNpbXBsZUhlYWRlcnMoaGVhZGVycykge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5zTm9uU2ltcGxlID0gZmFsc2U7XG4gICAgICAgICAgICBxcS5lYWNoKGNvbnRhaW5zTm9uU2ltcGxlLCBmdW5jdGlvbihpZHgsIGhlYWRlcikge1xuICAgICAgICAgICAgICAgIGlmIChxcS5pbmRleE9mKFsgXCJBY2NlcHRcIiwgXCJBY2NlcHQtTGFuZ3VhZ2VcIiwgXCJDb250ZW50LUxhbmd1YWdlXCIsIFwiQ29udGVudC1UeXBlXCIgXSwgaGVhZGVyKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnNOb25TaW1wbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbnNOb25TaW1wbGU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNYZHIoeGhyKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jb3JzLmV4cGVjdGVkICYmIHhoci53aXRoQ3JlZGVudGlhbHMgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRDb3JzQWpheFRyYW5zcG9ydCgpIHtcbiAgICAgICAgICAgIHZhciB4aHJPclhkcjtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QgfHwgd2luZG93LkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB4aHJPclhkciA9IHFxLmNyZWF0ZVhockluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHhock9yWGRyLndpdGhDcmVkZW50aWFscyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHhock9yWGRyID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHhock9yWGRyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgICAgICAgICAgICAgIHhock9yWGRyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICAgICAgICAgICAgICB4aHJPclhkci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICAgICAgICAgICAgICB4aHJPclhkci5vbnByb2dyZXNzID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geGhyT3JYZHI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0WGhyT3JYZHIoaWQsIHN1cHBsaWVkWGhyKSB7XG4gICAgICAgICAgICB2YXIgeGhyT3JYZHIgPSByZXF1ZXN0RGF0YVtpZF0ueGhyO1xuICAgICAgICAgICAgaWYgKCF4aHJPclhkcikge1xuICAgICAgICAgICAgICAgIGlmIChzdXBwbGllZFhocikge1xuICAgICAgICAgICAgICAgICAgICB4aHJPclhkciA9IHN1cHBsaWVkWGhyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNvcnMuZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhock9yWGRyID0gZ2V0Q29yc0FqYXhUcmFuc3BvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhock9yWGRyID0gcXEuY3JlYXRlWGhySW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YVtpZF0ueGhyID0geGhyT3JYZHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geGhyT3JYZHI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVxdWV1ZShpZCkge1xuICAgICAgICAgICAgdmFyIGkgPSBxcS5pbmRleE9mKHF1ZXVlLCBpZCksIG1heCA9IG9wdGlvbnMubWF4Q29ubmVjdGlvbnMsIG5leHRJZDtcbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGF0YVtpZF07XG4gICAgICAgICAgICBxdWV1ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID49IG1heCAmJiBpIDwgbWF4KSB7XG4gICAgICAgICAgICAgICAgbmV4dElkID0gcXVldWVbbWF4IC0gMV07XG4gICAgICAgICAgICAgICAgc2VuZFJlcXVlc3QobmV4dElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbkNvbXBsZXRlKGlkLCB4ZHJFcnJvcikge1xuICAgICAgICAgICAgdmFyIHhociA9IGdldFhock9yWGRyKGlkKSwgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QsIGlzRXJyb3IgPSB4ZHJFcnJvciA9PT0gdHJ1ZTtcbiAgICAgICAgICAgIGRlcXVldWUoaWQpO1xuICAgICAgICAgICAgaWYgKGlzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2cobWV0aG9kICsgXCIgcmVxdWVzdCBmb3IgXCIgKyBpZCArIFwiIGhhcyBmYWlsZWRcIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzWGRyKHhocikgJiYgIWlzUmVzcG9uc2VTdWNjZXNzZnVsKHhoci5zdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgaXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgbG9nKG1ldGhvZCArIFwiIHJlcXVlc3QgZm9yIFwiICsgaWQgKyBcIiBoYXMgZmFpbGVkIC0gcmVzcG9uc2UgY29kZSBcIiArIHhoci5zdGF0dXMsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLm9uQ29tcGxldGUoaWQsIHhociwgaXNFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0UGFyYW1zKGlkKSB7XG4gICAgICAgICAgICB2YXIgb25EZW1hbmRQYXJhbXMgPSByZXF1ZXN0RGF0YVtpZF0uYWRkaXRpb25hbFBhcmFtcywgbWFuZGF0ZWRQYXJhbXMgPSBvcHRpb25zLm1hbmRhdGVkUGFyYW1zLCBwYXJhbXM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJhbXNTdG9yZS5nZXQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBvcHRpb25zLnBhcmFtc1N0b3JlLmdldChpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25EZW1hbmRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBxcS5lYWNoKG9uRGVtYW5kUGFyYW1zLCBmdW5jdGlvbihuYW1lLCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbbmFtZV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWFuZGF0ZWRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBxcS5lYWNoKG1hbmRhdGVkUGFyYW1zLCBmdW5jdGlvbihuYW1lLCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbbmFtZV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNlbmRSZXF1ZXN0KGlkLCBvcHRYaHIpIHtcbiAgICAgICAgICAgIHZhciB4aHIgPSBnZXRYaHJPclhkcihpZCwgb3B0WGhyKSwgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QsIHBhcmFtcyA9IGdldFBhcmFtcyhpZCksIHBheWxvYWQgPSByZXF1ZXN0RGF0YVtpZF0ucGF5bG9hZCwgdXJsO1xuICAgICAgICAgICAgb3B0aW9ucy5vblNlbmQoaWQpO1xuICAgICAgICAgICAgdXJsID0gY3JlYXRlVXJsKGlkLCBwYXJhbXMsIHJlcXVlc3REYXRhW2lkXS5hZGRpdGlvbmFsUXVlcnlQYXJhbXMpO1xuICAgICAgICAgICAgaWYgKGlzWGRyKHhocikpIHtcbiAgICAgICAgICAgICAgICB4aHIub25sb2FkID0gZ2V0WGRyTG9hZEhhbmRsZXIoaWQpO1xuICAgICAgICAgICAgICAgIHhoci5vbmVycm9yID0gZ2V0WGRyRXJyb3JIYW5kbGVyKGlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGdldFhoclJlYWR5U3RhdGVDaGFuZ2VIYW5kbGVyKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZ2lzdGVyRm9yVXBsb2FkUHJvZ3Jlc3MoaWQpO1xuICAgICAgICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29ycy5leHBlY3RlZCAmJiBvcHRpb25zLmNvcnMuc2VuZENyZWRlbnRpYWxzICYmICFpc1hkcih4aHIpKSB7XG4gICAgICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRIZWFkZXJzKGlkKTtcbiAgICAgICAgICAgIGxvZyhcIlNlbmRpbmcgXCIgKyBtZXRob2QgKyBcIiByZXF1ZXN0IGZvciBcIiArIGlkKTtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgeGhyLnNlbmQocGF5bG9hZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNob3VsZFBhcmFtc0JlSW5RdWVyeVN0cmluZyB8fCAhcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgeGhyLnNlbmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1zICYmIG9wdGlvbnMuY29udGVudFR5cGUgJiYgb3B0aW9ucy5jb250ZW50VHlwZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIikgPj0gMCkge1xuICAgICAgICAgICAgICAgIHhoci5zZW5kKHFxLm9iajJ1cmwocGFyYW1zLCBcIlwiKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcyAmJiBvcHRpb25zLmNvbnRlbnRUeXBlICYmIG9wdGlvbnMuY29udGVudFR5cGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiYXBwbGljYXRpb24vanNvblwiKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgeGhyLnNlbmQoSlNPTi5zdHJpbmdpZnkocGFyYW1zKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHhoci5zZW5kKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geGhyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVVybChpZCwgcGFyYW1zLCBhZGRpdGlvbmFsUXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBlbmRwb2ludCA9IG9wdGlvbnMuZW5kcG9pbnRTdG9yZS5nZXQoaWQpLCBhZGRUb1BhdGggPSByZXF1ZXN0RGF0YVtpZF0uYWRkVG9QYXRoO1xuICAgICAgICAgICAgaWYgKGFkZFRvUGF0aCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlbmRwb2ludCArPSBcIi9cIiArIGFkZFRvUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRQYXJhbXNCZUluUXVlcnlTdHJpbmcgJiYgcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgZW5kcG9pbnQgPSBxcS5vYmoydXJsKHBhcmFtcywgZW5kcG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxRdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgICAgIGVuZHBvaW50ID0gcXEub2JqMnVybChhZGRpdGlvbmFsUXVlcnlQYXJhbXMsIGVuZHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbmRwb2ludDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRYaHJSZWFkeVN0YXRlQ2hhbmdlSGFuZGxlcihpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChnZXRYaHJPclhkcihpZCkucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRm9yVXBsb2FkUHJvZ3Jlc3MoaWQpIHtcbiAgICAgICAgICAgIHZhciBvblByb2dyZXNzID0gb3B0aW9ucy5vblByb2dyZXNzO1xuICAgICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICBnZXRYaHJPclhkcihpZCkudXBsb2FkLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3MoaWQsIGUubG9hZGVkLCBlLnRvdGFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0WGRyTG9hZEhhbmRsZXIoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKGlkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0WGRyRXJyb3JIYW5kbGVyKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZShpZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldEhlYWRlcnMoaWQpIHtcbiAgICAgICAgICAgIHZhciB4aHIgPSBnZXRYaHJPclhkcihpZCksIGN1c3RvbUhlYWRlcnMgPSBvcHRpb25zLmN1c3RvbUhlYWRlcnMsIG9uRGVtYW5kSGVhZGVycyA9IHJlcXVlc3REYXRhW2lkXS5hZGRpdGlvbmFsSGVhZGVycyB8fCB7fSwgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QsIGFsbEhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICghaXNYZHIoeGhyKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuYWNjZXB0SGVhZGVyICYmIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIG9wdGlvbnMuYWNjZXB0SGVhZGVyKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxvd1hSZXF1ZXN0ZWRXaXRoQW5kQ2FjaGVDb250cm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5jb3JzLmV4cGVjdGVkIHx8ICghaXNTaW1wbGVNZXRob2QoKSB8fCBjb250YWluc05vblNpbXBsZUhlYWRlcnMoY3VzdG9tSGVhZGVycykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlgtUmVxdWVzdGVkLVdpdGhcIiwgXCJYTUxIdHRwUmVxdWVzdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ2FjaGUtQ29udHJvbFwiLCBcIm5vLWNhY2hlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnRUeXBlICYmIChtZXRob2QgPT09IFwiUE9TVFwiIHx8IG1ldGhvZCA9PT0gXCJQVVRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgb3B0aW9ucy5jb250ZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHFxLmV4dGVuZChhbGxIZWFkZXJzLCBxcS5pc0Z1bmN0aW9uKGN1c3RvbUhlYWRlcnMpID8gY3VzdG9tSGVhZGVycyhpZCkgOiBjdXN0b21IZWFkZXJzKTtcbiAgICAgICAgICAgICAgICBxcS5leHRlbmQoYWxsSGVhZGVycywgb25EZW1hbmRIZWFkZXJzKTtcbiAgICAgICAgICAgICAgICBxcS5lYWNoKGFsbEhlYWRlcnMsIGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzUmVzcG9uc2VTdWNjZXNzZnVsKHJlc3BvbnNlQ29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHFxLmluZGV4T2Yob3B0aW9ucy5zdWNjZXNzZnVsUmVzcG9uc2VDb2Rlc1tvcHRpb25zLm1ldGhvZF0sIHJlc3BvbnNlQ29kZSkgPj0gMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwcmVwYXJlVG9TZW5kKGlkLCBvcHRYaHIsIGFkZFRvUGF0aCwgYWRkaXRpb25hbFBhcmFtcywgYWRkaXRpb25hbFF1ZXJ5UGFyYW1zLCBhZGRpdGlvbmFsSGVhZGVycywgcGF5bG9hZCkge1xuICAgICAgICAgICAgcmVxdWVzdERhdGFbaWRdID0ge1xuICAgICAgICAgICAgICAgIGFkZFRvUGF0aDogYWRkVG9QYXRoLFxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxQYXJhbXM6IGFkZGl0aW9uYWxQYXJhbXMsXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbFF1ZXJ5UGFyYW1zOiBhZGRpdGlvbmFsUXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbEhlYWRlcnM6IGFkZGl0aW9uYWxIZWFkZXJzLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbGVuID0gcXVldWUucHVzaChpZCk7XG4gICAgICAgICAgICBpZiAobGVuIDw9IG9wdGlvbnMubWF4Q29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VuZFJlcXVlc3QoaWQsIG9wdFhocik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2hvdWxkUGFyYW1zQmVJblF1ZXJ5U3RyaW5nID0gb3B0aW9ucy5tZXRob2QgPT09IFwiR0VUXCIgfHwgb3B0aW9ucy5tZXRob2QgPT09IFwiREVMRVRFXCI7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBpbml0VHJhbnNwb3J0OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoLCBwYXJhbXMsIGhlYWRlcnMsIHBheWxvYWQsIGNhY2hlQnVzdGVyLCBhZGRpdGlvbmFsUXVlcnlQYXJhbXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgd2l0aFBhdGg6IGZ1bmN0aW9uKGFwcGVuZFRvUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IGFwcGVuZFRvUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3aXRoUGFyYW1zOiBmdW5jdGlvbihhZGRpdGlvbmFsUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBhZGRpdGlvbmFsUGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdpdGhRdWVyeVBhcmFtczogZnVuY3Rpb24oX2FkZGl0aW9uYWxRdWVyeVBhcmFtc18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxRdWVyeVBhcmFtcyA9IF9hZGRpdGlvbmFsUXVlcnlQYXJhbXNfO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdpdGhIZWFkZXJzOiBmdW5jdGlvbihhZGRpdGlvbmFsSGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyA9IGFkZGl0aW9uYWxIZWFkZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdpdGhQYXlsb2FkOiBmdW5jdGlvbih0aGVQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkID0gdGhlUGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3aXRoQ2FjaGVCdXN0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVCdXN0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNlbmQ6IGZ1bmN0aW9uKG9wdFhocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlQnVzdGVyICYmIHFxLmluZGV4T2YoWyBcIkdFVFwiLCBcIkRFTEVURVwiIF0sIG9wdGlvbnMubWV0aG9kKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnFxdGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlcGFyZVRvU2VuZChpZCwgb3B0WGhyLCBwYXRoLCBwYXJhbXMsIGFkZGl0aW9uYWxRdWVyeVBhcmFtcywgaGVhZGVycywgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbmNlbGVkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGRlcXVldWUoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHFxLlVwbG9hZEhhbmRsZXIgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgcHJveHkgPSBzcGVjLnByb3h5LCBmaWxlU3RhdGUgPSB7fSwgb25DYW5jZWwgPSBwcm94eS5vbkNhbmNlbCwgZ2V0TmFtZSA9IHByb3h5LmdldE5hbWU7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKGlkLCBmaWxlSXRlbSkge1xuICAgICAgICAgICAgICAgIGZpbGVTdGF0ZVtpZF0gPSBmaWxlSXRlbTtcbiAgICAgICAgICAgICAgICBmaWxlU3RhdGVbaWRdLnRlbXAgPSB7fTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBjYW5jZWxGaW5hbGl6YXRpb25FZmZvcnQgPSBuZXcgcXEuUHJvbWlzZSgpLCBvbkNhbmNlbFJldFZhbCA9IG9uQ2FuY2VsKGlkLCBnZXROYW1lKGlkKSwgY2FuY2VsRmluYWxpemF0aW9uRWZmb3J0KTtcbiAgICAgICAgICAgICAgICBvbkNhbmNlbFJldFZhbC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5pc1ZhbGlkKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVN0YXRlW2lkXS5jYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmV4cHVuZ2UoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEZpbmFsaXphdGlvbkVmZm9ydC5zdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhwdW5nZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZmlsZVN0YXRlW2lkXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRUaGlyZFBhcnR5RmlsZUlkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlU3RhdGVbaWRdLmtleTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1ZhbGlkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlU3RhdGVbaWRdICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZpbGVTdGF0ZSA9IHt9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXRGaWxlU3RhdGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVTdGF0ZVtpZF07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NldFRoaXJkUGFydHlGaWxlSWQ6IGZ1bmN0aW9uKGlkLCB0aGlyZFBhcnR5RmlsZUlkKSB7XG4gICAgICAgICAgICAgICAgZmlsZVN0YXRlW2lkXS5rZXkgPSB0aGlyZFBhcnR5RmlsZUlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF93YXNDYW5jZWxlZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFmaWxlU3RhdGVbaWRdLmNhbmNlbGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHFxLlVwbG9hZEhhbmRsZXJDb250cm9sbGVyID0gZnVuY3Rpb24obywgbmFtZXNwYWNlKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgY29udHJvbGxlciA9IHRoaXMsIGNodW5raW5nUG9zc2libGUgPSBmYWxzZSwgY29uY3VycmVudENodW5raW5nUG9zc2libGUgPSBmYWxzZSwgY2h1bmtpbmcsIHByZXZlbnRSZXRyeVJlc3BvbnNlLCBsb2csIGhhbmRsZXIsIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBwYXJhbXNTdG9yZToge30sXG4gICAgICAgICAgICBtYXhDb25uZWN0aW9uczogMyxcbiAgICAgICAgICAgIGNodW5raW5nOiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbXVsdGlwbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9nOiBmdW5jdGlvbihzdHIsIGxldmVsKSB7fSxcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3M6IGZ1bmN0aW9uKGlkLCBmaWxlTmFtZSwgbG9hZGVkLCB0b3RhbCkge30sXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbihpZCwgZmlsZU5hbWUsIHJlc3BvbnNlLCB4aHIpIHt9LFxuICAgICAgICAgICAgb25DYW5jZWw6IGZ1bmN0aW9uKGlkLCBmaWxlTmFtZSkge30sXG4gICAgICAgICAgICBvblVwbG9hZFByZXA6IGZ1bmN0aW9uKGlkKSB7fSxcbiAgICAgICAgICAgIG9uVXBsb2FkOiBmdW5jdGlvbihpZCwgZmlsZU5hbWUpIHt9LFxuICAgICAgICAgICAgb25VcGxvYWRDaHVuazogZnVuY3Rpb24oaWQsIGZpbGVOYW1lLCBjaHVua0RhdGEpIHt9LFxuICAgICAgICAgICAgb25VcGxvYWRDaHVua1N1Y2Nlc3M6IGZ1bmN0aW9uKGlkLCBjaHVua0RhdGEsIHJlc3BvbnNlLCB4aHIpIHt9LFxuICAgICAgICAgICAgb25BdXRvUmV0cnk6IGZ1bmN0aW9uKGlkLCBmaWxlTmFtZSwgcmVzcG9uc2UsIHhocikge30sXG4gICAgICAgICAgICBvblJlc3VtZTogZnVuY3Rpb24oaWQsIGZpbGVOYW1lLCBjaHVua0RhdGEpIHt9LFxuICAgICAgICAgICAgb25VdWlkQ2hhbmdlZDogZnVuY3Rpb24oaWQsIG5ld1V1aWQpIHt9LFxuICAgICAgICAgICAgZ2V0TmFtZTogZnVuY3Rpb24oaWQpIHt9LFxuICAgICAgICAgICAgc2V0U2l6ZTogZnVuY3Rpb24oaWQsIG5ld1NpemUpIHt9LFxuICAgICAgICAgICAgaXNRdWV1ZWQ6IGZ1bmN0aW9uKGlkKSB7fSxcbiAgICAgICAgICAgIGdldElkc0luUHJveHlHcm91cDogZnVuY3Rpb24oaWQpIHt9LFxuICAgICAgICAgICAgZ2V0SWRzSW5CYXRjaDogZnVuY3Rpb24oaWQpIHt9XG4gICAgICAgIH0sIGNodW5rZWQgPSB7XG4gICAgICAgICAgICBkb25lOiBmdW5jdGlvbihpZCwgY2h1bmtJZHgsIHJlc3BvbnNlLCB4aHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2h1bmtEYXRhID0gaGFuZGxlci5fZ2V0Q2h1bmtEYXRhKGlkLCBjaHVua0lkeCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5hdHRlbXB0aW5nUmVzdW1lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkudGVtcC5jaHVua1Byb2dyZXNzW2NodW5rSWR4XTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmxvYWRlZCArPSBjaHVua0RhdGEuc2l6ZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uVXBsb2FkQ2h1bmtTdWNjZXNzKGlkLCBoYW5kbGVyLl9nZXRDaHVua0RhdGFGb3JDYWxsYmFjayhjaHVua0RhdGEpLCByZXNwb25zZSwgeGhyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IG9wdGlvbnMuZ2V0U2l6ZShpZCksIG5hbWUgPSBvcHRpb25zLmdldE5hbWUoaWQpO1xuICAgICAgICAgICAgICAgIGxvZyhcIkFsbCBjaHVua3MgaGF2ZSBiZWVuIHVwbG9hZGVkIGZvciBcIiArIGlkICsgXCIgLSBmaW5hbGl6aW5nLi4uLlwiKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmZpbmFsaXplQ2h1bmtzKGlkKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlLCB4aHIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwiRmluYWxpemUgc3VjY2Vzc2Z1bCBmb3IgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWl6ZWRSZXNwb25zZSA9IHVwbG9hZC5ub3JtYWxpemVSZXNwb25zZShyZXNwb25zZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25Qcm9ncmVzcyhpZCwgbmFtZSwgc2l6ZSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuX21heWJlRGVsZXRlUGVyc2lzdGVkQ2h1bmtEYXRhKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkLmNsZWFudXAoaWQsIG5vcm1haXplZFJlc3BvbnNlLCB4aHIpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKHJlc3BvbnNlLCB4aHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1haXplZFJlc3BvbnNlID0gdXBsb2FkLm5vcm1hbGl6ZVJlc3BvbnNlKHJlc3BvbnNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIlByb2JsZW0gZmluYWxpemluZyBjaHVua3MgZm9yIGZpbGUgSUQgXCIgKyBpZCArIFwiIC0gXCIgKyBub3JtYWl6ZWRSZXNwb25zZS5lcnJvciwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vcm1haXplZFJlc3BvbnNlLnJlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua2VkLnJlc2V0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMub25BdXRvUmV0cnkoaWQsIG5hbWUsIG5vcm1haXplZFJlc3BvbnNlLCB4aHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWQuY2xlYW51cChpZCwgbm9ybWFpemVkUmVzcG9uc2UsIHhocik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVGYWlsdXJlOiBmdW5jdGlvbihjaHVua0lkeCwgaWQsIHJlc3BvbnNlLCB4aHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG9wdGlvbnMuZ2V0TmFtZShpZCk7XG4gICAgICAgICAgICAgICAgbG9nKFwiQ2h1bmtlZCB1cGxvYWQgcmVxdWVzdCBmYWlsZWQgZm9yIFwiICsgaWQgKyBcIiwgY2h1bmsgXCIgKyBjaHVua0lkeCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5jbGVhckNhY2hlZENodW5rKGlkLCBjaHVua0lkeCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlVG9SZXBvcnQgPSB1cGxvYWQubm9ybWFsaXplUmVzcG9uc2UocmVzcG9uc2UsIGZhbHNlKSwgaW5Qcm9ncmVzc0lkeDtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VUb1JlcG9ydC5yZXNldCkge1xuICAgICAgICAgICAgICAgICAgICBjaHVua2VkLnJlc2V0KGlkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpblByb2dyZXNzSWR4ID0gcXEuaW5kZXhPZihoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmNodW5raW5nLmluUHJvZ3Jlc3MsIGNodW5rSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluUHJvZ3Jlc3NJZHggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5jaHVua2luZy5pblByb2dyZXNzLnNwbGljZShpblByb2dyZXNzSWR4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkuY2h1bmtpbmcucmVtYWluaW5nLnVuc2hpZnQoY2h1bmtJZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS50ZW1wLmlnbm9yZUZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmN1cnJlbnRDaHVua2luZ1Bvc3NpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLnRlbXAuaWdub3JlRmFpbHVyZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cocXEuZm9ybWF0KFwiR29pbmcgdG8gYXR0ZW1wdCB0byBhYm9ydCB0aGVzZSBjaHVua3M6IHt9LiBUaGVzZSBhcmUgY3VycmVudGx5IGluLXByb2dyZXNzOiB7fS5cIiwgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoaGFuZGxlci5fZ2V0WGhycyhpZCkpKSwgSlNPTi5zdHJpbmdpZnkoaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5jaHVua2luZy5pblByb2dyZXNzKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChoYW5kbGVyLl9nZXRYaHJzKGlkKSwgZnVuY3Rpb24oY2tpZCwgY2tYaHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cocXEuZm9ybWF0KFwiQXR0ZW1wdGluZyB0byBhYm9ydCBmaWxlIHt9Lnt9LiBYSFIgcmVhZHlTdGF0ZSB7fS4gXCIsIGlkLCBja2lkLCBja1hoci5yZWFkeVN0YXRlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2tYaHIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBja1hoci5fY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5tb3ZlSW5Qcm9ncmVzc1RvUmVtYWluaW5nKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLmZyZWUoaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5vbkF1dG9SZXRyeShpZCwgbmFtZSwgcmVzcG9uc2VUb1JlcG9ydCwgeGhyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkLmNsZWFudXAoaWQsIHJlc3BvbnNlVG9SZXBvcnQsIHhocik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzTW9yZVBhcnRzOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkuY2h1bmtpbmcucmVtYWluaW5nLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0UGFydDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dElkeCA9IGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkuY2h1bmtpbmcucmVtYWluaW5nLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRJZHggPj0gaGFuZGxlci5fZ2V0VG90YWxDaHVua3MoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRJZHggPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dElkeDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBsb2coXCJTZXJ2ZXIgb3IgY2FsbGJhY2sgaGFzIG9yZGVyZWQgY2h1bmtpbmcgZWZmb3J0IHRvIGJlIHJlc3RhcnRlZCBvbiBuZXh0IGF0dGVtcHQgZm9yIGl0ZW0gSUQgXCIgKyBpZCwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLl9tYXliZURlbGV0ZVBlcnNpc3RlZENodW5rRGF0YShpZCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5yZWV2YWx1YXRlQ2h1bmtpbmcoaWQpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkubG9hZGVkID0gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZW5kTmV4dDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IG9wdGlvbnMuZ2V0U2l6ZShpZCksIG5hbWUgPSBvcHRpb25zLmdldE5hbWUoaWQpLCBjaHVua0lkeCA9IGNodW5rZWQubmV4dFBhcnQoaWQpLCBjaHVua0RhdGEgPSBoYW5kbGVyLl9nZXRDaHVua0RhdGEoaWQsIGNodW5rSWR4KSwgcmVzdW1pbmcgPSBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmF0dGVtcHRpbmdSZXN1bWUsIGluUHJvZ3Jlc3NDaHVua3MgPSBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmNodW5raW5nLmluUHJvZ3Jlc3MgfHwgW107XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkubG9hZGVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5sb2FkZWQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdW1pbmcgJiYgb3B0aW9ucy5vblJlc3VtZShpZCwgbmFtZSwgY2h1bmtEYXRhKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtlZC5yZXNldChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rSWR4ID0gY2h1bmtlZC5uZXh0UGFydChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rRGF0YSA9IGhhbmRsZXIuX2dldENodW5rRGF0YShpZCwgY2h1bmtJZHgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2h1bmtJZHggPT0gbnVsbCAmJiBpblByb2dyZXNzQ2h1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjaHVua2VkLmZpbmFsaXplKGlkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2cocXEuZm9ybWF0KFwiU2VuZGluZyBjaHVua2VkIHVwbG9hZCByZXF1ZXN0IGZvciBpdGVtIHt9Lnt9LCBieXRlcyB7fS17fSBvZiB7fS5cIiwgaWQsIGNodW5rSWR4LCBjaHVua0RhdGEuc3RhcnQgKyAxLCBjaHVua0RhdGEuZW5kLCBzaXplKSk7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25VcGxvYWRDaHVuayhpZCwgbmFtZSwgaGFuZGxlci5fZ2V0Q2h1bmtEYXRhRm9yQ2FsbGJhY2soY2h1bmtEYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIGluUHJvZ3Jlc3NDaHVua3MucHVzaChjaHVua0lkeCk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkuY2h1bmtpbmcuaW5Qcm9ncmVzcyA9IGluUHJvZ3Jlc3NDaHVua3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25jdXJyZW50Q2h1bmtpbmdQb3NzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIub3BlbihpZCwgY2h1bmtJZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25jdXJyZW50Q2h1bmtpbmdQb3NzaWJsZSAmJiBjb25uZWN0aW9uTWFuYWdlci5hdmFpbGFibGUoKSAmJiBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmNodW5raW5nLnJlbWFpbmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rZWQuc2VuZE5leHQoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVua0RhdGEuYmxvYi5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cocXEuZm9ybWF0KFwiQ2h1bmsge30gZm9yIGZpbGUge30gd2lsbCBub3QgYmUgdXBsb2FkZWQsIHplcm8gc2l6ZWQgY2h1bmsuXCIsIGNodW5rSWR4LCBpZCksIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua2VkLmhhbmRsZUZhaWx1cmUoY2h1bmtJZHgsIGlkLCBcIkZpbGUgaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZVwiLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIudXBsb2FkQ2h1bmsoaWQsIGNodW5rSWR4LCByZXN1bWluZykudGhlbihmdW5jdGlvbiBzdWNjZXNzKHJlc3BvbnNlLCB4aHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coXCJDaHVua2VkIHVwbG9hZCByZXF1ZXN0IHN1Y2NlZWRlZCBmb3IgXCIgKyBpZCArIFwiLCBjaHVuayBcIiArIGNodW5rSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNsZWFyQ2FjaGVkQ2h1bmsoaWQsIGNodW5rSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5Qcm9ncmVzc0NodW5rcyA9IGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkuY2h1bmtpbmcuaW5Qcm9ncmVzcyB8fCBbXSwgcmVzcG9uc2VUb1JlcG9ydCA9IHVwbG9hZC5ub3JtYWxpemVSZXNwb25zZShyZXNwb25zZSwgdHJ1ZSksIGluUHJvZ3Jlc3NDaHVua0lkeCA9IHFxLmluZGV4T2YoaW5Qcm9ncmVzc0NodW5rcywgY2h1bmtJZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhxcS5mb3JtYXQoXCJDaHVuayB7fSBmb3IgZmlsZSB7fSB1cGxvYWRlZCBzdWNjZXNzZnVsbHkuXCIsIGNodW5rSWR4LCBpZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rZWQuZG9uZShpZCwgY2h1bmtJZHgsIHJlc3BvbnNlVG9SZXBvcnQsIHhocik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluUHJvZ3Jlc3NDaHVua0lkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluUHJvZ3Jlc3NDaHVua3Muc3BsaWNlKGluUHJvZ3Jlc3NDaHVua0lkeCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuX21heWJlUGVyc2lzdENodW5rZWRTdGF0ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaHVua2VkLmhhc01vcmVQYXJ0cyhpZCkgJiYgaW5Qcm9ncmVzc0NodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtlZC5maW5hbGl6ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaHVua2VkLmhhc01vcmVQYXJ0cyhpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtlZC5zZW5kTmV4dChpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKHFxLmZvcm1hdChcIkZpbGUgSUQge30gaGFzIG5vIG1vcmUgY2h1bmtzIHRvIHNlbmQgYW5kIHRoZXNlIGNodW5rIGluZGV4ZXMgYXJlIHN0aWxsIG1hcmtlZCBhcyBpbi1wcm9ncmVzczoge31cIiwgaWQsIEpTT04uc3RyaW5naWZ5KGluUHJvZ3Jlc3NDaHVua3MpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gZmFpbHVyZShyZXNwb25zZSwgeGhyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtlZC5oYW5kbGVGYWlsdXJlKGNodW5rSWR4LCBpZCwgcmVzcG9uc2UsIHhocik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5kb25lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2xlYXJYaHIoaWQsIGNodW5rSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBjb25uZWN0aW9uTWFuYWdlciA9IHtcbiAgICAgICAgICAgIF9vcGVuOiBbXSxcbiAgICAgICAgICAgIF9vcGVuQ2h1bmtzOiB7fSxcbiAgICAgICAgICAgIF93YWl0aW5nOiBbXSxcbiAgICAgICAgICAgIGF2YWlsYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heCA9IG9wdGlvbnMubWF4Q29ubmVjdGlvbnMsIG9wZW5DaHVua0VudHJpZXNDb3VudCA9IDAsIG9wZW5DaHVua3NDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgcXEuZWFjaChjb25uZWN0aW9uTWFuYWdlci5fb3BlbkNodW5rcywgZnVuY3Rpb24oZmlsZUlkLCBvcGVuQ2h1bmtJbmRleGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5DaHVua0VudHJpZXNDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBvcGVuQ2h1bmtzQ291bnQgKz0gb3BlbkNodW5rSW5kZXhlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heCAtIChjb25uZWN0aW9uTWFuYWdlci5fb3Blbi5sZW5ndGggLSBvcGVuQ2h1bmtFbnRyaWVzQ291bnQgKyBvcGVuQ2h1bmtzQ291bnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyZWU6IGZ1bmN0aW9uKGlkLCBkb250QWxsb3dOZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFsbG93TmV4dCA9ICFkb250QWxsb3dOZXh0LCB3YWl0aW5nSW5kZXggPSBxcS5pbmRleE9mKGNvbm5lY3Rpb25NYW5hZ2VyLl93YWl0aW5nLCBpZCksIGNvbm5lY3Rpb25zSW5kZXggPSBxcS5pbmRleE9mKGNvbm5lY3Rpb25NYW5hZ2VyLl9vcGVuLCBpZCksIG5leHRJZDtcbiAgICAgICAgICAgICAgICBkZWxldGUgY29ubmVjdGlvbk1hbmFnZXIuX29wZW5DaHVua3NbaWRdO1xuICAgICAgICAgICAgICAgIGlmICh1cGxvYWQuZ2V0UHJveHlPckJsb2IoaWQpIGluc3RhbmNlb2YgcXEuQmxvYlByb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIkdlbmVyYXRlZCBibG9iIHVwbG9hZCBoYXMgZW5kZWQgZm9yIFwiICsgaWQgKyBcIiwgZGlzcG9zaW5nIGdlbmVyYXRlZCBibG9iLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkuZmlsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdhaXRpbmdJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLl93YWl0aW5nLnNwbGljZSh3YWl0aW5nSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWxsb3dOZXh0ICYmIGNvbm5lY3Rpb25zSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5fb3Blbi5zcGxpY2UoY29ubmVjdGlvbnNJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRJZCA9IGNvbm5lY3Rpb25NYW5hZ2VyLl93YWl0aW5nLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0SWQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIuX29wZW4ucHVzaChuZXh0SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkLnN0YXJ0KG5leHRJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0V2FpdGluZ09yQ29ubmVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2FpdGluZ09yQ29ubmVjdGVkID0gW107XG4gICAgICAgICAgICAgICAgcXEuZWFjaChjb25uZWN0aW9uTWFuYWdlci5fb3BlbkNodW5rcywgZnVuY3Rpb24oZmlsZUlkLCBjaHVua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rcyAmJiBjaHVua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWl0aW5nT3JDb25uZWN0ZWQucHVzaChwYXJzZUludChmaWxlSWQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHFxLmVhY2goY29ubmVjdGlvbk1hbmFnZXIuX29wZW4sIGZ1bmN0aW9uKGlkeCwgZmlsZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29ubmVjdGlvbk1hbmFnZXIuX29wZW5DaHVua3NbZmlsZUlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FpdGluZ09yQ29ubmVjdGVkLnB1c2gocGFyc2VJbnQoZmlsZUlkKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB3YWl0aW5nT3JDb25uZWN0ZWQgPSB3YWl0aW5nT3JDb25uZWN0ZWQuY29uY2F0KGNvbm5lY3Rpb25NYW5hZ2VyLl93YWl0aW5nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2FpdGluZ09yQ29ubmVjdGVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzVXNpbmdDb25uZWN0aW9uOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxcS5pbmRleE9mKGNvbm5lY3Rpb25NYW5hZ2VyLl9vcGVuLCBpZCkgPj0gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcGVuOiBmdW5jdGlvbihpZCwgY2h1bmtJZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmtJZHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5fd2FpdGluZy5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25NYW5hZ2VyLmF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVua0lkeCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5fd2FpdGluZy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLl9vcGVuLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVuQ2h1bmtzRW50cnkgPSBjb25uZWN0aW9uTWFuYWdlci5fb3BlbkNodW5rc1tpZF0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkNodW5rc0VudHJ5LnB1c2goY2h1bmtJZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLl9vcGVuQ2h1bmtzW2lkXSA9IG9wZW5DaHVua3NFbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIuX3dhaXRpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5fb3BlbiA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzaW1wbGUgPSB7XG4gICAgICAgICAgICBzZW5kOiBmdW5jdGlvbihpZCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkubG9hZGVkID0gMDtcbiAgICAgICAgICAgICAgICBsb2coXCJTZW5kaW5nIHNpbXBsZSB1cGxvYWQgcmVxdWVzdCBmb3IgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci51cGxvYWRGaWxlKGlkKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlLCBvcHRYaHIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwiU2ltcGxlIHVwbG9hZCByZXF1ZXN0IHN1Y2NlZWRlZCBmb3IgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZVRvUmVwb3J0ID0gdXBsb2FkLm5vcm1hbGl6ZVJlc3BvbnNlKHJlc3BvbnNlLCB0cnVlKSwgc2l6ZSA9IG9wdGlvbnMuZ2V0U2l6ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25Qcm9ncmVzcyhpZCwgbmFtZSwgc2l6ZSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZC5tYXliZU5ld1V1aWQoaWQsIHJlc3BvbnNlVG9SZXBvcnQpO1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWQuY2xlYW51cChpZCwgcmVzcG9uc2VUb1JlcG9ydCwgb3B0WGhyKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihyZXNwb25zZSwgb3B0WGhyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIlNpbXBsZSB1cGxvYWQgcmVxdWVzdCBmYWlsZWQgZm9yIFwiICsgaWQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VUb1JlcG9ydCA9IHVwbG9hZC5ub3JtYWxpemVSZXNwb25zZShyZXNwb25zZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMub25BdXRvUmV0cnkoaWQsIG5hbWUsIHJlc3BvbnNlVG9SZXBvcnQsIG9wdFhocikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZC5jbGVhbnVwKGlkLCByZXNwb25zZVRvUmVwb3J0LCBvcHRYaHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHVwbG9hZCA9IHtcbiAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBsb2coXCJDYW5jZWxsaW5nIFwiICsgaWQpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyYW1zU3RvcmUucmVtb3ZlKGlkKTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5mcmVlKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhbnVwOiBmdW5jdGlvbihpZCwgcmVzcG9uc2UsIG9wdFhocikge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gb3B0aW9ucy5nZXROYW1lKGlkKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uQ29tcGxldGUoaWQsIG5hbWUsIHJlc3BvbnNlLCBvcHRYaHIpO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuX2NsZWFyWGhycyAmJiBoYW5kbGVyLl9jbGVhclhocnMoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5mcmVlKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRQcm94eU9yQmxvYjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5nZXRQcm94eSAmJiBoYW5kbGVyLmdldFByb3h5KGlkKSB8fCBoYW5kbGVyLmdldEZpbGUgJiYgaGFuZGxlci5nZXRGaWxlKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbml0SGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXJUeXBlID0gbmFtZXNwYWNlID8gcXFbbmFtZXNwYWNlXSA6IHFxLnRyYWRpdGlvbmFsLCBoYW5kbGVyTW9kdWxlU3VidHlwZSA9IHFxLnN1cHBvcnRlZEZlYXR1cmVzLmFqYXhVcGxvYWRpbmcgPyBcIlhoclwiIDogXCJGb3JtXCI7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IG5ldyBoYW5kbGVyVHlwZVtoYW5kbGVyTW9kdWxlU3VidHlwZSArIFwiVXBsb2FkSGFuZGxlclwiXShvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldERhdGFCeVV1aWQ6IG9wdGlvbnMuZ2V0RGF0YUJ5VXVpZCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0TmFtZTogb3B0aW9ucy5nZXROYW1lLFxuICAgICAgICAgICAgICAgICAgICBnZXRTaXplOiBvcHRpb25zLmdldFNpemUsXG4gICAgICAgICAgICAgICAgICAgIGdldFV1aWQ6IG9wdGlvbnMuZ2V0VXVpZCxcbiAgICAgICAgICAgICAgICAgICAgbG9nOiBsb2csXG4gICAgICAgICAgICAgICAgICAgIG9uQ2FuY2VsOiBvcHRpb25zLm9uQ2FuY2VsLFxuICAgICAgICAgICAgICAgICAgICBvblByb2dyZXNzOiBvcHRpb25zLm9uUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIG9uVXVpZENoYW5nZWQ6IG9wdGlvbnMub25VdWlkQ2hhbmdlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLl9yZW1vdmVFeHBpcmVkQ2h1bmtpbmdSZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuX3JlbW92ZUV4cGlyZWRDaHVua2luZ1JlY29yZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNEZWZlcnJlZEVsaWdpYmxlRm9yVXBsb2FkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmlzUXVldWVkKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXliZURlZmVyOiBmdW5jdGlvbihpZCwgYmxvYikge1xuICAgICAgICAgICAgICAgIGlmIChibG9iICYmICFoYW5kbGVyLmdldEZpbGUoaWQpICYmIGJsb2IgaW5zdGFuY2VvZiBxcS5CbG9iUHJveHkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vblVwbG9hZFByZXAoaWQpO1xuICAgICAgICAgICAgICAgICAgICBsb2coXCJBdHRlbXB0aW5nIHRvIGdlbmVyYXRlIGEgYmxvYiBvbi1kZW1hbmQgZm9yIFwiICsgaWQpO1xuICAgICAgICAgICAgICAgICAgICBibG9iLmNyZWF0ZSgpLnRoZW4oZnVuY3Rpb24oZ2VuZXJhdGVkQmxvYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKFwiR2VuZXJhdGVkIGFuIG9uLWRlbWFuZCBibG9iIGZvciBcIiArIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIudXBkYXRlQmxvYihpZCwgZ2VuZXJhdGVkQmxvYik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNldFNpemUoaWQsIGdlbmVyYXRlZEJsb2Iuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLnJlZXZhbHVhdGVDaHVua2luZyhpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWQubWF5YmVTZW5kRGVmZXJyZWRGaWxlcyhpZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yUmVzcG9uc2UgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclJlc3BvbnNlLmVycm9yID0gZXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKHFxLmZvcm1hdChcIkZhaWxlZCB0byBnZW5lcmF0ZSBibG9iIGZvciBJRCB7fS4gIEVycm9yIG1lc3NhZ2U6IHt9LlwiLCBpZCwgZXJyb3JNZXNzYWdlKSwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25Db21wbGV0ZShpZCwgb3B0aW9ucy5nZXROYW1lKGlkKSwgcXEuZXh0ZW5kKGVycm9yUmVzcG9uc2UsIHByZXZlbnRSZXRyeVJlc3BvbnNlKSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWQubWF5YmVTZW5kRGVmZXJyZWRGaWxlcyhpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5mcmVlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwbG9hZC5tYXliZVNlbmREZWZlcnJlZEZpbGVzKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heWJlU2VuZERlZmVycmVkRmlsZXM6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkc0luR3JvdXAgPSBvcHRpb25zLmdldElkc0luUHJveHlHcm91cChpZCksIHVwbG9hZGVkVGhpc0lkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGlkc0luR3JvdXAgJiYgaWRzSW5Hcm91cC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwiTWF5YmUgcmVhZHkgdG8gdXBsb2FkIHByb3h5IGdyb3VwIGZpbGUgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgICAgIHFxLmVhY2goaWRzSW5Hcm91cCwgZnVuY3Rpb24oaWR4LCBpZEluR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cGxvYWQuaXNEZWZlcnJlZEVsaWdpYmxlRm9yVXBsb2FkKGlkSW5Hcm91cCkgJiYgISFoYW5kbGVyLmdldEZpbGUoaWRJbkdyb3VwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZGVkVGhpc0lkID0gaWRJbkdyb3VwID09PSBpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWQubm93KGlkSW5Hcm91cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHVwbG9hZC5pc0RlZmVycmVkRWxpZ2libGVGb3JVcGxvYWQoaWRJbkdyb3VwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkZWRUaGlzSWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWQubm93KGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwbG9hZGVkVGhpc0lkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heWJlTmV3VXVpZDogZnVuY3Rpb24oaWQsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm5ld1V1aWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uVXVpZENoYW5nZWQoaWQsIHJlc3BvbnNlLm5ld1V1aWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub3JtYWxpemVSZXNwb25zZTogZnVuY3Rpb24ob3JpZ2luYWxSZXNwb25zZSwgc3VjY2Vzc2Z1bCkge1xuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IG9yaWdpbmFsUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFxcS5pc09iamVjdChvcmlnaW5hbFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAocXEuaXNTdHJpbmcob3JpZ2luYWxSZXNwb25zZSkgJiYgIXN1Y2Nlc3NmdWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmVycm9yID0gb3JpZ2luYWxSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNwb25zZS5zdWNjZXNzID0gc3VjY2Vzc2Z1bDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm93OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gb3B0aW9ucy5nZXROYW1lKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRyb2xsZXIuaXNWYWxpZChpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHFxLkVycm9yKGlkICsgXCIgaXMgbm90IGEgdmFsaWQgZmlsZSBJRCB0byB1cGxvYWQhXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uVXBsb2FkKGlkLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmtpbmdQb3NzaWJsZSAmJiBoYW5kbGVyLl9zaG91bGRDaHVua1RoaXNGaWxlKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICBjaHVua2VkLnNlbmROZXh0KGlkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaW1wbGUuc2VuZChpZCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciBibG9iVG9VcGxvYWQgPSB1cGxvYWQuZ2V0UHJveHlPckJsb2IoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChibG9iVG9VcGxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwbG9hZC5tYXliZURlZmVyKGlkLCBibG9iVG9VcGxvYWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZC5ub3coaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKGlkLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5hZGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGxvYWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25NYW5hZ2VyLm9wZW4oaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1cGxvYWQuc3RhcnQoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmV0cnk6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmN1cnJlbnRDaHVua2luZ1Bvc3NpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkudGVtcC5pZ25vcmVGYWlsdXJlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uTWFuYWdlci5pc1VzaW5nQ29ubmVjdGlvbihpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwbG9hZC5zdGFydChpZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIudXBsb2FkKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciBjYW5jZWxSZXRWYWwgPSBoYW5kbGVyLmNhbmNlbChpZCk7XG4gICAgICAgICAgICAgICAgaWYgKHFxLmlzR2VuZXJpY1Byb21pc2UoY2FuY2VsUmV0VmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxSZXRWYWwudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZC5jYW5jZWwoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNhbmNlbFJldFZhbCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkLmNhbmNlbChpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbmNlbEFsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdhaXRpbmdPckNvbm5lY3RlZCA9IGNvbm5lY3Rpb25NYW5hZ2VyLmdldFdhaXRpbmdPckNvbm5lY3RlZCgpLCBpO1xuICAgICAgICAgICAgICAgIGlmICh3YWl0aW5nT3JDb25uZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IHdhaXRpbmdPckNvbm5lY3RlZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jYW5jZWwod2FpdGluZ09yQ29ubmVjdGVkW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5yZXNldCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEZpbGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuZ2V0UHJveHkgJiYgaGFuZGxlci5nZXRQcm94eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuZ2V0UHJveHkoaWQpLnJlZmVyZW5jZUJsb2I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmdldEZpbGUgJiYgaGFuZGxlci5nZXRGaWxlKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1Byb3hpZWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKGhhbmRsZXIuZ2V0UHJveHkgJiYgaGFuZGxlci5nZXRQcm94eShpZCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldElucHV0OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmdldElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmdldElucHV0KGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGxvZyhcIlJlc2V0dGluZyB1cGxvYWQgaGFuZGxlclwiKTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNhbmNlbEFsbCgpO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5yZXNldCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4cHVuZ2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuaXNWYWxpZChpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuZXhwdW5nZShpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuaXNWYWxpZChpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UmVzdW1hYmxlRmlsZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5nZXRSZXN1bWFibGVGaWxlc0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuZ2V0UmVzdW1hYmxlRmlsZXNEYXRhKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRUaGlyZFBhcnR5RmlsZUlkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLmlzVmFsaWQoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmdldFRoaXJkUGFydHlGaWxlSWQoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXVzZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5pc1Jlc3VtYWJsZShpZCkgJiYgaGFuZGxlci5wYXVzZSAmJiBjb250cm9sbGVyLmlzVmFsaWQoaWQpICYmIGhhbmRsZXIucGF1c2UoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLmZyZWUoaWQpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLm1vdmVJblByb2dyZXNzVG9SZW1haW5pbmcoaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzUmVzdW1hYmxlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWhhbmRsZXIuaXNSZXN1bWFibGUgJiYgaGFuZGxlci5pc1Jlc3VtYWJsZShpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBxcS5leHRlbmQob3B0aW9ucywgbyk7XG4gICAgICAgIGxvZyA9IG9wdGlvbnMubG9nO1xuICAgICAgICBjaHVua2luZ1Bvc3NpYmxlID0gb3B0aW9ucy5jaHVua2luZy5lbmFibGVkICYmIHFxLnN1cHBvcnRlZEZlYXR1cmVzLmNodW5raW5nO1xuICAgICAgICBjb25jdXJyZW50Q2h1bmtpbmdQb3NzaWJsZSA9IGNodW5raW5nUG9zc2libGUgJiYgb3B0aW9ucy5jaHVua2luZy5jb25jdXJyZW50LmVuYWJsZWQ7XG4gICAgICAgIHByZXZlbnRSZXRyeVJlc3BvbnNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB7fTtcbiAgICAgICAgICAgIHJlc3BvbnNlW29wdGlvbnMucHJldmVudFJldHJ5UGFyYW1dID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSgpO1xuICAgICAgICB1cGxvYWQuaW5pdEhhbmRsZXIoKTtcbiAgICB9O1xuICAgIHFxLldpbmRvd1JlY2VpdmVNZXNzYWdlID0gZnVuY3Rpb24obykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKG1lc3NhZ2UsIGxldmVsKSB7fVxuICAgICAgICB9LCBjYWxsYmFja1dyYXBwZXJEZXRhY2hlcnMgPSB7fTtcbiAgICAgICAgcXEuZXh0ZW5kKG9wdGlvbnMsIG8pO1xuICAgICAgICBxcS5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgcmVjZWl2ZU1lc3NhZ2U6IGZ1bmN0aW9uKGlkLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBvbk1lc3NhZ2VDYWxsYmFja1dyYXBwZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhldmVudC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cucG9zdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tXcmFwcGVyRGV0YWNoZXJzW2lkXSA9IHFxKHdpbmRvdykuYXR0YWNoKFwibWVzc2FnZVwiLCBvbk1lc3NhZ2VDYWxsYmFja1dyYXBwZXIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcImlmcmFtZSBtZXNzYWdlIHBhc3Npbmcgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIhXCIsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0b3BSZWNlaXZpbmdNZXNzYWdlczogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LnBvc3RNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXRhY2hlciA9IGNhbGxiYWNrV3JhcHBlckRldGFjaGVyc1tpZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXRhY2hlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWNoZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBxcS5Gb3JtVXBsb2FkSGFuZGxlciA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBvcHRpb25zID0gc3BlYy5vcHRpb25zLCBoYW5kbGVyID0gdGhpcywgcHJveHkgPSBzcGVjLnByb3h5LCBmb3JtSGFuZGxlckluc3RhbmNlSWQgPSBxcS5nZXRVbmlxdWVJZCgpLCBvbmxvYWRDYWxsYmFja3MgPSB7fSwgZGV0YWNoTG9hZEV2ZW50cyA9IHt9LCBwb3N0TWVzc2FnZUNhbGxiYWNrVGltZXJzID0ge30sIGlzQ29ycyA9IG9wdGlvbnMuaXNDb3JzLCBpbnB1dE5hbWUgPSBvcHRpb25zLmlucHV0TmFtZSwgZ2V0VXVpZCA9IHByb3h5LmdldFV1aWQsIGxvZyA9IHByb3h5LmxvZywgY29yc01lc3NhZ2VSZWNlaXZlciA9IG5ldyBxcS5XaW5kb3dSZWNlaXZlTWVzc2FnZSh7XG4gICAgICAgICAgICBsb2c6IGxvZ1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gZXhwdW5nZUZpbGUoaWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkZXRhY2hMb2FkRXZlbnRzW2lkXTtcbiAgICAgICAgICAgIGlmIChpc0NvcnMpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocG9zdE1lc3NhZ2VDYWxsYmFja1RpbWVyc1tpZF0pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwb3N0TWVzc2FnZUNhbGxiYWNrVGltZXJzW2lkXTtcbiAgICAgICAgICAgICAgICBjb3JzTWVzc2FnZVJlY2VpdmVyLnN0b3BSZWNlaXZpbmdNZXNzYWdlcyhpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFuZGxlci5fZ2V0SWZyYW1lTmFtZShpZCkpO1xuICAgICAgICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICAgICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgXCJqYXZhc2NyaXB0OmZhbHNlO1wiKTtcbiAgICAgICAgICAgICAgICBxcShpZnJhbWUpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEZpbGVJZEZvcklmcmFtZU5hbWUoaWZyYW1lTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlmcmFtZU5hbWUuc3BsaXQoXCJfXCIpWzBdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGluaXRJZnJhbWVGb3JVcGxvYWQobmFtZSkge1xuICAgICAgICAgICAgdmFyIGlmcmFtZSA9IHFxLnRvRWxlbWVudChcIjxpZnJhbWUgc3JjPSdqYXZhc2NyaXB0OmZhbHNlOycgbmFtZT0nXCIgKyBuYW1lICsgXCInIC8+XCIpO1xuICAgICAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZShcImlkXCIsIG5hbWUpO1xuICAgICAgICAgICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBpZnJhbWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJQb3N0TWVzc2FnZUNhbGxiYWNrKGlmcmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpZnJhbWVOYW1lID0gaWZyYW1lLmlkLCBmaWxlSWQgPSBnZXRGaWxlSWRGb3JJZnJhbWVOYW1lKGlmcmFtZU5hbWUpLCB1dWlkID0gZ2V0VXVpZChmaWxlSWQpO1xuICAgICAgICAgICAgb25sb2FkQ2FsbGJhY2tzW3V1aWRdID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBkZXRhY2hMb2FkRXZlbnRzW2ZpbGVJZF0gPSBxcShpZnJhbWUpLmF0dGFjaChcImxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuZ2V0SW5wdXQoZmlsZUlkKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2coXCJSZWNlaXZlZCBpZnJhbWUgbG9hZCBldmVudCBmb3IgQ09SUyB1cGxvYWQgcmVxdWVzdCAoaWZyYW1lIG5hbWUgXCIgKyBpZnJhbWVOYW1lICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUNhbGxiYWNrVGltZXJzW2lmcmFtZU5hbWVdID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBcIk5vIHZhbGlkIG1lc3NhZ2UgcmVjZWl2ZWQgZnJvbSBsb2FkZWQgaWZyYW1lIGZvciBpZnJhbWUgbmFtZSBcIiArIGlmcmFtZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2coZXJyb3JNZXNzYWdlLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCAxZTMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29yc01lc3NhZ2VSZWNlaXZlci5yZWNlaXZlTWVzc2FnZShpZnJhbWVOYW1lLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgbG9nKFwiUmVjZWl2ZWQgdGhlIGZvbGxvd2luZyB3aW5kb3cgbWVzc2FnZTogJ1wiICsgbWVzc2FnZSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZUlkID0gZ2V0RmlsZUlkRm9ySWZyYW1lTmFtZShpZnJhbWVOYW1lKSwgcmVzcG9uc2UgPSBoYW5kbGVyLl9wYXJzZUpzb25SZXNwb25zZShtZXNzYWdlKSwgdXVpZCA9IHJlc3BvbnNlLnV1aWQsIG9ubG9hZENhbGxiYWNrO1xuICAgICAgICAgICAgICAgIGlmICh1dWlkICYmIG9ubG9hZENhbGxiYWNrc1t1dWlkXSkge1xuICAgICAgICAgICAgICAgICAgICBsb2coXCJIYW5kbGluZyByZXNwb25zZSBmb3IgaWZyYW1lIG5hbWUgXCIgKyBpZnJhbWVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHBvc3RNZXNzYWdlQ2FsbGJhY2tUaW1lcnNbaWZyYW1lTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcG9zdE1lc3NhZ2VDYWxsYmFja1RpbWVyc1tpZnJhbWVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fZGV0YWNoTG9hZEV2ZW50KGlmcmFtZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBvbmxvYWRDYWxsYmFjayA9IG9ubG9hZENhbGxiYWNrc1t1dWlkXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ubG9hZENhbGxiYWNrc1t1dWlkXTtcbiAgICAgICAgICAgICAgICAgICAgY29yc01lc3NhZ2VSZWNlaXZlci5zdG9wUmVjZWl2aW5nTWVzc2FnZXMoaWZyYW1lTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIG9ubG9hZENhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF1dWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIidcIiArIG1lc3NhZ2UgKyBcIicgZG9lcyBub3QgY29udGFpbiBhIFVVSUQgLSBpZ25vcmluZy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIG5ldyBxcS5VcGxvYWRIYW5kbGVyKHNwZWMpKTtcbiAgICAgICAgcXEub3ZlcnJpZGUodGhpcywgZnVuY3Rpb24oc3VwZXJfKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFkZDogZnVuY3Rpb24oaWQsIGZpbGVJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlcl8uYWRkKGlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogZmlsZUlucHV0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmaWxlSW5wdXQuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBpbnB1dE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZUlucHV0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFxKGZpbGVJbnB1dCkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV4cHVuZ2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cHVuZ2VGaWxlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJfLmV4cHVuZ2UoaWQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNWYWxpZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyXy5pc1ZhbGlkKGlkKSAmJiBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmlucHV0ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBnZXRJbnB1dDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5pbnB1dDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYXR0YWNoTG9hZEV2ZW50OiBmdW5jdGlvbihpZnJhbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlRGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICBpZiAoaXNDb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyUG9zdE1lc3NhZ2VDYWxsYmFjayhpZnJhbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZXRhY2hMb2FkRXZlbnRzW2lmcmFtZS5pZF0gPSBxcShpZnJhbWUpLmF0dGFjaChcImxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2coXCJSZWNlaXZlZCByZXNwb25zZSBmb3IgXCIgKyBpZnJhbWUuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpZnJhbWUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlmcmFtZS5jb250ZW50RG9jdW1lbnQgJiYgaWZyYW1lLmNvbnRlbnREb2N1bWVudC5ib2R5ICYmIGlmcmFtZS5jb250ZW50RG9jdW1lbnQuYm9keS5pbm5lckhUTUwgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhcIkVycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBhY2Nlc3MgaWZyYW1lIGR1cmluZyBoYW5kbGluZyBvZiB1cGxvYWQgcmVzcG9uc2UgKFwiICsgZXJyb3IubWVzc2FnZSArIFwiKVwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlRGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2VEZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jcmVhdGVJZnJhbWU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlmcmFtZU5hbWUgPSBoYW5kbGVyLl9nZXRJZnJhbWVOYW1lKGlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5pdElmcmFtZUZvclVwbG9hZChpZnJhbWVOYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZGV0YWNoTG9hZEV2ZW50OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGlmIChkZXRhY2hMb2FkRXZlbnRzW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFjaExvYWRFdmVudHNbaWRdKCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkZXRhY2hMb2FkRXZlbnRzW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldElmcmFtZU5hbWU6IGZ1bmN0aW9uKGZpbGVJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlSWQgKyBcIl9cIiArIGZvcm1IYW5kbGVySW5zdGFuY2VJZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaW5pdEZvcm1Gb3JVcGxvYWQ6IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gc3BlYy5tZXRob2QsIGVuZHBvaW50ID0gc3BlYy5lbmRwb2ludCwgcGFyYW1zID0gc3BlYy5wYXJhbXMsIHBhcmFtc0luQm9keSA9IHNwZWMucGFyYW1zSW5Cb2R5LCB0YXJnZXROYW1lID0gc3BlYy50YXJnZXROYW1lLCBmb3JtID0gcXEudG9FbGVtZW50KFwiPGZvcm0gbWV0aG9kPSdcIiArIG1ldGhvZCArIFwiJyBlbmN0eXBlPSdtdWx0aXBhcnQvZm9ybS1kYXRhJz48L2Zvcm0+XCIpLCB1cmwgPSBlbmRwb2ludDtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zSW5Cb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIHFxLm9iajJJbnB1dHMocGFyYW1zLCBmb3JtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSBxcS5vYmoydXJsKHBhcmFtcywgZW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3JtLnNldEF0dHJpYnV0ZShcImFjdGlvblwiLCB1cmwpO1xuICAgICAgICAgICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKFwidGFyZ2V0XCIsIHRhcmdldE5hbWUpO1xuICAgICAgICAgICAgICAgIGZvcm0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3BhcnNlSnNvblJlc3BvbnNlOiBmdW5jdGlvbihpbm5lckh0bWxPck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB7fTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHFxLnBhcnNlSnNvbihpbm5lckh0bWxPck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIkVycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBwYXJzZSBpZnJhbWUgdXBsb2FkIHJlc3BvbnNlIChcIiArIGVycm9yLm1lc3NhZ2UgKyBcIilcIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHFxLlhoclVwbG9hZEhhbmRsZXIgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMsIG5hbWVzcGFjZSA9IHNwZWMub3B0aW9ucy5uYW1lc3BhY2UsIHByb3h5ID0gc3BlYy5wcm94eSwgY2h1bmtpbmcgPSBzcGVjLm9wdGlvbnMuY2h1bmtpbmcsIHJlc3VtZSA9IHNwZWMub3B0aW9ucy5yZXN1bWUsIGNodW5rRmlsZXMgPSBjaHVua2luZyAmJiBzcGVjLm9wdGlvbnMuY2h1bmtpbmcuZW5hYmxlZCAmJiBxcS5zdXBwb3J0ZWRGZWF0dXJlcy5jaHVua2luZywgcmVzdW1lRW5hYmxlZCA9IHJlc3VtZSAmJiBzcGVjLm9wdGlvbnMucmVzdW1lLmVuYWJsZWQgJiYgY2h1bmtGaWxlcyAmJiBxcS5zdXBwb3J0ZWRGZWF0dXJlcy5yZXN1bWUsIGdldE5hbWUgPSBwcm94eS5nZXROYW1lLCBnZXRTaXplID0gcHJveHkuZ2V0U2l6ZSwgZ2V0VXVpZCA9IHByb3h5LmdldFV1aWQsIGdldEVuZHBvaW50ID0gcHJveHkuZ2V0RW5kcG9pbnQsIGdldERhdGFCeVV1aWQgPSBwcm94eS5nZXREYXRhQnlVdWlkLCBvblV1aWRDaGFuZ2VkID0gcHJveHkub25VdWlkQ2hhbmdlZCwgb25Qcm9ncmVzcyA9IHByb3h5Lm9uUHJvZ3Jlc3MsIGxvZyA9IHByb3h5LmxvZztcbiAgICAgICAgZnVuY3Rpb24gYWJvcnQoaWQpIHtcbiAgICAgICAgICAgIHFxLmVhY2goaGFuZGxlci5fZ2V0WGhycyhpZCksIGZ1bmN0aW9uKHhocklkLCB4aHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWpheFJlcXVlc3RlciA9IGhhbmRsZXIuX2dldEFqYXhSZXF1ZXN0ZXIoaWQsIHhocklkKTtcbiAgICAgICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIGFqYXhSZXF1ZXN0ZXIgJiYgYWpheFJlcXVlc3Rlci5jYW5jZWxlZCAmJiBhamF4UmVxdWVzdGVyLmNhbmNlbGVkKGlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCBuZXcgcXEuVXBsb2FkSGFuZGxlcihzcGVjKSk7XG4gICAgICAgIHFxLm92ZXJyaWRlKHRoaXMsIGZ1bmN0aW9uKHN1cGVyXykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKGlkLCBibG9iT3JQcm94eSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXEuaXNGaWxlKGJsb2JPclByb3h5KSB8fCBxcS5pc0Jsb2IoYmxvYk9yUHJveHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdXBlcl8uYWRkKGlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogYmxvYk9yUHJveHlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJsb2JPclByb3h5IGluc3RhbmNlb2YgcXEuQmxvYlByb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdXBlcl8uYWRkKGlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJveHk6IGJsb2JPclByb3h5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhc3NlZCBvYmogaXMgbm90IGEgRmlsZSwgQmxvYiwgb3IgcHJveHlcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5faW5pdFRlbXBTdGF0ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VtZUVuYWJsZWQgJiYgaGFuZGxlci5fbWF5YmVQcmVwYXJlRm9yUmVzdW1lKGlkKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV4cHVuZ2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFib3J0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fbWF5YmVEZWxldGVQZXJzaXN0ZWRDaHVua0RhdGEoaWQpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9jbGVhclhocnMoaWQpO1xuICAgICAgICAgICAgICAgICAgICBzdXBlcl8uZXhwdW5nZShpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBjbGVhckNhY2hlZENodW5rOiBmdW5jdGlvbihpZCwgY2h1bmtJZHgpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS50ZW1wLmNhY2hlZENodW5rc1tjaHVua0lkeF07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYXJYaHI6IGZ1bmN0aW9uKGlkLCBjaHVua0lkeCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wU3RhdGUgPSBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLnRlbXA7XG4gICAgICAgICAgICAgICAgaWYgKHRlbXBTdGF0ZS54aHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0ZW1wU3RhdGUueGhyc1tjaHVua0lkeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZW1wU3RhdGUuYWpheFJlcXVlc3RlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRlbXBTdGF0ZS5hamF4UmVxdWVzdGVyc1tjaHVua0lkeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbmFsaXplQ2h1bmtzOiBmdW5jdGlvbihpZCwgcmVzcG9uc2VQYXJzZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdENodW5rSWR4ID0gaGFuZGxlci5fZ2V0VG90YWxDaHVua3MoaWQpIC0gMSwgeGhyID0gaGFuZGxlci5fZ2V0WGhyKGlkLCBsYXN0Q2h1bmtJZHgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVBhcnNlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHFxLlByb21pc2UoKS5zdWNjZXNzKHJlc3BvbnNlUGFyc2VyKHhociksIHhocik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcXEuUHJvbWlzZSgpLnN1Y2Nlc3Moe30sIHhocik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RmlsZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5pc1ZhbGlkKGlkKSAmJiBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmZpbGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UHJveHk6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuaXNWYWxpZChpZCkgJiYgaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5wcm94eTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRSZXN1bWFibGVGaWxlc0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bWFibGVGaWxlc0RhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLl9pdGVyYXRlUmVzdW1lUmVjb3JkcyhmdW5jdGlvbihrZXksIHVwbG9hZERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5tb3ZlSW5Qcm9ncmVzc1RvUmVtYWluaW5nKG51bGwsIHVwbG9hZERhdGEuY2h1bmtpbmcuaW5Qcm9ncmVzcywgdXBsb2FkRGF0YS5jaHVua2luZy5yZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHVwbG9hZERhdGEubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZzogdXBsb2FkRGF0YS5jaHVua2luZy5yZW1haW5pbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiB1cGxvYWREYXRhLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1dWlkOiB1cGxvYWREYXRhLnV1aWRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwbG9hZERhdGEua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmtleSA9IHVwbG9hZERhdGEua2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZUZpbGVzRGF0YS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bWFibGVGaWxlc0RhdGE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNSZXN1bWFibGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhY2h1bmtpbmcgJiYgaGFuZGxlci5pc1ZhbGlkKGlkKSAmJiAhaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5ub3RSZXN1bWFibGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW92ZUluUHJvZ3Jlc3NUb1JlbWFpbmluZzogZnVuY3Rpb24oaWQsIG9wdEluUHJvZ3Jlc3MsIG9wdFJlbWFpbmluZykge1xuICAgICAgICAgICAgICAgIHZhciBpblByb2dyZXNzID0gb3B0SW5Qcm9ncmVzcyB8fCBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmNodW5raW5nLmluUHJvZ3Jlc3MsIHJlbWFpbmluZyA9IG9wdFJlbWFpbmluZyB8fCBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmNodW5raW5nLnJlbWFpbmluZztcbiAgICAgICAgICAgICAgICBpZiAoaW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBsb2cocXEuZm9ybWF0KFwiTW92aW5nIHRoZXNlIGNodW5rcyBmcm9tIGluLXByb2dyZXNzIHt9LCB0byByZW1haW5pbmcuXCIsIEpTT04uc3RyaW5naWZ5KGluUHJvZ3Jlc3MpKSk7XG4gICAgICAgICAgICAgICAgICAgIGluUHJvZ3Jlc3MucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICBxcS5lYWNoKGluUHJvZ3Jlc3MsIGZ1bmN0aW9uKGlkeCwgY2h1bmtJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZy51bnNoaWZ0KGNodW5rSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGluUHJvZ3Jlc3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF1c2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuaXNWYWxpZChpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKHFxLmZvcm1hdChcIkFib3J0aW5nIFhIUiB1cGxvYWQgZm9yIHt9ICd7fScgZHVlIHRvIHBhdXNlIGluc3RydWN0aW9uLlwiLCBpZCwgZ2V0TmFtZShpZCkpKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBhYm9ydChpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWV2YWx1YXRlQ2h1bmtpbmc6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNodW5raW5nICYmIGhhbmRsZXIuaXNWYWxpZChpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKSwgdG90YWxDaHVua3MsIGk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5jaHVua2luZztcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2h1bmtpbmcgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxDaHVua3MgPSBoYW5kbGVyLl9nZXRUb3RhbENodW5rcyhpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbENodW5rcyA+IDEgfHwgY2h1bmtpbmcubWFuZGF0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jaHVua2luZy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNodW5raW5nLnBhcnRzID0gdG90YWxDaHVua3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jaHVua2luZy5yZW1haW5pbmcgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2h1bmtpbmcucmVtYWluaW5nLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9pbml0VGVtcFN0YXRlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNodW5raW5nLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVCbG9iOiBmdW5jdGlvbihpZCwgbmV3QmxvYikge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmlzVmFsaWQoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkuZmlsZSA9IG5ld0Jsb2I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jbGVhclhocnM6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBTdGF0ZSA9IGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkudGVtcDtcbiAgICAgICAgICAgICAgICBxcS5lYWNoKHRlbXBTdGF0ZS5hamF4UmVxdWVzdGVycywgZnVuY3Rpb24oY2h1bmtJZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGVtcFN0YXRlLmFqYXhSZXF1ZXN0ZXJzW2NodW5rSWRdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHFxLmVhY2godGVtcFN0YXRlLnhocnMsIGZ1bmN0aW9uKGNodW5rSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRlbXBTdGF0ZS54aHJzW2NodW5rSWRdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jcmVhdGVYaHI6IGZ1bmN0aW9uKGlkLCBvcHRDaHVua0lkeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLl9yZWdpc3RlclhocihpZCwgb3B0Q2h1bmtJZHgsIHFxLmNyZWF0ZVhockluc3RhbmNlKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXRBamF4UmVxdWVzdGVyOiBmdW5jdGlvbihpZCwgb3B0Q2h1bmtJZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2h1bmtJZHggPSBvcHRDaHVua0lkeCA9PSBudWxsID8gLTEgOiBvcHRDaHVua0lkeDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS50ZW1wLmFqYXhSZXF1ZXN0ZXJzW2NodW5rSWR4XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZ2V0Q2h1bmtEYXRhOiBmdW5jdGlvbihpZCwgY2h1bmtJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBjaHVua1NpemUgPSBjaHVua2luZy5wYXJ0U2l6ZSwgZmlsZVNpemUgPSBnZXRTaXplKGlkKSwgZmlsZU9yQmxvYiA9IGhhbmRsZXIuZ2V0RmlsZShpZCksIHN0YXJ0Qnl0ZXMgPSBjaHVua1NpemUgKiBjaHVua0luZGV4LCBlbmRCeXRlcyA9IHN0YXJ0Qnl0ZXMgKyBjaHVua1NpemUgPj0gZmlsZVNpemUgPyBmaWxlU2l6ZSA6IHN0YXJ0Qnl0ZXMgKyBjaHVua1NpemUsIHRvdGFsQ2h1bmtzID0gaGFuZGxlci5fZ2V0VG90YWxDaHVua3MoaWQpLCBjYWNoZWRDaHVua3MgPSB0aGlzLl9nZXRGaWxlU3RhdGUoaWQpLnRlbXAuY2FjaGVkQ2h1bmtzLCBibG9iID0gY2FjaGVkQ2h1bmtzW2NodW5rSW5kZXhdIHx8IHFxLnNsaWNlQmxvYihmaWxlT3JCbG9iLCBzdGFydEJ5dGVzLCBlbmRCeXRlcyk7XG4gICAgICAgICAgICAgICAgY2FjaGVkQ2h1bmtzW2NodW5rSW5kZXhdID0gYmxvYjtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0OiBjaHVua0luZGV4LFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnRCeXRlcyxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmRCeXRlcyxcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IHRvdGFsQ2h1bmtzLFxuICAgICAgICAgICAgICAgICAgICBibG9iOiBibG9iLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBlbmRCeXRlcyAtIHN0YXJ0Qnl0ZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXRDaHVua0RhdGFGb3JDYWxsYmFjazogZnVuY3Rpb24oY2h1bmtEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydEluZGV4OiBjaHVua0RhdGEucGFydCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRCeXRlOiBjaHVua0RhdGEuc3RhcnQgKyAxLFxuICAgICAgICAgICAgICAgICAgICBlbmRCeXRlOiBjaHVua0RhdGEuZW5kLFxuICAgICAgICAgICAgICAgICAgICB0b3RhbFBhcnRzOiBjaHVua0RhdGEuY291bnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXRMb2NhbFN0b3JhZ2VJZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0VmVyc2lvbiA9IFwiNS4wXCIsIG5hbWUgPSBnZXROYW1lKGlkKSwgc2l6ZSA9IGdldFNpemUoaWQpLCBjaHVua1NpemUgPSBjaHVua2luZy5wYXJ0U2l6ZSwgZW5kcG9pbnQgPSBnZXRFbmRwb2ludChpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHFxLmZvcm1hdChcInFxe31yZXN1bWV7fS17fS17fS17fS17fVwiLCBuYW1lc3BhY2UsIGZvcm1hdFZlcnNpb24sIG5hbWUsIHNpemUsIGNodW5rU2l6ZSwgZW5kcG9pbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXRNaW1lVHlwZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5nZXRGaWxlKGlkKS50eXBlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXRQZXJzaXN0YWJsZURhdGE6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkuY2h1bmtpbmc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldFRvdGFsQ2h1bmtzOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGlmIChjaHVua2luZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZVNpemUgPSBnZXRTaXplKGlkKSwgY2h1bmtTaXplID0gY2h1bmtpbmcucGFydFNpemU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwoZmlsZVNpemUgLyBjaHVua1NpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZ2V0WGhyOiBmdW5jdGlvbihpZCwgb3B0Q2h1bmtJZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2h1bmtJZHggPSBvcHRDaHVua0lkeCA9PSBudWxsID8gLTEgOiBvcHRDaHVua0lkeDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS50ZW1wLnhocnNbY2h1bmtJZHhdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXRYaHJzOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLnRlbXAueGhycztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaXRlcmF0ZVJlc3VtZVJlY29yZHM6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VtZUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChsb2NhbFN0b3JhZ2UsIGZ1bmN0aW9uKGtleSwgaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKHFxLmZvcm1hdChcInFxe31yZXN1bWVcIiwgbmFtZXNwYWNlKSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXBsb2FkRGF0YSA9IEpTT04ucGFyc2UoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soa2V5LCB1cGxvYWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pbml0VGVtcFN0YXRlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkudGVtcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgYWpheFJlcXVlc3RlcnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBjaHVua1Byb2dyZXNzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgeGhyczoge30sXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZENodW5rczoge31cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9tYXJrTm90UmVzdW1hYmxlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkubm90UmVzdW1hYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWF5YmVEZWxldGVQZXJzaXN0ZWRDaHVua0RhdGE6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsU3RvcmFnZUlkO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bWVFbmFibGVkICYmIGhhbmRsZXIuaXNSZXN1bWFibGUoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZUlkID0gaGFuZGxlci5fZ2V0TG9jYWxTdG9yYWdlSWQoaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlSWQgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0obG9jYWxTdG9yYWdlSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShsb2NhbFN0b3JhZ2VJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX21heWJlUHJlcGFyZUZvclJlc3VtZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLCBsb2NhbFN0b3JhZ2VJZCwgcGVyc2lzdGVkRGF0YTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1lRW5hYmxlZCAmJiBzdGF0ZS5rZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2VJZCA9IGhhbmRsZXIuX2dldExvY2FsU3RvcmFnZUlkKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdGVkRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGxvY2FsU3RvcmFnZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlcnNpc3RlZERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNpc3RlZERhdGEgPSBKU09OLnBhcnNlKHBlcnNpc3RlZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdldERhdGFCeVV1aWQocGVyc2lzdGVkRGF0YS51dWlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuX21hcmtOb3RSZXN1bWFibGUoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cocXEuZm9ybWF0KFwiSWRlbnRpZmllZCBmaWxlIHdpdGggSUQge30gYW5kIG5hbWUgb2Yge30gYXMgcmVzdW1hYmxlLlwiLCBpZCwgZ2V0TmFtZShpZCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblV1aWRDaGFuZ2VkKGlkLCBwZXJzaXN0ZWREYXRhLnV1aWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmtleSA9IHBlcnNpc3RlZERhdGEua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNodW5raW5nID0gcGVyc2lzdGVkRGF0YS5jaHVua2luZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sb2FkZWQgPSBwZXJzaXN0ZWREYXRhLmxvYWRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hdHRlbXB0aW5nUmVzdW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLm1vdmVJblByb2dyZXNzVG9SZW1haW5pbmcoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9tYXliZVBlcnNpc3RDaHVua2VkU3RhdGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKSwgbG9jYWxTdG9yYWdlSWQsIHBlcnNpc3RlZERhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VtZUVuYWJsZWQgJiYgaGFuZGxlci5pc1Jlc3VtYWJsZShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlSWQgPSBoYW5kbGVyLl9nZXRMb2NhbFN0b3JhZ2VJZChpZCk7XG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RlZERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBnZXROYW1lKGlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGdldFNpemUoaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXVpZDogZ2V0VXVpZChpZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHN0YXRlLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5raW5nOiBzdGF0ZS5jaHVua2luZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlZDogc3RhdGUubG9hZGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFVwZGF0ZWQ6IERhdGUubm93KClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGxvY2FsU3RvcmFnZUlkLCBKU09OLnN0cmluZ2lmeShwZXJzaXN0ZWREYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cocXEuZm9ybWF0KFwiVW5hYmxlIHRvIHNhdmUgcmVzdW1lIGRhdGEgZm9yICd7fScgZHVlIHRvIGVycm9yOiAne30nLlwiLCBpZCwgZXJyb3IudG9TdHJpbmcoKSksIFwid2FyblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVnaXN0ZXJQcm9ncmVzc0hhbmRsZXI6IGZ1bmN0aW9uKGlkLCBjaHVua0lkeCwgY2h1bmtTaXplKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhociA9IGhhbmRsZXIuX2dldFhocihpZCwgY2h1bmtJZHgpLCBuYW1lID0gZ2V0TmFtZShpZCksIHByb2dyZXNzQ2FsY3VsYXRvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2ltcGxlOiBmdW5jdGlvbihsb2FkZWQsIHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZVNpemUgPSBnZXRTaXplKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2FkZWQgPT09IHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Qcm9ncmVzcyhpZCwgbmFtZSwgZmlsZVNpemUsIGZpbGVTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Qcm9ncmVzcyhpZCwgbmFtZSwgbG9hZGVkID49IGZpbGVTaXplID8gZmlsZVNpemUgLSAxIDogbG9hZGVkLCBmaWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNodW5rZWQ6IGZ1bmN0aW9uKGxvYWRlZCwgdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaHVua1Byb2dyZXNzID0gaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS50ZW1wLmNodW5rUHJvZ3Jlc3MsIHRvdGFsU3VjY2Vzc2Z1bGx5TG9hZGVkRm9yRmlsZSA9IGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkubG9hZGVkLCBsb2FkZWRGb3JSZXF1ZXN0ID0gbG9hZGVkLCB0b3RhbEZvclJlcXVlc3QgPSB0b3RhbCwgdG90YWxGaWxlU2l6ZSA9IGdldFNpemUoaWQpLCBlc3RBY3R1YWxDaHVua0xvYWRlZCA9IGxvYWRlZEZvclJlcXVlc3QgLSAodG90YWxGb3JSZXF1ZXN0IC0gY2h1bmtTaXplKSwgdG90YWxMb2FkZWRGb3JGaWxlID0gdG90YWxTdWNjZXNzZnVsbHlMb2FkZWRGb3JGaWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtQcm9ncmVzc1tjaHVua0lkeF0gPSBlc3RBY3R1YWxDaHVua0xvYWRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFxLmVhY2goY2h1bmtQcm9ncmVzcywgZnVuY3Rpb24oY2h1bmtJZHgsIGNodW5rTG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxMb2FkZWRGb3JGaWxlICs9IGNodW5rTG9hZGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblByb2dyZXNzKGlkLCBuYW1lLCB0b3RhbExvYWRlZEZvckZpbGUsIHRvdGFsRmlsZVNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gY2h1bmtTaXplID09IG51bGwgPyBcInNpbXBsZVwiIDogXCJjaHVua2VkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0NhbGN1bGF0b3JbdHlwZV0oZS5sb2FkZWQsIGUudG90YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVnaXN0ZXJYaHI6IGZ1bmN0aW9uKGlkLCBvcHRDaHVua0lkeCwgeGhyLCBvcHRBamF4UmVxdWVzdGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhocnNJZCA9IG9wdENodW5rSWR4ID09IG51bGwgPyAtMSA6IG9wdENodW5rSWR4LCB0ZW1wU3RhdGUgPSBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLnRlbXA7XG4gICAgICAgICAgICAgICAgdGVtcFN0YXRlLnhocnMgPSB0ZW1wU3RhdGUueGhycyB8fCB7fTtcbiAgICAgICAgICAgICAgICB0ZW1wU3RhdGUuYWpheFJlcXVlc3RlcnMgPSB0ZW1wU3RhdGUuYWpheFJlcXVlc3RlcnMgfHwge307XG4gICAgICAgICAgICAgICAgdGVtcFN0YXRlLnhocnNbeGhyc0lkXSA9IHhocjtcbiAgICAgICAgICAgICAgICBpZiAob3B0QWpheFJlcXVlc3Rlcikge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3RhdGUuYWpheFJlcXVlc3RlcnNbeGhyc0lkXSA9IG9wdEFqYXhSZXF1ZXN0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB4aHI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JlbW92ZUV4cGlyZWRDaHVua2luZ1JlY29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBleHBpcmF0aW9uRGF5cyA9IHJlc3VtZS5yZWNvcmRzRXhwaXJlSW47XG4gICAgICAgICAgICAgICAgaGFuZGxlci5faXRlcmF0ZVJlc3VtZVJlY29yZHMoZnVuY3Rpb24oa2V5LCB1cGxvYWREYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHBpcmF0aW9uRGF0ZSA9IG5ldyBEYXRlKHVwbG9hZERhdGEubGFzdFVwZGF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICBleHBpcmF0aW9uRGF0ZS5zZXREYXRlKGV4cGlyYXRpb25EYXRlLmdldERhdGUoKSArIGV4cGlyYXRpb25EYXlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGlyYXRpb25EYXRlLmdldFRpbWUoKSA8PSBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2coXCJSZW1vdmluZyBleHBpcmVkIHJlc3VtZSByZWNvcmQgd2l0aCBrZXkgXCIgKyBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaG91bGRDaHVua1RoaXNGaWxlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5jaHVua2luZykge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLnJlZXZhbHVhdGVDaHVua2luZyhpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5jaHVua2luZy5lbmFibGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHFxLkRlbGV0ZUZpbGVBamF4UmVxdWVzdGVyID0gZnVuY3Rpb24obykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIHJlcXVlc3Rlciwgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIHV1aWRQYXJhbU5hbWU6IFwicXF1dWlkXCIsXG4gICAgICAgICAgICBlbmRwb2ludFN0b3JlOiB7fSxcbiAgICAgICAgICAgIG1heENvbm5lY3Rpb25zOiAzLFxuICAgICAgICAgICAgY3VzdG9tSGVhZGVyczogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyYW1zU3RvcmU6IHt9LFxuICAgICAgICAgICAgY29yczoge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZW5kQ3JlZGVudGlhbHM6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9nOiBmdW5jdGlvbihzdHIsIGxldmVsKSB7fSxcbiAgICAgICAgICAgIG9uRGVsZXRlOiBmdW5jdGlvbihpZCkge30sXG4gICAgICAgICAgICBvbkRlbGV0ZUNvbXBsZXRlOiBmdW5jdGlvbihpZCwgeGhyT3JYZHIsIGlzRXJyb3IpIHt9XG4gICAgICAgIH07XG4gICAgICAgIHFxLmV4dGVuZChvcHRpb25zLCBvKTtcbiAgICAgICAgZnVuY3Rpb24gZ2V0TWFuZGF0ZWRQYXJhbXMoKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKSA9PT0gXCJQT1NUXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBfbWV0aG9kOiBcIkRFTEVURVwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0ZXIgPSBxcS5leHRlbmQodGhpcywgbmV3IHFxLkFqYXhSZXF1ZXN0ZXIoe1xuICAgICAgICAgICAgYWNjZXB0SGVhZGVyOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIHZhbGlkTWV0aG9kczogWyBcIlBPU1RcIiwgXCJERUxFVEVcIiBdLFxuICAgICAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgIGVuZHBvaW50U3RvcmU6IG9wdGlvbnMuZW5kcG9pbnRTdG9yZSxcbiAgICAgICAgICAgIHBhcmFtc1N0b3JlOiBvcHRpb25zLnBhcmFtc1N0b3JlLFxuICAgICAgICAgICAgbWFuZGF0ZWRQYXJhbXM6IGdldE1hbmRhdGVkUGFyYW1zKCksXG4gICAgICAgICAgICBtYXhDb25uZWN0aW9uczogb3B0aW9ucy5tYXhDb25uZWN0aW9ucyxcbiAgICAgICAgICAgIGN1c3RvbUhlYWRlcnM6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY3VzdG9tSGVhZGVycy5nZXQoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvZzogb3B0aW9ucy5sb2csXG4gICAgICAgICAgICBvblNlbmQ6IG9wdGlvbnMub25EZWxldGUsXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBvcHRpb25zLm9uRGVsZXRlQ29tcGxldGUsXG4gICAgICAgICAgICBjb3JzOiBvcHRpb25zLmNvcnNcbiAgICAgICAgfSkpO1xuICAgICAgICBxcS5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgc2VuZERlbGV0ZTogZnVuY3Rpb24oaWQsIHV1aWQsIGFkZGl0aW9uYWxNYW5kYXRlZFBhcmFtcykge1xuICAgICAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsT3B0aW9ucyA9IGFkZGl0aW9uYWxNYW5kYXRlZFBhcmFtcyB8fCB7fTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvZyhcIlN1Ym1pdHRpbmcgZGVsZXRlIGZpbGUgcmVxdWVzdCBmb3IgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWV0aG9kID09PSBcIkRFTEVURVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Rlci5pbml0VHJhbnNwb3J0KGlkKS53aXRoUGF0aCh1dWlkKS53aXRoUGFyYW1zKGFkZGl0aW9uYWxPcHRpb25zKS5zZW5kKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnNbb3B0aW9ucy51dWlkUGFyYW1OYW1lXSA9IHV1aWQ7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Rlci5pbml0VHJhbnNwb3J0KGlkKS53aXRoUGFyYW1zKGFkZGl0aW9uYWxPcHRpb25zKS5zZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gZGV0ZWN0U3Vic2FtcGxpbmcoaW1nKSB7XG4gICAgICAgICAgICB2YXIgaXcgPSBpbWcubmF0dXJhbFdpZHRoLCBpaCA9IGltZy5uYXR1cmFsSGVpZ2h0LCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLCBjdHg7XG4gICAgICAgICAgICBpZiAoaXcgKiBpaCA+IDEwMjQgKiAxMDI0KSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7XG4gICAgICAgICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgLWl3ICsgMSwgMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YVszXSA9PT0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRldGVjdFZlcnRpY2FsU3F1YXNoKGltZywgaXcsIGloKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSwgc3kgPSAwLCBleSA9IGloLCBweSA9IGloLCBjdHgsIGRhdGEsIGFscGhhLCByYXRpbztcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaWg7XG4gICAgICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICAgICAgICAgICAgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgaWgpLmRhdGE7XG4gICAgICAgICAgICB3aGlsZSAocHkgPiBzeSkge1xuICAgICAgICAgICAgICAgIGFscGhhID0gZGF0YVsocHkgLSAxKSAqIDQgKyAzXTtcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXkgPSBweTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzeSA9IHB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBweSA9IGV5ICsgc3kgPj4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhdGlvID0gcHkgLyBpaDtcbiAgICAgICAgICAgIHJldHVybiByYXRpbyA9PT0gMCA/IDEgOiByYXRpbztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZW5kZXJJbWFnZVRvRGF0YVVSTChpbWcsIGJsb2IsIG9wdGlvbnMsIGRvU3F1YXNoKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSwgbWltZSA9IG9wdGlvbnMubWltZSB8fCBcImltYWdlL2pwZWdcIiwgcHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCk7XG4gICAgICAgICAgICByZW5kZXJJbWFnZVRvQ2FudmFzKGltZywgYmxvYiwgY2FudmFzLCBvcHRpb25zLCBkb1NxdWFzaCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3MoY2FudmFzLnRvRGF0YVVSTChtaW1lLCBvcHRpb25zLnF1YWxpdHkgfHwgLjgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWF5YmVDYWxjdWxhdGVEb3duc2FtcGxlZERpbWVuc2lvbnMoc3BlYykge1xuICAgICAgICAgICAgdmFyIG1heFBpeGVscyA9IDUyNDFlMztcbiAgICAgICAgICAgIGlmICghcXEuaW9zKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcXEuRXJyb3IoXCJEb3duc2FtcGxlZCBkaW1lbnNpb25zIGNhbiBvbmx5IGJlIHJlbGlhYmx5IGNhbGN1bGF0ZWQgZm9yIGlPUyFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BlYy5vcmlnSGVpZ2h0ICogc3BlYy5vcmlnV2lkdGggPiBtYXhQaXhlbHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuZXdIZWlnaHQ6IE1hdGgucm91bmQoTWF0aC5zcXJ0KG1heFBpeGVscyAqIChzcGVjLm9yaWdIZWlnaHQgLyBzcGVjLm9yaWdXaWR0aCkpKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3V2lkdGg6IE1hdGgucm91bmQoTWF0aC5zcXJ0KG1heFBpeGVscyAqIChzcGVjLm9yaWdXaWR0aCAvIHNwZWMub3JpZ0hlaWdodCkpKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVuZGVySW1hZ2VUb0NhbnZhcyhpbWcsIGJsb2IsIGNhbnZhcywgb3B0aW9ucywgZG9TcXVhc2gpIHtcbiAgICAgICAgICAgIHZhciBpdyA9IGltZy5uYXR1cmFsV2lkdGgsIGloID0gaW1nLm5hdHVyYWxIZWlnaHQsIHdpZHRoID0gb3B0aW9ucy53aWR0aCwgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQsIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksIHByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpLCBtb2RpZmllZERpbWVuc2lvbnM7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVzaXplKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckltYWdlVG9DYW52YXNXaXRoQ3VzdG9tUmVzaXplcih7XG4gICAgICAgICAgICAgICAgICAgIGJsb2I6IGJsb2IsXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhczogY2FudmFzLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1nLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZUhlaWdodDogaWgsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlV2lkdGg6IGl3LFxuICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbjogb3B0aW9ucy5vcmllbnRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplOiBvcHRpb25zLnJlc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFdpZHRoOiB3aWR0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFxcS5zdXBwb3J0ZWRGZWF0dXJlcy51bmxpbWl0ZWRTY2FsZWRJbWFnZVNpemUpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllZERpbWVuc2lvbnMgPSBtYXliZUNhbGN1bGF0ZURvd25zYW1wbGVkRGltZW5zaW9ucyh7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdXaWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdIZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllZERpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEubG9nKHFxLmZvcm1hdChcIkhhZCB0byByZWR1Y2UgZGltZW5zaW9ucyBkdWUgdG8gZGV2aWNlIGxpbWl0YXRpb25zIGZyb20ge313IC8ge31oIHRvIHt9dyAvIHt9aFwiLCB3aWR0aCwgaGVpZ2h0LCBtb2RpZmllZERpbWVuc2lvbnMubmV3V2lkdGgsIG1vZGlmaWVkRGltZW5zaW9ucy5uZXdIZWlnaHQpLCBcIndhcm5cIik7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gbW9kaWZpZWREaW1lbnNpb25zLm5ld1dpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBtb2RpZmllZERpbWVuc2lvbnMubmV3SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zZm9ybUNvb3JkaW5hdGUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zLm9yaWVudGF0aW9uKTtcbiAgICAgICAgICAgIGlmIChxcS5pb3MoKSkge1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRldGVjdFN1YnNhbXBsaW5nKGltZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl3IC89IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpaCAvPSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gMTAyNCwgdG1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSwgdmVydFNxdWFzaFJhdGlvID0gZG9TcXVhc2ggPyBkZXRlY3RWZXJ0aWNhbFNxdWFzaChpbWcsIGl3LCBpaCkgOiAxLCBkdyA9IE1hdGguY2VpbChkICogd2lkdGggLyBpdyksIGRoID0gTWF0aC5jZWlsKGQgKiBoZWlnaHQgLyBpaCAvIHZlcnRTcXVhc2hSYXRpbyksIHN5ID0gMCwgZHkgPSAwLCB0bXBDdHgsIHN4LCBkeDtcbiAgICAgICAgICAgICAgICAgICAgdG1wQ2FudmFzLndpZHRoID0gdG1wQ2FudmFzLmhlaWdodCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgIHRtcEN0eCA9IHRtcENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzeSA8IGloKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3ggPCBpdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgZCwgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wQ3R4LmRyYXdJbWFnZShpbWcsIC1zeCwgLXN5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRtcENhbnZhcywgMCwgMCwgZCwgZCwgZHgsIGR5LCBkdywgZGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN4ICs9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHggKz0gZHc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzeSArPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHkgKz0gZGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wQ2FudmFzID0gdG1wQ3R4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW52YXMucXFJbWFnZVJlbmRlcmVkICYmIGNhbnZhcy5xcUltYWdlUmVuZGVyZWQoKTtcbiAgICAgICAgICAgIHByb21pc2Uuc3VjY2VzcygpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVuZGVySW1hZ2VUb0NhbnZhc1dpdGhDdXN0b21SZXNpemVyKHJlc2l6ZUluZm8pIHtcbiAgICAgICAgICAgIHZhciBibG9iID0gcmVzaXplSW5mby5ibG9iLCBpbWFnZSA9IHJlc2l6ZUluZm8uaW1hZ2UsIGltYWdlSGVpZ2h0ID0gcmVzaXplSW5mby5pbWFnZUhlaWdodCwgaW1hZ2VXaWR0aCA9IHJlc2l6ZUluZm8uaW1hZ2VXaWR0aCwgb3JpZW50YXRpb24gPSByZXNpemVJbmZvLm9yaWVudGF0aW9uLCBwcm9taXNlID0gbmV3IHFxLlByb21pc2UoKSwgcmVzaXplID0gcmVzaXplSW5mby5yZXNpemUsIHNvdXJjZUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksIHNvdXJjZUNhbnZhc0NvbnRleHQgPSBzb3VyY2VDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLCB0YXJnZXRDYW52YXMgPSByZXNpemVJbmZvLmNhbnZhcywgdGFyZ2V0SGVpZ2h0ID0gcmVzaXplSW5mby50YXJnZXRIZWlnaHQsIHRhcmdldFdpZHRoID0gcmVzaXplSW5mby50YXJnZXRXaWR0aDtcbiAgICAgICAgICAgIHRyYW5zZm9ybUNvb3JkaW5hdGUoc291cmNlQ2FudmFzLCBpbWFnZVdpZHRoLCBpbWFnZUhlaWdodCwgb3JpZW50YXRpb24pO1xuICAgICAgICAgICAgdGFyZ2V0Q2FudmFzLmhlaWdodCA9IHRhcmdldEhlaWdodDtcbiAgICAgICAgICAgIHRhcmdldENhbnZhcy53aWR0aCA9IHRhcmdldFdpZHRoO1xuICAgICAgICAgICAgc291cmNlQ2FudmFzQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgICAgICAgICAgcmVzaXplKHtcbiAgICAgICAgICAgICAgICBibG9iOiBibG9iLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGFyZ2V0SGVpZ2h0LFxuICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZSxcbiAgICAgICAgICAgICAgICBzb3VyY2VDYW52YXM6IHNvdXJjZUNhbnZhcyxcbiAgICAgICAgICAgICAgICB0YXJnZXRDYW52YXM6IHRhcmdldENhbnZhcyxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGFyZ2V0V2lkdGhcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gc3VjY2VzcygpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRDYW52YXMucXFJbWFnZVJlbmRlcmVkICYmIHRhcmdldENhbnZhcy5xcUltYWdlUmVuZGVyZWQoKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIH0sIHByb21pc2UuZmFpbHVyZSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0cmFuc2Zvcm1Db29yZGluYXRlKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgb3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICBzd2l0Y2ggKG9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoLCAwKTtcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoLTEsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKC41ICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSguNSAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgLWhlaWdodCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoLjUgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoLCAtaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoLTEsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKC0uNSAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXdpZHRoLCAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIE1lZ2FQaXhJbWFnZShzcmNJbWFnZSwgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5CbG9iICYmIHNyY0ltYWdlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpLCBVUkwgPSB3aW5kb3cuVVJMICYmIHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMID8gd2luZG93LlVSTCA6IHdpbmRvdy53ZWJraXRVUkwgJiYgd2luZG93LndlYmtpdFVSTC5jcmVhdGVPYmplY3RVUkwgPyB3aW5kb3cud2Via2l0VVJMIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFVUkwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiTm8gY3JlYXRlT2JqZWN0VVJMIGZ1bmN0aW9uIGZvdW5kIHRvIGNyZWF0ZSBibG9iIHVybFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzcmNJbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmxvYiA9IHNyY0ltYWdlO1xuICAgICAgICAgICAgICAgICAgICBzcmNJbWFnZSA9IGltZztcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzcmNJbWFnZS5uYXR1cmFsV2lkdGggJiYgIXNyY0ltYWdlLm5hdHVyYWxIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBzcmNJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHNlbGYuaW1hZ2VMb2FkTGlzdGVuZXJzO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmltYWdlTG9hZExpc3RlbmVycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNyY0ltYWdlLm9uZXJyb3IgPSBlcnJvckNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VMb2FkTGlzdGVuZXJzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNyY0ltYWdlID0gc3JjSW1hZ2U7XG4gICAgICAgIH1cbiAgICAgICAgTWVnYVBpeEltYWdlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBpbWdXaWR0aCA9IHRoaXMuc3JjSW1hZ2UubmF0dXJhbFdpZHRoLCBpbWdIZWlnaHQgPSB0aGlzLnNyY0ltYWdlLm5hdHVyYWxIZWlnaHQsIHdpZHRoID0gb3B0aW9ucy53aWR0aCwgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQsIG1heFdpZHRoID0gb3B0aW9ucy5tYXhXaWR0aCwgbWF4SGVpZ2h0ID0gb3B0aW9ucy5tYXhIZWlnaHQsIGRvU3F1YXNoID0gIXRoaXMuYmxvYiB8fCB0aGlzLmJsb2IudHlwZSA9PT0gXCJpbWFnZS9qcGVnXCIsIHRhZ05hbWUgPSB0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBvcHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5pbWFnZUxvYWRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlTG9hZExpc3RlbmVycy5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbmRlcih0YXJnZXQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCAmJiAhaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW1nSGVpZ2h0ICogd2lkdGggLyBpbWdXaWR0aCA8PCAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoZWlnaHQgJiYgIXdpZHRoKSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBpbWdXaWR0aCAqIGhlaWdodCAvIGltZ0hlaWdodCA8PCAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ1dpZHRoO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ0hlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXhXaWR0aCAmJiB3aWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbWdIZWlnaHQgKiB3aWR0aCAvIGltZ1dpZHRoIDw8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4SGVpZ2h0ICYmIGhlaWdodCA+IG1heEhlaWdodCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IG1heEhlaWdodDtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ1dpZHRoICogaGVpZ2h0IC8gaW1nSGVpZ2h0IDw8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHQgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICB9LCBxcS5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKG9wdGlvbnNLZXksIG9wdGlvbnNWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG9wdFtvcHRpb25zS2V5XSA9IG9wdGlvbnNWYWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09IFwiaW1nXCIpIHtcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbGRUYXJnZXRTcmMgPSB0YXJnZXQuc3JjO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJJbWFnZVRvRGF0YVVSTChzZWxmLnNyY0ltYWdlLCBzZWxmLmJsb2IsIG9wdCwgZG9TcXVhc2gpLnRoZW4oZnVuY3Rpb24oZGF0YVVyaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNyYyA9IGRhdGFVcmk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRUYXJnZXRTcmMgPT09IHRhcmdldC5zcmMgJiYgdGFyZ2V0Lm9ubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSBcImNhbnZhc1wiKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVySW1hZ2VUb0NhbnZhcyh0aGlzLnNyY0ltYWdlLCB0aGlzLmJsb2IsIHRhcmdldCwgb3B0LCBkb1NxdWFzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub25yZW5kZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRoaXMub25yZW5kZXIodGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcXEuTWVnYVBpeEltYWdlID0gTWVnYVBpeEltYWdlO1xuICAgIH0pKCk7XG4gICAgcXEuSW1hZ2VHZW5lcmF0b3IgPSBmdW5jdGlvbihsb2cpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIGZ1bmN0aW9uIGlzSW1nKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImltZ1wiO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzQ2FudmFzKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImNhbnZhc1wiO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzSW1nQ29yc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1hZ2UoKS5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzQ2FudmFzU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICByZXR1cm4gY2FudmFzLmdldENvbnRleHQgJiYgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZXRlcm1pbmVNaW1lT2ZGaWxlTmFtZShuYW1lV2l0aFBhdGgpIHtcbiAgICAgICAgICAgIHZhciBwYXRoU2VnbWVudHMgPSBuYW1lV2l0aFBhdGguc3BsaXQoXCIvXCIpLCBuYW1lID0gcGF0aFNlZ21lbnRzW3BhdGhTZWdtZW50cy5sZW5ndGggLSAxXS5zcGxpdChcIj9cIilbMF0sIGV4dGVuc2lvbiA9IHFxLmdldEV4dGVuc2lvbihuYW1lKTtcbiAgICAgICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbiAmJiBleHRlbnNpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJqcGVnXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJqcGdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJpbWFnZS9qcGVnXCI7XG5cbiAgICAgICAgICAgICAgY2FzZSBcInBuZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImltYWdlL3BuZ1wiO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJibXBcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJpbWFnZS9ibXBcIjtcblxuICAgICAgICAgICAgICBjYXNlIFwiZ2lmXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaW1hZ2UvZ2lmXCI7XG5cbiAgICAgICAgICAgICAgY2FzZSBcInRpZmZcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInRpZlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImltYWdlL3RpZmZcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0Nyb3NzT3JpZ2luKHVybCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpLCB0YXJnZXRQcm90b2NvbCwgdGFyZ2V0SG9zdG5hbWUsIHRhcmdldFBvcnQ7XG4gICAgICAgICAgICB0YXJnZXRBbmNob3IuaHJlZiA9IHVybDtcbiAgICAgICAgICAgIHRhcmdldFByb3RvY29sID0gdGFyZ2V0QW5jaG9yLnByb3RvY29sO1xuICAgICAgICAgICAgdGFyZ2V0UG9ydCA9IHRhcmdldEFuY2hvci5wb3J0O1xuICAgICAgICAgICAgdGFyZ2V0SG9zdG5hbWUgPSB0YXJnZXRBbmNob3IuaG9zdG5hbWU7XG4gICAgICAgICAgICBpZiAodGFyZ2V0UHJvdG9jb2wudG9Mb3dlckNhc2UoKSAhPT0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXRIb3N0bmFtZS50b0xvd2VyQ2FzZSgpICE9PSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldFBvcnQgIT09IHdpbmRvdy5sb2NhdGlvbi5wb3J0ICYmICFxcS5pZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJJbWdMb2FkTGlzdGVuZXJzKGltZywgcHJvbWlzZSkge1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGltZy5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGltZy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3MoaW1nKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGltZy5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGltZy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsb2coXCJQcm9ibGVtIGRyYXdpbmcgdGh1bWJuYWlsIVwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgIHByb21pc2UuZmFpbHVyZShpbWcsIFwiUHJvYmxlbSBkcmF3aW5nIHRodW1ibmFpbCFcIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlZ2lzdGVyQ2FudmFzRHJhd0ltYWdlTGlzdGVuZXIoY2FudmFzLCBwcm9taXNlKSB7XG4gICAgICAgICAgICBjYW52YXMucXFJbWFnZVJlbmRlcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKGNhbnZhcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlZ2lzdGVyVGh1bWJuYWlsUmVuZGVyZWRMaXN0ZW5lcihpbWdPckNhbnZhcywgcHJvbWlzZSkge1xuICAgICAgICAgICAgdmFyIHJlZ2lzdGVyZWQgPSBpc0ltZyhpbWdPckNhbnZhcykgfHwgaXNDYW52YXMoaW1nT3JDYW52YXMpO1xuICAgICAgICAgICAgaWYgKGlzSW1nKGltZ09yQ2FudmFzKSkge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVySW1nTG9hZExpc3RlbmVycyhpbWdPckNhbnZhcywgcHJvbWlzZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ2FudmFzKGltZ09yQ2FudmFzKSkge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyQ2FudmFzRHJhd0ltYWdlTGlzdGVuZXIoaW1nT3JDYW52YXMsIHByb21pc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLmZhaWx1cmUoaW1nT3JDYW52YXMpO1xuICAgICAgICAgICAgICAgIGxvZyhxcS5mb3JtYXQoXCJFbGVtZW50IGNvbnRhaW5lciBvZiB0eXBlIHt9IGlzIG5vdCBzdXBwb3J0ZWQhXCIsIGltZ09yQ2FudmFzLnRhZ05hbWUpLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZHJhdyhmaWxlT3JCbG9iLCBjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBkcmF3UHJldmlldyA9IG5ldyBxcS5Qcm9taXNlKCksIGlkZW50aWZpZXIgPSBuZXcgcXEuSWRlbnRpZnkoZmlsZU9yQmxvYiwgbG9nKSwgbWF4U2l6ZSA9IG9wdGlvbnMubWF4U2l6ZSwgb3JpZW50ID0gb3B0aW9ucy5vcmllbnQgPT0gbnVsbCA/IHRydWUgOiBvcHRpb25zLm9yaWVudCwgbWVnYXBpeEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb250YWluZXIub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsb2coXCJDb3VsZCBub3QgcmVuZGVyIHByZXZpZXcsIGZpbGUgbWF5IGJlIHRvbyBsYXJnZSFcIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICBkcmF3UHJldmlldy5mYWlsdXJlKGNvbnRhaW5lciwgXCJCcm93c2VyIGNhbm5vdCByZW5kZXIgaW1hZ2UhXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlkZW50aWZpZXIuaXNQcmV2aWV3YWJsZSgpLnRoZW4oZnVuY3Rpb24obWltZSkge1xuICAgICAgICAgICAgICAgIHZhciBkdW1teUV4aWYgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcXEuUHJvbWlzZSgpLnN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGV4aWYgPSBvcmllbnQgPyBuZXcgcXEuRXhpZihmaWxlT3JCbG9iLCBsb2cpIDogZHVtbXlFeGlmLCBtcEltZyA9IG5ldyBxcS5NZWdhUGl4SW1hZ2UoZmlsZU9yQmxvYiwgbWVnYXBpeEVycm9ySGFuZGxlcik7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lzdGVyVGh1bWJuYWlsUmVuZGVyZWRMaXN0ZW5lcihjb250YWluZXIsIGRyYXdQcmV2aWV3KSkge1xuICAgICAgICAgICAgICAgICAgICBleGlmLnBhcnNlKCkudGhlbihmdW5jdGlvbihleGlmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZW50YXRpb24gPSBleGlmICYmIGV4aWYuT3JpZW50YXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBtcEltZy5yZW5kZXIoY29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6IG1heFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBtYXhTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lOiBtaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZTogb3B0aW9ucy5jdXN0b21SZXNpemVGdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGZhaWx1cmVNc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhxcS5mb3JtYXQoXCJFWElGIGRhdGEgY291bGQgbm90IGJlIHBhcnNlZCAoe30pLiAgQXNzdW1pbmcgb3JpZW50YXRpb24gPSAxLlwiLCBmYWlsdXJlTXNnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtcEltZy5yZW5kZXIoY29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6IG1heFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBtYXhTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWU6IG1pbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplOiBvcHRpb25zLmN1c3RvbVJlc2l6ZUZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbG9nKFwiTm90IHByZXZpZXdhYmxlXCIpO1xuICAgICAgICAgICAgICAgIGRyYXdQcmV2aWV3LmZhaWx1cmUoY29udGFpbmVyLCBcIk5vdCBwcmV2aWV3YWJsZVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRyYXdQcmV2aWV3O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRyYXdPbkNhbnZhc09ySW1nRnJvbVVybCh1cmwsIGNhbnZhc09ySW1nLCBkcmF3LCBtYXhTaXplLCBjdXN0b21SZXNpemVGdW5jdGlvbikge1xuICAgICAgICAgICAgdmFyIHRlbXBJbWcgPSBuZXcgSW1hZ2UoKSwgdGVtcEltZ1JlbmRlciA9IG5ldyBxcS5Qcm9taXNlKCk7XG4gICAgICAgICAgICByZWdpc3RlclRodW1ibmFpbFJlbmRlcmVkTGlzdGVuZXIodGVtcEltZywgdGVtcEltZ1JlbmRlcik7XG4gICAgICAgICAgICBpZiAoaXNDcm9zc09yaWdpbih1cmwpKSB7XG4gICAgICAgICAgICAgICAgdGVtcEltZy5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wSW1nLnNyYyA9IHVybDtcbiAgICAgICAgICAgIHRlbXBJbWdSZW5kZXIudGhlbihmdW5jdGlvbiByZW5kZXJlZCgpIHtcbiAgICAgICAgICAgICAgICByZWdpc3RlclRodW1ibmFpbFJlbmRlcmVkTGlzdGVuZXIoY2FudmFzT3JJbWcsIGRyYXcpO1xuICAgICAgICAgICAgICAgIHZhciBtcEltZyA9IG5ldyBxcS5NZWdhUGl4SW1hZ2UodGVtcEltZyk7XG4gICAgICAgICAgICAgICAgbXBJbWcucmVuZGVyKGNhbnZhc09ySW1nLCB7XG4gICAgICAgICAgICAgICAgICAgIG1heFdpZHRoOiBtYXhTaXplLFxuICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IG1heFNpemUsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IGRldGVybWluZU1pbWVPZkZpbGVOYW1lKHVybCksXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZTogY3VzdG9tUmVzaXplRnVuY3Rpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGRyYXcuZmFpbHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZHJhd09uSW1nRnJvbVVybFdpdGhDc3NTY2FsaW5nKHVybCwgaW1nLCBkcmF3LCBtYXhTaXplKSB7XG4gICAgICAgICAgICByZWdpc3RlclRodW1ibmFpbFJlbmRlcmVkTGlzdGVuZXIoaW1nLCBkcmF3KTtcbiAgICAgICAgICAgIHFxKGltZykuY3NzKHtcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogbWF4U2l6ZSArIFwicHhcIixcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IG1heFNpemUgKyBcInB4XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkcmF3RnJvbVVybCh1cmwsIGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGRyYXcgPSBuZXcgcXEuUHJvbWlzZSgpLCBzY2FsZSA9IG9wdGlvbnMuc2NhbGUsIG1heFNpemUgPSBzY2FsZSA/IG9wdGlvbnMubWF4U2l6ZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoc2NhbGUgJiYgaXNJbWcoY29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0NhbnZhc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Nyb3NzT3JpZ2luKHVybCkgJiYgIWlzSW1nQ29yc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3T25JbWdGcm9tVXJsV2l0aENzc1NjYWxpbmcodXJsLCBjb250YWluZXIsIGRyYXcsIG1heFNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd09uQ2FudmFzT3JJbWdGcm9tVXJsKHVybCwgY29udGFpbmVyLCBkcmF3LCBtYXhTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdPbkltZ0Zyb21VcmxXaXRoQ3NzU2NhbGluZyh1cmwsIGNvbnRhaW5lciwgZHJhdywgbWF4U2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0NhbnZhcyhjb250YWluZXIpKSB7XG4gICAgICAgICAgICAgICAgZHJhd09uQ2FudmFzT3JJbWdGcm9tVXJsKHVybCwgY29udGFpbmVyLCBkcmF3LCBtYXhTaXplKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVnaXN0ZXJUaHVtYm5haWxSZW5kZXJlZExpc3RlbmVyKGNvbnRhaW5lciwgZHJhdykpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc3JjID0gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgICAgIH1cbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIGdlbmVyYXRlOiBmdW5jdGlvbihmaWxlQmxvYk9yVXJsLCBjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocXEuaXNTdHJpbmcoZmlsZUJsb2JPclVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwiQXR0ZW1wdGluZyB0byB1cGRhdGUgdGh1bWJuYWlsIGJhc2VkIG9uIHNlcnZlciByZXNwb25zZS5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkcmF3RnJvbVVybChmaWxlQmxvYk9yVXJsLCBjb250YWluZXIsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIkF0dGVtcHRpbmcgdG8gZHJhdyBjbGllbnQtc2lkZSBpbWFnZSBwcmV2aWV3LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRyYXcoZmlsZUJsb2JPclVybCwgY29udGFpbmVyLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl90ZXN0aW5nID0ge307XG4gICAgICAgIHRoaXMuX3Rlc3RpbmcuaXNJbWcgPSBpc0ltZztcbiAgICAgICAgdGhpcy5fdGVzdGluZy5pc0NhbnZhcyA9IGlzQ2FudmFzO1xuICAgICAgICB0aGlzLl90ZXN0aW5nLmlzQ3Jvc3NPcmlnaW4gPSBpc0Nyb3NzT3JpZ2luO1xuICAgICAgICB0aGlzLl90ZXN0aW5nLmRldGVybWluZU1pbWVPZkZpbGVOYW1lID0gZGV0ZXJtaW5lTWltZU9mRmlsZU5hbWU7XG4gICAgfTtcbiAgICBxcS5FeGlmID0gZnVuY3Rpb24oZmlsZU9yQmxvYiwgbG9nKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgVEFHX0lEUyA9IFsgMjc0IF0sIFRBR19JTkZPID0ge1xuICAgICAgICAgICAgMjc0OiB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJPcmllbnRhdGlvblwiLFxuICAgICAgICAgICAgICAgIGJ5dGVzOiAyXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlTGl0dGxlRW5kaWFuKGhleCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IDAsIHBvdyA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaGV4Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZygwLCAyKSwgMTYpICogTWF0aC5wb3coMiwgcG93KTtcbiAgICAgICAgICAgICAgICBoZXggPSBoZXguc3Vic3RyaW5nKDIsIGhleC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHBvdyArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZWVrVG9BcHAxKG9mZnNldCwgcHJvbWlzZSkge1xuICAgICAgICAgICAgdmFyIHRoZU9mZnNldCA9IG9mZnNldCwgdGhlUHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgICAgICBpZiAodGhlT2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGVPZmZzZXQgPSAyO1xuICAgICAgICAgICAgICAgIHRoZVByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXEucmVhZEJsb2JUb0hleChmaWxlT3JCbG9iLCB0aGVPZmZzZXQsIDQpLnRoZW4oZnVuY3Rpb24oaGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gL15mZmUoWzAtOV0pLy5leGVjKGhleCksIHNlZ21lbnRMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSAhPT0gXCIxXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRMZW5ndGggPSBwYXJzZUludChoZXguc2xpY2UoNCwgOCksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZWtUb0FwcDEodGhlT2Zmc2V0ICsgc2VnbWVudExlbmd0aCArIDIsIHRoZVByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhlUHJvbWlzZS5zdWNjZXNzKHRoZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGVQcm9taXNlLmZhaWx1cmUoXCJObyBFWElGIGhlYWRlciB0byBiZSBmb3VuZCFcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhlUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRBcHAxT2Zmc2V0KCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgcXEucmVhZEJsb2JUb0hleChmaWxlT3JCbG9iLCAwLCA2KS50aGVuKGZ1bmN0aW9uKGhleCkge1xuICAgICAgICAgICAgICAgIGlmIChoZXguaW5kZXhPZihcImZmZDhcIikgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5mYWlsdXJlKFwiTm90IGEgdmFsaWQgSlBFRyFcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vla1RvQXBwMSgpLnRoZW4oZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3Mob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuZmFpbHVyZShlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNMaXR0bGVFbmRpYW4oYXBwMVN0YXJ0KSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCk7XG4gICAgICAgICAgICBxcS5yZWFkQmxvYlRvSGV4KGZpbGVPckJsb2IsIGFwcDFTdGFydCArIDEwLCAyKS50aGVuKGZ1bmN0aW9uKGhleCkge1xuICAgICAgICAgICAgICAgIHByb21pc2Uuc3VjY2VzcyhoZXggPT09IFwiNDk0OVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0RGlyRW50cnlDb3VudChhcHAxU3RhcnQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgcXEucmVhZEJsb2JUb0hleChmaWxlT3JCbG9iLCBhcHAxU3RhcnQgKyAxOCwgMikudGhlbihmdW5jdGlvbihoZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnN1Y2Nlc3MocGFyc2VMaXR0bGVFbmRpYW4oaGV4KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKHBhcnNlSW50KGhleCwgMTYpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldElmZChhcHAxU3RhcnQsIGRpckVudHJpZXMpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBhcHAxU3RhcnQgKyAyMCwgYnl0ZXMgPSBkaXJFbnRyaWVzICogMTI7XG4gICAgICAgICAgICByZXR1cm4gcXEucmVhZEJsb2JUb0hleChmaWxlT3JCbG9iLCBvZmZzZXQsIGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXREaXJFbnRyaWVzKGlmZEhleCkge1xuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBbXSwgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgKyAyNCA8PSBpZmRIZXgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKGlmZEhleC5zbGljZShvZmZzZXQsIG9mZnNldCArIDI0KSk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDI0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0VGFnVmFsdWVzKGxpdHRsZUVuZGlhbiwgZGlyRW50cmllcykge1xuICAgICAgICAgICAgdmFyIFRBR19WQUxfT0ZGU0VUID0gMTYsIHRhZ3NUb0ZpbmQgPSBxcS5leHRlbmQoW10sIFRBR19JRFMpLCB2YWxzID0ge307XG4gICAgICAgICAgICBxcS5lYWNoKGRpckVudHJpZXMsIGZ1bmN0aW9uKGlkeCwgZW50cnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWRIZXggPSBlbnRyeS5zbGljZSgwLCA0KSwgaWQgPSBsaXR0bGVFbmRpYW4gPyBwYXJzZUxpdHRsZUVuZGlhbihpZEhleCkgOiBwYXJzZUludChpZEhleCwgMTYpLCB0YWdzVG9GaW5kSWR4ID0gdGFnc1RvRmluZC5pbmRleE9mKGlkKSwgdGFnVmFsSGV4LCB0YWdOYW1lLCB0YWdWYWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ3NUb0ZpbmRJZHggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lID0gVEFHX0lORk9baWRdLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHRhZ1ZhbExlbmd0aCA9IFRBR19JTkZPW2lkXS5ieXRlcztcbiAgICAgICAgICAgICAgICAgICAgdGFnVmFsSGV4ID0gZW50cnkuc2xpY2UoVEFHX1ZBTF9PRkZTRVQsIFRBR19WQUxfT0ZGU0VUICsgdGFnVmFsTGVuZ3RoICogMik7XG4gICAgICAgICAgICAgICAgICAgIHZhbHNbdGFnTmFtZV0gPSBsaXR0bGVFbmRpYW4gPyBwYXJzZUxpdHRsZUVuZGlhbih0YWdWYWxIZXgpIDogcGFyc2VJbnQodGFnVmFsSGV4LCAxNik7XG4gICAgICAgICAgICAgICAgICAgIHRhZ3NUb0ZpbmQuc3BsaWNlKHRhZ3NUb0ZpbmRJZHgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGFnc1RvRmluZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHM7XG4gICAgICAgIH1cbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VyID0gbmV3IHFxLlByb21pc2UoKSwgb25QYXJzZUZhaWx1cmUgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhxcS5mb3JtYXQoXCJFWElGIGhlYWRlciBwYXJzZSBmYWlsZWQ6ICd7fScgXCIsIG1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmZhaWx1cmUobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBnZXRBcHAxT2Zmc2V0KCkudGhlbihmdW5jdGlvbihhcHAxT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhxcS5mb3JtYXQoXCJNb3ZpbmcgZm9yd2FyZCB3aXRoIEVYSUYgaGVhZGVyIHBhcnNpbmcgZm9yICd7fSdcIiwgZmlsZU9yQmxvYi5uYW1lID09PSB1bmRlZmluZWQgPyBcImJsb2JcIiA6IGZpbGVPckJsb2IubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBpc0xpdHRsZUVuZGlhbihhcHAxT2Zmc2V0KS50aGVuKGZ1bmN0aW9uKGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKHFxLmZvcm1hdChcIkVYSUYgQnl0ZSBvcmRlciBpcyB7fSBlbmRpYW5cIiwgbGl0dGxlRW5kaWFuID8gXCJsaXR0bGVcIiA6IFwiYmlnXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldERpckVudHJ5Q291bnQoYXBwMU9mZnNldCwgbGl0dGxlRW5kaWFuKS50aGVuKGZ1bmN0aW9uKGRpckVudHJ5Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cocXEuZm9ybWF0KFwiRm91bmQge30gQVBQMSBkaXJlY3RvcnkgZW50cmllc1wiLCBkaXJFbnRyeUNvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SWZkKGFwcDFPZmZzZXQsIGRpckVudHJ5Q291bnQpLnRoZW4oZnVuY3Rpb24oaWZkSGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXJFbnRyaWVzID0gZ2V0RGlyRW50cmllcyhpZmRIZXgpLCB0YWdWYWx1ZXMgPSBnZXRUYWdWYWx1ZXMobGl0dGxlRW5kaWFuLCBkaXJFbnRyaWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKFwiU3VjY2Vzc2Z1bGx5IHBhcnNlZCBzb21lIEVYSUYgdGFnc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN1Y2Nlc3ModGFnVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBvblBhcnNlRmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBvblBhcnNlRmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIG9uUGFyc2VGYWlsdXJlKTtcbiAgICAgICAgICAgICAgICB9LCBvblBhcnNlRmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3Rlc3RpbmcgPSB7fTtcbiAgICAgICAgdGhpcy5fdGVzdGluZy5wYXJzZUxpdHRsZUVuZGlhbiA9IHBhcnNlTGl0dGxlRW5kaWFuO1xuICAgIH07XG4gICAgcXEuSWRlbnRpZnkgPSBmdW5jdGlvbihmaWxlT3JCbG9iLCBsb2cpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmlhYmxlKG1hZ2ljQnl0ZXMsIHF1ZXN0aW9uYWJsZUJ5dGVzKSB7XG4gICAgICAgICAgICB2YXIgaWRlbnRpZmlhYmxlID0gZmFsc2UsIG1hZ2ljQnl0ZXNFbnRyaWVzID0gW10uY29uY2F0KG1hZ2ljQnl0ZXMpO1xuICAgICAgICAgICAgcXEuZWFjaChtYWdpY0J5dGVzRW50cmllcywgZnVuY3Rpb24oaWR4LCBtYWdpY0J5dGVzQXJyYXlFbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmIChxdWVzdGlvbmFibGVCeXRlcy5pbmRleE9mKG1hZ2ljQnl0ZXNBcnJheUVudHJ5KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gaWRlbnRpZmlhYmxlO1xuICAgICAgICB9XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBpc1ByZXZpZXdhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGlkZW50aWZpZXIgPSBuZXcgcXEuUHJvbWlzZSgpLCBwcmV2aWV3YWJsZSA9IGZhbHNlLCBuYW1lID0gZmlsZU9yQmxvYi5uYW1lID09PSB1bmRlZmluZWQgPyBcImJsb2JcIiA6IGZpbGVPckJsb2IubmFtZTtcbiAgICAgICAgICAgICAgICBsb2cocXEuZm9ybWF0KFwiQXR0ZW1wdGluZyB0byBkZXRlcm1pbmUgaWYge30gY2FuIGJlIHJlbmRlcmVkIGluIHRoaXMgYnJvd3NlclwiLCBuYW1lKSk7XG4gICAgICAgICAgICAgICAgbG9nKFwiRmlyc3QgcGFzczogY2hlY2sgdHlwZSBhdHRyaWJ1dGUgb2YgYmxvYiBvYmplY3QuXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUHJldmlld2FibGVTeW5jKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwiU2Vjb25kIHBhc3M6IGNoZWNrIGZvciBtYWdpYyBieXRlcyBpbiBmaWxlIGhlYWRlci5cIik7XG4gICAgICAgICAgICAgICAgICAgIHFxLnJlYWRCbG9iVG9IZXgoZmlsZU9yQmxvYiwgMCwgNCkudGhlbihmdW5jdGlvbihoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFxLmVhY2goc2VsZi5QUkVWSUVXQUJMRV9NSU1FX1RZUEVTLCBmdW5jdGlvbihtaW1lLCBieXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0lkZW50aWZpYWJsZShieXRlcywgaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWltZSAhPT0gXCJpbWFnZS90aWZmXCIgfHwgcXEuc3VwcG9ydGVkRmVhdHVyZXMudGlmZlByZXZpZXdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyLnN1Y2Nlc3MobWltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKHFxLmZvcm1hdChcIid7fScgaXMge30gYWJsZSB0byBiZSByZW5kZXJlZCBpbiB0aGlzIGJyb3dzZXJcIiwgbmFtZSwgcHJldmlld2FibGUgPyBcIlwiIDogXCJOT1RcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2aWV3YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIuZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhcIkVycm9yIHJlYWRpbmcgZmlsZSB3LyBuYW1lICdcIiArIG5hbWUgKyBcIicuICBOb3QgYWJsZSB0byBiZSByZW5kZXJlZCBpbiB0aGlzIGJyb3dzZXIuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllci5mYWlsdXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIuZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1ByZXZpZXdhYmxlU3luYzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVNaW1lID0gZmlsZU9yQmxvYi50eXBlLCBpc1JlY29nbml6ZWRJbWFnZSA9IHFxLmluZGV4T2YoT2JqZWN0LmtleXModGhpcy5QUkVWSUVXQUJMRV9NSU1FX1RZUEVTKSwgZmlsZU1pbWUpID49IDAsIHByZXZpZXdhYmxlID0gZmFsc2UsIG5hbWUgPSBmaWxlT3JCbG9iLm5hbWUgPT09IHVuZGVmaW5lZCA/IFwiYmxvYlwiIDogZmlsZU9yQmxvYi5uYW1lO1xuICAgICAgICAgICAgICAgIGlmIChpc1JlY29nbml6ZWRJbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZU1pbWUgPT09IFwiaW1hZ2UvdGlmZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3YWJsZSA9IHFxLnN1cHBvcnRlZEZlYXR1cmVzLnRpZmZQcmV2aWV3cztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpZXdhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAhcHJldmlld2FibGUgJiYgbG9nKG5hbWUgKyBcIiBpcyBub3QgcHJldmlld2FibGUgaW4gdGhpcyBicm93c2VyIHBlciB0aGUgYmxvYidzIHR5cGUgYXR0clwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlld2FibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcXEuSWRlbnRpZnkucHJvdG90eXBlLlBSRVZJRVdBQkxFX01JTUVfVFlQRVMgPSB7XG4gICAgICAgIFwiaW1hZ2UvanBlZ1wiOiBcImZmZDhmZlwiLFxuICAgICAgICBcImltYWdlL2dpZlwiOiBcIjQ3NDk0NlwiLFxuICAgICAgICBcImltYWdlL3BuZ1wiOiBcIjg5NTA0ZVwiLFxuICAgICAgICBcImltYWdlL2JtcFwiOiBcIjQyNGRcIixcbiAgICAgICAgXCJpbWFnZS90aWZmXCI6IFsgXCI0OTQ5MmEwMFwiLCBcIjRkNGQwMDJhXCIgXVxuICAgIH07XG4gICAgcXEuSW1hZ2VWYWxpZGF0aW9uID0gZnVuY3Rpb24oYmxvYiwgbG9nKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBmdW5jdGlvbiBoYXNOb25aZXJvTGltaXRzKGxpbWl0cykge1xuICAgICAgICAgICAgdmFyIGF0TGVhc3RPbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHFxLmVhY2gobGltaXRzLCBmdW5jdGlvbihsaW1pdCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0TGVhc3RPbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYXRMZWFzdE9uZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRXaWR0aEhlaWdodCgpIHtcbiAgICAgICAgICAgIHZhciBzaXplRGV0ZXJtaW5hdGlvbiA9IG5ldyBxcS5Qcm9taXNlKCk7XG4gICAgICAgICAgICBuZXcgcXEuSWRlbnRpZnkoYmxvYiwgbG9nKS5pc1ByZXZpZXdhYmxlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKSwgdXJsID0gd2luZG93LlVSTCAmJiB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTCA/IHdpbmRvdy5VUkwgOiB3aW5kb3cud2Via2l0VVJMICYmIHdpbmRvdy53ZWJraXRVUkwuY3JlYXRlT2JqZWN0VVJMID8gd2luZG93LndlYmtpdFVSTCA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2coXCJDYW5ub3QgZGV0ZXJtaW5lIGRpbWVuc2lvbnMgZm9yIGltYWdlLiAgTWF5IGJlIHRvbyBsYXJnZS5cIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVEZXRlcm1pbmF0aW9uLmZhaWx1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplRGV0ZXJtaW5hdGlvbi5zdWNjZXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gdXJsLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2coXCJObyBjcmVhdGVPYmplY3RVUkwgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGdlbmVyYXRlIGltYWdlIFVSTCFcIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZURldGVybWluYXRpb24uZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHNpemVEZXRlcm1pbmF0aW9uLmZhaWx1cmUpO1xuICAgICAgICAgICAgcmV0dXJuIHNpemVEZXRlcm1pbmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEZhaWxpbmdMaW1pdChsaW1pdHMsIGRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgIHZhciBmYWlsaW5nTGltaXQ7XG4gICAgICAgICAgICBxcS5lYWNoKGxpbWl0cywgZnVuY3Rpb24obGltaXROYW1lLCBsaW1pdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbWl0VmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW1pdE1hdGNoZXIgPSAvKG1heHxtaW4pKFdpZHRofEhlaWdodCkvLmV4ZWMobGltaXROYW1lKSwgZGltZW5zaW9uUHJvcE5hbWUgPSBsaW1pdE1hdGNoZXJbMl0uY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBsaW1pdE1hdGNoZXJbMl0uc2xpY2UoMSksIGFjdHVhbFZhbHVlID0gZGltZW5zaW9uc1tkaW1lbnNpb25Qcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobGltaXRNYXRjaGVyWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1pblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdHVhbFZhbHVlIDwgbGltaXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWxpbmdMaW1pdCA9IGxpbWl0TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3R1YWxWYWx1ZSA+IGxpbWl0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsaW5nTGltaXQgPSBsaW1pdE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWlsaW5nTGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWxpZGF0ZSA9IGZ1bmN0aW9uKGxpbWl0cykge1xuICAgICAgICAgICAgdmFyIHZhbGlkYXRpb25FZmZvcnQgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgbG9nKFwiQXR0ZW1wdGluZyB0byB2YWxpZGF0ZSBpbWFnZS5cIik7XG4gICAgICAgICAgICBpZiAoaGFzTm9uWmVyb0xpbWl0cyhsaW1pdHMpKSB7XG4gICAgICAgICAgICAgICAgZ2V0V2lkdGhIZWlnaHQoKS50aGVuKGZ1bmN0aW9uKGRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhaWxpbmdMaW1pdCA9IGdldEZhaWxpbmdMaW1pdChsaW1pdHMsIGRpbWVuc2lvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmFpbGluZ0xpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRWZmb3J0LmZhaWx1cmUoZmFpbGluZ0xpbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25FZmZvcnQuc3VjY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdmFsaWRhdGlvbkVmZm9ydC5zdWNjZXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvbkVmZm9ydC5zdWNjZXNzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGlvbkVmZm9ydDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHFxLlNlc3Npb24gPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGVuZHBvaW50OiBudWxsLFxuICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgICAgIGN1c3RvbUhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgY29yczoge30sXG4gICAgICAgICAgICBhZGRGaWxlUmVjb3JkOiBmdW5jdGlvbihzZXNzaW9uRGF0YSkge30sXG4gICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKG1lc3NhZ2UsIGxldmVsKSB7fVxuICAgICAgICB9O1xuICAgICAgICBxcS5leHRlbmQob3B0aW9ucywgc3BlYywgdHJ1ZSk7XG4gICAgICAgIGZ1bmN0aW9uIGlzSnNvblJlc3BvbnNlVmFsaWQocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChxcS5pc0FycmF5KHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5sb2coXCJTZXNzaW9uIHJlc3BvbnNlIGlzIG5vdCBhbiBhcnJheS5cIiwgXCJlcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVGaWxlSXRlbXMoZmlsZUl0ZW1zLCBzdWNjZXNzLCB4aHJPclhkciwgcHJvbWlzZSkge1xuICAgICAgICAgICAgdmFyIHNvbWVJdGVtc0lnbm9yZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSBzdWNjZXNzICYmIGlzSnNvblJlc3BvbnNlVmFsaWQoZmlsZUl0ZW1zKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgcXEuZWFjaChmaWxlSXRlbXMsIGZ1bmN0aW9uKGlkeCwgZmlsZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVJdGVtLnV1aWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29tZUl0ZW1zSWdub3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvZyhxcS5mb3JtYXQoXCJTZXNzaW9uIHJlc3BvbnNlIGl0ZW0ge30gZGlkIG5vdCBpbmNsdWRlIGEgdmFsaWQgVVVJRCAtIGlnbm9yaW5nLlwiLCBpZHgpLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpbGVJdGVtLm5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29tZUl0ZW1zSWdub3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvZyhxcS5mb3JtYXQoXCJTZXNzaW9uIHJlc3BvbnNlIGl0ZW0ge30gZGlkIG5vdCBpbmNsdWRlIGEgdmFsaWQgbmFtZSAtIGlnbm9yaW5nLlwiLCBpZHgpLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmFkZEZpbGVSZWNvcmQoZmlsZUl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29tZUl0ZW1zSWdub3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2coZXJyLm1lc3NhZ2UsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZVtzdWNjZXNzICYmICFzb21lSXRlbXNJZ25vcmVkID8gXCJzdWNjZXNzXCIgOiBcImZhaWx1cmVcIl0oZmlsZUl0ZW1zLCB4aHJPclhkcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVmcmVzaEVmZm9ydCA9IG5ldyBxcS5Qcm9taXNlKCksIHJlZnJlc2hDb21wbGV0ZUNhbGxiYWNrID0gZnVuY3Rpb24ocmVzcG9uc2UsIHN1Y2Nlc3MsIHhock9yWGRyKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRmlsZUl0ZW1zKHJlc3BvbnNlLCBzdWNjZXNzLCB4aHJPclhkciwgcmVmcmVzaEVmZm9ydCk7XG4gICAgICAgICAgICB9LCByZXF1ZXN0ZXJPcHRpb25zID0gcXEuZXh0ZW5kKHt9LCBvcHRpb25zKSwgcmVxdWVzdGVyID0gbmV3IHFxLlNlc3Npb25BamF4UmVxdWVzdGVyKHFxLmV4dGVuZChyZXF1ZXN0ZXJPcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZTogcmVmcmVzaENvbXBsZXRlQ2FsbGJhY2tcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJlcXVlc3Rlci5xdWVyeVNlcnZlcigpO1xuICAgICAgICAgICAgcmV0dXJuIHJlZnJlc2hFZmZvcnQ7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBxcS5TZXNzaW9uQWpheFJlcXVlc3RlciA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciByZXF1ZXN0ZXIsIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlbmRwb2ludDogbnVsbCxcbiAgICAgICAgICAgIGN1c3RvbUhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgICAgIGNvcnM6IHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VuZENyZWRlbnRpYWxzOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKHJlc3BvbnNlLCBzdWNjZXNzLCB4aHJPclhkcikge30sXG4gICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKHN0ciwgbGV2ZWwpIHt9XG4gICAgICAgIH07XG4gICAgICAgIHFxLmV4dGVuZChvcHRpb25zLCBzcGVjKTtcbiAgICAgICAgZnVuY3Rpb24gb25Db21wbGV0ZShpZCwgeGhyT3JYZHIsIGlzRXJyb3IpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoeGhyT3JYZHIucmVzcG9uc2VUZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHFxLnBhcnNlSnNvbih4aHJPclhkci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvZyhcIlByb2JsZW0gcGFyc2luZyBzZXNzaW9uIHJlc3BvbnNlOiBcIiArIGVyci5tZXNzYWdlLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICBpc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLm9uQ29tcGxldGUocmVzcG9uc2UsICFpc0Vycm9yLCB4aHJPclhkcik7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdGVyID0gcXEuZXh0ZW5kKHRoaXMsIG5ldyBxcS5BamF4UmVxdWVzdGVyKHtcbiAgICAgICAgICAgIGFjY2VwdEhlYWRlcjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB2YWxpZE1ldGhvZHM6IFsgXCJHRVRcIiBdLFxuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgZW5kcG9pbnRTdG9yZToge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmVuZHBvaW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjdXN0b21IZWFkZXJzOiBvcHRpb25zLmN1c3RvbUhlYWRlcnMsXG4gICAgICAgICAgICBsb2c6IG9wdGlvbnMubG9nLFxuICAgICAgICAgICAgb25Db21wbGV0ZTogb25Db21wbGV0ZSxcbiAgICAgICAgICAgIGNvcnM6IG9wdGlvbnMuY29yc1xuICAgICAgICB9KSk7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBxdWVyeVNlcnZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHFxLmV4dGVuZCh7fSwgb3B0aW9ucy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9nKFwiU2Vzc2lvbiBxdWVyeSByZXF1ZXN0LlwiKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZXIuaW5pdFRyYW5zcG9ydChcInNlc3Npb25SZWZyZXNoXCIpLndpdGhQYXJhbXMocGFyYW1zKS53aXRoQ2FjaGVCdXN0ZXIoKS5zZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcXEuU2NhbGVyID0gZnVuY3Rpb24oc3BlYywgbG9nKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGN1c3RvbVJlc2l6ZUZ1bmN0aW9uID0gc3BlYy5jdXN0b21SZXNpemVyLCBpbmNsdWRlT3JpZ2luYWwgPSBzcGVjLnNlbmRPcmlnaW5hbCwgb3JpZW50ID0gc3BlYy5vcmllbnQsIGRlZmF1bHRUeXBlID0gc3BlYy5kZWZhdWx0VHlwZSwgZGVmYXVsdFF1YWxpdHkgPSBzcGVjLmRlZmF1bHRRdWFsaXR5IC8gMTAwLCBmYWlsZWRUb1NjYWxlVGV4dCA9IHNwZWMuZmFpbHVyZVRleHQsIGluY2x1ZGVFeGlmID0gc3BlYy5pbmNsdWRlRXhpZiwgc2l6ZXMgPSB0aGlzLl9nZXRTb3J0ZWRTaXplcyhzcGVjLnNpemVzKTtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHFxLnN1cHBvcnRlZEZlYXR1cmVzLnNjYWxpbmcgJiYgc2l6ZXMubGVuZ3RoID4gMCxcbiAgICAgICAgICAgIGdldEZpbGVSZWNvcmRzOiBmdW5jdGlvbihvcmlnaW5hbEZpbGVVdWlkLCBvcmlnaW5hbEZpbGVOYW1lLCBvcmlnaW5hbEJsb2JPckJsb2JEYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCByZWNvcmRzID0gW10sIG9yaWdpbmFsQmxvYiA9IG9yaWdpbmFsQmxvYk9yQmxvYkRhdGEuYmxvYiA/IG9yaWdpbmFsQmxvYk9yQmxvYkRhdGEuYmxvYiA6IG9yaWdpbmFsQmxvYk9yQmxvYkRhdGEsIGlkZW50aWZpZXIgPSBuZXcgcXEuSWRlbnRpZnkob3JpZ2luYWxCbG9iLCBsb2cpO1xuICAgICAgICAgICAgICAgIGlmIChpZGVudGlmaWVyLmlzUHJldmlld2FibGVTeW5jKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChzaXplcywgZnVuY3Rpb24oaWR4LCBzaXplUmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0VHlwZSA9IHNlbGYuX2RldGVybWluZU91dHB1dFR5cGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRUeXBlOiBkZWZhdWx0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRUeXBlOiBzaXplUmVjb3JkLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmVHlwZTogb3JpZ2luYWxCbG9iLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dWlkOiBxcS5nZXRVbmlxdWVJZCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHNlbGYuX2dldE5hbWUob3JpZ2luYWxGaWxlTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzaXplUmVjb3JkLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG91dHB1dFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZlR5cGU6IG9yaWdpbmFsQmxvYi50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvYjogbmV3IHFxLkJsb2JQcm94eShvcmlnaW5hbEJsb2IsIHFxLmJpbmQoc2VsZi5fZ2VuZXJhdGVTY2FsZWRJbWFnZSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21SZXNpemVGdW5jdGlvbjogY3VzdG9tUmVzaXplRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFNpemU6IHNpemVSZWNvcmQubWF4U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZW50OiBvcmllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG91dHB1dFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YWxpdHk6IGRlZmF1bHRRdWFsaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsZWRUZXh0OiBmYWlsZWRUb1NjYWxlVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZUV4aWY6IGluY2x1ZGVFeGlmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2c6IGxvZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZWNvcmRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXVpZDogb3JpZ2luYWxGaWxlVXVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsRmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBvcmlnaW5hbEJsb2Iuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2I6IGluY2x1ZGVPcmlnaW5hbCA/IG9yaWdpbmFsQmxvYiA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV1aWQ6IG9yaWdpbmFsRmlsZVV1aWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBvcmlnaW5hbEZpbGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogb3JpZ2luYWxCbG9iLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9iOiBvcmlnaW5hbEJsb2JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZU5ld0ZpbGU6IGZ1bmN0aW9uKGZpbGUsIG5hbWUsIHV1aWQsIHNpemUsIGZpbGVMaXN0LCBiYXRjaElkLCB1dWlkUGFyYW1OYW1lLCBhcGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGJ1dHRvbklkID0gZmlsZS5xcUJ1dHRvbklkIHx8IGZpbGUuYmxvYiAmJiBmaWxlLmJsb2IucXFCdXR0b25JZCwgc2NhbGVkSWRzID0gW10sIG9yaWdpbmFsSWQgPSBudWxsLCBhZGRGaWxlVG9IYW5kbGVyID0gYXBpLmFkZEZpbGVUb0hhbmRsZXIsIHVwbG9hZERhdGEgPSBhcGkudXBsb2FkRGF0YSwgcGFyYW1zU3RvcmUgPSBhcGkucGFyYW1zU3RvcmUsIHByb3h5R3JvdXBJZCA9IHFxLmdldFVuaXF1ZUlkKCk7XG4gICAgICAgICAgICAgICAgcXEuZWFjaChzZWxmLmdldEZpbGVSZWNvcmRzKHV1aWQsIG5hbWUsIGZpbGUpLCBmdW5jdGlvbihpZHgsIHJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvYlNpemUgPSByZWNvcmQuc2l6ZSwgaWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuYmxvYiBpbnN0YW5jZW9mIHFxLkJsb2JQcm94eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvYlNpemUgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZCA9IHVwbG9hZERhdGEuYWRkRmlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dWlkOiByZWNvcmQudXVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHJlY29yZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogYmxvYlNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXRjaElkOiBiYXRjaElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlHcm91cElkOiBwcm94eUdyb3VwSWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuYmxvYiBpbnN0YW5jZW9mIHFxLkJsb2JQcm94eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkSWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJZCA9IGlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuYmxvYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRmlsZVRvSGFuZGxlcihpZCwgcmVjb3JkLmJsb2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUxpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU6IHJlY29yZC5ibG9iXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZERhdGEuc2V0U3RhdHVzKGlkLCBxcS5zdGF0dXMuUkVKRUNURUQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChzY2FsZWRJZHMsIGZ1bmN0aW9uKGlkeCwgc2NhbGVkSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXFwYXJlbnR1dWlkOiB1cGxvYWREYXRhLnJldHJpZXZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG9yaWdpbmFsSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS51dWlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFxcGFyZW50c2l6ZTogdXBsb2FkRGF0YS5yZXRyaWV2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBvcmlnaW5hbElkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1t1dWlkUGFyYW1OYW1lXSA9IHVwbG9hZERhdGEucmV0cmlldmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzY2FsZWRJZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudXVpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZERhdGEuc2V0UGFyZW50SWQoc2NhbGVkSWQsIG9yaWdpbmFsSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zU3RvcmUuYWRkUmVhZE9ubHkoc2NhbGVkSWQsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGVkSWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtW3V1aWRQYXJhbU5hbWVdID0gdXBsb2FkRGF0YS5yZXRyaWV2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBvcmlnaW5hbElkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudXVpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNTdG9yZS5hZGRSZWFkT25seShvcmlnaW5hbElkLCBwYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHFxLmV4dGVuZChxcS5TY2FsZXIucHJvdG90eXBlLCB7XG4gICAgICAgIHNjYWxlSW1hZ2U6IGZ1bmN0aW9uKGlkLCBzcGVjcywgYXBpKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGlmICghcXEuc3VwcG9ydGVkRmVhdHVyZXMuc2NhbGluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBxcS5FcnJvcihcIlNjYWxpbmcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNjYWxpbmdFZmZvcnQgPSBuZXcgcXEuUHJvbWlzZSgpLCBsb2cgPSBhcGkubG9nLCBmaWxlID0gYXBpLmdldEZpbGUoaWQpLCB1cGxvYWREYXRhID0gYXBpLnVwbG9hZERhdGEucmV0cmlldmUoe1xuICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgfSksIG5hbWUgPSB1cGxvYWREYXRhICYmIHVwbG9hZERhdGEubmFtZSwgdXVpZCA9IHVwbG9hZERhdGEgJiYgdXBsb2FkRGF0YS51dWlkLCBzY2FsaW5nT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBjdXN0b21SZXNpemVyOiBzcGVjcy5jdXN0b21SZXNpemVyLFxuICAgICAgICAgICAgICAgIHNlbmRPcmlnaW5hbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgb3JpZW50OiBzcGVjcy5vcmllbnQsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFR5cGU6IHNwZWNzLnR5cGUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0UXVhbGl0eTogc3BlY3MucXVhbGl0eSxcbiAgICAgICAgICAgICAgICBmYWlsZWRUb1NjYWxlVGV4dDogXCJVbmFibGUgdG8gc2NhbGVcIixcbiAgICAgICAgICAgICAgICBzaXplczogWyB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIG1heFNpemU6IHNwZWNzLm1heFNpemVcbiAgICAgICAgICAgICAgICB9IF1cbiAgICAgICAgICAgIH0sIHNjYWxlciA9IG5ldyBxcS5TY2FsZXIoc2NhbGluZ09wdGlvbnMsIGxvZyk7XG4gICAgICAgICAgICBpZiAoIXFxLlNjYWxlciB8fCAhcXEuc3VwcG9ydGVkRmVhdHVyZXMuaW1hZ2VQcmV2aWV3cyB8fCAhZmlsZSkge1xuICAgICAgICAgICAgICAgIHNjYWxpbmdFZmZvcnQuZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgIGxvZyhcIkNvdWxkIG5vdCBnZW5lcmF0ZSByZXF1ZXN0ZWQgc2NhbGVkIGltYWdlIGZvciBcIiArIGlkICsgXCIuICBcIiArIFwiU2NhbGluZyBpcyBlaXRoZXIgbm90IHBvc3NpYmxlIGluIHRoaXMgYnJvd3Nlciwgb3IgdGhlIGZpbGUgY291bGQgbm90IGJlIGxvY2F0ZWQuXCIsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHFxLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSBzY2FsZXIuZ2V0RmlsZVJlY29yZHModXVpZCwgbmFtZSwgZmlsZSlbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQgJiYgcmVjb3JkLmJsb2IgaW5zdGFuY2VvZiBxcS5CbG9iUHJveHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZC5ibG9iLmNyZWF0ZSgpLnRoZW4oc2NhbGluZ0VmZm9ydC5zdWNjZXNzLCBzY2FsaW5nRWZmb3J0LmZhaWx1cmUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKGlkICsgXCIgaXMgbm90IGEgc2NhbGFibGUgaW1hZ2UhXCIsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsaW5nRWZmb3J0LmZhaWx1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NhbGluZ0VmZm9ydDtcbiAgICAgICAgfSxcbiAgICAgICAgX2RldGVybWluZU91dHB1dFR5cGU6IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RlZFR5cGUgPSBzcGVjLnJlcXVlc3RlZFR5cGUsIGRlZmF1bHRUeXBlID0gc3BlYy5kZWZhdWx0VHlwZSwgcmVmZXJlbmNlVHlwZSA9IHNwZWMucmVmVHlwZTtcbiAgICAgICAgICAgIGlmICghZGVmYXVsdFR5cGUgJiYgIXJlcXVlc3RlZFR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVmZXJlbmNlVHlwZSAhPT0gXCJpbWFnZS9qcGVnXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW1hZ2UvcG5nXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWZlcmVuY2VUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0ZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHFxLmluZGV4T2YoT2JqZWN0LmtleXMocXEuSWRlbnRpZnkucHJvdG90eXBlLlBSRVZJRVdBQkxFX01JTUVfVFlQRVMpLCByZXF1ZXN0ZWRUeXBlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RlZFR5cGUgPT09IFwiaW1hZ2UvdGlmZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxcS5zdXBwb3J0ZWRGZWF0dXJlcy50aWZmUHJldmlld3MgPyByZXF1ZXN0ZWRUeXBlIDogZGVmYXVsdFR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRUeXBlO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0TmFtZTogZnVuY3Rpb24ob3JpZ2luYWxOYW1lLCBzY2FsZWRWZXJzaW9uUHJvcGVydGllcykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICB2YXIgc3RhcnRPZkV4dCA9IG9yaWdpbmFsTmFtZS5sYXN0SW5kZXhPZihcIi5cIiksIHZlcnNpb25UeXBlID0gc2NhbGVkVmVyc2lvblByb3BlcnRpZXMudHlwZSB8fCBcImltYWdlL3BuZ1wiLCByZWZlcmVuY2VUeXBlID0gc2NhbGVkVmVyc2lvblByb3BlcnRpZXMucmVmVHlwZSwgc2NhbGVkTmFtZSA9IFwiXCIsIHNjYWxlZEV4dCA9IHFxLmdldEV4dGVuc2lvbihvcmlnaW5hbE5hbWUpLCBuYW1lQXBwZW5kYWdlID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChzY2FsZWRWZXJzaW9uUHJvcGVydGllcy5uYW1lICYmIHNjYWxlZFZlcnNpb25Qcm9wZXJ0aWVzLm5hbWUudHJpbSgpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG5hbWVBcHBlbmRhZ2UgPSBcIiAoXCIgKyBzY2FsZWRWZXJzaW9uUHJvcGVydGllcy5uYW1lICsgXCIpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnRPZkV4dCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc2NhbGVkTmFtZSA9IG9yaWdpbmFsTmFtZS5zdWJzdHIoMCwgc3RhcnRPZkV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZmVyZW5jZVR5cGUgIT09IHZlcnNpb25UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlZEV4dCA9IHZlcnNpb25UeXBlLnNwbGl0KFwiL1wiKVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2NhbGVkTmFtZSArPSBuYW1lQXBwZW5kYWdlICsgXCIuXCIgKyBzY2FsZWRFeHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYWxlZE5hbWUgPSBvcmlnaW5hbE5hbWUgKyBuYW1lQXBwZW5kYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNjYWxlZE5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRTb3J0ZWRTaXplczogZnVuY3Rpb24oc2l6ZXMpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgc2l6ZXMgPSBxcS5leHRlbmQoW10sIHNpemVzKTtcbiAgICAgICAgICAgIHJldHVybiBzaXplcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYS5tYXhTaXplID4gYi5tYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYS5tYXhTaXplIDwgYi5tYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dlbmVyYXRlU2NhbGVkSW1hZ2U6IGZ1bmN0aW9uKHNwZWMsIHNvdXJjZUZpbGUpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBjdXN0b21SZXNpemVGdW5jdGlvbiA9IHNwZWMuY3VzdG9tUmVzaXplRnVuY3Rpb24sIGxvZyA9IHNwZWMubG9nLCBtYXhTaXplID0gc3BlYy5tYXhTaXplLCBvcmllbnQgPSBzcGVjLm9yaWVudCwgdHlwZSA9IHNwZWMudHlwZSwgcXVhbGl0eSA9IHNwZWMucXVhbGl0eSwgZmFpbGVkVGV4dCA9IHNwZWMuZmFpbGVkVGV4dCwgaW5jbHVkZUV4aWYgPSBzcGVjLmluY2x1ZGVFeGlmICYmIHNvdXJjZUZpbGUudHlwZSA9PT0gXCJpbWFnZS9qcGVnXCIgJiYgdHlwZSA9PT0gXCJpbWFnZS9qcGVnXCIsIHNjYWxpbmdFZmZvcnQgPSBuZXcgcXEuUHJvbWlzZSgpLCBpbWFnZUdlbmVyYXRvciA9IG5ldyBxcS5JbWFnZUdlbmVyYXRvcihsb2cpLCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgbG9nKFwiQXR0ZW1wdGluZyB0byBnZW5lcmF0ZSBzY2FsZWQgdmVyc2lvbiBmb3IgXCIgKyBzb3VyY2VGaWxlLm5hbWUpO1xuICAgICAgICAgICAgaW1hZ2VHZW5lcmF0b3IuZ2VuZXJhdGUoc291cmNlRmlsZSwgY2FudmFzLCB7XG4gICAgICAgICAgICAgICAgbWF4U2l6ZTogbWF4U2l6ZSxcbiAgICAgICAgICAgICAgICBvcmllbnQ6IG9yaWVudCxcbiAgICAgICAgICAgICAgICBjdXN0b21SZXNpemVGdW5jdGlvbjogY3VzdG9tUmVzaXplRnVuY3Rpb25cbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlZEltYWdlRGF0YVVyaSA9IGNhbnZhcy50b0RhdGFVUkwodHlwZSwgcXVhbGl0eSksIHNpZ25hbFN1Y2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwiU3VjY2VzcyBnZW5lcmF0aW5nIHNjYWxlZCB2ZXJzaW9uIGZvciBcIiArIHNvdXJjZUZpbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9iID0gcXEuZGF0YVVyaVRvQmxvYihzY2FsZWRJbWFnZURhdGFVcmkpO1xuICAgICAgICAgICAgICAgICAgICBzY2FsaW5nRWZmb3J0LnN1Y2Nlc3MoYmxvYik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZUV4aWYpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faW5zZXJ0RXhpZkhlYWRlcihzb3VyY2VGaWxlLCBzY2FsZWRJbWFnZURhdGFVcmksIGxvZykudGhlbihmdW5jdGlvbihzY2FsZWRJbWFnZURhdGFVcmlXaXRoRXhpZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkSW1hZ2VEYXRhVXJpID0gc2NhbGVkSW1hZ2VEYXRhVXJpV2l0aEV4aWY7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWxTdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKFwiUHJvYmxlbSBpbnNlcnRpbmcgRVhJRiBoZWFkZXIgaW50byBzY2FsZWQgaW1hZ2UuICBVc2luZyBzY2FsZWQgaW1hZ2Ugdy9vdXQgRVhJRiBkYXRhLlwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsU3VjY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaWduYWxTdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbG9nKFwiRmFpbGVkIGF0dGVtcHQgdG8gZ2VuZXJhdGUgc2NhbGVkIHZlcnNpb24gZm9yIFwiICsgc291cmNlRmlsZS5uYW1lLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgIHNjYWxpbmdFZmZvcnQuZmFpbHVyZShmYWlsZWRUZXh0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNjYWxpbmdFZmZvcnQ7XG4gICAgICAgIH0sXG4gICAgICAgIF9pbnNlcnRFeGlmSGVhZGVyOiBmdW5jdGlvbihvcmlnaW5hbEltYWdlLCBzY2FsZWRJbWFnZURhdGFVcmksIGxvZykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKSwgaW5zZXJ0aW9uRWZmb3J0ID0gbmV3IHFxLlByb21pc2UoKSwgb3JpZ2luYWxJbWFnZURhdGFVcmkgPSBcIlwiO1xuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsSW1hZ2VEYXRhVXJpID0gcmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgICAgICBpbnNlcnRpb25FZmZvcnQuc3VjY2VzcyhxcS5FeGlmUmVzdG9yZXIucmVzdG9yZShvcmlnaW5hbEltYWdlRGF0YVVyaSwgc2NhbGVkSW1hZ2VEYXRhVXJpKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBsb2coXCJQcm9ibGVtIHJlYWRpbmcgXCIgKyBvcmlnaW5hbEltYWdlLm5hbWUgKyBcIiBkdXJpbmcgYXR0ZW1wdCB0byB0cmFuc2ZlciBFWElGIGRhdGEgdG8gc2NhbGVkIHZlcnNpb24uXCIsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgaW5zZXJ0aW9uRWZmb3J0LmZhaWx1cmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChvcmlnaW5hbEltYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnRpb25FZmZvcnQ7XG4gICAgICAgIH0sXG4gICAgICAgIF9kYXRhVXJpVG9CbG9iOiBmdW5jdGlvbihkYXRhVXJpKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIHZhciBieXRlU3RyaW5nLCBtaW1lU3RyaW5nLCBhcnJheUJ1ZmZlciwgaW50QXJyYXk7XG4gICAgICAgICAgICBpZiAoZGF0YVVyaS5zcGxpdChcIixcIilbMF0uaW5kZXhPZihcImJhc2U2NFwiKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZVN0cmluZyA9IGF0b2IoZGF0YVVyaS5zcGxpdChcIixcIilbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBieXRlU3RyaW5nID0gZGVjb2RlVVJJKGRhdGFVcmkuc3BsaXQoXCIsXCIpWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1pbWVTdHJpbmcgPSBkYXRhVXJpLnNwbGl0KFwiLFwiKVswXS5zcGxpdChcIjpcIilbMV0uc3BsaXQoXCI7XCIpWzBdO1xuICAgICAgICAgICAgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVN0cmluZy5sZW5ndGgpO1xuICAgICAgICAgICAgaW50QXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICBxcS5lYWNoKGJ5dGVTdHJpbmcsIGZ1bmN0aW9uKGlkeCwgY2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgaW50QXJyYXlbaWR4XSA9IGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQmxvYihhcnJheUJ1ZmZlciwgbWltZVN0cmluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9jcmVhdGVCbG9iOiBmdW5jdGlvbihkYXRhLCBtaW1lKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIHZhciBCbG9iQnVpbGRlciA9IHdpbmRvdy5CbG9iQnVpbGRlciB8fCB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1vekJsb2JCdWlsZGVyIHx8IHdpbmRvdy5NU0Jsb2JCdWlsZGVyLCBibG9iQnVpbGRlciA9IEJsb2JCdWlsZGVyICYmIG5ldyBCbG9iQnVpbGRlcigpO1xuICAgICAgICAgICAgaWYgKGJsb2JCdWlsZGVyKSB7XG4gICAgICAgICAgICAgICAgYmxvYkJ1aWxkZXIuYXBwZW5kKGRhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBibG9iQnVpbGRlci5nZXRCbG9iKG1pbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJsb2IoWyBkYXRhIF0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbWltZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcXEuRXhpZlJlc3RvcmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBFeGlmUmVzdG9yZXIgPSB7fTtcbiAgICAgICAgRXhpZlJlc3RvcmVyLktFWV9TVFIgPSBcIkFCQ0RFRkdISUpLTE1OT1BcIiArIFwiUVJTVFVWV1hZWmFiY2RlZlwiICsgXCJnaGlqa2xtbm9wcXJzdHV2XCIgKyBcInd4eXowMTIzNDU2Nzg5Ky9cIiArIFwiPVwiO1xuICAgICAgICBFeGlmUmVzdG9yZXIuZW5jb2RlNjQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IFwiXCIsIGNocjEsIGNocjIsIGNocjMgPSBcIlwiLCBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0ID0gXCJcIiwgaSA9IDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY2hyMSA9IGlucHV0W2krK107XG4gICAgICAgICAgICAgICAgY2hyMiA9IGlucHV0W2krK107XG4gICAgICAgICAgICAgICAgY2hyMyA9IGlucHV0W2krK107XG4gICAgICAgICAgICAgICAgZW5jMSA9IGNocjEgPj4gMjtcbiAgICAgICAgICAgICAgICBlbmMyID0gKGNocjEgJiAzKSA8PCA0IHwgY2hyMiA+PiA0O1xuICAgICAgICAgICAgICAgIGVuYzMgPSAoY2hyMiAmIDE1KSA8PCAyIHwgY2hyMyA+PiA2O1xuICAgICAgICAgICAgICAgIGVuYzQgPSBjaHIzICYgNjM7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGNocjIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuYzMgPSBlbmM0ID0gNjQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hTihjaHIzKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmM0ID0gNjQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIHRoaXMuS0VZX1NUUi5jaGFyQXQoZW5jMSkgKyB0aGlzLktFWV9TVFIuY2hhckF0KGVuYzIpICsgdGhpcy5LRVlfU1RSLmNoYXJBdChlbmMzKSArIHRoaXMuS0VZX1NUUi5jaGFyQXQoZW5jNCk7XG4gICAgICAgICAgICAgICAgY2hyMSA9IGNocjIgPSBjaHIzID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbmMxID0gZW5jMiA9IGVuYzMgPSBlbmM0ID0gXCJcIjtcbiAgICAgICAgICAgIH0gd2hpbGUgKGkgPCBpbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICAgICAgRXhpZlJlc3RvcmVyLnJlc3RvcmUgPSBmdW5jdGlvbihvcmlnRmlsZUJhc2U2NCwgcmVzaXplZEZpbGVCYXNlNjQpIHtcbiAgICAgICAgICAgIHZhciBleHBlY3RlZEJhc2U2NEhlYWRlciA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxcIjtcbiAgICAgICAgICAgIGlmICghb3JpZ0ZpbGVCYXNlNjQubWF0Y2goZXhwZWN0ZWRCYXNlNjRIZWFkZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc2l6ZWRGaWxlQmFzZTY0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJhd0ltYWdlID0gdGhpcy5kZWNvZGU2NChvcmlnRmlsZUJhc2U2NC5yZXBsYWNlKGV4cGVjdGVkQmFzZTY0SGVhZGVyLCBcIlwiKSk7XG4gICAgICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNsaWNlMlNlZ21lbnRzKHJhd0ltYWdlKTtcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IHRoaXMuZXhpZk1hbmlwdWxhdGlvbihyZXNpemVkRmlsZUJhc2U2NCwgc2VnbWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkQmFzZTY0SGVhZGVyICsgdGhpcy5lbmNvZGU2NChpbWFnZSk7XG4gICAgICAgIH07XG4gICAgICAgIEV4aWZSZXN0b3Jlci5leGlmTWFuaXB1bGF0aW9uID0gZnVuY3Rpb24ocmVzaXplZEZpbGVCYXNlNjQsIHNlZ21lbnRzKSB7XG4gICAgICAgICAgICB2YXIgZXhpZkFycmF5ID0gdGhpcy5nZXRFeGlmQXJyYXkoc2VnbWVudHMpLCBuZXdJbWFnZUFycmF5ID0gdGhpcy5pbnNlcnRFeGlmKHJlc2l6ZWRGaWxlQmFzZTY0LCBleGlmQXJyYXkpLCBhQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobmV3SW1hZ2VBcnJheSk7XG4gICAgICAgICAgICByZXR1cm4gYUJ1ZmZlcjtcbiAgICAgICAgfTtcbiAgICAgICAgRXhpZlJlc3RvcmVyLmdldEV4aWZBcnJheSA9IGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG4gICAgICAgICAgICB2YXIgc2VnO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBzZWdtZW50cy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgICAgIHNlZyA9IHNlZ21lbnRzW3hdO1xuICAgICAgICAgICAgICAgIGlmIChzZWdbMF0gPT0gMjU1ICYgc2VnWzFdID09IDIyNSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgRXhpZlJlc3RvcmVyLmluc2VydEV4aWYgPSBmdW5jdGlvbihyZXNpemVkRmlsZUJhc2U2NCwgZXhpZkFycmF5KSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2VEYXRhID0gcmVzaXplZEZpbGVCYXNlNjQucmVwbGFjZShcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsXCIsIFwiXCIpLCBidWYgPSB0aGlzLmRlY29kZTY0KGltYWdlRGF0YSksIHNlcGFyYXRlUG9pbnQgPSBidWYuaW5kZXhPZigyNTUsIDMpLCBtYWUgPSBidWYuc2xpY2UoMCwgc2VwYXJhdGVQb2ludCksIGF0byA9IGJ1Zi5zbGljZShzZXBhcmF0ZVBvaW50KSwgYXJyYXkgPSBtYWU7XG4gICAgICAgICAgICBhcnJheSA9IGFycmF5LmNvbmNhdChleGlmQXJyYXkpO1xuICAgICAgICAgICAgYXJyYXkgPSBhcnJheS5jb25jYXQoYXRvKTtcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfTtcbiAgICAgICAgRXhpZlJlc3RvcmVyLnNsaWNlMlNlZ21lbnRzID0gZnVuY3Rpb24ocmF3SW1hZ2VBcnJheSkge1xuICAgICAgICAgICAgdmFyIGhlYWQgPSAwLCBzZWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICBpZiAocmF3SW1hZ2VBcnJheVtoZWFkXSA9PSAyNTUgJiByYXdJbWFnZUFycmF5W2hlYWQgKyAxXSA9PSAyMTgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyYXdJbWFnZUFycmF5W2hlYWRdID09IDI1NSAmIHJhd0ltYWdlQXJyYXlbaGVhZCArIDFdID09IDIxNikge1xuICAgICAgICAgICAgICAgICAgICBoZWFkICs9IDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHJhd0ltYWdlQXJyYXlbaGVhZCArIDJdICogMjU2ICsgcmF3SW1hZ2VBcnJheVtoZWFkICsgM10sIGVuZFBvaW50ID0gaGVhZCArIGxlbmd0aCArIDIsIHNlZyA9IHJhd0ltYWdlQXJyYXkuc2xpY2UoaGVhZCwgZW5kUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHNlZyk7XG4gICAgICAgICAgICAgICAgICAgIGhlYWQgPSBlbmRQb2ludDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhlYWQgPiByYXdJbWFnZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VnbWVudHM7XG4gICAgICAgIH07XG4gICAgICAgIEV4aWZSZXN0b3Jlci5kZWNvZGU2NCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gXCJcIiwgY2hyMSwgY2hyMiwgY2hyMyA9IFwiXCIsIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQgPSBcIlwiLCBpID0gMCwgYnVmID0gW107XG4gICAgICAgICAgICB2YXIgYmFzZTY0dGVzdCA9IC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZztcbiAgICAgICAgICAgIGlmIChiYXNlNjR0ZXN0LmV4ZWMoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgd2VyZSBpbnZhbGlkIGJhc2U2NCBjaGFyYWN0ZXJzIGluIHRoZSBpbnB1dCB0ZXh0LiAgXCIgKyBcIlZhbGlkIGJhc2U2NCBjaGFyYWN0ZXJzIGFyZSBBLVosIGEteiwgMC05LCAnKycsICcvJyxhbmQgJz0nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgXCJcIik7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgZW5jMSA9IHRoaXMuS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgICAgICAgICBlbmMyID0gdGhpcy5LRVlfU1RSLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICAgICAgICAgIGVuYzMgPSB0aGlzLktFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgICAgICAgICAgZW5jNCA9IHRoaXMuS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgICAgICAgICBjaHIxID0gZW5jMSA8PCAyIHwgZW5jMiA+PiA0O1xuICAgICAgICAgICAgICAgIGNocjIgPSAoZW5jMiAmIDE1KSA8PCA0IHwgZW5jMyA+PiAyO1xuICAgICAgICAgICAgICAgIGNocjMgPSAoZW5jMyAmIDMpIDw8IDYgfCBlbmM0O1xuICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKGNocjEpO1xuICAgICAgICAgICAgICAgIGlmIChlbmMzICE9IDY0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKGNocjIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW5jNCAhPSA2NCkge1xuICAgICAgICAgICAgICAgICAgICBidWYucHVzaChjaHIzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hyMSA9IGNocjIgPSBjaHIzID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbmMxID0gZW5jMiA9IGVuYzMgPSBlbmM0ID0gXCJcIjtcbiAgICAgICAgICAgIH0gd2hpbGUgKGkgPCBpbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEV4aWZSZXN0b3JlcjtcbiAgICB9KCk7XG4gICAgcXEuVG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBnZXRTaXplKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgcGVyRmlsZVByb2dyZXNzID0ge30sIHRvdGFsTG9hZGVkID0gMCwgdG90YWxTaXplID0gMCwgbGFzdExvYWRlZFNlbnQgPSAtMSwgbGFzdFRvdGFsU2VudCA9IC0xLCBjYWxsYmFja1Byb3h5ID0gZnVuY3Rpb24obG9hZGVkLCB0b3RhbCkge1xuICAgICAgICAgICAgaWYgKGxvYWRlZCAhPT0gbGFzdExvYWRlZFNlbnQgfHwgdG90YWwgIT09IGxhc3RUb3RhbFNlbnQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhsb2FkZWQsIHRvdGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RMb2FkZWRTZW50ID0gbG9hZGVkO1xuICAgICAgICAgICAgbGFzdFRvdGFsU2VudCA9IHRvdGFsO1xuICAgICAgICB9LCBub1JldHJ5YWJsZUZpbGVzID0gZnVuY3Rpb24oZmFpbGVkLCByZXRyeWFibGUpIHtcbiAgICAgICAgICAgIHZhciBub25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHFxLmVhY2goZmFpbGVkLCBmdW5jdGlvbihpZHgsIGZhaWxlZElkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHFxLmluZGV4T2YocmV0cnlhYmxlLCBmYWlsZWRJZCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBub25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBub25lO1xuICAgICAgICB9LCBvbkNhbmNlbCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICB1cGRhdGVUb3RhbFByb2dyZXNzKGlkLCAtMSwgLTEpO1xuICAgICAgICAgICAgZGVsZXRlIHBlckZpbGVQcm9ncmVzc1tpZF07XG4gICAgICAgIH0sIG9uQWxsQ29tcGxldGUgPSBmdW5jdGlvbihzdWNjZXNzZnVsLCBmYWlsZWQsIHJldHJ5YWJsZSkge1xuICAgICAgICAgICAgaWYgKGZhaWxlZC5sZW5ndGggPT09IDAgfHwgbm9SZXRyeWFibGVGaWxlcyhmYWlsZWQsIHJldHJ5YWJsZSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja1Byb3h5KHRvdGFsU2l6ZSwgdG90YWxTaXplKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIG9uTmV3ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gZ2V0U2l6ZShpZCk7XG4gICAgICAgICAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb3RhbFByb2dyZXNzKGlkLCAwLCBzaXplKTtcbiAgICAgICAgICAgICAgICBwZXJGaWxlUHJvZ3Jlc3NbaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBsb2FkZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsOiBzaXplXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdXBkYXRlVG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uKGlkLCBuZXdMb2FkZWQsIG5ld1RvdGFsKSB7XG4gICAgICAgICAgICB2YXIgb2xkTG9hZGVkID0gcGVyRmlsZVByb2dyZXNzW2lkXSA/IHBlckZpbGVQcm9ncmVzc1tpZF0ubG9hZGVkIDogMCwgb2xkVG90YWwgPSBwZXJGaWxlUHJvZ3Jlc3NbaWRdID8gcGVyRmlsZVByb2dyZXNzW2lkXS50b3RhbCA6IDA7XG4gICAgICAgICAgICBpZiAobmV3TG9hZGVkID09PSAtMSAmJiBuZXdUb3RhbCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0b3RhbExvYWRlZCAtPSBvbGRMb2FkZWQ7XG4gICAgICAgICAgICAgICAgdG90YWxTaXplIC09IG9sZFRvdGFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3TG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsTG9hZGVkICs9IG5ld0xvYWRlZCAtIG9sZExvYWRlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBuZXdUb3RhbCAtIG9sZFRvdGFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrUHJveHkodG90YWxMb2FkZWQsIHRvdGFsU2l6ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBvbkFsbENvbXBsZXRlOiBvbkFsbENvbXBsZXRlLFxuICAgICAgICAgICAgb25TdGF0dXNDaGFuZ2U6IGZ1bmN0aW9uKGlkLCBvbGRTdGF0dXMsIG5ld1N0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0dXMgPT09IHFxLnN0YXR1cy5DQU5DRUxFRCB8fCBuZXdTdGF0dXMgPT09IHFxLnN0YXR1cy5SRUpFQ1RFRCkge1xuICAgICAgICAgICAgICAgICAgICBvbkNhbmNlbChpZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdTdGF0dXMgPT09IHFxLnN0YXR1cy5TVUJNSVRUSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uTmV3KGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25JbmRpdmlkdWFsUHJvZ3Jlc3M6IGZ1bmN0aW9uKGlkLCBsb2FkZWQsIHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVG90YWxQcm9ncmVzcyhpZCwgbG9hZGVkLCB0b3RhbCk7XG4gICAgICAgICAgICAgICAgcGVyRmlsZVByb2dyZXNzW2lkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkOiBsb2FkZWQsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsOiB0b3RhbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25OZXdTaXplOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIG9uTmV3KGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcGVyRmlsZVByb2dyZXNzID0ge307XG4gICAgICAgICAgICAgICAgdG90YWxMb2FkZWQgPSAwO1xuICAgICAgICAgICAgICAgIHRvdGFsU2l6ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcXEuUGFzdGVTdXBwb3J0ID0gZnVuY3Rpb24obykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIG9wdGlvbnMsIGRldGFjaFBhc3RlSGFuZGxlcjtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRhcmdldEVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKG1lc3NhZ2UsIGxldmVsKSB7fSxcbiAgICAgICAgICAgICAgICBwYXN0ZVJlY2VpdmVkOiBmdW5jdGlvbihibG9iKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBpc0ltYWdlKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnR5cGUgJiYgaXRlbS50eXBlLmluZGV4T2YoXCJpbWFnZS9cIikgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJQYXN0ZUhhbmRsZXIoKSB7XG4gICAgICAgICAgICBkZXRhY2hQYXN0ZUhhbmRsZXIgPSBxcShvcHRpb25zLnRhcmdldEVsZW1lbnQpLmF0dGFjaChcInBhc3RlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsaXBib2FyZERhdGEgPSBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgICAgICAgICAgICAgIGlmIChjbGlwYm9hcmREYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHFxLmVhY2goY2xpcGJvYXJkRGF0YS5pdGVtcywgZnVuY3Rpb24oaWR4LCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbWFnZShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9iID0gaXRlbS5nZXRBc0ZpbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrcy5wYXN0ZVJlY2VpdmVkKGJsb2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1bnJlZ2lzdGVyUGFzdGVIYW5kbGVyKCkge1xuICAgICAgICAgICAgaWYgKGRldGFjaFBhc3RlSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGRldGFjaFBhc3RlSGFuZGxlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHFxLmV4dGVuZChvcHRpb25zLCBvKTtcbiAgICAgICAgcmVnaXN0ZXJQYXN0ZUhhbmRsZXIoKTtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyUGFzdGVIYW5kbGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcXEuRm9ybVN1cHBvcnQgPSBmdW5jdGlvbihvcHRpb25zLCBzdGFydFVwbG9hZCwgbG9nKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGludGVyY2VwdFN1Ym1pdCA9IG9wdGlvbnMuaW50ZXJjZXB0U3VibWl0LCBmb3JtRWwgPSBvcHRpb25zLmVsZW1lbnQsIGF1dG9VcGxvYWQgPSBvcHRpb25zLmF1dG9VcGxvYWQ7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBuZXdFbmRwb2ludDogbnVsbCxcbiAgICAgICAgICAgIG5ld0F1dG9VcGxvYWQ6IGF1dG9VcGxvYWQsXG4gICAgICAgICAgICBhdHRhY2hlZFRvRm9ybTogZmFsc2UsXG4gICAgICAgICAgICBnZXRGb3JtSW5wdXRzQXNPYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChmb3JtRWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2Zvcm0yT2JqKGZvcm1FbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBkZXRlcm1pbmVOZXdFbmRwb2ludChmb3JtRWwpIHtcbiAgICAgICAgICAgIGlmIChmb3JtRWwuZ2V0QXR0cmlidXRlKFwiYWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5uZXdFbmRwb2ludCA9IGZvcm1FbC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVGb3JtKGZvcm1FbCwgbmF0aXZlU3VibWl0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybUVsLmNoZWNrVmFsaWRpdHkgJiYgIWZvcm1FbC5jaGVja1ZhbGlkaXR5KCkpIHtcbiAgICAgICAgICAgICAgICBsb2coXCJGb3JtIGRpZCBub3QgcGFzcyB2YWxpZGF0aW9uIGNoZWNrcyAtIHdpbGwgbm90IHVwbG9hZC5cIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICBuYXRpdmVTdWJtaXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWF5YmVVcGxvYWRPblN1Ym1pdChmb3JtRWwpIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVTdWJtaXQgPSBmb3JtRWwuc3VibWl0O1xuICAgICAgICAgICAgcXEoZm9ybUVsKS5hdHRhY2goXCJzdWJtaXRcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUZvcm0oZm9ybUVsLCBuYXRpdmVTdWJtaXQpICYmIHN0YXJ0VXBsb2FkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvcm1FbC5zdWJtaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUZvcm0oZm9ybUVsLCBuYXRpdmVTdWJtaXQpICYmIHN0YXJ0VXBsb2FkKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRldGVybWluZUZvcm1FbChmb3JtRWwpIHtcbiAgICAgICAgICAgIGlmIChmb3JtRWwpIHtcbiAgICAgICAgICAgICAgICBpZiAocXEuaXNTdHJpbmcoZm9ybUVsKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3JtRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmb3JtRWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm9ybUVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIkF0dGFjaGluZyB0byBmb3JtIGVsZW1lbnQuXCIpO1xuICAgICAgICAgICAgICAgICAgICBkZXRlcm1pbmVOZXdFbmRwb2ludChmb3JtRWwpO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcmNlcHRTdWJtaXQgJiYgbWF5YmVVcGxvYWRPblN1Ym1pdChmb3JtRWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtRWw7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybUVsID0gZGV0ZXJtaW5lRm9ybUVsKGZvcm1FbCk7XG4gICAgICAgIHRoaXMuYXR0YWNoZWRUb0Zvcm0gPSAhIWZvcm1FbDtcbiAgICB9O1xuICAgIHFxLmV4dGVuZChxcS5Gb3JtU3VwcG9ydC5wcm90b3R5cGUsIHtcbiAgICAgICAgX2Zvcm0yT2JqOiBmdW5jdGlvbihmb3JtKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIHZhciBvYmogPSB7fSwgbm90SXJyZWxldmFudFR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlycmVsZXZhbnRUeXBlcyA9IFsgXCJidXR0b25cIiwgXCJpbWFnZVwiLCBcInJlc2V0XCIsIFwic3VibWl0XCIgXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXEuaW5kZXhPZihpcnJlbGV2YW50VHlwZXMsIHR5cGUudG9Mb3dlckNhc2UoKSkgPCAwO1xuICAgICAgICAgICAgfSwgcmFkaW9PckNoZWNrYm94ID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxcS5pbmRleE9mKFsgXCJjaGVja2JveFwiLCBcInJhZGlvXCIgXSwgdHlwZS50b0xvd2VyQ2FzZSgpKSA+PSAwO1xuICAgICAgICAgICAgfSwgaWdub3JlVmFsdWUgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIGlmIChyYWRpb09yQ2hlY2tib3goZWwudHlwZSkgJiYgIWVsLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbC5kaXNhYmxlZCAmJiBlbC50eXBlLnRvTG93ZXJDYXNlKCkgIT09IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICB9LCBzZWxlY3RWYWx1ZSA9IGZ1bmN0aW9uKHNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcXEuZWFjaChxcShzZWxlY3QpLmNoaWxkcmVuKCksIGZ1bmN0aW9uKGlkeCwgY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJvcHRpb25cIiAmJiBjaGlsZC5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjaGlsZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBxcS5lYWNoKGZvcm0uZWxlbWVudHMsIGZ1bmN0aW9uKGlkeCwgZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHFxLmlzSW5wdXQoZWwsIHRydWUpIHx8IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0YXJlYVwiKSAmJiBub3RJcnJlbGV2YW50VHlwZShlbC50eXBlKSAmJiAhaWdub3JlVmFsdWUoZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtlbC5uYW1lXSA9IGVsLnZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInNlbGVjdFwiICYmICFpZ25vcmVWYWx1ZShlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VsZWN0VmFsdWUoZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtlbC5uYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcXEuQ3J5cHRvSlMgPSBmdW5jdGlvbihNYXRoLCB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIEMgPSB7fTtcbiAgICAgICAgdmFyIENfbGliID0gQy5saWIgPSB7fTtcbiAgICAgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBGKCkge31cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbihvdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgRi5wcm90b3R5cGUgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VidHlwZSA9IG5ldyBGKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUubWl4SW4ob3ZlcnJpZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN1YnR5cGUuaGFzT3duUHJvcGVydHkoXCJpbml0XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdC5wcm90b3R5cGUgPSBzdWJ0eXBlO1xuICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlciA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5leHRlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuaW5pdC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgICAgICBtaXhJbjogZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IHByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcInRvU3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvU3RyaW5nID0gcHJvcGVydGllcy50b1N0cmluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0LnByb3RvdHlwZS5leHRlbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuICAgICAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5ID0gQmFzZS5leHRlbmQoe1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24od29yZHMsIHNpZ0J5dGVzKSB7XG4gICAgICAgICAgICAgICAgd29yZHMgPSB0aGlzLndvcmRzID0gd29yZHMgfHwgW107XG4gICAgICAgICAgICAgICAgaWYgKHNpZ0J5dGVzICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gc2lnQnl0ZXM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbihlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChlbmNvZGVyIHx8IEhleCkuc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmNhdDogZnVuY3Rpb24od29yZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoaXNXb3JkcyA9IHRoaXMud29yZHM7XG4gICAgICAgICAgICAgICAgdmFyIHRoYXRXb3JkcyA9IHdvcmRBcnJheS53b3JkcztcbiAgICAgICAgICAgICAgICB2YXIgdGhpc1NpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcbiAgICAgICAgICAgICAgICB2YXIgdGhhdFNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xhbXAoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1NpZ0J5dGVzICUgNCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdEJ5dGUgPSB0aGF0V29yZHNbaSA+Pj4gMl0gPj4+IDI0IC0gaSAlIDQgKiA4ICYgMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzW3RoaXNTaWdCeXRlcyArIGkgPj4+IDJdIHw9IHRoYXRCeXRlIDw8IDI0IC0gKHRoaXNTaWdCeXRlcyArIGkpICUgNCAqIDg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoYXRXb3Jkcy5sZW5ndGggPiA2NTUzNSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSArPSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbdGhpc1NpZ0J5dGVzICsgaSA+Pj4gMl0gPSB0aGF0V29yZHNbaSA+Pj4gMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHMucHVzaC5hcHBseSh0aGlzV29yZHMsIHRoYXRXb3Jkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgKz0gdGhhdFNpZ0J5dGVzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsYW1wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgd29yZHMgPSB0aGlzLndvcmRzO1xuICAgICAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG4gICAgICAgICAgICAgICAgd29yZHNbc2lnQnl0ZXMgPj4+IDJdICY9IDQyOTQ5NjcyOTUgPDwgMzIgLSBzaWdCeXRlcyAlIDQgKiA4O1xuICAgICAgICAgICAgICAgIHdvcmRzLmxlbmd0aCA9IE1hdGguY2VpbChzaWdCeXRlcyAvIDQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgY2xvbmUud29yZHMgPSB0aGlzLndvcmRzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByYW5kb206IGZ1bmN0aW9uKG5CeXRlcykge1xuICAgICAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkJ5dGVzOyBpICs9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgd29yZHMucHVzaChNYXRoLnJhbmRvbSgpICogNDI5NDk2NzI5NiB8IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBuQnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIENfZW5jID0gQy5lbmMgPSB7fTtcbiAgICAgICAgdmFyIEhleCA9IENfZW5jLkhleCA9IHtcbiAgICAgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24od29yZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuICAgICAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcbiAgICAgICAgICAgICAgICB2YXIgaGV4Q2hhcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSB3b3Jkc1tpID4+PiAyXSA+Pj4gMjQgLSBpICUgNCAqIDggJiAyNTU7XG4gICAgICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgPj4+IDQpLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgJiAxNSkudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleENoYXJzLmpvaW4oXCJcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKGhleFN0cikge1xuICAgICAgICAgICAgICAgIHZhciBoZXhTdHJMZW5ndGggPSBoZXhTdHIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGV4U3RyTGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gM10gfD0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cihpLCAyKSwgMTYpIDw8IDI0IC0gaSAlIDggKiA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBoZXhTdHJMZW5ndGggLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIExhdGluMSA9IENfZW5jLkxhdGluMSA9IHtcbiAgICAgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24od29yZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuICAgICAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcbiAgICAgICAgICAgICAgICB2YXIgbGF0aW4xQ2hhcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSB3b3Jkc1tpID4+PiAyXSA+Pj4gMjQgLSBpICUgNCAqIDggJiAyNTU7XG4gICAgICAgICAgICAgICAgICAgIGxhdGluMUNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiaXRlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsYXRpbjFDaGFycy5qb2luKFwiXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbihsYXRpbjFTdHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF0aW4xU3RyTGVuZ3RoID0gbGF0aW4xU3RyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGluMVN0ckxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDJdIHw9IChsYXRpbjFTdHIuY2hhckNvZGVBdChpKSAmIDI1NSkgPDwgMjQgLSBpICUgNCAqIDg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGxhdGluMVN0ckxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmOCA9IHtcbiAgICAgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24od29yZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgVVRGLTggZGF0YVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKHV0ZjhTdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTGF0aW4xLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1dGY4U3RyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBCYXNlLmV4dGVuZCh7XG4gICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBXb3JkQXJyYXkuaW5pdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgPSAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9hcHBlbmQ6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gVXRmOC5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YS5jb25jYXQoZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyArPSBkYXRhLnNpZ0J5dGVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9wcm9jZXNzOiBmdW5jdGlvbihkb0ZsdXNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xuICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuICAgICAgICAgICAgICAgIHZhciBuQmxvY2tzUmVhZHkgPSBkYXRhU2lnQnl0ZXMgLyBibG9ja1NpemVCeXRlcztcbiAgICAgICAgICAgICAgICBpZiAoZG9GbHVzaCkge1xuICAgICAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLmNlaWwobkJsb2Nrc1JlYWR5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLm1heCgobkJsb2Nrc1JlYWR5IHwgMCkgLSB0aGlzLl9taW5CdWZmZXJTaXplLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG5Xb3Jkc1JlYWR5ID0gbkJsb2Nrc1JlYWR5ICogYmxvY2tTaXplO1xuICAgICAgICAgICAgICAgIHZhciBuQnl0ZXNSZWFkeSA9IE1hdGgubWluKG5Xb3Jkc1JlYWR5ICogNCwgZGF0YVNpZ0J5dGVzKTtcbiAgICAgICAgICAgICAgICBpZiAobldvcmRzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSBibG9ja1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUHJvY2Vzc0Jsb2NrKGRhdGFXb3Jkcywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc2VkV29yZHMgPSBkYXRhV29yZHMuc3BsaWNlKDAsIG5Xb3Jkc1JlYWR5KTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuQnl0ZXNSZWFkeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdChwcm9jZXNzZWRXb3JkcywgbkJ5dGVzUmVhZHkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgY2xvbmUuX2RhdGEgPSB0aGlzLl9kYXRhLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9taW5CdWZmZXJTaXplOiAwXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xuICAgICAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oY2ZnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbihtZXNzYWdlVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24obWVzc2FnZVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmxvY2tTaXplOiA1MTIgLyAzMixcbiAgICAgICAgICAgIF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uKGhhc2hlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihtZXNzYWdlLCBjZmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBoYXNoZXIuaW5pdChjZmcpLmZpbmFsaXplKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NyZWF0ZUhtYWNIZWxwZXI6IGZ1bmN0aW9uKGhhc2hlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihtZXNzYWdlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDX2FsZ28uSE1BQy5pbml0KGhhc2hlciwga2V5KS5maW5hbGl6ZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIENfYWxnbyA9IEMuYWxnbyA9IHt9O1xuICAgICAgICByZXR1cm4gQztcbiAgICB9KE1hdGgpO1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIEMgPSBxcS5DcnlwdG9KUztcbiAgICAgICAgdmFyIENfbGliID0gQy5saWI7XG4gICAgICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG4gICAgICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuICAgICAgICB2YXIgQmFzZTY0ID0gQ19lbmMuQmFzZTY0ID0ge1xuICAgICAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbih3b3JkQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG4gICAgICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gICAgICAgICAgICAgICAgd29yZEFycmF5LmNsYW1wKCk7XG4gICAgICAgICAgICAgICAgdmFyIGJhc2U2NENoYXJzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBieXRlMSA9IHdvcmRzW2kgPj4+IDJdID4+PiAyNCAtIGkgJSA0ICogOCAmIDI1NTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGUyID0gd29yZHNbaSArIDEgPj4+IDJdID4+PiAyNCAtIChpICsgMSkgJSA0ICogOCAmIDI1NTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGUzID0gd29yZHNbaSArIDIgPj4+IDJdID4+PiAyNCAtIChpICsgMikgJSA0ICogOCAmIDI1NTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyaXBsZXQgPSBieXRlMSA8PCAxNiB8IGJ5dGUyIDw8IDggfCBieXRlMztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA0ICYmIGkgKyBqICogLjc1IDwgc2lnQnl0ZXM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChtYXAuY2hhckF0KHRyaXBsZXQgPj4+IDYgKiAoMyAtIGopICYgNjMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcbiAgICAgICAgICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJhc2U2NENoYXJzLmxlbmd0aCAlIDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gocGFkZGluZ0NoYXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNjRDaGFycy5qb2luKFwiXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbihiYXNlNjRTdHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmFzZTY0U3RyTGVuZ3RoID0gYmFzZTY0U3RyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuICAgICAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0luZGV4ID0gYmFzZTY0U3RyLmluZGV4T2YocGFkZGluZ0NoYXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFkZGluZ0luZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlNjRTdHJMZW5ndGggPSBwYWRkaW5nSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIG5CeXRlcyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlNjRTdHJMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAlIDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiaXRzMSA9IG1hcC5pbmRleE9mKGJhc2U2NFN0ci5jaGFyQXQoaSAtIDEpKSA8PCBpICUgNCAqIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYml0czIgPSBtYXAuaW5kZXhPZihiYXNlNjRTdHIuY2hhckF0KGkpKSA+Pj4gNiAtIGkgJSA0ICogMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRzW25CeXRlcyA+Pj4gMl0gfD0gKGJpdHMxIHwgYml0czIpIDw8IDI0IC0gbkJ5dGVzICUgNCAqIDg7XG4gICAgICAgICAgICAgICAgICAgICAgICBuQnl0ZXMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgbkJ5dGVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWFwOiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCJcbiAgICAgICAgfTtcbiAgICB9KSgpO1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIEMgPSBxcS5DcnlwdG9KUztcbiAgICAgICAgdmFyIENfbGliID0gQy5saWI7XG4gICAgICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcbiAgICAgICAgdmFyIENfZW5jID0gQy5lbmM7XG4gICAgICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmODtcbiAgICAgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcbiAgICAgICAgdmFyIEhNQUMgPSBDX2FsZ28uSE1BQyA9IEJhc2UuZXh0ZW5kKHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGhhc2hlciwga2V5KSB7XG4gICAgICAgICAgICAgICAgaGFzaGVyID0gdGhpcy5faGFzaGVyID0gbmV3IGhhc2hlci5pbml0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBVdGY4LnBhcnNlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBoYXNoZXJCbG9ja1NpemUgPSBoYXNoZXIuYmxvY2tTaXplO1xuICAgICAgICAgICAgICAgIHZhciBoYXNoZXJCbG9ja1NpemVCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZSAqIDQ7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zaWdCeXRlcyA+IGhhc2hlckJsb2NrU2l6ZUJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGhhc2hlci5maW5hbGl6ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZXkuY2xhbXAoKTtcbiAgICAgICAgICAgICAgICB2YXIgb0tleSA9IHRoaXMuX29LZXkgPSBrZXkuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB2YXIgaUtleSA9IHRoaXMuX2lLZXkgPSBrZXkuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB2YXIgb0tleVdvcmRzID0gb0tleS53b3JkcztcbiAgICAgICAgICAgICAgICB2YXIgaUtleVdvcmRzID0gaUtleS53b3JkcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhc2hlckJsb2NrU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG9LZXlXb3Jkc1tpXSBePSAxNTQ5NTU2ODI4O1xuICAgICAgICAgICAgICAgICAgICBpS2V5V29yZHNbaV0gXj0gOTA5NTIyNDg2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvS2V5LnNpZ0J5dGVzID0gaUtleS5zaWdCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZUJ5dGVzO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcbiAgICAgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcbiAgICAgICAgICAgICAgICBoYXNoZXIudXBkYXRlKHRoaXMuX2lLZXkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24obWVzc2FnZVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc2hlci51cGRhdGUobWVzc2FnZVVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uKG1lc3NhZ2VVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFzaGVyID0gdGhpcy5faGFzaGVyO1xuICAgICAgICAgICAgICAgIHZhciBpbm5lckhhc2ggPSBoYXNoZXIuZmluYWxpemUobWVzc2FnZVVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGhtYWMgPSBoYXNoZXIuZmluYWxpemUodGhpcy5fb0tleS5jbG9uZSgpLmNvbmNhdChpbm5lckhhc2gpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG1hYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSkoKTtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBDID0gcXEuQ3J5cHRvSlM7XG4gICAgICAgIHZhciBDX2xpYiA9IEMubGliO1xuICAgICAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuICAgICAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuICAgICAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuICAgICAgICB2YXIgVyA9IFtdO1xuICAgICAgICB2YXIgU0hBMSA9IENfYWxnby5TSEExID0gSGFzaGVyLmV4dGVuZCh7XG4gICAgICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbIDE3MzI1ODQxOTMsIDQwMjMyMzM0MTcsIDI1NjIzODMxMDIsIDI3MTczMzg3OCwgMzI4NTM3NzUyMCBdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uKE0sIG9mZnNldCkge1xuICAgICAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcbiAgICAgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuICAgICAgICAgICAgICAgIHZhciBjID0gSFsyXTtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IEhbM107XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBIWzRdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBXW2ldID0gTVtvZmZzZXQgKyBpXSB8IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl07XG4gICAgICAgICAgICAgICAgICAgICAgICBXW2ldID0gbiA8PCAxIHwgbiA+Pj4gMzE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSAoYSA8PCA1IHwgYSA+Pj4gMjcpICsgZSArIFdbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgMjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgKz0gKGIgJiBjIHwgfmIgJiBkKSArIDE1MTg1MDAyNDk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDQwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ICs9IChiIF4gYyBeIGQpICsgMTg1OTc3NTM5MztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgNjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgKz0gKGIgJiBjIHwgYiAmIGQgfCBjICYgZCkgLSAxODk0MDA3NTg4O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdCArPSAoYiBeIGMgXiBkKSAtIDg5OTQ5NzUxNDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlID0gZDtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGM7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBiIDw8IDMwIHwgYiA+Pj4gMjtcbiAgICAgICAgICAgICAgICAgICAgYiA9IGE7XG4gICAgICAgICAgICAgICAgICAgIGEgPSB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBIWzBdID0gSFswXSArIGEgfCAwO1xuICAgICAgICAgICAgICAgIEhbMV0gPSBIWzFdICsgYiB8IDA7XG4gICAgICAgICAgICAgICAgSFsyXSA9IEhbMl0gKyBjIHwgMDtcbiAgICAgICAgICAgICAgICBIWzNdID0gSFszXSArIGQgfCAwO1xuICAgICAgICAgICAgICAgIEhbNF0gPSBIWzRdICsgZSB8IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcbiAgICAgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuICAgICAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcbiAgICAgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAxMjggPDwgMjQgLSBuQml0c0xlZnQgJSAzMjtcbiAgICAgICAgICAgICAgICBkYXRhV29yZHNbKG5CaXRzTGVmdCArIDY0ID4+PiA5IDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gNDI5NDk2NzI5Nik7XG4gICAgICAgICAgICAgICAgZGF0YVdvcmRzWyhuQml0c0xlZnQgKyA2NCA+Pj4gOSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG4gICAgICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzaDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgQy5TSEExID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMSk7XG4gICAgICAgIEMuSG1hY1NIQTEgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMSk7XG4gICAgfSkoKTtcbiAgICAoZnVuY3Rpb24oTWF0aCkge1xuICAgICAgICB2YXIgQyA9IHFxLkNyeXB0b0pTO1xuICAgICAgICB2YXIgQ19saWIgPSBDLmxpYjtcbiAgICAgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcbiAgICAgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcbiAgICAgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcbiAgICAgICAgdmFyIEggPSBbXTtcbiAgICAgICAgdmFyIEsgPSBbXTtcbiAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gaXNQcmltZShuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNxcnROID0gTWF0aC5zcXJ0KG4pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGZhY3RvciA9IDI7IGZhY3RvciA8PSBzcXJ0TjsgZmFjdG9yKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobiAlIGZhY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEZyYWN0aW9uYWxCaXRzKG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG4gLSAobiB8IDApKSAqIDQyOTQ5NjcyOTYgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG4gPSAyO1xuICAgICAgICAgICAgdmFyIG5QcmltZSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoblByaW1lIDwgNjQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmltZShuKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoblByaW1lIDwgOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgSFtuUHJpbWVdID0gZ2V0RnJhY3Rpb25hbEJpdHMoTWF0aC5wb3cobiwgMSAvIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBLW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLCAxIC8gMykpO1xuICAgICAgICAgICAgICAgICAgICBuUHJpbWUrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgICB2YXIgVyA9IFtdO1xuICAgICAgICB2YXIgU0hBMjU2ID0gQ19hbGdvLlNIQTI1NiA9IEhhc2hlci5leHRlbmQoe1xuICAgICAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoSC5zbGljZSgwKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbihNLCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuICAgICAgICAgICAgICAgIHZhciBiID0gSFsxXTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuICAgICAgICAgICAgICAgIHZhciBlID0gSFs0XTtcbiAgICAgICAgICAgICAgICB2YXIgZiA9IEhbNV07XG4gICAgICAgICAgICAgICAgdmFyIGcgPSBIWzZdO1xuICAgICAgICAgICAgICAgIHZhciBoID0gSFs3XTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgV1tpXSA9IE1bb2Zmc2V0ICsgaV0gfCAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMHggPSBXW2kgLSAxNV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEwID0gKGdhbW1hMHggPDwgMjUgfCBnYW1tYTB4ID4+PiA3KSBeIChnYW1tYTB4IDw8IDE0IHwgZ2FtbWEweCA+Pj4gMTgpIF4gZ2FtbWEweCA+Pj4gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTF4ID0gV1tpIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExID0gKGdhbW1hMXggPDwgMTUgfCBnYW1tYTF4ID4+PiAxNykgXiAoZ2FtbWExeCA8PCAxMyB8IGdhbW1hMXggPj4+IDE5KSBeIGdhbW1hMXggPj4+IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgV1tpXSA9IGdhbW1hMCArIFdbaSAtIDddICsgZ2FtbWExICsgV1tpIC0gMTZdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaCA9IGUgJiBmIF4gfmUgJiBnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFqID0gYSAmIGIgXiBhICYgYyBeIGIgJiBjO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbWEwID0gKGEgPDwgMzAgfCBhID4+PiAyKSBeIChhIDw8IDE5IHwgYSA+Pj4gMTMpIF4gKGEgPDwgMTAgfCBhID4+PiAyMik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWdtYTEgPSAoZSA8PCAyNiB8IGUgPj4+IDYpIF4gKGUgPDwgMjEgfCBlID4+PiAxMSkgXiAoZSA8PCA3IHwgZSA+Pj4gMjUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2ldICsgV1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQyID0gc2lnbWEwICsgbWFqO1xuICAgICAgICAgICAgICAgICAgICBoID0gZztcbiAgICAgICAgICAgICAgICAgICAgZyA9IGY7XG4gICAgICAgICAgICAgICAgICAgIGYgPSBlO1xuICAgICAgICAgICAgICAgICAgICBlID0gZCArIHQxIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGM7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBiO1xuICAgICAgICAgICAgICAgICAgICBiID0gYTtcbiAgICAgICAgICAgICAgICAgICAgYSA9IHQxICsgdDIgfCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBIWzBdID0gSFswXSArIGEgfCAwO1xuICAgICAgICAgICAgICAgIEhbMV0gPSBIWzFdICsgYiB8IDA7XG4gICAgICAgICAgICAgICAgSFsyXSA9IEhbMl0gKyBjIHwgMDtcbiAgICAgICAgICAgICAgICBIWzNdID0gSFszXSArIGQgfCAwO1xuICAgICAgICAgICAgICAgIEhbNF0gPSBIWzRdICsgZSB8IDA7XG4gICAgICAgICAgICAgICAgSFs1XSA9IEhbNV0gKyBmIHwgMDtcbiAgICAgICAgICAgICAgICBIWzZdID0gSFs2XSArIGcgfCAwO1xuICAgICAgICAgICAgICAgIEhbN10gPSBIWzddICsgaCB8IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcbiAgICAgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuICAgICAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcbiAgICAgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAxMjggPDwgMjQgLSBuQml0c0xlZnQgJSAzMjtcbiAgICAgICAgICAgICAgICBkYXRhV29yZHNbKG5CaXRzTGVmdCArIDY0ID4+PiA5IDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gNDI5NDk2NzI5Nik7XG4gICAgICAgICAgICAgICAgZGF0YVdvcmRzWyhuQml0c0xlZnQgKyA2NCA+Pj4gOSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG4gICAgICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzaDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgQy5TSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEEyNTYpO1xuICAgICAgICBDLkhtYWNTSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMjU2KTtcbiAgICB9KShNYXRoKTtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIEMgPSBxcS5DcnlwdG9KUztcbiAgICAgICAgdmFyIENfbGliID0gQy5saWI7XG4gICAgICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG4gICAgICAgIHZhciBzdXBlckluaXQgPSBXb3JkQXJyYXkuaW5pdDtcbiAgICAgICAgdmFyIHN1YkluaXQgPSBXb3JkQXJyYXkuaW5pdCA9IGZ1bmN0aW9uKHR5cGVkQXJyYXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0eXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSB8fCB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkgfHwgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkgfHwgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5IHx8IHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5IHx8IHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSB8fCB0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8IHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0eXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheS5idWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlZEFycmF5Qnl0ZUxlbmd0aCA9IHR5cGVkQXJyYXkuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkQXJyYXlCeXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMl0gfD0gdHlwZWRBcnJheVtpXSA8PCAyNCAtIGkgJSA0ICogODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VwZXJJbml0LmNhbGwodGhpcywgd29yZHMsIHR5cGVkQXJyYXlCeXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3VwZXJJbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHN1YkluaXQucHJvdG90eXBlID0gV29yZEFycmF5O1xuICAgIH0pKCk7XG4gICAgcXEuczMgPSBxcS5zMyB8fCB7fTtcbiAgICBxcS5zMy51dGlsID0gcXEuczMudXRpbCB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBBTEdPUklUSE1fUEFSQU1fTkFNRTogXCJ4LWFtei1hbGdvcml0aG1cIixcbiAgICAgICAgICAgIEFXU19QQVJBTV9QUkVGSVg6IFwieC1hbXotbWV0YS1cIixcbiAgICAgICAgICAgIENSRURFTlRJQUxfUEFSQU1fTkFNRTogXCJ4LWFtei1jcmVkZW50aWFsXCIsXG4gICAgICAgICAgICBEQVRFX1BBUkFNX05BTUU6IFwieC1hbXotZGF0ZVwiLFxuICAgICAgICAgICAgUkVEVUNFRF9SRURVTkRBTkNZX1BBUkFNX05BTUU6IFwieC1hbXotc3RvcmFnZS1jbGFzc1wiLFxuICAgICAgICAgICAgUkVEVUNFRF9SRURVTkRBTkNZX1BBUkFNX1ZBTFVFOiBcIlJFRFVDRURfUkVEVU5EQU5DWVwiLFxuICAgICAgICAgICAgU0VSVkVSX1NJREVfRU5DUllQVElPTl9QQVJBTV9OQU1FOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIixcbiAgICAgICAgICAgIFNFUlZFUl9TSURFX0VOQ1JZUFRJT05fUEFSQU1fVkFMVUU6IFwiQUVTMjU2XCIsXG4gICAgICAgICAgICBTRVNTSU9OX1RPS0VOX1BBUkFNX05BTUU6IFwieC1hbXotc2VjdXJpdHktdG9rZW5cIixcbiAgICAgICAgICAgIFY0X0FMR09SSVRITV9QQVJBTV9WQUxVRTogXCJBV1M0LUhNQUMtU0hBMjU2XCIsXG4gICAgICAgICAgICBWNF9TSUdOQVRVUkVfUEFSQU1fTkFNRTogXCJ4LWFtei1zaWduYXR1cmVcIixcbiAgICAgICAgICAgIENBU0VfU0VOU0lUSVZFX1BBUkFNX05BTUVTOiBbIFwiQ2FjaGUtQ29udHJvbFwiLCBcIkNvbnRlbnQtRGlzcG9zaXRpb25cIiwgXCJDb250ZW50LUVuY29kaW5nXCIsIFwiQ29udGVudC1NRDVcIiBdLFxuICAgICAgICAgICAgVU5TSUdOQUJMRV9SRVNUX0hFQURFUl9OQU1FUzogWyBcIkNhY2hlLUNvbnRyb2xcIiwgXCJDb250ZW50LURpc3Bvc2l0aW9uXCIsIFwiQ29udGVudC1FbmNvZGluZ1wiLCBcIkNvbnRlbnQtTUQ1XCIgXSxcbiAgICAgICAgICAgIFVOUFJFRklYRURfUEFSQU1fTkFNRVM6IFsgXCJDYWNoZS1Db250cm9sXCIsIFwiQ29udGVudC1EaXNwb3NpdGlvblwiLCBcIkNvbnRlbnQtRW5jb2RpbmdcIiwgXCJDb250ZW50LU1ENVwiLCBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCIsIFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXlcIiwgXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIiBdLFxuICAgICAgICAgICAgZ2V0QnVja2V0OiBmdW5jdGlvbihlbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJucyA9IFsgL14oPzpodHRwcz86XFwvXFwvKT8oW2EtejAtOS5cXC1fXSspXFwuczMoPzotW2EtejAtOVxcLV0rKT9cXC5hbWF6b25hd3NcXC5jb20vaSwgL14oPzpodHRwcz86XFwvXFwvKT9zMyg/Oi1bYS16MC05XFwtXSspP1xcLmFtYXpvbmF3c1xcLmNvbVxcLyhbYS16MC05LlxcLV9dKykvaSwgL14oPzpodHRwcz86XFwvXFwvKT8oW2EtejAtOS5cXC1fXSspL2kgXSwgYnVja2V0O1xuICAgICAgICAgICAgICAgIHFxLmVhY2gocGF0dGVybnMsIGZ1bmN0aW9uKGlkeCwgcGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoZW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1Y2tldDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZ2V0UHJlZml4ZWRQYXJhbU5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocXEuaW5kZXhPZihxcS5zMy51dGlsLlVOUFJFRklYRURfUEFSQU1fTkFNRVMsIG5hbWUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBxcS5zMy51dGlsLkFXU19QQVJBTV9QUkVGSVggKyBuYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFBvbGljeTogZnVuY3Rpb24oc3BlYykge1xuICAgICAgICAgICAgICAgIHZhciBwb2xpY3kgPSB7fSwgY29uZGl0aW9ucyA9IFtdLCBidWNrZXQgPSBzcGVjLmJ1Y2tldCwgZGF0ZSA9IHNwZWMuZGF0ZSwgZHJpZnQgPSBzcGVjLmNsb2NrRHJpZnQsIGtleSA9IHNwZWMua2V5LCBhY2Nlc3NLZXkgPSBzcGVjLmFjY2Vzc0tleSwgYWNsID0gc3BlYy5hY2wsIHR5cGUgPSBzcGVjLnR5cGUsIGV4cGVjdGVkU3RhdHVzID0gc3BlYy5leHBlY3RlZFN0YXR1cywgc2Vzc2lvblRva2VuID0gc3BlYy5zZXNzaW9uVG9rZW4sIHBhcmFtcyA9IHNwZWMucGFyYW1zLCBzdWNjZXNzUmVkaXJlY3RVcmwgPSBxcS5zMy51dGlsLmdldFN1Y2Nlc3NSZWRpcmVjdEFic29sdXRlVXJsKHNwZWMuc3VjY2Vzc1JlZGlyZWN0VXJsKSwgbWluRmlsZVNpemUgPSBzcGVjLm1pbkZpbGVTaXplLCBtYXhGaWxlU2l6ZSA9IHNwZWMubWF4RmlsZVNpemUsIHJlZHVjZWRSZWR1bmRhbmN5ID0gc3BlYy5yZWR1Y2VkUmVkdW5kYW5jeSwgcmVnaW9uID0gc3BlYy5yZWdpb24sIHNlcnZlclNpZGVFbmNyeXB0aW9uID0gc3BlYy5zZXJ2ZXJTaWRlRW5jcnlwdGlvbiwgc2lnbmF0dXJlVmVyc2lvbiA9IHNwZWMuc2lnbmF0dXJlVmVyc2lvbjtcbiAgICAgICAgICAgICAgICBwb2xpY3kuZXhwaXJhdGlvbiA9IHFxLnMzLnV0aWwuZ2V0UG9saWN5RXhwaXJhdGlvbkRhdGUoZGF0ZSwgZHJpZnQpO1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGFjbDogYWNsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0OiBidWNrZXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogdHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzX2FjdGlvbl9zdGF0dXM6IGV4cGVjdGVkU3RhdHVzLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzUmVkaXJlY3RVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NfYWN0aW9uX3JlZGlyZWN0OiBzdWNjZXNzUmVkaXJlY3RVcmxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VkUmVkdW5kYW5jeSkge1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25zLnB1c2goe30pO1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25zW2NvbmRpdGlvbnMubGVuZ3RoIC0gMV1bcXEuczMudXRpbC5SRURVQ0VEX1JFRFVOREFOQ1lfUEFSQU1fTkFNRV0gPSBxcS5zMy51dGlsLlJFRFVDRURfUkVEVU5EQU5DWV9QQVJBTV9WQUxVRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25Ub2tlbikge1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25zLnB1c2goe30pO1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25zW2NvbmRpdGlvbnMubGVuZ3RoIC0gMV1bcXEuczMudXRpbC5TRVNTSU9OX1RPS0VOX1BBUkFNX05BTUVdID0gc2Vzc2lvblRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VydmVyU2lkZUVuY3J5cHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9ucy5wdXNoKHt9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uc1tjb25kaXRpb25zLmxlbmd0aCAtIDFdW3FxLnMzLnV0aWwuU0VSVkVSX1NJREVfRU5DUllQVElPTl9QQVJBTV9OQU1FXSA9IHFxLnMzLnV0aWwuU0VSVkVSX1NJREVfRU5DUllQVElPTl9QQVJBTV9WQUxVRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hdHVyZVZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2lnbmF0dXJlVmVyc2lvbiA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25zLnB1c2goe30pO1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25zW2NvbmRpdGlvbnMubGVuZ3RoIC0gMV1bcXEuczMudXRpbC5BTEdPUklUSE1fUEFSQU1fTkFNRV0gPSBxcS5zMy51dGlsLlY0X0FMR09SSVRITV9QQVJBTV9WQUxVRTtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9ucy5wdXNoKHt9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uc1tjb25kaXRpb25zLmxlbmd0aCAtIDFdLmtleSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9ucy5wdXNoKHt9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uc1tjb25kaXRpb25zLmxlbmd0aCAtIDFdW3FxLnMzLnV0aWwuQ1JFREVOVElBTF9QQVJBTV9OQU1FXSA9IHFxLnMzLnV0aWwuZ2V0VjRDcmVkZW50aWFsc1N0cmluZyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBkYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBhY2Nlc3NLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb246IHJlZ2lvblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9ucy5wdXNoKHt9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uc1tjb25kaXRpb25zLmxlbmd0aCAtIDFdW3FxLnMzLnV0aWwuREFURV9QQVJBTV9OQU1FXSA9IHFxLnMzLnV0aWwuZ2V0VjRQb2xpY3lEYXRlKGRhdGUsIGRyaWZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXEuZWFjaChwYXJhbXMsIGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXdzUGFyYW1OYW1lID0gcXEuczMudXRpbC5fZ2V0UHJlZml4ZWRQYXJhbU5hbWUobmFtZSksIHBhcmFtID0ge307XG4gICAgICAgICAgICAgICAgICAgIGlmIChxcS5pbmRleE9mKHFxLnMzLnV0aWwuVU5QUkVGSVhFRF9QQVJBTV9OQU1FUywgYXdzUGFyYW1OYW1lKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbVthd3NQYXJhbU5hbWVdID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1bYXdzUGFyYW1OYW1lXSA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbnMucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcG9saWN5LmNvbmRpdGlvbnMgPSBjb25kaXRpb25zO1xuICAgICAgICAgICAgICAgIHFxLnMzLnV0aWwuZW5mb3JjZVNpemVMaW1pdHMocG9saWN5LCBtaW5GaWxlU2l6ZSwgbWF4RmlsZVNpemUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2xpY3k7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVmcmVzaFBvbGljeUNyZWRlbnRpYWxzOiBmdW5jdGlvbihwb2xpY3ksIG5ld1Nlc3Npb25Ub2tlbikge1xuICAgICAgICAgICAgICAgIHZhciBzZXNzaW9uVG9rZW5Gb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHFxLmVhY2gocG9saWN5LmNvbmRpdGlvbnMsIGZ1bmN0aW9uKG9sZENvbmRJZHgsIG9sZENvbmRPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChvbGRDb25kT2JqLCBmdW5jdGlvbihvbGRDb25kTmFtZSwgb2xkQ29uZFZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZENvbmROYW1lID09PSBxcS5zMy51dGlsLlNFU1NJT05fVE9LRU5fUEFSQU1fTkFNRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZENvbmRPYmpbb2xkQ29uZE5hbWVdID0gbmV3U2Vzc2lvblRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25Ub2tlbkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uVG9rZW5Gb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBwb2xpY3kuY29uZGl0aW9ucy5wdXNoKHt9KTtcbiAgICAgICAgICAgICAgICAgICAgcG9saWN5LmNvbmRpdGlvbnNbcG9saWN5LmNvbmRpdGlvbnMubGVuZ3RoIC0gMV1bcXEuczMudXRpbC5TRVNTSU9OX1RPS0VOX1BBUkFNX05BTUVdID0gbmV3U2Vzc2lvblRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZUF3c1BhcmFtczogZnVuY3Rpb24oc3BlYywgc2lnblBvbGljeUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF3c1BhcmFtcyA9IHt9LCBjdXN0b21QYXJhbXMgPSBzcGVjLnBhcmFtcywgcHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCksIHNlc3Npb25Ub2tlbiA9IHNwZWMuc2Vzc2lvblRva2VuLCBkcmlmdCA9IHNwZWMuY2xvY2tEcmlmdCwgdHlwZSA9IHNwZWMudHlwZSwga2V5ID0gc3BlYy5rZXksIGFjY2Vzc0tleSA9IHNwZWMuYWNjZXNzS2V5LCBhY2wgPSBzcGVjLmFjbCwgZXhwZWN0ZWRTdGF0dXMgPSBzcGVjLmV4cGVjdGVkU3RhdHVzLCBzdWNjZXNzUmVkaXJlY3RVcmwgPSBxcS5zMy51dGlsLmdldFN1Y2Nlc3NSZWRpcmVjdEFic29sdXRlVXJsKHNwZWMuc3VjY2Vzc1JlZGlyZWN0VXJsKSwgcmVkdWNlZFJlZHVuZGFuY3kgPSBzcGVjLnJlZHVjZWRSZWR1bmRhbmN5LCByZWdpb24gPSBzcGVjLnJlZ2lvbiwgc2VydmVyU2lkZUVuY3J5cHRpb24gPSBzcGVjLnNlcnZlclNpZGVFbmNyeXB0aW9uLCBzaWduYXR1cmVWZXJzaW9uID0gc3BlYy5zaWduYXR1cmVWZXJzaW9uLCBub3cgPSBuZXcgRGF0ZSgpLCBsb2cgPSBzcGVjLmxvZywgcG9saWN5SnNvbjtcbiAgICAgICAgICAgICAgICBzcGVjLmRhdGUgPSBub3c7XG4gICAgICAgICAgICAgICAgcG9saWN5SnNvbiA9IHFxLnMzLnV0aWwuZ2V0UG9saWN5KHNwZWMpO1xuICAgICAgICAgICAgICAgIGF3c1BhcmFtcy5rZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdzUGFyYW1zW1wiQ29udGVudC1UeXBlXCJdID0gdHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3c1BhcmFtcy5zdWNjZXNzX2FjdGlvbl9zdGF0dXMgPSBleHBlY3RlZFN0YXR1cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3NSZWRpcmVjdFVybCkge1xuICAgICAgICAgICAgICAgICAgICBhd3NQYXJhbXMuc3VjY2Vzc19hY3Rpb25fcmVkaXJlY3QgPSBzdWNjZXNzUmVkaXJlY3RVcmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VkUmVkdW5kYW5jeSkge1xuICAgICAgICAgICAgICAgICAgICBhd3NQYXJhbXNbcXEuczMudXRpbC5SRURVQ0VEX1JFRFVOREFOQ1lfUEFSQU1fTkFNRV0gPSBxcS5zMy51dGlsLlJFRFVDRURfUkVEVU5EQU5DWV9QQVJBTV9WQUxVRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZlclNpZGVFbmNyeXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3c1BhcmFtc1txcS5zMy51dGlsLlNFUlZFUl9TSURFX0VOQ1JZUFRJT05fUEFSQU1fTkFNRV0gPSBxcS5zMy51dGlsLlNFUlZFUl9TSURFX0VOQ1JZUFRJT05fUEFSQU1fVkFMVUU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgYXdzUGFyYW1zW3FxLnMzLnV0aWwuU0VTU0lPTl9UT0tFTl9QQVJBTV9OQU1FXSA9IHNlc3Npb25Ub2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdzUGFyYW1zLmFjbCA9IGFjbDtcbiAgICAgICAgICAgICAgICBxcS5lYWNoKGN1c3RvbVBhcmFtcywgZnVuY3Rpb24obmFtZSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhd3NQYXJhbU5hbWUgPSBxcS5zMy51dGlsLl9nZXRQcmVmaXhlZFBhcmFtTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHFxLmluZGV4T2YocXEuczMudXRpbC5VTlBSRUZJWEVEX1BBUkFNX05BTUVTLCBhd3NQYXJhbU5hbWUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3c1BhcmFtc1thd3NQYXJhbU5hbWVdID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdzUGFyYW1zW2F3c1BhcmFtTmFtZV0gPSBlbmNvZGVVUklDb21wb25lbnQodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzaWduYXR1cmVWZXJzaW9uID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3c1BhcmFtcy5BV1NBY2Nlc3NLZXlJZCA9IGFjY2Vzc0tleTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZVZlcnNpb24gPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdzUGFyYW1zW3FxLnMzLnV0aWwuQUxHT1JJVEhNX1BBUkFNX05BTUVdID0gcXEuczMudXRpbC5WNF9BTEdPUklUSE1fUEFSQU1fVkFMVUU7XG4gICAgICAgICAgICAgICAgICAgIGF3c1BhcmFtc1txcS5zMy51dGlsLkNSRURFTlRJQUxfUEFSQU1fTkFNRV0gPSBxcS5zMy51dGlsLmdldFY0Q3JlZGVudGlhbHNTdHJpbmcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogbm93LFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBhY2Nlc3NLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb246IHJlZ2lvblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXdzUGFyYW1zW3FxLnMzLnV0aWwuREFURV9QQVJBTV9OQU1FXSA9IHFxLnMzLnV0aWwuZ2V0VjRQb2xpY3lEYXRlKG5vdywgZHJpZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaWduUG9saWN5Q2FsbGJhY2socG9saWN5SnNvbikudGhlbihmdW5jdGlvbihwb2xpY3lBbmRTaWduYXR1cmUsIHVwZGF0ZWRBY2Nlc3NLZXksIHVwZGF0ZWRTZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgYXdzUGFyYW1zLnBvbGljeSA9IHBvbGljeUFuZFNpZ25hdHVyZS5wb2xpY3k7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVjLnNpZ25hdHVyZVZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3c1BhcmFtcy5zaWduYXR1cmUgPSBwb2xpY3lBbmRTaWduYXR1cmUuc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWRBY2Nlc3NLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd3NQYXJhbXMuQVdTQWNjZXNzS2V5SWQgPSB1cGRhdGVkQWNjZXNzS2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNwZWMuc2lnbmF0dXJlVmVyc2lvbiA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdzUGFyYW1zW3FxLnMzLnV0aWwuVjRfU0lHTkFUVVJFX1BBUkFNX05BTUVdID0gcG9saWN5QW5kU2lnbmF0dXJlLnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZFNlc3Npb25Ub2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdzUGFyYW1zW3FxLnMzLnV0aWwuU0VTU0lPTl9UT0tFTl9QQVJBTV9OQU1FXSA9IHVwZGF0ZWRTZXNzaW9uVG9rZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKGF3c1BhcmFtcyk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZSB8fCBcIkNhbid0IGNvbnRpbnVlIGZ1cnRoZXIgd2l0aCByZXF1ZXN0IHRvIFMzIGFzIHdlIGRpZCBub3QgcmVjZWl2ZSBcIiArIFwiYSB2YWxpZCBzaWduYXR1cmUgYW5kIHBvbGljeSBmcm9tIHRoZSBzZXJ2ZXIuXCI7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIlBvbGljeSBzaWduaW5nIGZhaWxlZC4gIFwiICsgZXJyb3JNZXNzYWdlLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmZhaWx1cmUoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmZvcmNlU2l6ZUxpbWl0czogZnVuY3Rpb24ocG9saWN5LCBtaW5TaXplLCBtYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkanVzdGVkTWluU2l6ZSA9IG1pblNpemUgPCAwID8gMCA6IG1pblNpemUsIGFkanVzdGVkTWF4U2l6ZSA9IG1heFNpemUgPD0gMCA/IDkwMDcxOTkyNTQ3NDA5OTIgOiBtYXhTaXplO1xuICAgICAgICAgICAgICAgIGlmIChtaW5TaXplID4gMCB8fCBtYXhTaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBwb2xpY3kuY29uZGl0aW9ucy5wdXNoKFsgXCJjb250ZW50LWxlbmd0aC1yYW5nZVwiLCBhZGp1c3RlZE1pblNpemUudG9TdHJpbmcoKSwgYWRqdXN0ZWRNYXhTaXplLnRvU3RyaW5nKCkgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFBvbGljeUV4cGlyYXRpb25EYXRlOiBmdW5jdGlvbihkYXRlLCBkcmlmdCkge1xuICAgICAgICAgICAgICAgIHZhciBhZGp1c3RlZERhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSArIGRyaWZ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXEuczMudXRpbC5nZXRQb2xpY3lEYXRlKGFkanVzdGVkRGF0ZSwgNSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q3JlZGVudGlhbHNEYXRlOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArIFwiXCIgKyAoXCIwXCIgKyAoZGF0ZS5nZXRVVENNb250aCgpICsgMSkpLnNsaWNlKC0yKSArIChcIjBcIiArIGRhdGUuZ2V0VVRDRGF0ZSgpKS5zbGljZSgtMik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UG9saWN5RGF0ZTogZnVuY3Rpb24oZGF0ZSwgX21pbnV0ZXNUb0FkZF8pIHtcbiAgICAgICAgICAgICAgICB2YXIgbWludXRlc1RvQWRkID0gX21pbnV0ZXNUb0FkZF8gfHwgMCwgcGFkLCByO1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0TWludXRlcyhkYXRlLmdldE1pbnV0ZXMoKSArIChtaW51dGVzVG9BZGQgfHwgMCkpO1xuICAgICAgICAgICAgICAgIGlmIChEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZCA9IGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgciA9IFN0cmluZyhudW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IFwiMFwiICsgcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZS5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgKyBwYWQoZGF0ZS5nZXRVVENNb250aCgpICsgMSkgKyBcIi1cIiArIHBhZChkYXRlLmdldFVUQ0RhdGUoKSkgKyBcIlRcIiArIHBhZChkYXRlLmdldFVUQ0hvdXJzKCkpICsgXCI6XCIgKyBwYWQoZGF0ZS5nZXRVVENNaW51dGVzKCkpICsgXCI6XCIgKyBwYWQoZGF0ZS5nZXRVVENTZWNvbmRzKCkpICsgXCIuXCIgKyBTdHJpbmcoKGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgLyAxZTMpLnRvRml4ZWQoMykpLnNsaWNlKDIsIDUpICsgXCJaXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcnNlSWZyYW1lUmVzcG9uc2U6IGZ1bmN0aW9uKGlmcmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSBpZnJhbWUuY29udGVudERvY3VtZW50IHx8IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LCBxdWVyeVN0cmluZyA9IGRvYy5sb2NhdGlvbi5zZWFyY2gsIG1hdGNoID0gL2J1Y2tldD0oLispJmtleT0oLispJmV0YWc9KC4rKS8uZXhlYyhxdWVyeVN0cmluZyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWNrZXQ6IG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV0YWc6IG1hdGNoWzNdLnJlcGxhY2UoLyUyMi9nLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRTdWNjZXNzUmVkaXJlY3RBYnNvbHV0ZVVybDogZnVuY3Rpb24oc3VjY2Vzc1JlZGlyZWN0VXJsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3NSZWRpcmVjdFVybCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0QW5jaG9yQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgdGFyZ2V0QW5jaG9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAocXEuaWU3KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEFuY2hvckNvbnRhaW5lci5pbm5lckhUTUwgPSBcIjxhIGhyZWY9J1wiICsgc3VjY2Vzc1JlZGlyZWN0VXJsICsgXCInPjwvYT5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEFuY2hvciA9IHRhcmdldEFuY2hvckNvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldEFuY2hvci5ocmVmO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRBbmNob3IuaHJlZiA9IHN1Y2Nlc3NSZWRpcmVjdFVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEFuY2hvci5ocmVmID0gdGFyZ2V0QW5jaG9yLmhyZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0QW5jaG9yLmhyZWY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0VjRDcmVkZW50aWFsc1N0cmluZzogZnVuY3Rpb24oc3BlYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVjLmtleSArIFwiL1wiICsgcXEuczMudXRpbC5nZXRDcmVkZW50aWFsc0RhdGUoc3BlYy5kYXRlKSArIFwiL1wiICsgc3BlYy5yZWdpb24gKyBcIi9zMy9hd3M0X3JlcXVlc3RcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRWNFBvbGljeURhdGU6IGZ1bmN0aW9uKGRhdGUsIGRyaWZ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkanVzdGVkRGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpICsgZHJpZnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBxcS5zMy51dGlsLmdldENyZWRlbnRpYWxzRGF0ZShhZGp1c3RlZERhdGUpICsgXCJUXCIgKyAoXCIwXCIgKyBhZGp1c3RlZERhdGUuZ2V0VVRDSG91cnMoKSkuc2xpY2UoLTIpICsgKFwiMFwiICsgYWRqdXN0ZWREYXRlLmdldFVUQ01pbnV0ZXMoKSkuc2xpY2UoLTIpICsgKFwiMFwiICsgYWRqdXN0ZWREYXRlLmdldFVUQ1NlY29uZHMoKSkuc2xpY2UoLTIpICsgXCJaXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5jb2RlUXVlcnlTdHJpbmdQYXJhbTogZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGVyY2VudEVuY29kZWQgPSBlbmNvZGVVUklDb21wb25lbnQocGFyYW0pO1xuICAgICAgICAgICAgICAgIHBlcmNlbnRFbmNvZGVkID0gcGVyY2VudEVuY29kZWQucmVwbGFjZSgvWyEnKCldL2csIGVzY2FwZSk7XG4gICAgICAgICAgICAgICAgcGVyY2VudEVuY29kZWQgPSBwZXJjZW50RW5jb2RlZC5yZXBsYWNlKC9cXCovZywgXCIlMkFcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBlcmNlbnRFbmNvZGVkLnJlcGxhY2UoLyUyMC9nLCBcIitcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXJpRXNjYXBlOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZyk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoL1teQS1aYS16MC05Xy5+XFwtJV0rL2csIGVzY2FwZSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoL1sqXS9nLCBmdW5jdGlvbihjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIlXCIgKyBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXJpRXNjYXBlUGF0aDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHFxLmVhY2gocGF0aC5zcGxpdChcIi9cIiksIGZ1bmN0aW9uKGlkeCwgaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHFxLnMzLnV0aWwudXJpRXNjYXBlKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIi9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSgpO1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHFxLm5vblRyYWRpdGlvbmFsQmFzZVB1YmxpY0FwaSA9IHtcbiAgICAgICAgICAgIHNldFVwbG9hZFN1Y2Nlc3NQYXJhbXM6IGZ1bmN0aW9uKHBhcmFtcywgaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWRTdWNjZXNzUGFyYW1zU3RvcmUuc2V0KHBhcmFtcywgaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFVwbG9hZFN1Y2Nlc3NFbmRwb2ludDogZnVuY3Rpb24oZW5kcG9pbnQsIGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkU3VjY2Vzc0VuZHBvaW50U3RvcmUuc2V0KGVuZHBvaW50LCBpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHFxLm5vblRyYWRpdGlvbmFsQmFzZVByaXZhdGVBcGkgPSB7XG4gICAgICAgICAgICBfb25Db21wbGV0ZTogZnVuY3Rpb24oaWQsIG5hbWUsIHJlc3VsdCwgeGhyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSByZXN1bHQuc3VjY2VzcyA/IHRydWUgOiBmYWxzZSwgc2VsZiA9IHRoaXMsIG9uQ29tcGxldGVBcmdzID0gYXJndW1lbnRzLCBzdWNjZXNzRW5kcG9pbnQgPSB0aGlzLl91cGxvYWRTdWNjZXNzRW5kcG9pbnRTdG9yZS5nZXQoaWQpLCBzdWNjZXNzQ3VzdG9tSGVhZGVycyA9IHRoaXMuX29wdGlvbnMudXBsb2FkU3VjY2Vzcy5jdXN0b21IZWFkZXJzLCBzdWNjZXNzTWV0aG9kID0gdGhpcy5fb3B0aW9ucy51cGxvYWRTdWNjZXNzLm1ldGhvZCwgY29ycyA9IHRoaXMuX29wdGlvbnMuY29ycywgcHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCksIHVwbG9hZFN1Y2Nlc3NQYXJhbXMgPSB0aGlzLl91cGxvYWRTdWNjZXNzUGFyYW1zU3RvcmUuZ2V0KGlkKSwgZmlsZVBhcmFtcyA9IHRoaXMuX3BhcmFtc1N0b3JlLmdldChpZCksIG9uU3VjY2Vzc0Zyb21TZXJ2ZXIgPSBmdW5jdGlvbihzdWNjZXNzUmVxdWVzdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2VsZi5fZmFpbGVkU3VjY2Vzc1JlcXVlc3RDYWxsYmFja3NbaWRdO1xuICAgICAgICAgICAgICAgICAgICBxcS5leHRlbmQocmVzdWx0LCBzdWNjZXNzUmVxdWVzdFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHFxLkZpbmVVcGxvYWRlckJhc2ljLnByb3RvdHlwZS5fb25Db21wbGV0ZS5hcHBseShzZWxmLCBvbkNvbXBsZXRlQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2Uuc3VjY2VzcyhzdWNjZXNzUmVxdWVzdFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSwgb25GYWlsdXJlRnJvbVNlcnZlciA9IGZ1bmN0aW9uKHN1Y2Nlc3NSZXF1ZXN0UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHN1Ym1pdFN1Y2Nlc3NSZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICBxcS5leHRlbmQocmVzdWx0LCBzdWNjZXNzUmVxdWVzdFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnJlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYuX2ZhaWxlZFN1Y2Nlc3NSZXF1ZXN0Q2FsbGJhY2tzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2ZhaWxlZFN1Y2Nlc3NSZXF1ZXN0Q2FsbGJhY2tzW2lkXSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5fb25BdXRvUmV0cnkoaWQsIG5hbWUsIHJlc3VsdCwgeGhyLCBjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFxLkZpbmVVcGxvYWRlckJhc2ljLnByb3RvdHlwZS5fb25Db21wbGV0ZS5hcHBseShzZWxmLCBvbkNvbXBsZXRlQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmZhaWx1cmUoc3VjY2Vzc1JlcXVlc3RSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgc3VibWl0U3VjY2Vzc1JlcXVlc3QsIHN1Y2Nlc3NBamF4UmVxdWVzdGVyO1xuICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzICYmIHN1Y2Nlc3NFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQWpheFJlcXVlc3RlciA9IG5ldyBxcS5VcGxvYWRTdWNjZXNzQWpheFJlcXVlc3Rlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogc3VjY2Vzc0VuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBzdWNjZXNzTWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tSGVhZGVyczogc3VjY2Vzc0N1c3RvbUhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JzOiBjb3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nOiBxcS5iaW5kKHRoaXMubG9nLCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcXEuZXh0ZW5kKHVwbG9hZFN1Y2Nlc3NQYXJhbXMsIHNlbGYuX2dldEVuZHBvaW50U3BlY2lmaWNQYXJhbXMoaWQsIHJlc3VsdCwgeGhyKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYXJhbXMgJiYgcXEuZXh0ZW5kKHVwbG9hZFN1Y2Nlc3NQYXJhbXMsIGZpbGVQYXJhbXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBzdWJtaXRTdWNjZXNzUmVxdWVzdCA9IHFxLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQWpheFJlcXVlc3Rlci5zZW5kU3VjY2Vzc1JlcXVlc3QoaWQsIHVwbG9hZFN1Y2Nlc3NQYXJhbXMpLnRoZW4ob25TdWNjZXNzRnJvbVNlcnZlciwgb25GYWlsdXJlRnJvbVNlcnZlcik7XG4gICAgICAgICAgICAgICAgICAgIH0sIHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICBzdWJtaXRTdWNjZXNzUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHFxLkZpbmVVcGxvYWRlckJhc2ljLnByb3RvdHlwZS5fb25Db21wbGV0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9tYW51YWxSZXRyeTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VjY2Vzc1JlcXVlc3RDYWxsYmFjayA9IHRoaXMuX2ZhaWxlZFN1Y2Nlc3NSZXF1ZXN0Q2FsbGJhY2tzW2lkXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXEuRmluZVVwbG9hZGVyQmFzaWMucHJvdG90eXBlLl9tYW51YWxSZXRyeS5jYWxsKHRoaXMsIGlkLCBzdWNjZXNzUmVxdWVzdENhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KSgpO1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHFxLnMzLkZpbmVVcGxvYWRlckJhc2ljID0gZnVuY3Rpb24obykge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NLZXk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNsb2NrRHJpZnQ6IDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9iamVjdFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgYWNsOiBcInByaXZhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0OiBxcS5iaW5kKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXEuczMudXRpbC5nZXRCdWNrZXQodGhpcy5nZXRFbmRwb2ludChpZCkpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogcXEuYmluZChmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8oPzpodHRwfGh0dHBzKTpcXC9cXC8oLispKD86XFwvLispPy8uZXhlYyh0aGlzLl9lbmRwb2ludFN0b3JlLmdldChpZCkpWzFdO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBcInV1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgcmVkdWNlZFJlZHVuZGFuY3k6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByZWdpb246IFwidXMtZWFzdC0xXCIsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclNpZGVFbmNyeXB0aW9uOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzS2V5OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzZWNyZXRLZXk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGV4cGlyYXRpb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25Ub2tlbjogbnVsbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogMlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdXBsb2FkU3VjY2Vzczoge1xuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tSGVhZGVyczoge31cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlmcmFtZVN1cHBvcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxCbGFua1BhZ2VQYXRoOiBudWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjaHVua2luZzoge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0U2l6ZTogNTI0Mjg4MFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29yczoge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd1hkcjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ3JlZGVudGlhbHNFeHBpcmVkOiBmdW5jdGlvbigpIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHFxLmV4dGVuZChvcHRpb25zLCBvLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZXRDcmVkZW50aWFscyhvcHRpb25zLmNyZWRlbnRpYWxzLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDcmVkZW50aWFscy5hY2Nlc3NLZXkgPSBvcHRpb25zLnJlcXVlc3QuYWNjZXNzS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWNsU3RvcmUgPSB0aGlzLl9jcmVhdGVTdG9yZShvcHRpb25zLm9iamVjdFByb3BlcnRpZXMuYWNsKTtcbiAgICAgICAgICAgIHFxLkZpbmVVcGxvYWRlckJhc2ljLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl91cGxvYWRTdWNjZXNzUGFyYW1zU3RvcmUgPSB0aGlzLl9jcmVhdGVTdG9yZSh0aGlzLl9vcHRpb25zLnVwbG9hZFN1Y2Nlc3MucGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMuX3VwbG9hZFN1Y2Nlc3NFbmRwb2ludFN0b3JlID0gdGhpcy5fY3JlYXRlU3RvcmUodGhpcy5fb3B0aW9ucy51cGxvYWRTdWNjZXNzLmVuZHBvaW50KTtcbiAgICAgICAgICAgIHRoaXMuX2ZhaWxlZFN1Y2Nlc3NSZXF1ZXN0Q2FsbGJhY2tzID0ge307XG4gICAgICAgICAgICB0aGlzLl9jYW5uZWRLZXlzID0ge307XG4gICAgICAgICAgICB0aGlzLl9jYW5uZWRCdWNrZXRzID0ge307XG4gICAgICAgICAgICB0aGlzLl9idWNrZXRzID0ge307XG4gICAgICAgICAgICB0aGlzLl9ob3N0cyA9IHt9O1xuICAgICAgICB9O1xuICAgICAgICBxcS5leHRlbmQocXEuczMuRmluZVVwbG9hZGVyQmFzaWMucHJvdG90eXBlLCBxcS5iYXNlUHVibGljQXBpKTtcbiAgICAgICAgcXEuZXh0ZW5kKHFxLnMzLkZpbmVVcGxvYWRlckJhc2ljLnByb3RvdHlwZSwgcXEuYmFzZVByaXZhdGVBcGkpO1xuICAgICAgICBxcS5leHRlbmQocXEuczMuRmluZVVwbG9hZGVyQmFzaWMucHJvdG90eXBlLCBxcS5ub25UcmFkaXRpb25hbEJhc2VQdWJsaWNBcGkpO1xuICAgICAgICBxcS5leHRlbmQocXEuczMuRmluZVVwbG9hZGVyQmFzaWMucHJvdG90eXBlLCBxcS5ub25UcmFkaXRpb25hbEJhc2VQcml2YXRlQXBpKTtcbiAgICAgICAgcXEuZXh0ZW5kKHFxLnMzLkZpbmVVcGxvYWRlckJhc2ljLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgZ2V0QnVja2V0OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYW5uZWRCdWNrZXRzW2lkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9idWNrZXRzW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nhbm5lZEJ1Y2tldHNbaWRdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEtleTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FubmVkS2V5c1tpZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlci5nZXRUaGlyZFBhcnR5RmlsZUlkKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nhbm5lZEtleXNbaWRdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBxcS5GaW5lVXBsb2FkZXJCYXNpYy5wcm90b3R5cGUucmVzZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9mYWlsZWRTdWNjZXNzUmVxdWVzdENhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1Y2tldHMgPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ob3N0cyA9IHt9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldENyZWRlbnRpYWxzOiBmdW5jdGlvbihjcmVkZW50aWFscywgaWdub3JlRW1wdHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3JlZGVudGlhbHMgJiYgY3JlZGVudGlhbHMuc2VjcmV0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3JlZGVudGlhbHMuYWNjZXNzS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcXEuRXJyb3IoXCJJbnZhbGlkIGNyZWRlbnRpYWxzOiBubyBhY2Nlc3NLZXlcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNyZWRlbnRpYWxzLmV4cGlyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBxcS5FcnJvcihcIkludmFsaWQgY3JlZGVudGlhbHM6IG5vIGV4cGlyYXRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Q3JlZGVudGlhbHMgPSBxcS5leHRlbmQoe30sIGNyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxcS5pc1N0cmluZyhjcmVkZW50aWFscy5leHBpcmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDcmVkZW50aWFscy5leHBpcmF0aW9uID0gbmV3IERhdGUoY3JlZGVudGlhbHMuZXhwaXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaWdub3JlRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHFxLkVycm9yKFwiSW52YWxpZCBjcmVkZW50aWFscyBwYXJhbWV0ZXIhXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDcmVkZW50aWFscyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRBY2w6IGZ1bmN0aW9uKGFjbCwgaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY2xTdG9yZS5zZXQoYWNsLCBpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NyZWF0ZVVwbG9hZEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcywgYWRkaXRpb25hbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFjbFN0b3JlOiB0aGlzLl9hY2xTdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QnVja2V0OiBxcS5iaW5kKHRoaXMuX2RldGVybWluZUJ1Y2tldCwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGdldEhvc3Q6IHFxLmJpbmQodGhpcy5fZGV0ZXJtaW5lSG9zdCwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGdldEtleU5hbWU6IHFxLmJpbmQodGhpcy5fZGV0ZXJtaW5lS2V5TmFtZSwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZVN1cHBvcnQ6IHRoaXMuX29wdGlvbnMuaWZyYW1lU3VwcG9ydCxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0UHJvcGVydGllczogdGhpcy5fb3B0aW9ucy5vYmplY3RQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHRoaXMuX29wdGlvbnMuc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICAgICBjbG9ja0RyaWZ0OiB0aGlzLl9vcHRpb25zLnJlcXVlc3QuY2xvY2tEcmlmdCxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluU2l6ZUxpbWl0OiB0aGlzLl9vcHRpb25zLnZhbGlkYXRpb24ubWluU2l6ZUxpbWl0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4U2l6ZUxpbWl0OiB0aGlzLl9vcHRpb25zLnZhbGlkYXRpb24uc2l6ZUxpbWl0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHFxLm92ZXJyaWRlKHRoaXMuX2VuZHBvaW50U3RvcmUsIGZ1bmN0aW9uKHN1cGVyXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRwb2ludCA9IHN1cGVyXy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRwb2ludC5pbmRleE9mKFwiaHR0cFwiKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cDovL1wiICsgZW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmRwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBxcS5vdmVycmlkZSh0aGlzLl9wYXJhbXNTdG9yZSwgZnVuY3Rpb24oc3VwZXJfKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFBhcmFtcyA9IHN1cGVyXy5nZXQoaWQpLCBtb2RpZmllZFBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFxLmVhY2gob2xkUGFyYW1zLCBmdW5jdGlvbihuYW1lLCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtTmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxcS5pbmRleE9mKHFxLnMzLnV0aWwuQ0FTRV9TRU5TSVRJVkVfUEFSQU1fTkFNRVMsIHBhcmFtTmFtZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWUgPSBwYXJhbU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZFBhcmFtc1twYXJhbU5hbWVdID0gcXEuaXNGdW5jdGlvbih2YWwpID8gdmFsKCkgOiB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZGlmaWVkUGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zLnNpZ25hdHVyZS5jcmVkZW50aWFsc1Byb3ZpZGVyID0ge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2N1cnJlbnRDcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25FeHBpcmVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVDcmVkZW50aWFscyA9IG5ldyBxcS5Qcm9taXNlKCksIGNhbGxiYWNrUmV0VmFsID0gc2VsZi5fb3B0aW9ucy5jYWxsYmFja3Mub25DcmVkZW50aWFsc0V4cGlyZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxcS5pc0dlbmVyaWNQcm9taXNlKGNhbGxiYWNrUmV0VmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrUmV0VmFsLnRoZW4oZnVuY3Rpb24oY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ3JlZGVudGlhbHMuc3VjY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2coXCJJbnZhbGlkIGNyZWRlbnRpYWxzIHJldHVybmVkIGZyb20gb25DcmVkZW50aWFsc0V4cGlyZWQgY2FsbGJhY2shIChcIiArIGVycm9yLm1lc3NhZ2UgKyBcIilcIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNyZWRlbnRpYWxzLmZhaWx1cmUoXCJvbkNyZWRlbnRpYWxzRXhwaXJlZCBkaWQgbm90IHJldHVybiB2YWxpZCBjcmVkZW50aWFscy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvck1zZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZyhcIm9uQ3JlZGVudGlhbHNFeHBpcmVkIGNhbGxiYWNrIGluZGljYXRlZCBmYWlsdXJlISAoXCIgKyBlcnJvck1zZyArIFwiKVwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVDcmVkZW50aWFscy5mYWlsdXJlKFwib25DcmVkZW50aWFsc0V4cGlyZWQgY2FsbGJhY2sgZmFpbGVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2coXCJvbkNyZWRlbnRpYWxzRXhwaXJlZCBjYWxsYmFjayBkaWQgbm90IHJldHVybiBhIHByb21pc2UhXCIsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ3JlZGVudGlhbHMuZmFpbHVyZShcIlVuZXhwZWN0ZWQgcmV0dXJuIHZhbHVlIGZvciBvbkNyZWRlbnRpYWxzRXhwaXJlZC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlQ3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBxcS5GaW5lVXBsb2FkZXJCYXNpYy5wcm90b3R5cGUuX2NyZWF0ZVVwbG9hZEhhbmRsZXIuY2FsbCh0aGlzLCBhZGRpdGlvbmFsT3B0aW9ucywgXCJzM1wiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZGV0ZXJtaW5lT2JqZWN0UHJvcGVydHlWYWx1ZTogZnVuY3Rpb24oaWQsIHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heWJlID0gdGhpcy5fb3B0aW9ucy5vYmplY3RQcm9wZXJ0aWVzW3Byb3BlcnR5XSwgcHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCksIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmIChxcS5pc0Z1bmN0aW9uKG1heWJlKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXliZSA9IG1heWJlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHFxLmlzR2VuZXJpY1Byb21pc2UobWF5YmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gbWF5YmU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3MobWF5YmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxcS5pc1N0cmluZyhtYXliZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKG1heWJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIHN1Y2Nlc3ModmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZltcIl9cIiArIHByb3BlcnR5ICsgXCJzXCJdW2lkXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIGZhaWx1cmUoZXJyb3JNc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEubG9nKFwiUHJvYmxlbSBkZXRlcm1pbmluZyBcIiArIHByb3BlcnR5ICsgXCIgZm9yIElEIFwiICsgaWQgKyBcIiAoXCIgKyBlcnJvck1zZyArIFwiKVwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9kZXRlcm1pbmVCdWNrZXQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RldGVybWluZU9iamVjdFByb3BlcnR5VmFsdWUoaWQsIFwiYnVja2V0XCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9kZXRlcm1pbmVIb3N0OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXRlcm1pbmVPYmplY3RQcm9wZXJ0eVZhbHVlKGlkLCBcImhvc3RcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2RldGVybWluZUtleU5hbWU6IGZ1bmN0aW9uKGlkLCBmaWxlbmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHFxLlByb21pc2UoKSwga2V5bmFtZUxvZ2ljID0gdGhpcy5fb3B0aW9ucy5vYmplY3RQcm9wZXJ0aWVzLmtleSwgZXh0ZW5zaW9uID0gcXEuZ2V0RXh0ZW5zaW9uKGZpbGVuYW1lKSwgb25HZXRLZXluYW1lRmFpbHVyZSA9IHByb21pc2UuZmFpbHVyZSwgb25HZXRLZXluYW1lU3VjY2VzcyA9IGZ1bmN0aW9uKGtleW5hbWUsIGV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5bmFtZVRvVXNlID0ga2V5bmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXluYW1lVG9Vc2UgKz0gXCIuXCIgKyBleHRlbnNpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKGtleW5hbWVUb1VzZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGtleW5hbWVMb2dpYykge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInV1aWRcIjpcbiAgICAgICAgICAgICAgICAgICAgb25HZXRLZXluYW1lU3VjY2Vzcyh0aGlzLmdldFV1aWQoaWQpLCBleHRlbnNpb24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbGVuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgIG9uR2V0S2V5bmFtZVN1Y2Nlc3MoZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHFxLmlzRnVuY3Rpb24oa2V5bmFtZUxvZ2ljKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlS2V5bmFtZUZ1bmN0aW9uKGtleW5hbWVMb2dpYywgaWQsIG9uR2V0S2V5bmFtZVN1Y2Nlc3MsIG9uR2V0S2V5bmFtZUZhaWx1cmUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coa2V5bmFtZUxvZ2ljICsgXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHRoZSBzMy5rZXluYW1lIG9wdGlvbiFcIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uR2V0S2V5bmFtZUZhaWx1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaGFuZGxlS2V5bmFtZUZ1bmN0aW9uOiBmdW5jdGlvbihrZXluYW1lRnVuYywgaWQsIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBvblN1Y2Nlc3MgPSBmdW5jdGlvbihrZXluYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayhrZXluYW1lKTtcbiAgICAgICAgICAgICAgICB9LCBvbkZhaWx1cmUgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2cocXEuZm9ybWF0KFwiRmFpbGVkIHRvIHJldHJpZXZlIGtleSBuYW1lIGZvciB7fS4gIFJlYXNvbjoge31cIiwgaWQsIHJlYXNvbiB8fCBcIm51bGxcIiksIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmVDYWxsYmFjayhyZWFzb24pO1xuICAgICAgICAgICAgICAgIH0sIGtleW5hbWUgPSBrZXluYW1lRnVuYy5jYWxsKHRoaXMsIGlkKTtcbiAgICAgICAgICAgICAgICBpZiAocXEuaXNHZW5lcmljUHJvbWlzZShrZXluYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBrZXluYW1lLnRoZW4ob25TdWNjZXNzLCBvbkZhaWx1cmUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5bmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzcyhrZXluYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldEVuZHBvaW50U3BlY2lmaWNQYXJhbXM6IGZ1bmN0aW9uKGlkLCByZXNwb25zZSwgbWF5YmVYaHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IHRoaXMuZ2V0S2V5KGlkKSxcbiAgICAgICAgICAgICAgICAgICAgdXVpZDogdGhpcy5nZXRVdWlkKGlkKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5nZXROYW1lKGlkKSxcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0OiB0aGlzLmdldEJ1Y2tldChpZClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChtYXliZVhociAmJiBtYXliZVhoci5nZXRSZXNwb25zZUhlYWRlcihcIkVUYWdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV0YWcgPSBtYXliZVhoci5nZXRSZXNwb25zZUhlYWRlcihcIkVUYWdcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5ldGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldGFnID0gcmVzcG9uc2UuZXRhZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25TdWJtaXREZWxldGU6IGZ1bmN0aW9uKGlkLCBvblN1Y2Nlc3NDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsTWFuZGF0ZWRQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogdGhpcy5nZXRLZXkoaWQpLFxuICAgICAgICAgICAgICAgICAgICBidWNrZXQ6IHRoaXMuZ2V0QnVja2V0KGlkKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHFxLkZpbmVVcGxvYWRlckJhc2ljLnByb3RvdHlwZS5fb25TdWJtaXREZWxldGUuY2FsbCh0aGlzLCBpZCwgb25TdWNjZXNzQ2FsbGJhY2ssIGFkZGl0aW9uYWxNYW5kYXRlZFBhcmFtcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2FkZENhbm5lZEZpbGU6IGZ1bmN0aW9uKHNlc3Npb25EYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkO1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRGF0YS5zM0tleSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBxcS5FcnJvcihcIkRpZCBub3QgZmluZCBzM0tleSBwcm9wZXJ0eSBpbiBzZXJ2ZXIgc2Vzc2lvbiByZXNwb25zZS4gIFRoaXMgaXMgcmVxdWlyZWQhXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gcXEuRmluZVVwbG9hZGVyQmFzaWMucHJvdG90eXBlLl9hZGRDYW5uZWRGaWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nhbm5lZEtleXNbaWRdID0gc2Vzc2lvbkRhdGEuczNLZXk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nhbm5lZEJ1Y2tldHNbaWRdID0gc2Vzc2lvbkRhdGEuczNCdWNrZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSkoKTtcbiAgICBpZiAoIXdpbmRvdy5VaW50OENsYW1wZWRBcnJheSkge1xuICAgICAgICB3aW5kb3cuVWludDhDbGFtcGVkQXJyYXkgPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgICBxcS5zMy5SZXF1ZXN0U2lnbmVyID0gZnVuY3Rpb24obykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIHJlcXVlc3RlciwgdGhpc1NpZ25hdHVyZVJlcXVlc3RlciA9IHRoaXMsIHBlbmRpbmdTaWduYXR1cmVzID0ge30sIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBleHBlY3RpbmdQb2xpY3k6IGZhbHNlLFxuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIHNpZ25hdHVyZVNwZWM6IHtcbiAgICAgICAgICAgICAgICBkcmlmdDogMCxcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFsc1Byb3ZpZGVyOiB7fSxcbiAgICAgICAgICAgICAgICBlbmRwb2ludDogbnVsbCxcbiAgICAgICAgICAgICAgICBjdXN0b21IZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF4Q29ubmVjdGlvbnM6IDMsXG4gICAgICAgICAgICBlbmRwb2ludFN0b3JlOiB7fSxcbiAgICAgICAgICAgIHBhcmFtc1N0b3JlOiB7fSxcbiAgICAgICAgICAgIGNvcnM6IHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VuZENyZWRlbnRpYWxzOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvZzogZnVuY3Rpb24oc3RyLCBsZXZlbCkge31cbiAgICAgICAgfSwgY3JlZGVudGlhbHNQcm92aWRlciwgZ2VuZXJhdGVIZWFkZXJzID0gZnVuY3Rpb24oc2lnbmF0dXJlQ29uc3RydWN0b3IsIHNpZ25hdHVyZSwgcHJvbWlzZSkge1xuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBzaWduYXR1cmVDb25zdHJ1Y3Rvci5nZXRIZWFkZXJzKCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaWduYXR1cmVTcGVjLnZlcnNpb24gPT09IDQpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBxcS5zMy51dGlsLlY0X0FMR09SSVRITV9QQVJBTV9WQUxVRSArIFwiIENyZWRlbnRpYWw9XCIgKyBvcHRpb25zLnNpZ25hdHVyZVNwZWMuY3JlZGVudGlhbHNQcm92aWRlci5nZXQoKS5hY2Nlc3NLZXkgKyBcIi9cIiArIHFxLnMzLnV0aWwuZ2V0Q3JlZGVudGlhbHNEYXRlKHNpZ25hdHVyZUNvbnN0cnVjdG9yLmdldFJlcXVlc3REYXRlKCkpICsgXCIvXCIgKyBvcHRpb25zLnNpZ25hdHVyZVNwZWMucmVnaW9uICsgXCIvXCIgKyBcInMzL2F3czRfcmVxdWVzdCxcIiArIFwiU2lnbmVkSGVhZGVycz1cIiArIHNpZ25hdHVyZUNvbnN0cnVjdG9yLmdldFNpZ25lZEhlYWRlcnMoKSArIFwiLFwiICsgXCJTaWduYXR1cmU9XCIgKyBzaWduYXR1cmU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IFwiQVdTIFwiICsgb3B0aW9ucy5zaWduYXR1cmVTcGVjLmNyZWRlbnRpYWxzUHJvdmlkZXIuZ2V0KCkuYWNjZXNzS2V5ICsgXCI6XCIgKyBzaWduYXR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3MoaGVhZGVycywgc2lnbmF0dXJlQ29uc3RydWN0b3IuZ2V0RW5kT2ZVcmwoKSk7XG4gICAgICAgIH0sIHYyID0ge1xuICAgICAgICAgICAgZ2V0U3RyaW5nVG9TaWduOiBmdW5jdGlvbihzaWduYXR1cmVTcGVjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHFxLmZvcm1hdChcInt9XFxue31cXG57fVxcblxcbnt9L3t9L3t9XCIsIHNpZ25hdHVyZVNwZWMubWV0aG9kLCBzaWduYXR1cmVTcGVjLmNvbnRlbnRNZDUgfHwgXCJcIiwgc2lnbmF0dXJlU3BlYy5jb250ZW50VHlwZSB8fCBcIlwiLCBzaWduYXR1cmVTcGVjLmhlYWRlcnNTdHIgfHwgXCJcXG5cIiwgc2lnbmF0dXJlU3BlYy5idWNrZXQsIHNpZ25hdHVyZVNwZWMuZW5kT2ZVcmwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpZ25BcGlSZXF1ZXN0OiBmdW5jdGlvbihzaWduYXR1cmVDb25zdHJ1Y3RvciwgaGVhZGVyc1N0ciwgc2lnbmF0dXJlRWZmb3J0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlcnNXb3JkQXJyYXkgPSBxcS5DcnlwdG9KUy5lbmMuVXRmOC5wYXJzZShoZWFkZXJzU3RyKSwgaGVhZGVyc0htYWNTaGExID0gcXEuQ3J5cHRvSlMuSG1hY1NIQTEoaGVhZGVyc1dvcmRBcnJheSwgY3JlZGVudGlhbHNQcm92aWRlci5nZXQoKS5zZWNyZXRLZXkpLCBoZWFkZXJzSG1hY1NoYTFCYXNlNjQgPSBxcS5DcnlwdG9KUy5lbmMuQmFzZTY0LnN0cmluZ2lmeShoZWFkZXJzSG1hY1NoYTEpO1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlSGVhZGVycyhzaWduYXR1cmVDb25zdHJ1Y3RvciwgaGVhZGVyc0htYWNTaGExQmFzZTY0LCBzaWduYXR1cmVFZmZvcnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpZ25Qb2xpY3k6IGZ1bmN0aW9uKHBvbGljeSwgc2lnbmF0dXJlRWZmb3J0LCB1cGRhdGVkQWNjZXNzS2V5LCB1cGRhdGVkU2Vzc2lvblRva2VuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvbGljeVN0ciA9IEpTT04uc3RyaW5naWZ5KHBvbGljeSksIHBvbGljeVdvcmRBcnJheSA9IHFxLkNyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKHBvbGljeVN0ciksIGJhc2U2NFBvbGljeSA9IHFxLkNyeXB0b0pTLmVuYy5CYXNlNjQuc3RyaW5naWZ5KHBvbGljeVdvcmRBcnJheSksIHBvbGljeUhtYWNTaGExID0gcXEuQ3J5cHRvSlMuSG1hY1NIQTEoYmFzZTY0UG9saWN5LCBjcmVkZW50aWFsc1Byb3ZpZGVyLmdldCgpLnNlY3JldEtleSksIHBvbGljeUhtYWNTaGExQmFzZTY0ID0gcXEuQ3J5cHRvSlMuZW5jLkJhc2U2NC5zdHJpbmdpZnkocG9saWN5SG1hY1NoYTEpO1xuICAgICAgICAgICAgICAgIHNpZ25hdHVyZUVmZm9ydC5zdWNjZXNzKHtcbiAgICAgICAgICAgICAgICAgICAgcG9saWN5OiBiYXNlNjRQb2xpY3ksXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogcG9saWN5SG1hY1NoYTFCYXNlNjRcbiAgICAgICAgICAgICAgICB9LCB1cGRhdGVkQWNjZXNzS2V5LCB1cGRhdGVkU2Vzc2lvblRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdjQgPSB7XG4gICAgICAgICAgICBnZXRDYW5vbmljYWxRdWVyeVN0cmluZzogZnVuY3Rpb24oZW5kT2ZVcmkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcXVlcnlQYXJhbUlkeCA9IGVuZE9mVXJpLmluZGV4T2YoXCI/XCIpLCBjYW5vbmljYWxRdWVyeVN0cmluZyA9IFwiXCIsIGVuY29kZWRRdWVyeVBhcmFtcywgZW5jb2RlZFF1ZXJ5UGFyYW1OYW1lcywgcXVlcnlTdHJpbmdzO1xuICAgICAgICAgICAgICAgIGlmIChxdWVyeVBhcmFtSWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlZFF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5ncyA9IGVuZE9mVXJpLnN1YnN0cihxdWVyeVBhcmFtSWR4ICsgMSkuc3BsaXQoXCImXCIpO1xuICAgICAgICAgICAgICAgICAgICBxcS5lYWNoKHF1ZXJ5U3RyaW5ncywgZnVuY3Rpb24oaWR4LCBxdWVyeVN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVBbmRWYWwgPSBxdWVyeVN0cmluZy5zcGxpdChcIj1cIiksIHBhcmFtVmFsID0gbmFtZUFuZFZhbFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbVZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1WYWwgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZFF1ZXJ5UGFyYW1zW2VuY29kZVVSSUNvbXBvbmVudChuYW1lQW5kVmFsWzBdKV0gPSBlbmNvZGVVUklDb21wb25lbnQocGFyYW1WYWwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlZFF1ZXJ5UGFyYW1OYW1lcyA9IE9iamVjdC5rZXlzKGVuY29kZWRRdWVyeVBhcmFtcykuc29ydCgpO1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVkUXVlcnlQYXJhbU5hbWVzLmZvckVhY2goZnVuY3Rpb24oZW5jb2RlZFF1ZXJ5UGFyYW1OYW1lLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFF1ZXJ5U3RyaW5nICs9IGVuY29kZWRRdWVyeVBhcmFtTmFtZSArIFwiPVwiICsgZW5jb2RlZFF1ZXJ5UGFyYW1zW2VuY29kZWRRdWVyeVBhcmFtTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4IDwgZW5jb2RlZFF1ZXJ5UGFyYW1OYW1lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsUXVlcnlTdHJpbmcgKz0gXCImXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2Fub25pY2FsUXVlcnlTdHJpbmc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q2Fub25pY2FsUmVxdWVzdDogZnVuY3Rpb24oc2lnbmF0dXJlU3BlYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBxcS5mb3JtYXQoXCJ7fVxcbnt9XFxue31cXG57fVxcbnt9XFxue31cIiwgc2lnbmF0dXJlU3BlYy5tZXRob2QsIHY0LmdldENhbm9uaWNhbFVyaShzaWduYXR1cmVTcGVjLmVuZE9mVXJsKSwgdjQuZ2V0Q2Fub25pY2FsUXVlcnlTdHJpbmcoc2lnbmF0dXJlU3BlYy5lbmRPZlVybCksIHNpZ25hdHVyZVNwZWMuaGVhZGVyc1N0ciB8fCBcIlxcblwiLCB2NC5nZXRTaWduZWRIZWFkZXJzKHNpZ25hdHVyZVNwZWMuaGVhZGVyTmFtZXMpLCBzaWduYXR1cmVTcGVjLmhhc2hlZENvbnRlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENhbm9uaWNhbFVyaTogZnVuY3Rpb24oZW5kT2ZVcmkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IGVuZE9mVXJpLCBxdWVyeVBhcmFtSWR4ID0gZW5kT2ZVcmkuaW5kZXhPZihcIj9cIik7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5UGFyYW1JZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBlbmRPZlVyaS5zdWJzdHIoMCwgcXVlcnlQYXJhbUlkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBcIi9cIiArIHBhdGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RW5jb2RlZEhhc2hlZFBheWxvYWQ6IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCksIHJlYWRlcjtcbiAgICAgICAgICAgICAgICBpZiAocXEuaXNCbG9iKGJvZHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQucmVhZHlTdGF0ZSA9PT0gRmlsZVJlYWRlci5ET05FKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuZmFpbHVyZShlLnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdvcmRBcnJheSA9IHFxLkNyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2Uuc3VjY2VzcyhxcS5DcnlwdG9KUy5TSEEyNTYod29yZEFycmF5KS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihib2R5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gYm9keSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3MocXEuQ3J5cHRvSlMuU0hBMjU2KGJvZHkpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRTY29wZTogZnVuY3Rpb24oZGF0ZSwgcmVnaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHFxLnMzLnV0aWwuZ2V0Q3JlZGVudGlhbHNEYXRlKGRhdGUpICsgXCIvXCIgKyByZWdpb24gKyBcIi9zMy9hd3M0X3JlcXVlc3RcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRTdHJpbmdUb1NpZ246IGZ1bmN0aW9uKHNpZ25hdHVyZVNwZWMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2Fub25pY2FsUmVxdWVzdCA9IHY0LmdldENhbm9uaWNhbFJlcXVlc3Qoc2lnbmF0dXJlU3BlYyksIGRhdGUgPSBxcS5zMy51dGlsLmdldFY0UG9saWN5RGF0ZShzaWduYXR1cmVTcGVjLmRhdGUsIHNpZ25hdHVyZVNwZWMuZHJpZnQpLCBoYXNoZWRSZXF1ZXN0ID0gcXEuQ3J5cHRvSlMuU0hBMjU2KGNhbm9uaWNhbFJlcXVlc3QpLnRvU3RyaW5nKCksIHNjb3BlID0gdjQuZ2V0U2NvcGUoc2lnbmF0dXJlU3BlYy5kYXRlLCBvcHRpb25zLnNpZ25hdHVyZVNwZWMucmVnaW9uKSwgc3RyaW5nVG9TaWduVGVtcGxhdGUgPSBcIkFXUzQtSE1BQy1TSEEyNTZcXG57fVxcbnt9XFxue31cIjtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoYXNoZWQ6IHFxLmZvcm1hdChzdHJpbmdUb1NpZ25UZW1wbGF0ZSwgZGF0ZSwgc2NvcGUsIGhhc2hlZFJlcXVlc3QpLFxuICAgICAgICAgICAgICAgICAgICByYXc6IHFxLmZvcm1hdChzdHJpbmdUb1NpZ25UZW1wbGF0ZSwgZGF0ZSwgc2NvcGUsIGNhbm9uaWNhbFJlcXVlc3QpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRTaWduZWRIZWFkZXJzOiBmdW5jdGlvbihoZWFkZXJOYW1lcykge1xuICAgICAgICAgICAgICAgIHZhciBzaWduZWRIZWFkZXJzID0gXCJcIjtcbiAgICAgICAgICAgICAgICBoZWFkZXJOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlck5hbWUsIGlkeCkge1xuICAgICAgICAgICAgICAgICAgICBzaWduZWRIZWFkZXJzICs9IGhlYWRlck5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA8IGhlYWRlck5hbWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25lZEhlYWRlcnMgKz0gXCI7XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmVkSGVhZGVycztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWduQXBpUmVxdWVzdDogZnVuY3Rpb24oc2lnbmF0dXJlQ29uc3RydWN0b3IsIGhlYWRlcnNTdHIsIHNpZ25hdHVyZUVmZm9ydCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWNyZXRLZXkgPSBjcmVkZW50aWFsc1Byb3ZpZGVyLmdldCgpLnNlY3JldEtleSwgaGVhZGVyc1BhdHRlcm4gPSAvLitcXG4uK1xcbihcXGQrKVxcLyguKylcXC9zM1xcLy4rXFxuKC4rKS8sIG1hdGNoZXMgPSBoZWFkZXJzUGF0dGVybi5leGVjKGhlYWRlcnNTdHIpLCBkYXRlS2V5LCBkYXRlUmVnaW9uS2V5LCBkYXRlUmVnaW9uU2VydmljZUtleSwgc2lnbmluZ0tleTtcbiAgICAgICAgICAgICAgICBkYXRlS2V5ID0gcXEuQ3J5cHRvSlMuSG1hY1NIQTI1NihtYXRjaGVzWzFdLCBcIkFXUzRcIiArIHNlY3JldEtleSk7XG4gICAgICAgICAgICAgICAgZGF0ZVJlZ2lvbktleSA9IHFxLkNyeXB0b0pTLkhtYWNTSEEyNTYobWF0Y2hlc1syXSwgZGF0ZUtleSk7XG4gICAgICAgICAgICAgICAgZGF0ZVJlZ2lvblNlcnZpY2VLZXkgPSBxcS5DcnlwdG9KUy5IbWFjU0hBMjU2KFwiczNcIiwgZGF0ZVJlZ2lvbktleSk7XG4gICAgICAgICAgICAgICAgc2lnbmluZ0tleSA9IHFxLkNyeXB0b0pTLkhtYWNTSEEyNTYoXCJhd3M0X3JlcXVlc3RcIiwgZGF0ZVJlZ2lvblNlcnZpY2VLZXkpO1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlSGVhZGVycyhzaWduYXR1cmVDb25zdHJ1Y3RvciwgcXEuQ3J5cHRvSlMuSG1hY1NIQTI1NihoZWFkZXJzU3RyLCBzaWduaW5nS2V5KSwgc2lnbmF0dXJlRWZmb3J0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWduUG9saWN5OiBmdW5jdGlvbihwb2xpY3ksIHNpZ25hdHVyZUVmZm9ydCwgdXBkYXRlZEFjY2Vzc0tleSwgdXBkYXRlZFNlc3Npb25Ub2tlbikge1xuICAgICAgICAgICAgICAgIHZhciBwb2xpY3lTdHIgPSBKU09OLnN0cmluZ2lmeShwb2xpY3kpLCBwb2xpY3lXb3JkQXJyYXkgPSBxcS5DcnlwdG9KUy5lbmMuVXRmOC5wYXJzZShwb2xpY3lTdHIpLCBiYXNlNjRQb2xpY3kgPSBxcS5DcnlwdG9KUy5lbmMuQmFzZTY0LnN0cmluZ2lmeShwb2xpY3lXb3JkQXJyYXkpLCBzZWNyZXRLZXkgPSBjcmVkZW50aWFsc1Byb3ZpZGVyLmdldCgpLnNlY3JldEtleSwgY3JlZGVudGlhbFBhdHRlcm4gPSAvLitcXC8oLispXFwvKC4rKVxcL3MzXFwvYXdzNF9yZXF1ZXN0LywgY3JlZGVudGlhbENvbmRpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3JlZGVudGlhbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHFxLmVhY2gocG9saWN5LmNvbmRpdGlvbnMsIGZ1bmN0aW9uKGtleSwgY29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gY29uZGl0aW9uW1wieC1hbXotY3JlZGVudGlhbFwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVkZW50aWFsO1xuICAgICAgICAgICAgICAgIH0oKSwgbWF0Y2hlcywgZGF0ZUtleSwgZGF0ZVJlZ2lvbktleSwgZGF0ZVJlZ2lvblNlcnZpY2VLZXksIHNpZ25pbmdLZXk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlcyA9IGNyZWRlbnRpYWxQYXR0ZXJuLmV4ZWMoY3JlZGVudGlhbENvbmRpdGlvbik7XG4gICAgICAgICAgICAgICAgZGF0ZUtleSA9IHFxLkNyeXB0b0pTLkhtYWNTSEEyNTYobWF0Y2hlc1sxXSwgXCJBV1M0XCIgKyBzZWNyZXRLZXkpO1xuICAgICAgICAgICAgICAgIGRhdGVSZWdpb25LZXkgPSBxcS5DcnlwdG9KUy5IbWFjU0hBMjU2KG1hdGNoZXNbMl0sIGRhdGVLZXkpO1xuICAgICAgICAgICAgICAgIGRhdGVSZWdpb25TZXJ2aWNlS2V5ID0gcXEuQ3J5cHRvSlMuSG1hY1NIQTI1NihcInMzXCIsIGRhdGVSZWdpb25LZXkpO1xuICAgICAgICAgICAgICAgIHNpZ25pbmdLZXkgPSBxcS5DcnlwdG9KUy5IbWFjU0hBMjU2KFwiYXdzNF9yZXF1ZXN0XCIsIGRhdGVSZWdpb25TZXJ2aWNlS2V5KTtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmVFZmZvcnQuc3VjY2Vzcyh7XG4gICAgICAgICAgICAgICAgICAgIHBvbGljeTogYmFzZTY0UG9saWN5LFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHFxLkNyeXB0b0pTLkhtYWNTSEEyNTYoYmFzZTY0UG9saWN5LCBzaWduaW5nS2V5KS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgfSwgdXBkYXRlZEFjY2Vzc0tleSwgdXBkYXRlZFNlc3Npb25Ub2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHFxLmV4dGVuZChvcHRpb25zLCBvLCB0cnVlKTtcbiAgICAgICAgY3JlZGVudGlhbHNQcm92aWRlciA9IG9wdGlvbnMuc2lnbmF0dXJlU3BlYy5jcmVkZW50aWFsc1Byb3ZpZGVyO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVTaWduYXR1cmVSZWNlaXZlZChpZCwgeGhyT3JYZHIsIGlzRXJyb3IpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZUpzb24gPSB4aHJPclhkci5yZXNwb25zZVRleHQsIHBlbmRpbmdTaWduYXR1cmVEYXRhID0gcGVuZGluZ1NpZ25hdHVyZXNbaWRdLCBwcm9taXNlID0gcGVuZGluZ1NpZ25hdHVyZURhdGEucHJvbWlzZSwgc2lnbmF0dXJlQ29uc3RydWN0b3IgPSBwZW5kaW5nU2lnbmF0dXJlRGF0YS5zaWduYXR1cmVDb25zdHJ1Y3RvciwgZXJyb3JNZXNzYWdlLCByZXNwb25zZTtcbiAgICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nU2lnbmF0dXJlc1tpZF07XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VKc29uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBxcS5wYXJzZUpzb24ocmVzcG9uc2VKc29uKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvZyhcIkVycm9yIGF0dGVtcHRpbmcgdG8gcGFyc2Ugc2lnbmF0dXJlIHJlc3BvbnNlOiBcIiArIGVycm9yLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICAgIGlzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHJlc3BvbnNlLmVycm9yO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5pbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgaXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJJbnZhbGlkIHBvbGljeSBkb2N1bWVudCBvciByZXF1ZXN0IGhlYWRlcnMhXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXhwZWN0aW5nUG9saWN5ICYmICFyZXNwb25zZS5wb2xpY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IFwiUmVzcG9uc2UgZG9lcyBub3QgaW5jbHVkZSB0aGUgYmFzZTY0IGVuY29kZWQgcG9saWN5IVwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJlc3BvbnNlLnNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBpc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJSZXNwb25zZSBkb2VzIG5vdCBpbmNsdWRlIHRoZSBzaWduYXR1cmUhXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBcIlJlY2VpdmVkIGFuIGVtcHR5IG9yIGludmFsaWQgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyIVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9nKGVycm9yTWVzc2FnZSwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5mYWlsdXJlKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVIZWFkZXJzKHNpZ25hdHVyZUNvbnN0cnVjdG9yLCByZXNwb25zZS5zaWduYXR1cmUsIHByb21pc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3MocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldFN0cmluZ1RvU2lnbkFydGlmYWN0cyhpZCwgdmVyc2lvbiwgcmVxdWVzdEluZm8pIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHFxLlByb21pc2UoKSwgbWV0aG9kID0gXCJQT1NUXCIsIGhlYWRlck5hbWVzID0gW10sIGhlYWRlcnNTdHIgPSBcIlwiLCBub3cgPSBuZXcgRGF0ZSgpLCBlbmRPZlVybCwgc2lnbmF0dXJlU3BlYywgdG9TaWduLCBnZW5lcmF0ZVN0cmluZ1RvU2lnbiA9IGZ1bmN0aW9uKHJlcXVlc3RJbmZvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRNZDUsIGhlYWRlckluZGV4ZXNUb1JlbW92ZSA9IFtdO1xuICAgICAgICAgICAgICAgIHFxLmVhY2gocmVxdWVzdEluZm8uaGVhZGVycywgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJOYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGhlYWRlck5hbWVzLnNvcnQoKTtcbiAgICAgICAgICAgICAgICBxcS5lYWNoKGhlYWRlck5hbWVzLCBmdW5jdGlvbihpZHgsIGhlYWRlck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHFxLmluZGV4T2YocXEuczMudXRpbC5VTlNJR05BQkxFX1JFU1RfSEVBREVSX05BTUVTLCBoZWFkZXJOYW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNTdHIgKz0gaGVhZGVyTmFtZS50b0xvd2VyQ2FzZSgpICsgXCI6XCIgKyByZXF1ZXN0SW5mby5oZWFkZXJzW2hlYWRlck5hbWVdLnRyaW0oKSArIFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyTmFtZSA9PT0gXCJDb250ZW50LU1ENVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50TWQ1ID0gcmVxdWVzdEluZm8uaGVhZGVyc1toZWFkZXJOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlckluZGV4ZXNUb1JlbW92ZS51bnNoaWZ0KGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBxcS5lYWNoKGhlYWRlckluZGV4ZXNUb1JlbW92ZSwgZnVuY3Rpb24oaWR4LCBoZWFkZXJJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyTmFtZXMuc3BsaWNlKGhlYWRlcklkeCwgMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlU3BlYyA9IHtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0OiByZXF1ZXN0SW5mby5idWNrZXQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRNZDU6IGNvbnRlbnRNZDUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiByZXF1ZXN0SW5mby5jb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogbm93LFxuICAgICAgICAgICAgICAgICAgICBkcmlmdDogb3B0aW9ucy5zaWduYXR1cmVTcGVjLmRyaWZ0LFxuICAgICAgICAgICAgICAgICAgICBlbmRPZlVybDogZW5kT2ZVcmwsXG4gICAgICAgICAgICAgICAgICAgIGhhc2hlZENvbnRlbnQ6IHJlcXVlc3RJbmZvLmhhc2hlZENvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlck5hbWVzOiBoZWFkZXJOYW1lcyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1N0cjogaGVhZGVyc1N0cixcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2RcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRvU2lnbiA9IHZlcnNpb24gPT09IDIgPyB2Mi5nZXRTdHJpbmdUb1NpZ24oc2lnbmF0dXJlU3BlYykgOiB2NC5nZXRTdHJpbmdUb1NpZ24oc2lnbmF0dXJlU3BlYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogbm93LFxuICAgICAgICAgICAgICAgICAgICBlbmRPZlVybDogZW5kT2ZVcmwsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25lZEhlYWRlcnM6IHZlcnNpb24gPT09IDQgPyB2NC5nZXRTaWduZWRIZWFkZXJzKHNpZ25hdHVyZVNwZWMuaGVhZGVyTmFtZXMpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdG9TaWduOiB2ZXJzaW9uID09PSA0ID8gdG9TaWduLmhhc2hlZCA6IHRvU2lnbixcbiAgICAgICAgICAgICAgICAgICAgdG9TaWduUmF3OiB2ZXJzaW9uID09PSA0ID8gdG9TaWduLnJhdyA6IHRvU2lnblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3dpdGNoIChyZXF1ZXN0SW5mby50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgdGhpc1NpZ25hdHVyZVJlcXVlc3Rlci5SRVFVRVNUX1RZUEUuTVVMVElQQVJUX0FCT1JUOlxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IFwiREVMRVRFXCI7XG4gICAgICAgICAgICAgICAgZW5kT2ZVcmwgPSBxcS5mb3JtYXQoXCJ1cGxvYWRJZD17fVwiLCByZXF1ZXN0SW5mby51cGxvYWRJZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSB0aGlzU2lnbmF0dXJlUmVxdWVzdGVyLlJFUVVFU1RfVFlQRS5NVUxUSVBBUlRfSU5JVElBVEU6XG4gICAgICAgICAgICAgICAgZW5kT2ZVcmwgPSBcInVwbG9hZHNcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIHRoaXNTaWduYXR1cmVSZXF1ZXN0ZXIuUkVRVUVTVF9UWVBFLk1VTFRJUEFSVF9DT01QTEVURTpcbiAgICAgICAgICAgICAgICBlbmRPZlVybCA9IHFxLmZvcm1hdChcInVwbG9hZElkPXt9XCIsIHJlcXVlc3RJbmZvLnVwbG9hZElkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIHRoaXNTaWduYXR1cmVSZXF1ZXN0ZXIuUkVRVUVTVF9UWVBFLk1VTFRJUEFSVF9VUExPQUQ6XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJQVVRcIjtcbiAgICAgICAgICAgICAgICBlbmRPZlVybCA9IHFxLmZvcm1hdChcInBhcnROdW1iZXI9e30mdXBsb2FkSWQ9e31cIiwgcmVxdWVzdEluZm8ucGFydE51bSwgcmVxdWVzdEluZm8udXBsb2FkSWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kT2ZVcmwgPSByZXF1ZXN0SW5mby5rZXkgKyBcIj9cIiArIGVuZE9mVXJsO1xuICAgICAgICAgICAgaWYgKHZlcnNpb24gPT09IDQpIHtcbiAgICAgICAgICAgICAgICB2NC5nZXRFbmNvZGVkSGFzaGVkUGF5bG9hZChyZXF1ZXN0SW5mby5jb250ZW50KS50aGVuKGZ1bmN0aW9uKGhhc2hlZENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEluZm8uaGVhZGVyc1tcIngtYW16LWNvbnRlbnQtc2hhMjU2XCJdID0gaGFzaGVkQ29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEluZm8uaGVhZGVycy5Ib3N0ID0gcmVxdWVzdEluZm8uaG9zdDtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEluZm8uaGVhZGVyc1tcIngtYW16LWRhdGVcIl0gPSBxcS5zMy51dGlsLmdldFY0UG9saWN5RGF0ZShub3csIG9wdGlvbnMuc2lnbmF0dXJlU3BlYy5kcmlmdCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJbmZvLmhhc2hlZENvbnRlbnQgPSBoYXNoZWRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3MoZ2VuZXJhdGVTdHJpbmdUb1NpZ24ocmVxdWVzdEluZm8pKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5mYWlsdXJlKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2Uuc3VjY2VzcyhnZW5lcmF0ZVN0cmluZ1RvU2lnbihyZXF1ZXN0SW5mbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGV0ZXJtaW5lU2lnbmF0dXJlQ2xpZW50U2lkZShpZCwgdG9CZVNpZ25lZCwgc2lnbmF0dXJlRWZmb3J0LCB1cGRhdGVkQWNjZXNzS2V5LCB1cGRhdGVkU2Vzc2lvblRva2VuKSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlZEhlYWRlcnM7XG4gICAgICAgICAgICBpZiAodG9CZVNpZ25lZC5zaWduYXR1cmVDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVkU2Vzc2lvblRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRIZWFkZXJzID0gdG9CZVNpZ25lZC5zaWduYXR1cmVDb25zdHJ1Y3Rvci5nZXRIZWFkZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRIZWFkZXJzW3FxLnMzLnV0aWwuU0VTU0lPTl9UT0tFTl9QQVJBTV9OQU1FXSA9IHVwZGF0ZWRTZXNzaW9uVG9rZW47XG4gICAgICAgICAgICAgICAgICAgIHRvQmVTaWduZWQuc2lnbmF0dXJlQ29uc3RydWN0b3Iud2l0aEhlYWRlcnModXBkYXRlZEhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b0JlU2lnbmVkLnNpZ25hdHVyZUNvbnN0cnVjdG9yLmdldFRvU2lnbihpZCkudGhlbihmdW5jdGlvbihzaWduYXR1cmVBcnRpZmFjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbkFwaVJlcXVlc3QodG9CZVNpZ25lZC5zaWduYXR1cmVDb25zdHJ1Y3Rvciwgc2lnbmF0dXJlQXJ0aWZhY3RzLnN0cmluZ1RvU2lnbiwgc2lnbmF0dXJlRWZmb3J0KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlRWZmb3J0LmZhaWx1cmUoZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZFNlc3Npb25Ub2tlbiAmJiBxcS5zMy51dGlsLnJlZnJlc2hQb2xpY3lDcmVkZW50aWFscyh0b0JlU2lnbmVkLCB1cGRhdGVkU2Vzc2lvblRva2VuKTtcbiAgICAgICAgICAgICAgICBzaWduUG9saWN5KHRvQmVTaWduZWQsIHNpZ25hdHVyZUVmZm9ydCwgdXBkYXRlZEFjY2Vzc0tleSwgdXBkYXRlZFNlc3Npb25Ub2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2lnblBvbGljeShwb2xpY3ksIHNpZ25hdHVyZUVmZm9ydCwgdXBkYXRlZEFjY2Vzc0tleSwgdXBkYXRlZFNlc3Npb25Ub2tlbikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmF0dXJlU3BlYy52ZXJzaW9uID09PSA0KSB7XG4gICAgICAgICAgICAgICAgdjQuc2lnblBvbGljeShwb2xpY3ksIHNpZ25hdHVyZUVmZm9ydCwgdXBkYXRlZEFjY2Vzc0tleSwgdXBkYXRlZFNlc3Npb25Ub2tlbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHYyLnNpZ25Qb2xpY3kocG9saWN5LCBzaWduYXR1cmVFZmZvcnQsIHVwZGF0ZWRBY2Nlc3NLZXksIHVwZGF0ZWRTZXNzaW9uVG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNpZ25BcGlSZXF1ZXN0KHNpZ25hdHVyZUNvbnN0cnVjdG9yLCBoZWFkZXJzU3RyLCBzaWduYXR1cmVFZmZvcnQpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNpZ25hdHVyZVNwZWMudmVyc2lvbiA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHY0LnNpZ25BcGlSZXF1ZXN0KHNpZ25hdHVyZUNvbnN0cnVjdG9yLCBoZWFkZXJzU3RyLCBzaWduYXR1cmVFZmZvcnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2Mi5zaWduQXBpUmVxdWVzdChzaWduYXR1cmVDb25zdHJ1Y3RvciwgaGVhZGVyc1N0ciwgc2lnbmF0dXJlRWZmb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0ZXIgPSBxcS5leHRlbmQodGhpcywgbmV3IHFxLkFqYXhSZXF1ZXN0ZXIoe1xuICAgICAgICAgICAgYWNjZXB0SGVhZGVyOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgICAgICBlbmRwb2ludFN0b3JlOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuc2lnbmF0dXJlU3BlYy5lbmRwb2ludDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyYW1zU3RvcmU6IG9wdGlvbnMucGFyYW1zU3RvcmUsXG4gICAgICAgICAgICBtYXhDb25uZWN0aW9uczogb3B0aW9ucy5tYXhDb25uZWN0aW9ucyxcbiAgICAgICAgICAgIGN1c3RvbUhlYWRlcnM6IG9wdGlvbnMuc2lnbmF0dXJlU3BlYy5jdXN0b21IZWFkZXJzLFxuICAgICAgICAgICAgbG9nOiBvcHRpb25zLmxvZyxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IGhhbmRsZVNpZ25hdHVyZVJlY2VpdmVkLFxuICAgICAgICAgICAgY29yczogb3B0aW9ucy5jb3JzXG4gICAgICAgIH0pKTtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIGdldFNpZ25hdHVyZTogZnVuY3Rpb24oaWQsIHRvQmVTaWduZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gdG9CZVNpZ25lZCwgc2lnbmF0dXJlQ29uc3RydWN0b3IgPSB0b0JlU2lnbmVkLnNpZ25hdHVyZUNvbnN0cnVjdG9yLCBzaWduYXR1cmVFZmZvcnQgPSBuZXcgcXEuUHJvbWlzZSgpLCBxdWVyeVBhcmFtcztcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaWduYXR1cmVTcGVjLnZlcnNpb24gPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2NDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3JlZGVudGlhbHNQcm92aWRlci5nZXQoKS5zZWNyZXRLZXkgJiYgcXEuQ3J5cHRvSlMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNyZWRlbnRpYWxzUHJvdmlkZXIuZ2V0KCkuZXhwaXJhdGlvbi5nZXRUaW1lKCkgPiBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRlcm1pbmVTaWduYXR1cmVDbGllbnRTaWRlKGlkLCB0b0JlU2lnbmVkLCBzaWduYXR1cmVFZmZvcnQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHNQcm92aWRlci5vbkV4cGlyZWQoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGVybWluZVNpZ25hdHVyZUNsaWVudFNpZGUoaWQsIHRvQmVTaWduZWQsIHNpZ25hdHVyZUVmZm9ydCwgY3JlZGVudGlhbHNQcm92aWRlci5nZXQoKS5hY2Nlc3NLZXksIGNyZWRlbnRpYWxzUHJvdmlkZXIuZ2V0KCkuc2Vzc2lvblRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yTXNnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2coXCJBdHRlbXB0IHRvIHVwZGF0ZSBleHBpcmVkIGNyZWRlbnRpYWxzIGFwcGFyZW50bHkgZmFpbGVkISBVbmFibGUgdG8gc2lnbiByZXF1ZXN0LiAgXCIsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlRWZmb3J0LmZhaWx1cmUoXCJVbmFibGUgdG8gc2lnbiByZXF1ZXN0IC0gZXhwaXJlZCBjcmVkZW50aWFscy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9nKFwiU3VibWl0dGluZyBTMyBzaWduYXR1cmUgcmVxdWVzdCBmb3IgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWduYXR1cmVDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlQ29uc3RydWN0b3IuZ2V0VG9TaWduKGlkKS50aGVuKGZ1bmN0aW9uKHNpZ25hdHVyZUFydGlmYWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogc2lnbmF0dXJlQXJ0aWZhY3RzLnN0cmluZ1RvU2lnblJhd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVyLmluaXRUcmFuc3BvcnQoaWQpLndpdGhQYXJhbXMocGFyYW1zKS53aXRoUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpLnNlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9nKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCBzaWduYXR1cmUuIFwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZUVmZm9ydC5mYWlsdXJlKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCBzaWduYXR1cmUuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZXIuaW5pdFRyYW5zcG9ydChpZCkud2l0aFBhcmFtcyhwYXJhbXMpLndpdGhRdWVyeVBhcmFtcyhxdWVyeVBhcmFtcykuc2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdTaWduYXR1cmVzW2lkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2U6IHNpZ25hdHVyZUVmZm9ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZUNvbnN0cnVjdG9yOiBzaWduYXR1cmVDb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlRWZmb3J0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnN0cnVjdFN0cmluZ1RvU2lnbjogZnVuY3Rpb24odHlwZSwgYnVja2V0LCBob3N0LCBrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IHt9LCB1cGxvYWRJZCwgY29udGVudCwgY29udGVudFR5cGUsIHBhcnROdW0sIGFydGlmYWN0cztcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB3aXRoSGVhZGVyczogZnVuY3Rpb24odGhlSGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyA9IHRoZUhlYWRlcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd2l0aFVwbG9hZElkOiBmdW5jdGlvbih0aGVVcGxvYWRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkSWQgPSB0aGVVcGxvYWRJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3aXRoQ29udGVudDogZnVuY3Rpb24odGhlQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IHRoZUNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd2l0aENvbnRlbnRUeXBlOiBmdW5jdGlvbih0aGVDb250ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGUgPSB0aGVDb250ZW50VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3aXRoUGFydE51bTogZnVuY3Rpb24odGhlUGFydE51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydE51bSA9IHRoZVBhcnROdW07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VG9TaWduOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlc3Npb25Ub2tlbiA9IGNyZWRlbnRpYWxzUHJvdmlkZXIuZ2V0KCkuc2Vzc2lvblRva2VuLCBwcm9taXNlID0gbmV3IHFxLlByb21pc2UoKSwgYWRqdXN0ZWREYXRlID0gbmV3IERhdGUoRGF0ZS5ub3coKSArIG9wdGlvbnMuc2lnbmF0dXJlU3BlYy5kcmlmdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW1wieC1hbXotZGF0ZVwiXSA9IGFkanVzdGVkRGF0ZS50b1VUQ1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlc3Npb25Ub2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbcXEuczMudXRpbC5TRVNTSU9OX1RPS0VOX1BBUkFNX05BTUVdID0gc2Vzc2lvblRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RyaW5nVG9TaWduQXJ0aWZhY3RzKGlkLCBvcHRpb25zLnNpZ25hdHVyZVNwZWMudmVyc2lvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1Y2tldDogYnVja2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogaG9zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0TnVtOiBwYXJ0TnVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkSWQ6IHVwbG9hZElkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKF9hcnRpZmFjdHNfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJ0aWZhY3RzID0gX2FydGlmYWN0c187XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gY29udGVudFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaGVhZGVycy5Ib3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogYXJ0aWZhY3RzLmRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZE9mVXJsOiBhcnRpZmFjdHMuZW5kT2ZVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25lZEhlYWRlcnM6IGFydGlmYWN0cy5zaWduZWRIZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdUb1NpZ246IGFydGlmYWN0cy50b1NpZ24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ1RvU2lnblJhdzogYXJ0aWZhY3RzLnRvU2lnblJhd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5mYWlsdXJlKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBxcS5leHRlbmQoe30sIGhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRFbmRPZlVybDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJ0aWZhY3RzICYmIGFydGlmYWN0cy5lbmRPZlVybDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0UmVxdWVzdERhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFydGlmYWN0cyAmJiBhcnRpZmFjdHMuZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0U2lnbmVkSGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJ0aWZhY3RzICYmIGFydGlmYWN0cy5zaWduZWRIZWFkZXJzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBxcS5zMy5SZXF1ZXN0U2lnbmVyLnByb3RvdHlwZS5SRVFVRVNUX1RZUEUgPSB7XG4gICAgICAgIE1VTFRJUEFSVF9JTklUSUFURTogXCJtdWx0aXBhcnRfaW5pdGlhdGVcIixcbiAgICAgICAgTVVMVElQQVJUX0NPTVBMRVRFOiBcIm11bHRpcGFydF9jb21wbGV0ZVwiLFxuICAgICAgICBNVUxUSVBBUlRfQUJPUlQ6IFwibXVsdGlwYXJ0X2Fib3J0XCIsXG4gICAgICAgIE1VTFRJUEFSVF9VUExPQUQ6IFwibXVsdGlwYXJ0X3VwbG9hZFwiXG4gICAgfTtcbiAgICBxcS5VcGxvYWRTdWNjZXNzQWpheFJlcXVlc3RlciA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciByZXF1ZXN0ZXIsIHBlbmRpbmdSZXF1ZXN0cyA9IFtdLCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGVuZHBvaW50OiBudWxsLFxuICAgICAgICAgICAgbWF4Q29ubmVjdGlvbnM6IDMsXG4gICAgICAgICAgICBjdXN0b21IZWFkZXJzOiB7fSxcbiAgICAgICAgICAgIHBhcmFtc1N0b3JlOiB7fSxcbiAgICAgICAgICAgIGNvcnM6IHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VuZENyZWRlbnRpYWxzOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvZzogZnVuY3Rpb24oc3RyLCBsZXZlbCkge31cbiAgICAgICAgfTtcbiAgICAgICAgcXEuZXh0ZW5kKG9wdGlvbnMsIG8pO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVTdWNjZXNzUmVzcG9uc2UoaWQsIHhock9yWGRyLCBpc0Vycm9yKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHBlbmRpbmdSZXF1ZXN0c1tpZF0sIHJlc3BvbnNlSnNvbiA9IHhock9yWGRyLnJlc3BvbnNlVGV4dCwgc3VjY2Vzc0luZGljYXRvciA9IHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgICB9LCBmYWlsdXJlSW5kaWNhdG9yID0ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlXG4gICAgICAgICAgICB9LCBwYXJzZWRSZXNwb25zZTtcbiAgICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nUmVxdWVzdHNbaWRdO1xuICAgICAgICAgICAgb3B0aW9ucy5sb2cocXEuZm9ybWF0KFwiUmVjZWl2ZWQgdGhlIGZvbGxvd2luZyByZXNwb25zZSBib2R5IHRvIGFuIHVwbG9hZCBzdWNjZXNzIHJlcXVlc3QgZm9yIGlkIHt9OiB7fVwiLCBpZCwgcmVzcG9uc2VKc29uKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlID0gcXEucGFyc2VKc29uKHJlc3BvbnNlSnNvbik7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IgfHwgcGFyc2VkUmVzcG9uc2UgJiYgKHBhcnNlZFJlc3BvbnNlLmVycm9yIHx8IHBhcnNlZFJlc3BvbnNlLnN1Y2Nlc3MgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvZyhcIlVwbG9hZCBzdWNjZXNzIHJlcXVlc3Qgd2FzIHJlamVjdGVkIGJ5IHRoZSBzZXJ2ZXIuXCIsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuZmFpbHVyZShxcS5leHRlbmQocGFyc2VkUmVzcG9uc2UsIGZhaWx1cmVJbmRpY2F0b3IpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvZyhcIlVwbG9hZCBzdWNjZXNzIHdhcyBhY2tub3dsZWRnZWQgYnkgdGhlIHNlcnZlci5cIik7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2Uuc3VjY2VzcyhxcS5leHRlbmQocGFyc2VkUmVzcG9uc2UsIHN1Y2Nlc3NJbmRpY2F0b3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9nKHFxLmZvcm1hdChcIllvdXIgc2VydmVyIGluZGljYXRlZCBmYWlsdXJlIGluIGl0cyB1cGxvYWQgc3VjY2VzcyByZXF1ZXN0IHJlc3BvbnNlIGZvciBpZCB7fSFcIiwgaWQpLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmZhaWx1cmUoZmFpbHVyZUluZGljYXRvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2coXCJVcGxvYWQgc3VjY2VzcyB3YXMgYWNrbm93bGVkZ2VkIGJ5IHRoZSBzZXJ2ZXIuXCIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3Moc3VjY2Vzc0luZGljYXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RlciA9IHFxLmV4dGVuZCh0aGlzLCBuZXcgcXEuQWpheFJlcXVlc3Rlcih7XG4gICAgICAgICAgICBhY2NlcHRIZWFkZXI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgIGVuZHBvaW50U3RvcmU6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5lbmRwb2ludDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyYW1zU3RvcmU6IG9wdGlvbnMucGFyYW1zU3RvcmUsXG4gICAgICAgICAgICBtYXhDb25uZWN0aW9uczogb3B0aW9ucy5tYXhDb25uZWN0aW9ucyxcbiAgICAgICAgICAgIGN1c3RvbUhlYWRlcnM6IG9wdGlvbnMuY3VzdG9tSGVhZGVycyxcbiAgICAgICAgICAgIGxvZzogb3B0aW9ucy5sb2csXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBoYW5kbGVTdWNjZXNzUmVzcG9uc2UsXG4gICAgICAgICAgICBjb3JzOiBvcHRpb25zLmNvcnNcbiAgICAgICAgfSkpO1xuICAgICAgICBxcS5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgc2VuZFN1Y2Nlc3NSZXF1ZXN0OiBmdW5jdGlvbihpZCwgc3BlYykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHFxLlByb21pc2UoKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvZyhcIlN1Ym1pdHRpbmcgdXBsb2FkIHN1Y2Nlc3MgcmVxdWVzdC9ub3RpZmljYXRpb24gZm9yIFwiICsgaWQpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Rlci5pbml0VHJhbnNwb3J0KGlkKS53aXRoUGFyYW1zKHNwZWMpLnNlbmQoKTtcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVxdWVzdHNbaWRdID0gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBxcS5zMy5Jbml0aWF0ZU11bHRpcGFydEFqYXhSZXF1ZXN0ZXIgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgcmVxdWVzdGVyLCBwZW5kaW5nSW5pdGlhdGVSZXF1ZXN0cyA9IHt9LCBvcHRpb25zID0ge1xuICAgICAgICAgICAgZmlsZW5hbWVQYXJhbTogXCJxcWZpbGVuYW1lXCIsXG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgZW5kcG9pbnRTdG9yZTogbnVsbCxcbiAgICAgICAgICAgIHBhcmFtc1N0b3JlOiBudWxsLFxuICAgICAgICAgICAgc2lnbmF0dXJlU3BlYzogbnVsbCxcbiAgICAgICAgICAgIGFjbFN0b3JlOiBudWxsLFxuICAgICAgICAgICAgcmVkdWNlZFJlZHVuZGFuY3k6IGZhbHNlLFxuICAgICAgICAgICAgc2VydmVyU2lkZUVuY3J5cHRpb246IGZhbHNlLFxuICAgICAgICAgICAgbWF4Q29ubmVjdGlvbnM6IDMsXG4gICAgICAgICAgICBnZXRDb250ZW50VHlwZTogZnVuY3Rpb24oaWQpIHt9LFxuICAgICAgICAgICAgZ2V0QnVja2V0OiBmdW5jdGlvbihpZCkge30sXG4gICAgICAgICAgICBnZXRIb3N0OiBmdW5jdGlvbihpZCkge30sXG4gICAgICAgICAgICBnZXRLZXk6IGZ1bmN0aW9uKGlkKSB7fSxcbiAgICAgICAgICAgIGdldE5hbWU6IGZ1bmN0aW9uKGlkKSB7fSxcbiAgICAgICAgICAgIGxvZzogZnVuY3Rpb24oc3RyLCBsZXZlbCkge31cbiAgICAgICAgfSwgZ2V0U2lnbmF0dXJlQWpheFJlcXVlc3RlcjtcbiAgICAgICAgcXEuZXh0ZW5kKG9wdGlvbnMsIG8pO1xuICAgICAgICBnZXRTaWduYXR1cmVBamF4UmVxdWVzdGVyID0gbmV3IHFxLnMzLlJlcXVlc3RTaWduZXIoe1xuICAgICAgICAgICAgZW5kcG9pbnRTdG9yZTogb3B0aW9ucy5lbmRwb2ludFN0b3JlLFxuICAgICAgICAgICAgc2lnbmF0dXJlU3BlYzogb3B0aW9ucy5zaWduYXR1cmVTcGVjLFxuICAgICAgICAgICAgY29yczogb3B0aW9ucy5jb3JzLFxuICAgICAgICAgICAgbG9nOiBvcHRpb25zLmxvZ1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gZ2V0SGVhZGVycyhpZCkge1xuICAgICAgICAgICAgdmFyIGJ1Y2tldCA9IG9wdGlvbnMuZ2V0QnVja2V0KGlkKSwgaG9zdCA9IG9wdGlvbnMuZ2V0SG9zdChpZCksIGhlYWRlcnMgPSB7fSwgcHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCksIGtleSA9IG9wdGlvbnMuZ2V0S2V5KGlkKSwgc2lnbmF0dXJlQ29uc3RydWN0b3I7XG4gICAgICAgICAgICBoZWFkZXJzW1wieC1hbXotYWNsXCJdID0gb3B0aW9ucy5hY2xTdG9yZS5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVkdWNlZFJlZHVuZGFuY3kpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW3FxLnMzLnV0aWwuUkVEVUNFRF9SRURVTkRBTkNZX1BBUkFNX05BTUVdID0gcXEuczMudXRpbC5SRURVQ0VEX1JFRFVOREFOQ1lfUEFSQU1fVkFMVUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zZXJ2ZXJTaWRlRW5jcnlwdGlvbikge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbcXEuczMudXRpbC5TRVJWRVJfU0lERV9FTkNSWVBUSU9OX1BBUkFNX05BTUVdID0gcXEuczMudXRpbC5TRVJWRVJfU0lERV9FTkNSWVBUSU9OX1BBUkFNX1ZBTFVFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVhZGVyc1txcS5zMy51dGlsLkFXU19QQVJBTV9QUkVGSVggKyBvcHRpb25zLmZpbGVuYW1lUGFyYW1dID0gZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMuZ2V0TmFtZShpZCkpO1xuICAgICAgICAgICAgcXEuZWFjaChvcHRpb25zLnBhcmFtc1N0b3JlLmdldChpZCksIGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAgICAgICAgICAgICAgIGlmIChxcS5pbmRleE9mKHFxLnMzLnV0aWwuVU5QUkVGSVhFRF9QQVJBTV9OQU1FUywgbmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW25hbWVdID0gdmFsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbcXEuczMudXRpbC5BV1NfUEFSQU1fUFJFRklYICsgbmFtZV0gPSBlbmNvZGVVUklDb21wb25lbnQodmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNpZ25hdHVyZUNvbnN0cnVjdG9yID0gZ2V0U2lnbmF0dXJlQWpheFJlcXVlc3Rlci5jb25zdHJ1Y3RTdHJpbmdUb1NpZ24oZ2V0U2lnbmF0dXJlQWpheFJlcXVlc3Rlci5SRVFVRVNUX1RZUEUuTVVMVElQQVJUX0lOSVRJQVRFLCBidWNrZXQsIGhvc3QsIGtleSkud2l0aENvbnRlbnRUeXBlKG9wdGlvbnMuZ2V0Q29udGVudFR5cGUoaWQpKS53aXRoSGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgICAgIGdldFNpZ25hdHVyZUFqYXhSZXF1ZXN0ZXIuZ2V0U2lnbmF0dXJlKGlkLCB7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlQ29uc3RydWN0b3I6IHNpZ25hdHVyZUNvbnN0cnVjdG9yXG4gICAgICAgICAgICB9KS50aGVuKHByb21pc2Uuc3VjY2VzcywgcHJvbWlzZS5mYWlsdXJlKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUluaXRpYXRlUmVxdWVzdENvbXBsZXRlKGlkLCB4aHIsIGlzRXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gcGVuZGluZ0luaXRpYXRlUmVxdWVzdHNbaWRdLCBkb21QYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCksIHJlc3BvbnNlRG9jID0gZG9tUGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4aHIucmVzcG9uc2VUZXh0LCBcImFwcGxpY2F0aW9uL3htbFwiKSwgdXBsb2FkSWRFbGVtZW50cywgbWVzc2FnZUVsZW1lbnRzLCB1cGxvYWRJZCwgZXJyb3JNZXNzYWdlLCBzdGF0dXM7XG4gICAgICAgICAgICBkZWxldGUgcGVuZGluZ0luaXRpYXRlUmVxdWVzdHNbaWRdO1xuICAgICAgICAgICAgaWYgKGlzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VFbGVtZW50cyA9IHJlc3BvbnNlRG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiTWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZUVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gbWVzc2FnZUVsZW1lbnRzWzBdLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBsb2FkSWRFbGVtZW50cyA9IHJlc3BvbnNlRG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiVXBsb2FkSWRcIik7XG4gICAgICAgICAgICAgICAgaWYgKHVwbG9hZElkRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWRJZCA9IHVwbG9hZElkRWxlbWVudHNbMF0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJVcGxvYWQgSUQgbWlzc2luZyBmcm9tIHJlcXVlc3RcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBsb2FkSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2cocXEuZm9ybWF0KFwiU3BlY2lmaWMgcHJvYmxlbSBkZXRlY3RlZCBpbml0aWF0aW5nIG11bHRpcGFydCB1cGxvYWQgcmVxdWVzdCBmb3Ige306ICd7fScuXCIsIGlkLCBlcnJvck1lc3NhZ2UpLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9nKHFxLmZvcm1hdChcIlVuZXhwbGFpbmVkIGVycm9yIHdpdGggaW5pdGlhdGUgbXVsdGlwYXJ0IHVwbG9hZCByZXF1ZXN0IGZvciB7fS4gIFN0YXR1cyBjb2RlIHt9LlwiLCBpZCwgc3RhdHVzKSwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5mYWlsdXJlKFwiUHJvYmxlbSBpbml0aWF0aW5nIHVwbG9hZCByZXF1ZXN0LlwiLCB4aHIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvZyhxcS5mb3JtYXQoXCJJbml0aWF0ZSBtdWx0aXBhcnQgdXBsb2FkIHJlcXVlc3Qgc3VjY2Vzc2Z1bCBmb3Ige30uICBVcGxvYWQgSUQgaXMge31cIiwgaWQsIHVwbG9hZElkKSk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKHVwbG9hZElkLCB4aHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RlciA9IHFxLmV4dGVuZCh0aGlzLCBuZXcgcXEuQWpheFJlcXVlc3Rlcih7XG4gICAgICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgY29udGVudFR5cGU6IG51bGwsXG4gICAgICAgICAgICBlbmRwb2ludFN0b3JlOiBvcHRpb25zLmVuZHBvaW50U3RvcmUsXG4gICAgICAgICAgICBtYXhDb25uZWN0aW9uczogb3B0aW9ucy5tYXhDb25uZWN0aW9ucyxcbiAgICAgICAgICAgIGFsbG93WFJlcXVlc3RlZFdpdGhBbmRDYWNoZUNvbnRyb2w6IGZhbHNlLFxuICAgICAgICAgICAgbG9nOiBvcHRpb25zLmxvZyxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IGhhbmRsZUluaXRpYXRlUmVxdWVzdENvbXBsZXRlLFxuICAgICAgICAgICAgc3VjY2Vzc2Z1bFJlc3BvbnNlQ29kZXM6IHtcbiAgICAgICAgICAgICAgICBQT1NUOiBbIDIwMCBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIHNlbmQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIGdldEhlYWRlcnMoaWQpLnRoZW4oZnVuY3Rpb24oaGVhZGVycywgZW5kT2ZVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2coXCJTdWJtaXR0aW5nIFMzIGluaXRpYXRlIG11bHRpcGFydCB1cGxvYWQgcmVxdWVzdCBmb3IgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdJbml0aWF0ZVJlcXVlc3RzW2lkXSA9IHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Rlci5pbml0VHJhbnNwb3J0KGlkKS53aXRoUGF0aChlbmRPZlVybCkud2l0aEhlYWRlcnMoaGVhZGVycykuc2VuZCgpO1xuICAgICAgICAgICAgICAgIH0sIHByb21pc2UuZmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcXEuczMuQ29tcGxldGVNdWx0aXBhcnRBamF4UmVxdWVzdGVyID0gZnVuY3Rpb24obykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIHJlcXVlc3RlciwgcGVuZGluZ0NvbXBsZXRlUmVxdWVzdHMgPSB7fSwgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3htbFwiLFxuICAgICAgICAgICAgZW5kcG9pbnRTdG9yZTogbnVsbCxcbiAgICAgICAgICAgIHNpZ25hdHVyZVNwZWM6IG51bGwsXG4gICAgICAgICAgICBtYXhDb25uZWN0aW9uczogMyxcbiAgICAgICAgICAgIGdldEJ1Y2tldDogZnVuY3Rpb24oaWQpIHt9LFxuICAgICAgICAgICAgZ2V0SG9zdDogZnVuY3Rpb24oaWQpIHt9LFxuICAgICAgICAgICAgZ2V0S2V5OiBmdW5jdGlvbihpZCkge30sXG4gICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKHN0ciwgbGV2ZWwpIHt9XG4gICAgICAgIH0sIGdldFNpZ25hdHVyZUFqYXhSZXF1ZXN0ZXI7XG4gICAgICAgIHFxLmV4dGVuZChvcHRpb25zLCBvKTtcbiAgICAgICAgZ2V0U2lnbmF0dXJlQWpheFJlcXVlc3RlciA9IG5ldyBxcS5zMy5SZXF1ZXN0U2lnbmVyKHtcbiAgICAgICAgICAgIGVuZHBvaW50U3RvcmU6IG9wdGlvbnMuZW5kcG9pbnRTdG9yZSxcbiAgICAgICAgICAgIHNpZ25hdHVyZVNwZWM6IG9wdGlvbnMuc2lnbmF0dXJlU3BlYyxcbiAgICAgICAgICAgIGNvcnM6IG9wdGlvbnMuY29ycyxcbiAgICAgICAgICAgIGxvZzogb3B0aW9ucy5sb2dcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGdldEhlYWRlcnMoaWQsIHVwbG9hZElkLCBib2R5KSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHt9LCBwcm9taXNlID0gbmV3IHFxLlByb21pc2UoKSwgYnVja2V0ID0gb3B0aW9ucy5nZXRCdWNrZXQoaWQpLCBob3N0ID0gb3B0aW9ucy5nZXRIb3N0KGlkKSwgc2lnbmF0dXJlQ29uc3RydWN0b3IgPSBnZXRTaWduYXR1cmVBamF4UmVxdWVzdGVyLmNvbnN0cnVjdFN0cmluZ1RvU2lnbihnZXRTaWduYXR1cmVBamF4UmVxdWVzdGVyLlJFUVVFU1RfVFlQRS5NVUxUSVBBUlRfQ09NUExFVEUsIGJ1Y2tldCwgaG9zdCwgb3B0aW9ucy5nZXRLZXkoaWQpKS53aXRoVXBsb2FkSWQodXBsb2FkSWQpLndpdGhDb250ZW50KGJvZHkpLndpdGhDb250ZW50VHlwZShcImFwcGxpY2F0aW9uL3htbDsgY2hhcnNldD1VVEYtOFwiKTtcbiAgICAgICAgICAgIGdldFNpZ25hdHVyZUFqYXhSZXF1ZXN0ZXIuZ2V0U2lnbmF0dXJlKGlkLCB7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlQ29uc3RydWN0b3I6IHNpZ25hdHVyZUNvbnN0cnVjdG9yXG4gICAgICAgICAgICB9KS50aGVuKHByb21pc2Uuc3VjY2VzcywgcHJvbWlzZS5mYWlsdXJlKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUNvbXBsZXRlUmVxdWVzdENvbXBsZXRlKGlkLCB4aHIsIGlzRXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gcGVuZGluZ0NvbXBsZXRlUmVxdWVzdHNbaWRdLCBkb21QYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCksIGJ1Y2tldCA9IG9wdGlvbnMuZ2V0QnVja2V0KGlkKSwga2V5ID0gb3B0aW9ucy5nZXRLZXkoaWQpLCByZXNwb25zZURvYyA9IGRvbVBhcnNlci5wYXJzZUZyb21TdHJpbmcoeGhyLnJlc3BvbnNlVGV4dCwgXCJhcHBsaWNhdGlvbi94bWxcIiksIGJ1Y2tldEVscyA9IHJlc3BvbnNlRG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiQnVja2V0XCIpLCBrZXlFbHMgPSByZXNwb25zZURvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcIktleVwiKTtcbiAgICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nQ29tcGxldGVSZXF1ZXN0c1tpZF07XG4gICAgICAgICAgICBvcHRpb25zLmxvZyhxcS5mb3JtYXQoXCJDb21wbGV0ZSByZXNwb25zZSBzdGF0dXMge30sIGJvZHkgPSB7fVwiLCB4aHIuc3RhdHVzLCB4aHIucmVzcG9uc2VUZXh0KSk7XG4gICAgICAgICAgICBpZiAoaXNFcnJvcikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9nKHFxLmZvcm1hdChcIkNvbXBsZXRlIE11bHRpcGFydCBVcGxvYWQgcmVxdWVzdCBmb3Ige30gZmFpbGVkIHdpdGggc3RhdHVzIHt9LlwiLCBpZCwgeGhyLnN0YXR1cyksIFwiZXJyb3JcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChidWNrZXRFbHMubGVuZ3RoICYmIGtleUVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1Y2tldEVsc1swXS50ZXh0Q29udGVudCAhPT0gYnVja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9nKHFxLmZvcm1hdChcIldyb25nIGJ1Y2tldCBpbiByZXNwb25zZSB0byBDb21wbGV0ZSBNdWx0aXBhcnQgVXBsb2FkIHJlcXVlc3QgZm9yIHt9LlwiLCBpZCksIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2cocXEuZm9ybWF0KFwiTWlzc2luZyBidWNrZXQgYW5kL29yIGtleSBpbiByZXNwb25zZSB0byBDb21wbGV0ZSBNdWx0aXBhcnQgVXBsb2FkIHJlcXVlc3QgZm9yIHt9LlwiLCBpZCksIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLmZhaWx1cmUoXCJQcm9ibGVtIGNvbWJpbmluZyB0aGUgZmlsZSBwYXJ0cyFcIiwgeGhyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKHt9LCB4aHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldENvbXBsZXRlUmVxdWVzdEJvZHkoZXRhZ0VudHJpZXMpIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudChudWxsLCBcIkNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkXCIsIG51bGwpO1xuICAgICAgICAgICAgZXRhZ0VudHJpZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucGFydCAtIGIucGFydDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcXEuZWFjaChldGFnRW50cmllcywgZnVuY3Rpb24oaWR4LCBldGFnRW50cnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydCA9IGV0YWdFbnRyeS5wYXJ0LCBldGFnID0gZXRhZ0VudHJ5LmV0YWcsIHBhcnRFbCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiUGFydFwiKSwgcGFydE51bUVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJQYXJ0TnVtYmVyXCIpLCBwYXJ0TnVtVGV4dEVsID0gZG9jLmNyZWF0ZVRleHROb2RlKHBhcnQpLCBldGFnVGV4dEVsID0gZG9jLmNyZWF0ZVRleHROb2RlKGV0YWcpLCBldGFnRWwgPSBkb2MuY3JlYXRlRWxlbWVudChcIkVUYWdcIik7XG4gICAgICAgICAgICAgICAgZXRhZ0VsLmFwcGVuZENoaWxkKGV0YWdUZXh0RWwpO1xuICAgICAgICAgICAgICAgIHBhcnROdW1FbC5hcHBlbmRDaGlsZChwYXJ0TnVtVGV4dEVsKTtcbiAgICAgICAgICAgICAgICBwYXJ0RWwuYXBwZW5kQ2hpbGQocGFydE51bUVsKTtcbiAgICAgICAgICAgICAgICBwYXJ0RWwuYXBwZW5kQ2hpbGQoZXRhZ0VsKTtcbiAgICAgICAgICAgICAgICBxcShkb2MpLmNoaWxkcmVuKClbMF0uYXBwZW5kQ2hpbGQocGFydEVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoZG9jKTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0ZXIgPSBxcS5leHRlbmQodGhpcywgbmV3IHFxLkFqYXhSZXF1ZXN0ZXIoe1xuICAgICAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3htbDsgY2hhcnNldD1VVEYtOFwiLFxuICAgICAgICAgICAgZW5kcG9pbnRTdG9yZTogb3B0aW9ucy5lbmRwb2ludFN0b3JlLFxuICAgICAgICAgICAgbWF4Q29ubmVjdGlvbnM6IG9wdGlvbnMubWF4Q29ubmVjdGlvbnMsXG4gICAgICAgICAgICBhbGxvd1hSZXF1ZXN0ZWRXaXRoQW5kQ2FjaGVDb250cm9sOiBmYWxzZSxcbiAgICAgICAgICAgIGxvZzogb3B0aW9ucy5sb2csXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBoYW5kbGVDb21wbGV0ZVJlcXVlc3RDb21wbGV0ZSxcbiAgICAgICAgICAgIHN1Y2Nlc3NmdWxSZXNwb25zZUNvZGVzOiB7XG4gICAgICAgICAgICAgICAgUE9TVDogWyAyMDAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBzZW5kOiBmdW5jdGlvbihpZCwgdXBsb2FkSWQsIGV0YWdFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpLCBib2R5ID0gZ2V0Q29tcGxldGVSZXF1ZXN0Qm9keShldGFnRW50cmllcyk7XG4gICAgICAgICAgICAgICAgZ2V0SGVhZGVycyhpZCwgdXBsb2FkSWQsIGJvZHkpLnRoZW4oZnVuY3Rpb24oaGVhZGVycywgZW5kT2ZVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2coXCJTdWJtaXR0aW5nIFMzIGNvbXBsZXRlIG11bHRpcGFydCB1cGxvYWQgcmVxdWVzdCBmb3IgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdDb21wbGV0ZVJlcXVlc3RzW2lkXSA9IHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZXIuaW5pdFRyYW5zcG9ydChpZCkud2l0aFBhdGgoZW5kT2ZVcmwpLndpdGhIZWFkZXJzKGhlYWRlcnMpLndpdGhQYXlsb2FkKGJvZHkpLnNlbmQoKTtcbiAgICAgICAgICAgICAgICB9LCBwcm9taXNlLmZhaWx1cmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHFxLnMzLkFib3J0TXVsdGlwYXJ0QWpheFJlcXVlc3RlciA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciByZXF1ZXN0ZXIsIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBlbmRwb2ludFN0b3JlOiBudWxsLFxuICAgICAgICAgICAgc2lnbmF0dXJlU3BlYzogbnVsbCxcbiAgICAgICAgICAgIG1heENvbm5lY3Rpb25zOiAzLFxuICAgICAgICAgICAgZ2V0QnVja2V0OiBmdW5jdGlvbihpZCkge30sXG4gICAgICAgICAgICBnZXRIb3N0OiBmdW5jdGlvbihpZCkge30sXG4gICAgICAgICAgICBnZXRLZXk6IGZ1bmN0aW9uKGlkKSB7fSxcbiAgICAgICAgICAgIGxvZzogZnVuY3Rpb24oc3RyLCBsZXZlbCkge31cbiAgICAgICAgfSwgZ2V0U2lnbmF0dXJlQWpheFJlcXVlc3RlcjtcbiAgICAgICAgcXEuZXh0ZW5kKG9wdGlvbnMsIG8pO1xuICAgICAgICBnZXRTaWduYXR1cmVBamF4UmVxdWVzdGVyID0gbmV3IHFxLnMzLlJlcXVlc3RTaWduZXIoe1xuICAgICAgICAgICAgZW5kcG9pbnRTdG9yZTogb3B0aW9ucy5lbmRwb2ludFN0b3JlLFxuICAgICAgICAgICAgc2lnbmF0dXJlU3BlYzogb3B0aW9ucy5zaWduYXR1cmVTcGVjLFxuICAgICAgICAgICAgY29yczogb3B0aW9ucy5jb3JzLFxuICAgICAgICAgICAgbG9nOiBvcHRpb25zLmxvZ1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gZ2V0SGVhZGVycyhpZCwgdXBsb2FkSWQpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXJzID0ge30sIHByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpLCBidWNrZXQgPSBvcHRpb25zLmdldEJ1Y2tldChpZCksIGhvc3QgPSBvcHRpb25zLmdldEhvc3QoaWQpLCBzaWduYXR1cmVDb25zdHJ1Y3RvciA9IGdldFNpZ25hdHVyZUFqYXhSZXF1ZXN0ZXIuY29uc3RydWN0U3RyaW5nVG9TaWduKGdldFNpZ25hdHVyZUFqYXhSZXF1ZXN0ZXIuUkVRVUVTVF9UWVBFLk1VTFRJUEFSVF9BQk9SVCwgYnVja2V0LCBob3N0LCBvcHRpb25zLmdldEtleShpZCkpLndpdGhVcGxvYWRJZCh1cGxvYWRJZCk7XG4gICAgICAgICAgICBnZXRTaWduYXR1cmVBamF4UmVxdWVzdGVyLmdldFNpZ25hdHVyZShpZCwge1xuICAgICAgICAgICAgICAgIHNpZ25hdHVyZUNvbnN0cnVjdG9yOiBzaWduYXR1cmVDb25zdHJ1Y3RvclxuICAgICAgICAgICAgfSkudGhlbihwcm9taXNlLnN1Y2Nlc3MsIHByb21pc2UuZmFpbHVyZSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVBYm9ydFJlcXVlc3RDb21wbGV0ZShpZCwgeGhyLCBpc0Vycm9yKSB7XG4gICAgICAgICAgICB2YXIgZG9tUGFyc2VyID0gbmV3IERPTVBhcnNlcigpLCByZXNwb25zZURvYyA9IGRvbVBhcnNlci5wYXJzZUZyb21TdHJpbmcoeGhyLnJlc3BvbnNlVGV4dCwgXCJhcHBsaWNhdGlvbi94bWxcIiksIGVycm9yRWxzID0gcmVzcG9uc2VEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJFcnJvclwiKSwgYXdzRXJyb3JNc2c7XG4gICAgICAgICAgICBvcHRpb25zLmxvZyhxcS5mb3JtYXQoXCJBYm9ydCByZXNwb25zZSBzdGF0dXMge30sIGJvZHkgPSB7fVwiLCB4aHIuc3RhdHVzLCB4aHIucmVzcG9uc2VUZXh0KSk7XG4gICAgICAgICAgICBpZiAoaXNFcnJvcikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9nKHFxLmZvcm1hdChcIkFib3J0IE11bHRpcGFydCBVcGxvYWQgcmVxdWVzdCBmb3Ige30gZmFpbGVkIHdpdGggc3RhdHVzIHt9LlwiLCBpZCwgeGhyLnN0YXR1cyksIFwiZXJyb3JcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvckVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGF3c0Vycm9yTXNnID0gcmVzcG9uc2VEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJNZXNzYWdlXCIpWzBdLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvZyhxcS5mb3JtYXQoXCJGYWlsZWQgdG8gQWJvcnQgTXVsdGlwYXJ0IFVwbG9hZCByZXF1ZXN0IGZvciB7fS4gIEVycm9yOiB7fVwiLCBpZCwgYXdzRXJyb3JNc2cpLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9nKHFxLmZvcm1hdChcIkFib3J0IE1QVSByZXF1ZXN0IHN1Y2NlZWRlZCBmb3IgZmlsZSBJRCB7fS5cIiwgaWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdGVyID0gcXEuZXh0ZW5kKHRoaXMsIG5ldyBxcS5BamF4UmVxdWVzdGVyKHtcbiAgICAgICAgICAgIHZhbGlkTWV0aG9kczogWyBcIkRFTEVURVwiIF0sXG4gICAgICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgY29udGVudFR5cGU6IG51bGwsXG4gICAgICAgICAgICBlbmRwb2ludFN0b3JlOiBvcHRpb25zLmVuZHBvaW50U3RvcmUsXG4gICAgICAgICAgICBtYXhDb25uZWN0aW9uczogb3B0aW9ucy5tYXhDb25uZWN0aW9ucyxcbiAgICAgICAgICAgIGFsbG93WFJlcXVlc3RlZFdpdGhBbmRDYWNoZUNvbnRyb2w6IGZhbHNlLFxuICAgICAgICAgICAgbG9nOiBvcHRpb25zLmxvZyxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IGhhbmRsZUFib3J0UmVxdWVzdENvbXBsZXRlLFxuICAgICAgICAgICAgc3VjY2Vzc2Z1bFJlc3BvbnNlQ29kZXM6IHtcbiAgICAgICAgICAgICAgICBERUxFVEU6IFsgMjA0IF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBxcS5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24oaWQsIHVwbG9hZElkKSB7XG4gICAgICAgICAgICAgICAgZ2V0SGVhZGVycyhpZCwgdXBsb2FkSWQpLnRoZW4oZnVuY3Rpb24oaGVhZGVycywgZW5kT2ZVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2coXCJTdWJtaXR0aW5nIFMzIEFib3J0IG11bHRpcGFydCB1cGxvYWQgcmVxdWVzdCBmb3IgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Rlci5pbml0VHJhbnNwb3J0KGlkKS53aXRoUGF0aChlbmRPZlVybCkud2l0aEhlYWRlcnMoaGVhZGVycykuc2VuZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHFxLnMzLlhoclVwbG9hZEhhbmRsZXIgPSBmdW5jdGlvbihzcGVjLCBwcm94eSkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGdldE5hbWUgPSBwcm94eS5nZXROYW1lLCBsb2cgPSBwcm94eS5sb2csIGNsb2NrRHJpZnQgPSBzcGVjLmNsb2NrRHJpZnQsIGV4cGVjdGVkU3RhdHVzID0gMjAwLCBvbkdldEJ1Y2tldCA9IHNwZWMuZ2V0QnVja2V0LCBvbkdldEhvc3QgPSBzcGVjLmdldEhvc3QsIG9uR2V0S2V5TmFtZSA9IHNwZWMuZ2V0S2V5TmFtZSwgZmlsZW5hbWVQYXJhbSA9IHNwZWMuZmlsZW5hbWVQYXJhbSwgcGFyYW1zU3RvcmUgPSBzcGVjLnBhcmFtc1N0b3JlLCBlbmRwb2ludFN0b3JlID0gc3BlYy5lbmRwb2ludFN0b3JlLCBhY2xTdG9yZSA9IHNwZWMuYWNsU3RvcmUsIHJlZHVjZWRSZWR1bmRhbmN5ID0gc3BlYy5vYmplY3RQcm9wZXJ0aWVzLnJlZHVjZWRSZWR1bmRhbmN5LCByZWdpb24gPSBzcGVjLm9iamVjdFByb3BlcnRpZXMucmVnaW9uLCBzZXJ2ZXJTaWRlRW5jcnlwdGlvbiA9IHNwZWMub2JqZWN0UHJvcGVydGllcy5zZXJ2ZXJTaWRlRW5jcnlwdGlvbiwgdmFsaWRhdGlvbiA9IHNwZWMudmFsaWRhdGlvbiwgc2lnbmF0dXJlID0gcXEuZXh0ZW5kKHtcbiAgICAgICAgICAgIHJlZ2lvbjogcmVnaW9uLFxuICAgICAgICAgICAgZHJpZnQ6IGNsb2NrRHJpZnRcbiAgICAgICAgfSwgc3BlYy5zaWduYXR1cmUpLCBoYW5kbGVyID0gdGhpcywgY3JlZGVudGlhbHNQcm92aWRlciA9IHNwZWMuc2lnbmF0dXJlLmNyZWRlbnRpYWxzUHJvdmlkZXIsIGNodW5rZWQgPSB7XG4gICAgICAgICAgICBjb21iaW5lOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciB1cGxvYWRJZCA9IGhhbmRsZXIuX2dldFBlcnNpc3RhYmxlRGF0YShpZCkudXBsb2FkSWQsIGV0YWdNYXAgPSBoYW5kbGVyLl9nZXRQZXJzaXN0YWJsZURhdGEoaWQpLmV0YWdzLCByZXN1bHQgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RlcnMuY29tcGxldGVNdWx0aXBhcnQuc2VuZChpZCwgdXBsb2FkSWQsIGV0YWdNYXApLnRoZW4ocmVzdWx0LnN1Y2Nlc3MsIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uLCB4aHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZhaWx1cmUodXBsb2FkLmRvbmUoaWQsIHhocikucmVzcG9uc2UsIHhocik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb25lOiBmdW5jdGlvbihpZCwgeGhyLCBjaHVua0lkeCkge1xuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHVwbG9hZC5yZXNwb25zZS5wYXJzZShpZCwgeGhyKSwgZXRhZztcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBldGFnID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiRVRhZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyLl9nZXRQZXJzaXN0YWJsZURhdGEoaWQpLmV0YWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9nZXRQZXJzaXN0YWJsZURhdGEoaWQpLmV0YWdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fZ2V0UGVyc2lzdGFibGVEYXRhKGlkKS5ldGFncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQ6IGNodW5rSWR4ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV0YWc6IGV0YWdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluaXRIZWFkZXJzOiBmdW5jdGlvbihpZCwgY2h1bmtJZHgsIGJsb2IpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IHt9LCBidWNrZXQgPSB1cGxvYWQuYnVja2V0LmdldE5hbWUoaWQpLCBob3N0ID0gdXBsb2FkLmhvc3QuZ2V0TmFtZShpZCksIGtleSA9IHVwbG9hZC5rZXkudXJsU2FmZShpZCksIHByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpLCBzaWduYXR1cmVDb25zdHJ1Y3RvciA9IHJlcXVlc3RlcnMucmVzdFNpZ25hdHVyZS5jb25zdHJ1Y3RTdHJpbmdUb1NpZ24ocmVxdWVzdGVycy5yZXN0U2lnbmF0dXJlLlJFUVVFU1RfVFlQRS5NVUxUSVBBUlRfVVBMT0FELCBidWNrZXQsIGhvc3QsIGtleSkud2l0aFBhcnROdW0oY2h1bmtJZHggKyAxKS53aXRoQ29udGVudChibG9iKS53aXRoVXBsb2FkSWQoaGFuZGxlci5fZ2V0UGVyc2lzdGFibGVEYXRhKGlkKS51cGxvYWRJZCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdGVycy5yZXN0U2lnbmF0dXJlLmdldFNpZ25hdHVyZShpZCArIFwiLlwiICsgY2h1bmtJZHgsIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlQ29uc3RydWN0b3I6IHNpZ25hdHVyZUNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgfSkudGhlbihwcm9taXNlLnN1Y2Nlc3MsIHByb21pc2UuZmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHV0OiBmdW5jdGlvbihpZCwgY2h1bmtJZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgeGhyID0gaGFuZGxlci5fY3JlYXRlWGhyKGlkLCBjaHVua0lkeCksIGNodW5rRGF0YSA9IGhhbmRsZXIuX2dldENodW5rRGF0YShpZCwgY2h1bmtJZHgpLCBkb21haW4gPSBzcGVjLmVuZHBvaW50U3RvcmUuZ2V0KGlkKSwgcHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgY2h1bmtlZC5pbml0SGVhZGVycyhpZCwgY2h1bmtJZHgsIGNodW5rRGF0YS5ibG9iKS50aGVuKGZ1bmN0aW9uKGhlYWRlcnMsIGVuZE9mVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4aHIuX2NhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKHFxLmZvcm1hdChcIlVwbG9hZCBvZiBpdGVtIHt9Lnt9IGNhbmNlbGxlZC4gVXBsb2FkIHdpbGwgbm90IHN0YXJ0IGFmdGVyIHN1Y2Nlc3NmdWwgc2lnbmF0dXJlIHJlcXVlc3QuXCIsIGlkLCBjaHVua0lkeCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5mYWlsdXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogXCJDaHVuayB1cGxvYWQgY2FuY2VsbGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IGRvbWFpbiArIFwiL1wiICsgZW5kT2ZVcmw7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9yZWdpc3RlclByb2dyZXNzSGFuZGxlcihpZCwgY2h1bmtJZHgsIGNodW5rRGF0YS5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZC50cmFjayhpZCwgeGhyLCBjaHVua0lkeCkudGhlbihwcm9taXNlLnN1Y2Nlc3MsIHByb21pc2UuZmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIub3BlbihcIlBVVFwiLCB1cmwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChoZWFkZXJzLCBmdW5jdGlvbihuYW1lLCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZChjaHVua0RhdGEuYmxvYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5mYWlsdXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBcIlByb2JsZW0gc2lnbmluZyB0aGUgY2h1bmshXCJcbiAgICAgICAgICAgICAgICAgICAgfSwgeGhyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZW5kOiBmdW5jdGlvbihpZCwgY2h1bmtJZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgY2h1bmtlZC5zZXR1cChpZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtlZC5wdXQoaWQsIGNodW5rSWR4KS50aGVuKHByb21pc2Uuc3VjY2VzcywgcHJvbWlzZS5mYWlsdXJlKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvck1lc3NhZ2UsIHhocikge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmZhaWx1cmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICB9LCB4aHIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldHVwOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHFxLlByb21pc2UoKSwgdXBsb2FkSWQgPSBoYW5kbGVyLl9nZXRQZXJzaXN0YWJsZURhdGEoaWQpLnVwbG9hZElkLCB1cGxvYWRJZFByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIGlmICghdXBsb2FkSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fZ2V0UGVyc2lzdGFibGVEYXRhKGlkKS51cGxvYWRJZCA9IHVwbG9hZElkUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVycy5pbml0aWF0ZU11bHRpcGFydC5zZW5kKGlkKS50aGVuKGZ1bmN0aW9uKHVwbG9hZElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9nZXRQZXJzaXN0YWJsZURhdGEoaWQpLnVwbG9hZElkID0gdXBsb2FkSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRJZFByb21pc2Uuc3VjY2Vzcyh1cGxvYWRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3ModXBsb2FkSWQpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvck1zZywgeGhyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9nZXRQZXJzaXN0YWJsZURhdGEoaWQpLnVwbG9hZElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuZmFpbHVyZShlcnJvck1zZywgeGhyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZElkUHJvbWlzZS5mYWlsdXJlKGVycm9yTXNnLCB4aHIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHVwbG9hZElkIGluc3RhbmNlb2YgcXEuUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWRJZC50aGVuKGZ1bmN0aW9uKHVwbG9hZElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3ModXBsb2FkSWQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3ModXBsb2FkSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgcmVxdWVzdGVycyA9IHtcbiAgICAgICAgICAgIGFib3J0TXVsdGlwYXJ0OiBuZXcgcXEuczMuQWJvcnRNdWx0aXBhcnRBamF4UmVxdWVzdGVyKHtcbiAgICAgICAgICAgICAgICBlbmRwb2ludFN0b3JlOiBlbmRwb2ludFN0b3JlLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZVNwZWM6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICBjb3JzOiBzcGVjLmNvcnMsXG4gICAgICAgICAgICAgICAgbG9nOiBsb2csXG4gICAgICAgICAgICAgICAgZ2V0QnVja2V0OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXBsb2FkLmJ1Y2tldC5nZXROYW1lKGlkKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldEhvc3Q6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1cGxvYWQuaG9zdC5nZXROYW1lKGlkKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldEtleTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwbG9hZC5rZXkudXJsU2FmZShpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjb21wbGV0ZU11bHRpcGFydDogbmV3IHFxLnMzLkNvbXBsZXRlTXVsdGlwYXJ0QWpheFJlcXVlc3Rlcih7XG4gICAgICAgICAgICAgICAgZW5kcG9pbnRTdG9yZTogZW5kcG9pbnRTdG9yZSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmVTcGVjOiBzaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgY29yczogc3BlYy5jb3JzLFxuICAgICAgICAgICAgICAgIGxvZzogbG9nLFxuICAgICAgICAgICAgICAgIGdldEJ1Y2tldDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwbG9hZC5idWNrZXQuZ2V0TmFtZShpZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRIb3N0OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXBsb2FkLmhvc3QuZ2V0TmFtZShpZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRLZXk6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1cGxvYWQua2V5LnVybFNhZmUoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaW5pdGlhdGVNdWx0aXBhcnQ6IG5ldyBxcS5zMy5Jbml0aWF0ZU11bHRpcGFydEFqYXhSZXF1ZXN0ZXIoe1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lUGFyYW06IGZpbGVuYW1lUGFyYW0sXG4gICAgICAgICAgICAgICAgZW5kcG9pbnRTdG9yZTogZW5kcG9pbnRTdG9yZSxcbiAgICAgICAgICAgICAgICBwYXJhbXNTdG9yZTogcGFyYW1zU3RvcmUsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlU3BlYzogc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIGFjbFN0b3JlOiBhY2xTdG9yZSxcbiAgICAgICAgICAgICAgICByZWR1Y2VkUmVkdW5kYW5jeTogcmVkdWNlZFJlZHVuZGFuY3ksXG4gICAgICAgICAgICAgICAgc2VydmVyU2lkZUVuY3J5cHRpb246IHNlcnZlclNpZGVFbmNyeXB0aW9uLFxuICAgICAgICAgICAgICAgIGNvcnM6IHNwZWMuY29ycyxcbiAgICAgICAgICAgICAgICBsb2c6IGxvZyxcbiAgICAgICAgICAgICAgICBnZXRDb250ZW50VHlwZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuX2dldE1pbWVUeXBlKGlkKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldEJ1Y2tldDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwbG9hZC5idWNrZXQuZ2V0TmFtZShpZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRIb3N0OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXBsb2FkLmhvc3QuZ2V0TmFtZShpZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRLZXk6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1cGxvYWQua2V5LnVybFNhZmUoaWQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0TmFtZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE5hbWUoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcG9saWN5U2lnbmF0dXJlOiBuZXcgcXEuczMuUmVxdWVzdFNpZ25lcih7XG4gICAgICAgICAgICAgICAgZXhwZWN0aW5nUG9saWN5OiB0cnVlLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZVNwZWM6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICBjb3JzOiBzcGVjLmNvcnMsXG4gICAgICAgICAgICAgICAgbG9nOiBsb2dcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcmVzdFNpZ25hdHVyZTogbmV3IHFxLnMzLlJlcXVlc3RTaWduZXIoe1xuICAgICAgICAgICAgICAgIGVuZHBvaW50U3RvcmU6IGVuZHBvaW50U3RvcmUsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlU3BlYzogc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIGNvcnM6IHNwZWMuY29ycyxcbiAgICAgICAgICAgICAgICBsb2c6IGxvZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgc2ltcGxlID0ge1xuICAgICAgICAgICAgaW5pdFBhcmFtczogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VzdG9tUGFyYW1zID0gcGFyYW1zU3RvcmUuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICBjdXN0b21QYXJhbXNbZmlsZW5hbWVQYXJhbV0gPSBnZXROYW1lKGlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXEuczMudXRpbC5nZW5lcmF0ZUF3c1BhcmFtcyh7XG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiBlbmRwb2ludFN0b3JlLmdldChpZCksXG4gICAgICAgICAgICAgICAgICAgIGNsb2NrRHJpZnQ6IGNsb2NrRHJpZnQsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogY3VzdG9tUGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBoYW5kbGVyLl9nZXRNaW1lVHlwZShpZCksXG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldDogdXBsb2FkLmJ1Y2tldC5nZXROYW1lKGlkKSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBoYW5kbGVyLmdldFRoaXJkUGFydHlGaWxlSWQoaWQpLFxuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NLZXk6IGNyZWRlbnRpYWxzUHJvdmlkZXIuZ2V0KCkuYWNjZXNzS2V5LFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uVG9rZW46IGNyZWRlbnRpYWxzUHJvdmlkZXIuZ2V0KCkuc2Vzc2lvblRva2VuLFxuICAgICAgICAgICAgICAgICAgICBhY2w6IGFjbFN0b3JlLmdldChpZCksXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkU3RhdHVzOiBleHBlY3RlZFN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgbWluRmlsZVNpemU6IHZhbGlkYXRpb24ubWluU2l6ZUxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBtYXhGaWxlU2l6ZTogdmFsaWRhdGlvbi5tYXhTaXplTGltaXQsXG4gICAgICAgICAgICAgICAgICAgIHJlZHVjZWRSZWR1bmRhbmN5OiByZWR1Y2VkUmVkdW5kYW5jeSxcbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uOiByZWdpb24sXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclNpZGVFbmNyeXB0aW9uOiBzZXJ2ZXJTaWRlRW5jcnlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlVmVyc2lvbjogc2lnbmF0dXJlLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGxvZzogbG9nXG4gICAgICAgICAgICAgICAgfSwgcXEuYmluZChyZXF1ZXN0ZXJzLnBvbGljeVNpZ25hdHVyZS5nZXRTaWduYXR1cmUsIHRoaXMsIGlkKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCksIHhociA9IGhhbmRsZXIuX2NyZWF0ZVhocihpZCksIGZpbGVPckJsb2IgPSBoYW5kbGVyLmdldEZpbGUoaWQpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuX3JlZ2lzdGVyUHJvZ3Jlc3NIYW5kbGVyKGlkKTtcbiAgICAgICAgICAgICAgICB1cGxvYWQudHJhY2soaWQsIHhocikudGhlbihwcm9taXNlLnN1Y2Nlc3MsIHByb21pc2UuZmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgc2ltcGxlLnNldHVwKGlkLCB4aHIsIGZpbGVPckJsb2IpLnRoZW4oZnVuY3Rpb24odG9TZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIlNlbmRpbmcgdXBsb2FkIHJlcXVlc3QgZm9yIFwiICsgaWQpO1xuICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZCh0b1NlbmQpO1xuICAgICAgICAgICAgICAgIH0sIHByb21pc2UuZmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0dXA6IGZ1bmN0aW9uKGlkLCB4aHIsIGZpbGVPckJsb2IpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKSwgZW5kcG9pbnQgPSBlbmRwb2ludFN0b3JlLmdldChpZCksIHVybCA9IGVuZHBvaW50LCBwcm9taXNlID0gbmV3IHFxLlByb21pc2UoKTtcbiAgICAgICAgICAgICAgICBzaW1wbGUuaW5pdFBhcmFtcyhpZCkudGhlbihmdW5jdGlvbihhd3NQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oXCJQT1NUXCIsIHVybCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHFxLm9iajJGb3JtRGF0YShhd3NQYXJhbXMsIGZvcm1EYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBmaWxlT3JCbG9iKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKGZvcm1EYXRhKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5mYWlsdXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHVwbG9hZCA9IHtcbiAgICAgICAgICAgIGJ1Y2tldDoge1xuICAgICAgICAgICAgICAgIHByb21pc2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHFxLlByb21pc2UoKSwgY2FjaGVkQnVja2V0ID0gaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5idWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWRCdWNrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2Uuc3VjY2VzcyhjYWNoZWRCdWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25HZXRCdWNrZXQoaWQpLnRoZW4oZnVuY3Rpb24oYnVja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKGJ1Y2tldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBwcm9taXNlLmZhaWx1cmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0TmFtZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkuYnVja2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpLCBjYWNoZWRIb3N0ID0gaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5ob3N0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkSG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKGNhY2hlZEhvc3QpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25HZXRIb3N0KGlkKS50aGVuKGZ1bmN0aW9uKGhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmhvc3QgPSBob3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2Uuc3VjY2Vzcyhob3N0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHByb21pc2UuZmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXROYW1lOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5ob3N0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb25lOiBmdW5jdGlvbihpZCwgeGhyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gdXBsb2FkLnJlc3BvbnNlLnBhcnNlKGlkLCB4aHIpLCBpc0Vycm9yID0gcmVzcG9uc2Uuc3VjY2VzcyAhPT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvciAmJiB1cGxvYWQucmVzcG9uc2Uuc2hvdWxkUmVzZXQocmVzcG9uc2UuY29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwiVGhpcyBpcyBhbiB1bnJlY292ZXJhYmxlIGVycm9yLCB3ZSBtdXN0IHJlc3RhcnQgdGhlIHVwbG9hZCBlbnRpcmVseSBvbiB0aGUgbmV4dCByZXRyeSBhdHRlbXB0LlwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5yZXNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6ICFpc0Vycm9yLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleToge1xuICAgICAgICAgICAgICAgIHByb21pc2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHFxLlByb21pc2UoKSwga2V5ID0gaGFuZGxlci5nZXRUaGlyZFBhcnR5RmlsZUlkKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9zZXRUaGlyZFBhcnR5RmlsZUlkKGlkLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uR2V0S2V5TmFtZShpZCwgZ2V0TmFtZShpZCkpLnRoZW4oZnVuY3Rpb24oa2V5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuX3NldFRoaXJkUGFydHlGaWxlSWQoaWQsIGtleU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2Uuc3VjY2VzcyhrZXlOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yUmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fc2V0VGhpcmRQYXJ0eUZpbGVJZChpZCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5mYWlsdXJlKGVycm9yUmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHFxLmlzR2VuZXJpY1Byb21pc2Uoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LnRoZW4ocHJvbWlzZS5zdWNjZXNzLCBwcm9taXNlLmZhaWx1cmUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB1cmxTYWZlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5jb2RlZEtleSA9IGhhbmRsZXIuZ2V0VGhpcmRQYXJ0eUZpbGVJZChpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxcS5zMy51dGlsLnVyaUVzY2FwZVBhdGgoZW5jb2RlZEtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKGlkLCB4aHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0ge30sIHBhcnNlZEVycm9yUHJvcHM7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cocXEuZm9ybWF0KFwiUmVjZWl2ZWQgcmVzcG9uc2Ugc3RhdHVzIHt9IHdpdGggYm9keToge31cIiwgeGhyLnN0YXR1cywgeGhyLnJlc3BvbnNlVGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IGV4cGVjdGVkU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZEVycm9yUHJvcHMgPSB1cGxvYWQucmVzcG9uc2UucGFyc2VFcnJvcih4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkRXJyb3JQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5lcnJvciA9IHBhcnNlZEVycm9yUHJvcHMubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuY29kZSA9IHBhcnNlZEVycm9yUHJvcHMuY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2coXCJFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gcGFyc2UgeGhyIHJlc3BvbnNlIHRleHQgKFwiICsgZXJyb3IubWVzc2FnZSArIFwiKVwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKGF3c1Jlc3BvbnNlWG1sKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCksIHBhcnNlZERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoYXdzUmVzcG9uc2VYbWwsIFwiYXBwbGljYXRpb24veG1sXCIpLCBlcnJvckVscyA9IHBhcnNlZERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcIkVycm9yXCIpLCBlcnJvckRldGFpbHMgPSB7fSwgY29kZUVscywgbWVzc2FnZUVscztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yRWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUVscyA9IHBhcnNlZERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcIkNvZGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRWxzID0gcGFyc2VkRG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiTWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlRWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yRGV0YWlscy5tZXNzYWdlID0gbWVzc2FnZUVsc1swXS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlRWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yRGV0YWlscy5jb2RlID0gY29kZUVsc1swXS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvckRldGFpbHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNob3VsZFJlc2V0OiBmdW5jdGlvbihlcnJvckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yQ29kZSA9PT0gXCJFbnRpdHlUb29TbWFsbFwiIHx8IGVycm9yQ29kZSA9PT0gXCJJbnZhbGlkUGFydFwiIHx8IGVycm9yQ29kZSA9PT0gXCJJbnZhbGlkUGFydE9yZGVyXCIgfHwgZXJyb3JDb2RlID09PSBcIk5vU3VjaFVwbG9hZFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGFydDogZnVuY3Rpb24oaWQsIG9wdENodW5rSWR4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIHVwbG9hZC5rZXkucHJvbWlzZShpZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkLmJ1Y2tldC5wcm9taXNlKGlkKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkLmhvc3QucHJvbWlzZShpZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0Q2h1bmtJZHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW1wbGUuc2VuZChpZCkudGhlbihwcm9taXNlLnN1Y2Nlc3MsIHByb21pc2UuZmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtlZC5zZW5kKGlkLCBvcHRDaHVua0lkeCkudGhlbihwcm9taXNlLnN1Y2Nlc3MsIHByb21pc2UuZmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yUmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuZmFpbHVyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JSZWFzb25cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhY2s6IGZ1bmN0aW9uKGlkLCB4aHIsIG9wdENodW5rSWR4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdENodW5rSWR4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB1cGxvYWQuZG9uZShpZCwgeGhyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlW3Jlc3VsdC5zdWNjZXNzID8gXCJzdWNjZXNzXCIgOiBcImZhaWx1cmVcIl0ocmVzdWx0LnJlc3BvbnNlLCB4aHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua2VkLmRvbmUoaWQsIHhociwgb3B0Q2h1bmtJZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHVwbG9hZC5kb25lKGlkLCB4aHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VbcmVzdWx0LnN1Y2Nlc3MgPyBcInN1Y2Nlc3NcIiA6IFwiZmFpbHVyZVwiXShyZXN1bHQucmVzcG9uc2UsIHhocik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBxcS5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgdXBsb2FkQ2h1bms6IHVwbG9hZC5zdGFydCxcbiAgICAgICAgICAgIHVwbG9hZEZpbGU6IHVwbG9hZC5zdGFydFxuICAgICAgICB9KTtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIG5ldyBxcS5YaHJVcGxvYWRIYW5kbGVyKHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHFxLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBcInMzXCJcbiAgICAgICAgICAgIH0sIHNwZWMpLFxuICAgICAgICAgICAgcHJveHk6IHFxLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgZ2V0RW5kcG9pbnQ6IHNwZWMuZW5kcG9pbnRTdG9yZS5nZXRcbiAgICAgICAgICAgIH0sIHByb3h5KVxuICAgICAgICB9KSk7XG4gICAgICAgIHFxLm92ZXJyaWRlKHRoaXMsIGZ1bmN0aW9uKHN1cGVyXykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBleHB1bmdlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXBsb2FkSWQgPSBoYW5kbGVyLl9nZXRQZXJzaXN0YWJsZURhdGEoaWQpICYmIGhhbmRsZXIuX2dldFBlcnNpc3RhYmxlRGF0YShpZCkudXBsb2FkSWQsIGV4aXN0ZWRJbkxvY2FsU3RvcmFnZSA9IGhhbmRsZXIuX21heWJlRGVsZXRlUGVyc2lzdGVkQ2h1bmtEYXRhKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwbG9hZElkICE9PSB1bmRlZmluZWQgJiYgZXhpc3RlZEluTG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZXJzLmFib3J0TXVsdGlwYXJ0LnNlbmQoaWQsIHVwbG9hZElkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdXBlcl8uZXhwdW5nZShpZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmaW5hbGl6ZUNodW5rczogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rZWQuY29tYmluZShpZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfZ2V0TG9jYWxTdG9yYWdlSWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlU3RvcmFnZUlkID0gc3VwZXJfLl9nZXRMb2NhbFN0b3JhZ2VJZChpZCksIGJ1Y2tldE5hbWUgPSB1cGxvYWQuYnVja2V0LmdldE5hbWUoaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVN0b3JhZ2VJZCArIFwiLVwiICsgYnVja2V0TmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHFxLnMzLkZvcm1VcGxvYWRIYW5kbGVyID0gZnVuY3Rpb24ob3B0aW9ucywgcHJveHkpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcywgY2xvY2tEcmlmdCA9IG9wdGlvbnMuY2xvY2tEcmlmdCwgb25VdWlkQ2hhbmdlZCA9IHByb3h5Lm9uVXVpZENoYW5nZWQsIGdldE5hbWUgPSBwcm94eS5nZXROYW1lLCBnZXRVdWlkID0gcHJveHkuZ2V0VXVpZCwgbG9nID0gcHJveHkubG9nLCBvbkdldEJ1Y2tldCA9IG9wdGlvbnMuZ2V0QnVja2V0LCBvbkdldEtleU5hbWUgPSBvcHRpb25zLmdldEtleU5hbWUsIGZpbGVuYW1lUGFyYW0gPSBvcHRpb25zLmZpbGVuYW1lUGFyYW0sIHBhcmFtc1N0b3JlID0gb3B0aW9ucy5wYXJhbXNTdG9yZSwgZW5kcG9pbnRTdG9yZSA9IG9wdGlvbnMuZW5kcG9pbnRTdG9yZSwgYWNsU3RvcmUgPSBvcHRpb25zLmFjbFN0b3JlLCByZWR1Y2VkUmVkdW5kYW5jeSA9IG9wdGlvbnMub2JqZWN0UHJvcGVydGllcy5yZWR1Y2VkUmVkdW5kYW5jeSwgcmVnaW9uID0gb3B0aW9ucy5vYmplY3RQcm9wZXJ0aWVzLnJlZ2lvbiwgc2VydmVyU2lkZUVuY3J5cHRpb24gPSBvcHRpb25zLm9iamVjdFByb3BlcnRpZXMuc2VydmVyU2lkZUVuY3J5cHRpb24sIHZhbGlkYXRpb24gPSBvcHRpb25zLnZhbGlkYXRpb24sIHNpZ25hdHVyZSA9IG9wdGlvbnMuc2lnbmF0dXJlLCBzdWNjZXNzUmVkaXJlY3RVcmwgPSBvcHRpb25zLmlmcmFtZVN1cHBvcnQubG9jYWxCbGFua1BhZ2VQYXRoLCBjcmVkZW50aWFsc1Byb3ZpZGVyID0gb3B0aW9ucy5zaWduYXR1cmUuY3JlZGVudGlhbHNQcm92aWRlciwgZ2V0U2lnbmF0dXJlQWpheFJlcXVlc3RlciA9IG5ldyBxcS5zMy5SZXF1ZXN0U2lnbmVyKHtcbiAgICAgICAgICAgIHNpZ25hdHVyZVNwZWM6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgIGNvcnM6IG9wdGlvbnMuY29ycyxcbiAgICAgICAgICAgIGxvZzogbG9nXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3VjY2Vzc1JlZGlyZWN0VXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1Y2Nlc3NSZWRpcmVjdEVuZHBvaW50IE1VU1QgYmUgZGVmaW5lZCBpZiB5b3UgaW50ZW5kIHRvIHVzZSBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IHRoZSBGaWxlIEFQSSFcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNWYWxpZFJlc3BvbnNlKGlkLCBpZnJhbWUpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSwgZW5kcG9pbnQgPSBvcHRpb25zLmVuZHBvaW50U3RvcmUuZ2V0KGlkKSwgYnVja2V0ID0gaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5idWNrZXQsIGRvYywgaW5uZXJIdG1sLCByZXNwb25zZURhdGE7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRvYyA9IGlmcmFtZS5jb250ZW50RG9jdW1lbnQgfHwgaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgaW5uZXJIdG1sID0gZG9jLmJvZHkuaW5uZXJIVE1MO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlRGF0YSA9IHFxLnMzLnV0aWwucGFyc2VJZnJhbWVSZXNwb25zZShpZnJhbWUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZURhdGEuYnVja2V0ID09PSBidWNrZXQgJiYgcmVzcG9uc2VEYXRhLmtleSA9PT0gcXEuczMudXRpbC5lbmNvZGVRdWVyeVN0cmluZ1BhcmFtKGhhbmRsZXIuZ2V0VGhpcmRQYXJ0eUZpbGVJZChpZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2coXCJSZXNwb25zZSBmcm9tIEFXUyBpbmNsdWRlZCBhbiB1bmV4cGVjdGVkIGJ1Y2tldCBvciBrZXkgbmFtZS5cIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nKFwiRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIHBhcnNlIGZvcm0gdXBsb2FkIHJlc3BvbnNlIChcIiArIGVycm9yLm1lc3NhZ2UgKyBcIilcIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZW5lcmF0ZUF3c1BhcmFtcyhpZCkge1xuICAgICAgICAgICAgdmFyIGN1c3RvbVBhcmFtcyA9IHBhcmFtc1N0b3JlLmdldChpZCk7XG4gICAgICAgICAgICBjdXN0b21QYXJhbXNbZmlsZW5hbWVQYXJhbV0gPSBnZXROYW1lKGlkKTtcbiAgICAgICAgICAgIHJldHVybiBxcS5zMy51dGlsLmdlbmVyYXRlQXdzUGFyYW1zKHtcbiAgICAgICAgICAgICAgICBlbmRwb2ludDogZW5kcG9pbnRTdG9yZS5nZXQoaWQpLFxuICAgICAgICAgICAgICAgIGNsb2NrRHJpZnQ6IGNsb2NrRHJpZnQsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBjdXN0b21QYXJhbXMsXG4gICAgICAgICAgICAgICAgYnVja2V0OiBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmJ1Y2tldCxcbiAgICAgICAgICAgICAgICBrZXk6IGhhbmRsZXIuZ2V0VGhpcmRQYXJ0eUZpbGVJZChpZCksXG4gICAgICAgICAgICAgICAgYWNjZXNzS2V5OiBjcmVkZW50aWFsc1Byb3ZpZGVyLmdldCgpLmFjY2Vzc0tleSxcbiAgICAgICAgICAgICAgICBzZXNzaW9uVG9rZW46IGNyZWRlbnRpYWxzUHJvdmlkZXIuZ2V0KCkuc2Vzc2lvblRva2VuLFxuICAgICAgICAgICAgICAgIGFjbDogYWNsU3RvcmUuZ2V0KGlkKSxcbiAgICAgICAgICAgICAgICBtaW5GaWxlU2l6ZTogdmFsaWRhdGlvbi5taW5TaXplTGltaXQsXG4gICAgICAgICAgICAgICAgbWF4RmlsZVNpemU6IHZhbGlkYXRpb24ubWF4U2l6ZUxpbWl0LFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NSZWRpcmVjdFVybDogc3VjY2Vzc1JlZGlyZWN0VXJsLFxuICAgICAgICAgICAgICAgIHJlZHVjZWRSZWR1bmRhbmN5OiByZWR1Y2VkUmVkdW5kYW5jeSxcbiAgICAgICAgICAgICAgICByZWdpb246IHJlZ2lvbixcbiAgICAgICAgICAgICAgICBzZXJ2ZXJTaWRlRW5jcnlwdGlvbjogc2VydmVyU2lkZUVuY3J5cHRpb24sXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlVmVyc2lvbjogc2lnbmF0dXJlLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgbG9nOiBsb2dcbiAgICAgICAgICAgIH0sIHFxLmJpbmQoZ2V0U2lnbmF0dXJlQWpheFJlcXVlc3Rlci5nZXRTaWduYXR1cmUsIHRoaXMsIGlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRm9ybShpZCwgaWZyYW1lKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCksIG1ldGhvZCA9IFwiUE9TVFwiLCBlbmRwb2ludCA9IG9wdGlvbnMuZW5kcG9pbnRTdG9yZS5nZXQoaWQpLCBmaWxlTmFtZSA9IGdldE5hbWUoaWQpO1xuICAgICAgICAgICAgZ2VuZXJhdGVBd3NQYXJhbXMoaWQpLnRoZW4oZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm0gPSBoYW5kbGVyLl9pbml0Rm9ybUZvclVwbG9hZCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNJbkJvZHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5hbWU6IGlmcmFtZS5uYW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKGZvcm0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5mYWlsdXJlKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlRmluaXNoZWRVcGxvYWQoaWQsIGlmcmFtZSwgZmlsZU5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVVcGxvYWQoaWQpIHtcbiAgICAgICAgICAgIHZhciBpZnJhbWUgPSBoYW5kbGVyLl9jcmVhdGVJZnJhbWUoaWQpLCBpbnB1dCA9IGhhbmRsZXIuZ2V0SW5wdXQoaWQpLCBwcm9taXNlID0gbmV3IHFxLlByb21pc2UoKTtcbiAgICAgICAgICAgIGNyZWF0ZUZvcm0oaWQsIGlmcmFtZSkudGhlbihmdW5jdGlvbihmb3JtKSB7XG4gICAgICAgICAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5fYXR0YWNoTG9hZEV2ZW50KGlmcmFtZSwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwiaWZyYW1lIGxvYWRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coXCJBbWF6b24gbGlrZWx5IHJlamVjdGVkIHRoZSB1cGxvYWQgcmVxdWVzdFwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuZmFpbHVyZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3VjY2VzcyA9IGlzVmFsaWRSZXNwb25zZShpZCwgaWZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhcIkEgc3VjY2VzcyByZXNwb25zZSB3YXMgcmVjZWl2ZWQgYnkgQW1hem9uLCBidXQgaXQgd2FzIGludmFsaWQgaW4gc29tZSB3YXkuXCIsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5mYWlsdXJlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXEuZXh0ZW5kKHJlc3BvbnNlLCBxcS5zMy51dGlsLnBhcnNlSWZyYW1lUmVzcG9uc2UoaWZyYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVGaW5pc2hlZFVwbG9hZChpZCwgaWZyYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsb2coXCJTZW5kaW5nIHVwbG9hZCByZXF1ZXN0IGZvciBcIiArIGlkKTtcbiAgICAgICAgICAgICAgICBmb3JtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIHFxKGZvcm0pLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSwgcHJvbWlzZS5mYWlsdXJlKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUZpbmlzaGVkVXBsb2FkKGlkLCBpZnJhbWUpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuX2RldGFjaExvYWRFdmVudChpZCk7XG4gICAgICAgICAgICBpZnJhbWUgJiYgcXEoaWZyYW1lKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBxcS5leHRlbmQodGhpcywgbmV3IHFxLkZvcm1VcGxvYWRIYW5kbGVyKHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBpc0NvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlucHV0TmFtZTogXCJmaWxlXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm94eToge1xuICAgICAgICAgICAgICAgIG9uQ2FuY2VsOiBvcHRpb25zLm9uQ2FuY2VsLFxuICAgICAgICAgICAgICAgIG9uVXVpZENoYW5nZWQ6IG9uVXVpZENoYW5nZWQsXG4gICAgICAgICAgICAgICAgZ2V0TmFtZTogZ2V0TmFtZSxcbiAgICAgICAgICAgICAgICBnZXRVdWlkOiBnZXRVdWlkLFxuICAgICAgICAgICAgICAgIGxvZzogbG9nXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIHVwbG9hZEZpbGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBnZXROYW1lKGlkKSwgcHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuZ2V0VGhpcmRQYXJ0eUZpbGVJZChpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkuYnVja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVVcGxvYWQoaWQpLnRoZW4ocHJvbWlzZS5zdWNjZXNzLCBwcm9taXNlLmZhaWx1cmUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25HZXRCdWNrZXQoaWQpLnRoZW4oZnVuY3Rpb24oYnVja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlVXBsb2FkKGlkKS50aGVuKHByb21pc2Uuc3VjY2VzcywgcHJvbWlzZS5mYWlsdXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb25HZXRLZXlOYW1lKGlkLCBuYW1lKS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25HZXRCdWNrZXQoaWQpLnRoZW4oZnVuY3Rpb24oYnVja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fc2V0VGhpcmRQYXJ0eUZpbGVJZChpZCwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVVcGxvYWQoaWQpLnRoZW4ocHJvbWlzZS5zdWNjZXNzLCBwcm9taXNlLmZhaWx1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3JSZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmZhaWx1cmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JSZWFzb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvclJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5mYWlsdXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JSZWFzb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcXEuRHJhZ0FuZERyb3AgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgb3B0aW9ucywgSElERV9aT05FU19FVkVOVF9OQU1FID0gXCJxcS1oaWRlem9uZXNcIiwgSElERV9CRUZPUkVfRU5URVJfQVRUUiA9IFwicXEtaGlkZS1kcm9wem9uZVwiLCB1cGxvYWREcm9wWm9uZXMgPSBbXSwgZHJvcHBlZEZpbGVzID0gW10sIGRpc3Bvc2VTdXBwb3J0ID0gbmV3IHFxLkRpc3Bvc2VTdXBwb3J0KCk7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBkcm9wWm9uZUVsZW1lbnRzOiBbXSxcbiAgICAgICAgICAgIGFsbG93TXVsdGlwbGVJdGVtczogdHJ1ZSxcbiAgICAgICAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgICAgICAgICBkcm9wQWN0aXZlOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBuZXcgcXEuRHJhZ0FuZERyb3AuY2FsbGJhY2tzKClcbiAgICAgICAgfTtcbiAgICAgICAgcXEuZXh0ZW5kKG9wdGlvbnMsIG8sIHRydWUpO1xuICAgICAgICBmdW5jdGlvbiB1cGxvYWREcm9wcGVkRmlsZXMoZmlsZXMsIHVwbG9hZERyb3Bab25lKSB7XG4gICAgICAgICAgICB2YXIgZmlsZXNBc0FycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZmlsZXMpO1xuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFja3MuZHJvcExvZyhcIkdyYWJiZWQgXCIgKyBmaWxlcy5sZW5ndGggKyBcIiBkcm9wcGVkIGZpbGVzLlwiKTtcbiAgICAgICAgICAgIHVwbG9hZERyb3Bab25lLmRyb3BEaXNhYmxlZChmYWxzZSk7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrcy5wcm9jZXNzaW5nRHJvcHBlZEZpbGVzQ29tcGxldGUoZmlsZXNBc0FycmF5LCB1cGxvYWREcm9wWm9uZS5nZXRFbGVtZW50KCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRyYXZlcnNlRmlsZVRyZWUoZW50cnkpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZUVudHJ5UHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCk7XG4gICAgICAgICAgICBpZiAoZW50cnkuaXNGaWxlKSB7XG4gICAgICAgICAgICAgICAgZW50cnkuZmlsZShmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZW50cnkubmFtZSwgZnVsbFBhdGggPSBlbnRyeS5mdWxsUGF0aCwgaW5kZXhPZk5hbWVJbkZ1bGxQYXRoID0gZnVsbFBhdGguaW5kZXhPZihuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZnVsbFBhdGggPSBmdWxsUGF0aC5zdWJzdHIoMCwgaW5kZXhPZk5hbWVJbkZ1bGxQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bGxQYXRoLmNoYXJBdCgwKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxQYXRoID0gZnVsbFBhdGguc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbGUucXFQYXRoID0gZnVsbFBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGRyb3BwZWRGaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUVudHJ5UHJvbWlzZS5zdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZmlsZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2tzLmRyb3BMb2coXCJQcm9ibGVtIHBhcnNpbmcgJ1wiICsgZW50cnkuZnVsbFBhdGggKyBcIicuICBGaWxlRXJyb3IgY29kZSBcIiArIGZpbGVFcnJvci5jb2RlICsgXCIuXCIsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRW50cnlQcm9taXNlLmZhaWx1cmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBnZXRGaWxlc0luRGlyZWN0b3J5KGVudHJ5KS50aGVuKGZ1bmN0aW9uIGFsbEVudHJpZXNSZWFkKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJpZXNMZWZ0ID0gZW50cmllcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHFxLmVhY2goZW50cmllcywgZnVuY3Rpb24oaWR4LCBlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VGaWxlVHJlZShlbnRyeSkuZG9uZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzTGVmdCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzTGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUVudHJ5UHJvbWlzZS5zdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUVudHJ5UHJvbWlzZS5zdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiByZWFkRmFpbHVyZShmaWxlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFja3MuZHJvcExvZyhcIlByb2JsZW0gcGFyc2luZyAnXCIgKyBlbnRyeS5mdWxsUGF0aCArIFwiJy4gIEZpbGVFcnJvciBjb2RlIFwiICsgZmlsZUVycm9yLmNvZGUgKyBcIi5cIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VFbnRyeVByb21pc2UuZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRW50cnlQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEZpbGVzSW5EaXJlY3RvcnkoZW50cnksIHJlYWRlciwgYWNjdW1FbnRyaWVzLCBleGlzdGluZ1Byb21pc2UpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gZXhpc3RpbmdQcm9taXNlIHx8IG5ldyBxcS5Qcm9taXNlKCksIGRpclJlYWRlciA9IHJlYWRlciB8fCBlbnRyeS5jcmVhdGVSZWFkZXIoKTtcbiAgICAgICAgICAgIGRpclJlYWRlci5yZWFkRW50cmllcyhmdW5jdGlvbiByZWFkU3VjY2VzcyhlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0VudHJpZXMgPSBhY2N1bUVudHJpZXMgPyBhY2N1bUVudHJpZXMuY29uY2F0KGVudHJpZXMpIDogZW50cmllcztcbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEZpbGVzSW5EaXJlY3RvcnkoZW50cnksIGRpclJlYWRlciwgbmV3RW50cmllcywgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2Uuc3VjY2VzcyhuZXdFbnRyaWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBwcm9taXNlLmZhaWx1cmUpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlRGF0YVRyYW5zZmVyKGRhdGFUcmFuc2ZlciwgdXBsb2FkRHJvcFpvbmUpIHtcbiAgICAgICAgICAgIHZhciBwZW5kaW5nRm9sZGVyUHJvbWlzZXMgPSBbXSwgaGFuZGxlRGF0YVRyYW5zZmVyUHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCk7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrcy5wcm9jZXNzaW5nRHJvcHBlZEZpbGVzKCk7XG4gICAgICAgICAgICB1cGxvYWREcm9wWm9uZS5kcm9wRGlzYWJsZWQodHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aCA+IDEgJiYgIW9wdGlvbnMuYWxsb3dNdWx0aXBsZUl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFja3MucHJvY2Vzc2luZ0Ryb3BwZWRGaWxlc0NvbXBsZXRlKFtdKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrcy5kcm9wRXJyb3IoXCJ0b29NYW55RmlsZXNFcnJvclwiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB1cGxvYWREcm9wWm9uZS5kcm9wRGlzYWJsZWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGhhbmRsZURhdGFUcmFuc2ZlclByb21pc2UuZmFpbHVyZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkcm9wcGVkRmlsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAocXEuaXNGb2xkZXJEcm9wU3VwcG9ydGVkKGRhdGFUcmFuc2ZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChkYXRhVHJhbnNmZXIuaXRlbXMsIGZ1bmN0aW9uKGlkeCwgaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gaXRlbS53ZWJraXRHZXRBc0VudHJ5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BwZWRGaWxlcy5wdXNoKGl0ZW0uZ2V0QXNGaWxlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdGb2xkZXJQcm9taXNlcy5wdXNoKHRyYXZlcnNlRmlsZVRyZWUoZW50cnkpLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nRm9sZGVyUHJvbWlzZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVuZGluZ0ZvbGRlclByb21pc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZURhdGFUcmFuc2ZlclByb21pc2Uuc3VjY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkcm9wcGVkRmlsZXMgPSBkYXRhVHJhbnNmZXIuZmlsZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nRm9sZGVyUHJvbWlzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZURhdGFUcmFuc2ZlclByb21pc2Uuc3VjY2VzcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVEYXRhVHJhbnNmZXJQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwRHJvcHpvbmUoZHJvcEFyZWEpIHtcbiAgICAgICAgICAgIHZhciBkcm9wWm9uZSA9IG5ldyBxcS5VcGxvYWREcm9wWm9uZSh7XG4gICAgICAgICAgICAgICAgSElERV9aT05FU19FVkVOVF9OQU1FOiBISURFX1pPTkVTX0VWRU5UX05BTUUsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZHJvcEFyZWEsXG4gICAgICAgICAgICAgICAgb25FbnRlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBxcShkcm9wQXJlYSkuYWRkQ2xhc3Mob3B0aW9ucy5jbGFzc2VzLmRyb3BBY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25MZWF2ZU5vdERlc2NlbmRhbnRzOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHFxKGRyb3BBcmVhKS5yZW1vdmVDbGFzcyhvcHRpb25zLmNsYXNzZXMuZHJvcEFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkRyb3A6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRGF0YVRyYW5zZmVyKGUuZGF0YVRyYW5zZmVyLCBkcm9wWm9uZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZERyb3BwZWRGaWxlcyhkcm9wcGVkRmlsZXMsIGRyb3Bab25lKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrcy5kcm9wTG9nKFwiRHJvcCBldmVudCBEYXRhVHJhbnNmZXIgcGFyc2luZyBmYWlsZWQuICBObyBmaWxlcyB3aWxsIGJlIHVwbG9hZGVkLlwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3Bvc2VTdXBwb3J0LmFkZERpc3Bvc2VyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRyb3Bab25lLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcXEoZHJvcEFyZWEpLmhhc0F0dHJpYnV0ZShISURFX0JFRk9SRV9FTlRFUl9BVFRSKSAmJiBxcShkcm9wQXJlYSkuaGlkZSgpO1xuICAgICAgICAgICAgdXBsb2FkRHJvcFpvbmVzLnB1c2goZHJvcFpvbmUpO1xuICAgICAgICAgICAgcmV0dXJuIGRyb3Bab25lO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRmlsZURyYWcoZHJhZ0V2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZmlsZURyYWc7XG4gICAgICAgICAgICBxcS5lYWNoKGRyYWdFdmVudC5kYXRhVHJhbnNmZXIudHlwZXMsIGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gXCJGaWxlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVEcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGVEcmFnO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxlYXZpbmdEb2N1bWVudE91dChlKSB7XG4gICAgICAgICAgICBpZiAocXEuZmlyZWZveCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFlLnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocXEuc2FmYXJpKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS54IDwgMCB8fCBlLnkgPCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGUueCA9PT0gMCAmJiBlLnkgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dXBEcmFnRHJvcCgpIHtcbiAgICAgICAgICAgIHZhciBkcm9wWm9uZXMgPSBvcHRpb25zLmRyb3Bab25lRWxlbWVudHMsIG1heWJlSGlkZURyb3Bab25lcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHFxLmVhY2goZHJvcFpvbmVzLCBmdW5jdGlvbihpZHgsIGRyb3Bab25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxcShkcm9wWm9uZSkuaGFzQXR0cmlidXRlKEhJREVfQkVGT1JFX0VOVEVSX0FUVFIpICYmIHFxKGRyb3Bab25lKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBxcShkcm9wWm9uZSkucmVtb3ZlQ2xhc3Mob3B0aW9ucy5jbGFzc2VzLmRyb3BBY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcXEuZWFjaChkcm9wWm9uZXMsIGZ1bmN0aW9uKGlkeCwgZHJvcFpvbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXBsb2FkRHJvcFpvbmUgPSBzZXR1cERyb3B6b25lKGRyb3Bab25lKTtcbiAgICAgICAgICAgICAgICBpZiAoZHJvcFpvbmVzLmxlbmd0aCAmJiBxcS5zdXBwb3J0ZWRGZWF0dXJlcy5maWxlRHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlU3VwcG9ydC5hdHRhY2goZG9jdW1lbnQsIFwiZHJhZ2VudGVyXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXBsb2FkRHJvcFpvbmUuZHJvcERpc2FibGVkKCkgJiYgaXNGaWxlRHJhZyhlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFxLmVhY2goZHJvcFpvbmVzLCBmdW5jdGlvbihpZHgsIGRyb3Bab25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkcm9wWm9uZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHFxKGRyb3Bab25lKS5oYXNBdHRyaWJ1dGUoSElERV9CRUZPUkVfRU5URVJfQVRUUikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFxKGRyb3Bab25lKS5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXNwb3NlU3VwcG9ydC5hdHRhY2goZG9jdW1lbnQsIFwiZHJhZ2xlYXZlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVhdmluZ0RvY3VtZW50T3V0KGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heWJlSGlkZURyb3Bab25lcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlzcG9zZVN1cHBvcnQuYXR0YWNoKHFxKGRvY3VtZW50KS5jaGlsZHJlbigpWzBdLCBcIm1vdXNlZW50ZXJcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIG1heWJlSGlkZURyb3Bab25lcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXNwb3NlU3VwcG9ydC5hdHRhY2goZG9jdW1lbnQsIFwiZHJvcFwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIG1heWJlSGlkZURyb3Bab25lcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXNwb3NlU3VwcG9ydC5hdHRhY2goZG9jdW1lbnQsIEhJREVfWk9ORVNfRVZFTlRfTkFNRSwgbWF5YmVIaWRlRHJvcFpvbmVzKTtcbiAgICAgICAgfVxuICAgICAgICBzZXR1cERyYWdEcm9wKCk7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBzZXR1cEV4dHJhRHJvcHpvbmU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRyb3Bab25lRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBzZXR1cERyb3B6b25lKGVsZW1lbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZURyb3B6b25lOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGR6cyA9IG9wdGlvbnMuZHJvcFpvbmVFbGVtZW50cztcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gZHpzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkenNbaV0gPT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkenMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2VTdXBwb3J0LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBxcS5lYWNoKHVwbG9hZERyb3Bab25lcywgZnVuY3Rpb24oaWR4LCBkcm9wWm9uZSkge1xuICAgICAgICAgICAgICAgICAgICBkcm9wWm9uZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcXEuRHJhZ0FuZERyb3AuY2FsbGJhY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvY2Vzc2luZ0Ryb3BwZWRGaWxlczogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgIHByb2Nlc3NpbmdEcm9wcGVkRmlsZXNDb21wbGV0ZTogZnVuY3Rpb24oZmlsZXMsIHRhcmdldEVsKSB7fSxcbiAgICAgICAgICAgIGRyb3BFcnJvcjogZnVuY3Rpb24oY29kZSwgZXJyb3JTcGVjaWZpY3MpIHtcbiAgICAgICAgICAgICAgICBxcS5sb2coXCJEcmFnICYgZHJvcCBlcnJvciBjb2RlICdcIiArIGNvZGUgKyBcIiB3aXRoIHRoZXNlIHNwZWNpZmljczogJ1wiICsgZXJyb3JTcGVjaWZpY3MgKyBcIidcIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkcm9wTG9nOiBmdW5jdGlvbihtZXNzYWdlLCBsZXZlbCkge1xuICAgICAgICAgICAgICAgIHFxLmxvZyhtZXNzYWdlLCBsZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBxcS5VcGxvYWREcm9wWm9uZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBkaXNwb3NlU3VwcG9ydCA9IG5ldyBxcS5EaXNwb3NlU3VwcG9ydCgpLCBvcHRpb25zLCBlbGVtZW50LCBwcmV2ZW50RHJvcCwgZHJvcE91dHNpZGVEaXNhYmxlZDtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICBvbkVudGVyOiBmdW5jdGlvbihlKSB7fSxcbiAgICAgICAgICAgIG9uTGVhdmU6IGZ1bmN0aW9uKGUpIHt9LFxuICAgICAgICAgICAgb25MZWF2ZU5vdERlc2NlbmRhbnRzOiBmdW5jdGlvbihlKSB7fSxcbiAgICAgICAgICAgIG9uRHJvcDogZnVuY3Rpb24oZSkge31cbiAgICAgICAgfTtcbiAgICAgICAgcXEuZXh0ZW5kKG9wdGlvbnMsIG8pO1xuICAgICAgICBlbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuICAgICAgICBmdW5jdGlvbiBkcmFnb3ZlclNob3VsZEJlQ2FuY2VsZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcXEuc2FmYXJpKCkgfHwgcXEuZmlyZWZveCgpICYmIHFxLndpbmRvd3MoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkaXNhYmxlRHJvcE91dHNpZGUoZSkge1xuICAgICAgICAgICAgaWYgKCFkcm9wT3V0c2lkZURpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdvdmVyU2hvdWxkQmVDYW5jZWxlZCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlU3VwcG9ydC5hdHRhY2goZG9jdW1lbnQsIFwiZHJhZ292ZXJcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlU3VwcG9ydC5hdHRhY2goZG9jdW1lbnQsIFwiZHJhZ292ZXJcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRyb3BPdXRzaWRlRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzVmFsaWRGaWxlRHJhZyhlKSB7XG4gICAgICAgICAgICBpZiAoIXFxLnN1cHBvcnRlZEZlYXR1cmVzLmZpbGVEcm9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVmZmVjdFRlc3QsIGR0ID0gZS5kYXRhVHJhbnNmZXIsIGlzU2FmYXJpID0gcXEuc2FmYXJpKCk7XG4gICAgICAgICAgICBlZmZlY3RUZXN0ID0gcXEuaWUoKSAmJiBxcS5zdXBwb3J0ZWRGZWF0dXJlcy5maWxlRHJvcCA/IHRydWUgOiBkdC5lZmZlY3RBbGxvd2VkICE9PSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHJldHVybiBkdCAmJiBlZmZlY3RUZXN0ICYmIChkdC5maWxlcyB8fCAhaXNTYWZhcmkgJiYgZHQudHlwZXMuY29udGFpbnMgJiYgZHQudHlwZXMuY29udGFpbnMoXCJGaWxlc1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNPclNldERyb3BEaXNhYmxlZChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICBpZiAoaXNEaXNhYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcHJldmVudERyb3AgPSBpc0Rpc2FibGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZXZlbnREcm9wO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXJIaWRlem9uZXNFdmVudCgpIHtcbiAgICAgICAgICAgIHZhciBoaWRlWm9uZXNFdmVudDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHRyaWdnZXJVc2luZ09sZEFwaSgpIHtcbiAgICAgICAgICAgICAgICBoaWRlWm9uZXNFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgICAgICAgICAgICAgaGlkZVpvbmVzRXZlbnQuaW5pdEV2ZW50KG9wdGlvbnMuSElERV9aT05FU19FVkVOVF9OQU1FLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBoaWRlWm9uZXNFdmVudCA9IG5ldyBDdXN0b21FdmVudChvcHRpb25zLkhJREVfWk9ORVNfRVZFTlRfTkFNRSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJVc2luZ09sZEFwaSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlclVzaW5nT2xkQXBpKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGhpZGVab25lc0V2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhdHRhY2hFdmVudHMoKSB7XG4gICAgICAgICAgICBkaXNwb3NlU3VwcG9ydC5hdHRhY2goZWxlbWVudCwgXCJkcmFnb3ZlclwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRmlsZURyYWcoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZWZmZWN0ID0gcXEuaWUoKSAmJiBxcS5zdXBwb3J0ZWRGZWF0dXJlcy5maWxlRHJvcCA/IG51bGwgOiBlLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkO1xuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QgPT09IFwibW92ZVwiIHx8IGVmZmVjdCA9PT0gXCJsaW5rTW92ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBcIm1vdmVcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXCJjb3B5XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXNwb3NlU3VwcG9ydC5hdHRhY2goZWxlbWVudCwgXCJkcmFnZW50ZXJcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNPclNldERyb3BEaXNhYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEZpbGVEcmFnKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVudGVyKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlzcG9zZVN1cHBvcnQuYXR0YWNoKGVsZW1lbnQsIFwiZHJhZ2xlYXZlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRGaWxlRHJhZyhlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnMub25MZWF2ZShlKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXRlZFRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgICAgICAgICAgIGlmIChxcSh0aGlzKS5jb250YWlucyhyZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnMub25MZWF2ZU5vdERlc2NlbmRhbnRzKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXNwb3NlU3VwcG9ydC5hdHRhY2goZWxlbWVudCwgXCJkcm9wXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzT3JTZXREcm9wRGlzYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRGaWxlRHJhZyhlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkRyb3AoZSk7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJIaWRlem9uZXNFdmVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRpc2FibGVEcm9wT3V0c2lkZSgpO1xuICAgICAgICBhdHRhY2hFdmVudHMoKTtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIGRyb3BEaXNhYmxlZDogZnVuY3Rpb24oaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc09yU2V0RHJvcERpc2FibGVkKGlzRGlzYWJsZWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2VTdXBwb3J0LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBxcS51aVB1YmxpY0FwaSA9IHtcbiAgICAgICAgICAgIGFkZEluaXRpYWxGaWxlczogZnVuY3Rpb24oY2FubmVkRmlsZUxpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQucHJvdG90eXBlLmFkZEluaXRpYWxGaWxlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuYWRkQ2FjaGVUb0RvbSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsZWFyU3RvcmVkRmlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5wcm90b3R5cGUuY2xlYXJTdG9yZWRGaWxlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuY2xlYXJGaWxlcygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZEV4dHJhRHJvcHpvbmU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kbmQgJiYgdGhpcy5fZG5kLnNldHVwRXh0cmFEcm9wem9uZShlbGVtZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVFeHRyYURyb3B6b25lOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZG5kLnJlbW92ZURyb3B6b25lKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRJdGVtQnlGaWxlSWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90ZW1wbGF0aW5nLmlzSGlkZGVuRm9yZXZlcihpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRpbmcuZ2V0RmlsZUNvbnRhaW5lcihpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQucHJvdG90eXBlLnJlc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5yZXNldCgpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5idXR0b24gJiYgdGhpcy5fdGVtcGxhdGluZy5nZXRCdXR0b24oKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWZhdWx0QnV0dG9uSWQgPSB0aGlzLl9jcmVhdGVVcGxvYWRCdXR0b24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogdGhpcy5fdGVtcGxhdGluZy5nZXRCdXR0b24oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aGlzLl9vcHRpb25zLnRleHQuZmlsZUlucHV0VGl0bGVcbiAgICAgICAgICAgICAgICAgICAgfSkuZ2V0QnV0dG9uSWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RuZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kbmQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kbmQgPSB0aGlzLl9zZXR1cERyYWdBbmREcm9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3RvdGFsRmlsZXNJbkJhdGNoID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxlc0luQmF0Y2hBZGRlZFRvVWkgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldHVwQ2xpY2tBbmRFZGl0RXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldE5hbWU6IGZ1bmN0aW9uKGlkLCBuZXdOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZEZpbGVuYW1lID0gdGhpcy5fb3B0aW9ucy5mb3JtYXRGaWxlTmFtZShuZXdOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQucHJvdG90eXBlLnNldE5hbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnVwZGF0ZUZpbGVuYW1lKGlkLCBmb3JtYXR0ZWRGaWxlbmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF1c2VVcGxvYWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdXNlZCA9IHRoaXMuX3BhcmVudC5wcm90b3R5cGUucGF1c2VVcGxvYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBwYXVzZWQgJiYgdGhpcy5fdGVtcGxhdGluZy51cGxvYWRQYXVzZWQoaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXVzZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGludWVVcGxvYWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRpbnVlZCA9IHRoaXMuX3BhcmVudC5wcm90b3R5cGUuY29udGludWVVcGxvYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZWQgJiYgdGhpcy5fdGVtcGxhdGluZy51cGxvYWRDb250aW51ZWQoaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250aW51ZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SWQ6IGZ1bmN0aW9uKGZpbGVDb250YWluZXJPckNoaWxkRWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGluZy5nZXRGaWxlSWQoZmlsZUNvbnRhaW5lck9yQ2hpbGRFbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RHJvcFRhcmdldDogZnVuY3Rpb24oZmlsZUlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGUgPSB0aGlzLmdldEZpbGUoZmlsZUlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5xcURyb3BUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHFxLnVpUHJpdmF0ZUFwaSA9IHtcbiAgICAgICAgICAgIF9nZXRCdXR0b246IGZ1bmN0aW9uKGJ1dHRvbklkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX3BhcmVudC5wcm90b3R5cGUuX2dldEJ1dHRvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICghYnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25JZCA9PT0gdGhpcy5fZGVmYXVsdEJ1dHRvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b24gPSB0aGlzLl90ZW1wbGF0aW5nLmdldEJ1dHRvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBidXR0b247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JlbW92ZUZpbGVJdGVtOiBmdW5jdGlvbihmaWxlSWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnJlbW92ZUZpbGUoZmlsZUlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2V0dXBDbGlja0FuZEVkaXRFdmVudEhhbmRsZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxlQnV0dG9uc0NsaWNrSGFuZGxlciA9IHFxLkZpbGVCdXR0b25zQ2xpY2tIYW5kbGVyICYmIHRoaXMuX2JpbmRGaWxlQnV0dG9uc0NsaWNrRXZlbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb2N1c2luRXZlbnRTdXBwb3J0ZWQgPSAhcXEuZmlyZWZveCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0VkaXRGaWxlbmFtZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maWxlbmFtZUNsaWNrSGFuZGxlciA9IHRoaXMuX2JpbmRGaWxlbmFtZUNsaWNrRXZlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlsZW5hbWVJbnB1dEZvY3VzSW5IYW5kbGVyID0gdGhpcy5fYmluZEZpbGVuYW1lSW5wdXRGb2N1c0luRXZlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlsZW5hbWVJbnB1dEZvY3VzSGFuZGxlciA9IHRoaXMuX2JpbmRGaWxlbmFtZUlucHV0Rm9jdXNFdmVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2V0dXBEcmFnQW5kRHJvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBkcm9wWm9uZUVsZW1lbnRzID0gdGhpcy5fb3B0aW9ucy5kcmFnQW5kRHJvcC5leHRyYURyb3B6b25lcywgdGVtcGxhdGluZyA9IHRoaXMuX3RlbXBsYXRpbmcsIGRlZmF1bHREcm9wWm9uZSA9IHRlbXBsYXRpbmcuZ2V0RHJvcFpvbmUoKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0RHJvcFpvbmUgJiYgZHJvcFpvbmVFbGVtZW50cy5wdXNoKGRlZmF1bHREcm9wWm9uZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBxcS5EcmFnQW5kRHJvcCh7XG4gICAgICAgICAgICAgICAgICAgIGRyb3Bab25lRWxlbWVudHM6IGRyb3Bab25lRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93TXVsdGlwbGVJdGVtczogdGhpcy5fb3B0aW9ucy5tdWx0aXBsZSxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcEFjdGl2ZTogdGhpcy5fb3B0aW9ucy5jbGFzc2VzLmRyb3BBY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzaW5nRHJvcHBlZEZpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0aW5nLnNob3dEcm9wUHJvY2Vzc2luZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdEcm9wcGVkRmlsZXNDb21wbGV0ZTogZnVuY3Rpb24oZmlsZXMsIHRhcmdldEVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGluZy5oaWRlRHJvcFByb2Nlc3NpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxcS5lYWNoKGZpbGVzLCBmdW5jdGlvbihpZHgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5xcURyb3BUYXJnZXQgPSB0YXJnZXRFbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkRmlsZXMoZmlsZXMsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkcm9wRXJyb3I6IGZ1bmN0aW9uKGNvZGUsIGVycm9yRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2l0ZW1FcnJvcihjb2RlLCBlcnJvckRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BMb2c6IGZ1bmN0aW9uKG1lc3NhZ2UsIGxldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2cobWVzc2FnZSwgbGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2JpbmRGaWxlQnV0dG9uc0NsaWNrRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHFxLkZpbGVCdXR0b25zQ2xpY2tIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGluZzogdGhpcy5fdGVtcGxhdGluZyxcbiAgICAgICAgICAgICAgICAgICAgbG9nOiBmdW5jdGlvbihtZXNzYWdlLCBsdmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9nKG1lc3NhZ2UsIGx2bCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uRGVsZXRlRmlsZTogZnVuY3Rpb24oZmlsZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRlbGV0ZUZpbGUoZmlsZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25DYW5jZWw6IGZ1bmN0aW9uKGZpbGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYW5jZWwoZmlsZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25SZXRyeTogZnVuY3Rpb24oZmlsZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJldHJ5KGZpbGVJZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uUGF1c2U6IGZ1bmN0aW9uKGZpbGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXVzZVVwbG9hZChmaWxlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkNvbnRpbnVlOiBmdW5jdGlvbihmaWxlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29udGludWVVcGxvYWQoZmlsZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25HZXROYW1lOiBmdW5jdGlvbihmaWxlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldE5hbWUoZmlsZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pc0VkaXRGaWxlbmFtZUVuYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0aW5nLmlzRWRpdEZpbGVuYW1lUG9zc2libGUoKSAmJiAhdGhpcy5fb3B0aW9ucy5hdXRvVXBsb2FkICYmIHFxLkZpbGVuYW1lQ2xpY2tIYW5kbGVyICYmIHFxLkZpbGVuYW1lSW5wdXRGb2N1c0hhbmRsZXIgJiYgcXEuRmlsZW5hbWVJbnB1dEZvY3VzSGFuZGxlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZmlsZW5hbWVFZGl0SGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCB0ZW1wbGF0aW5nID0gdGhpcy5fdGVtcGxhdGluZztcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0aW5nOiB0ZW1wbGF0aW5nLFxuICAgICAgICAgICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKG1lc3NhZ2UsIGx2bCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2cobWVzc2FnZSwgbHZsKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25HZXRVcGxvYWRTdGF0dXM6IGZ1bmN0aW9uKGZpbGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0VXBsb2Fkcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGZpbGVJZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkdldE5hbWU6IGZ1bmN0aW9uKGZpbGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0TmFtZShmaWxlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvblNldE5hbWU6IGZ1bmN0aW9uKGlkLCBuZXdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNldE5hbWUoaWQsIG5ld05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkVkaXRpbmdTdGF0dXNDaGFuZ2U6IGZ1bmN0aW9uKGlkLCBpc0VkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxcUlucHV0ID0gcXEodGVtcGxhdGluZy5nZXRFZGl0SW5wdXQoaWQpKSwgcXFGaWxlQ29udGFpbmVyID0gcXEodGVtcGxhdGluZy5nZXRGaWxlQ29udGFpbmVyKGlkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFZGl0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXFJbnB1dC5hZGRDbGFzcyhcInFxLWVkaXRpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGluZy5oaWRlRmlsZW5hbWUoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRpbmcuaGlkZUVkaXRJY29uKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXFJbnB1dC5yZW1vdmVDbGFzcyhcInFxLWVkaXRpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGluZy5zaG93RmlsZW5hbWUoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRpbmcuc2hvd0VkaXRJY29uKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHFxRmlsZUNvbnRhaW5lci5hZGRDbGFzcyhcInFxLXRlbXBcIikucmVtb3ZlQ2xhc3MoXCJxcS10ZW1wXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25VcGxvYWRTdGF0dXNDaGFuZ2U6IGZ1bmN0aW9uKGlkLCBvbGRTdGF0dXMsIG5ld1N0YXR1cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5wcm90b3R5cGUuX29uVXBsb2FkU3RhdHVzQ2hhbmdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzRWRpdEZpbGVuYW1lRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90ZW1wbGF0aW5nLmdldEZpbGVDb250YWluZXIoaWQpICYmIG5ld1N0YXR1cyAhPT0gcXEuc3RhdHVzLlNVQk1JVFRFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5tYXJrRmlsZW5hbWVFZGl0YWJsZShpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLmhpZGVFZGl0SWNvbihpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9sZFN0YXR1cyA9PT0gcXEuc3RhdHVzLlVQTE9BRF9SRVRSWUlORyAmJiBuZXdTdGF0dXMgPT09IHFxLnN0YXR1cy5VUExPQURJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5oaWRlUmV0cnkoaWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnNldFN0YXR1c1RleHQoaWQpO1xuICAgICAgICAgICAgICAgICAgICBxcSh0aGlzLl90ZW1wbGF0aW5nLmdldEZpbGVDb250YWluZXIoaWQpKS5yZW1vdmVDbGFzcyh0aGlzLl9jbGFzc2VzLnJldHJ5aW5nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5ld1N0YXR1cyA9PT0gcXEuc3RhdHVzLlVQTE9BRF9GQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5oaWRlUGF1c2UoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYmluZEZpbGVuYW1lSW5wdXRGb2N1c0luRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzcGVjID0gcXEuZXh0ZW5kKHt9LCB0aGlzLl9maWxlbmFtZUVkaXRIYW5kbGVyKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcXEuRmlsZW5hbWVJbnB1dEZvY3VzSW5IYW5kbGVyKHNwZWMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9iaW5kRmlsZW5hbWVJbnB1dEZvY3VzRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzcGVjID0gcXEuZXh0ZW5kKHt9LCB0aGlzLl9maWxlbmFtZUVkaXRIYW5kbGVyKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcXEuRmlsZW5hbWVJbnB1dEZvY3VzSGFuZGxlcihzcGVjKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYmluZEZpbGVuYW1lQ2xpY2tFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwZWMgPSBxcS5leHRlbmQoe30sIHRoaXMuX2ZpbGVuYW1lRWRpdEhhbmRsZXIoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBxcS5GaWxlbmFtZUNsaWNrSGFuZGxlcihzcGVjKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc3RvcmVGb3JMYXRlcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQucHJvdG90eXBlLl9zdG9yZUZvckxhdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5oaWRlU3Bpbm5lcihpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uQWxsQ29tcGxldGU6IGZ1bmN0aW9uKHN1Y2Nlc3NmdWwsIGZhaWxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5wcm90b3R5cGUuX29uQWxsQ29tcGxldGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnJlc2V0VG90YWxQcm9ncmVzcygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblN1Ym1pdDogZnVuY3Rpb24oaWQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZ2V0RmlsZShpZCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGUgJiYgZmlsZS5xcVBhdGggJiYgdGhpcy5fb3B0aW9ucy5kcmFnQW5kRHJvcC5yZXBvcnREaXJlY3RvcnlQYXRocykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXNTdG9yZS5hZGRSZWFkT25seShpZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXFwYXRoOiBmaWxlLnFxUGF0aFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnByb3RvdHlwZS5fb25TdWJtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb0xpc3QoaWQsIG5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblN1Ym1pdHRlZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNFZGl0RmlsZW5hbWVFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5tYXJrRmlsZW5hbWVFZGl0YWJsZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuc2hvd0VkaXRJY29uKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9mb2N1c2luRXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGVuYW1lSW5wdXRGb2N1c0hhbmRsZXIuYWRkSGFuZGxlcih0aGlzLl90ZW1wbGF0aW5nLmdldEVkaXRJbnB1dChpZCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblByb2dyZXNzOiBmdW5jdGlvbihpZCwgbmFtZSwgbG9hZGVkLCB0b3RhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5wcm90b3R5cGUuX29uUHJvZ3Jlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnVwZGF0ZVByb2dyZXNzKGlkLCBsb2FkZWQsIHRvdGFsKTtcbiAgICAgICAgICAgICAgICBpZiAodG90YWwgPT09IDAgfHwgTWF0aC5yb3VuZChsb2FkZWQgLyB0b3RhbCAqIDEwMCkgPT09IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLmhpZGVDYW5jZWwoaWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLmhpZGVQYXVzZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuaGlkZVByb2dyZXNzKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5zZXRTdGF0dXNUZXh0KGlkLCB0aGlzLl9vcHRpb25zLnRleHQud2FpdGluZ0ZvclJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheUZpbGVTaXplKGlkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5RmlsZVNpemUoaWQsIGxvYWRlZCwgdG90YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25Ub3RhbFByb2dyZXNzOiBmdW5jdGlvbihsb2FkZWQsIHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnByb3RvdHlwZS5fb25Ub3RhbFByb2dyZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy51cGRhdGVUb3RhbFByb2dyZXNzKGxvYWRlZCwgdG90YWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkNvbXBsZXRlOiBmdW5jdGlvbihpZCwgbmFtZSwgcmVzdWx0LCB4aHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50UmV0VmFsID0gdGhpcy5fcGFyZW50LnByb3RvdHlwZS5fb25Db21wbGV0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0ZW1wbGF0aW5nID0gdGhpcy5fdGVtcGxhdGluZywgZmlsZUNvbnRhaW5lciA9IHRlbXBsYXRpbmcuZ2V0RmlsZUNvbnRhaW5lcihpZCksIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlVXBsb2FkKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGVDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0aW5nLnNldFN0YXR1c1RleHQoaWQpO1xuICAgICAgICAgICAgICAgICAgICBxcShmaWxlQ29udGFpbmVyKS5yZW1vdmVDbGFzcyhzZWxmLl9jbGFzc2VzLnJldHJ5aW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGluZy5oaWRlUHJvZ3Jlc3MoaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5nZXRVcGxvYWRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgICAgICB9KS5zdGF0dXMgIT09IHFxLnN0YXR1cy5VUExPQURfRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0aW5nLmhpZGVDYW5jZWwoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRpbmcuaGlkZVNwaW5uZXIoaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX21hcmtGaWxlQXNTdWNjZXNzZnVsKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFxKGZpbGVDb250YWluZXIpLmFkZENsYXNzKHNlbGYuX2NsYXNzZXMuZmFpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0aW5nLnNob3dDYW5jZWwoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRpbmcuaXNSZXRyeVBvc3NpYmxlKCkgJiYgIXNlbGYuX3ByZXZlbnRSZXRyaWVzW2lkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFxKGZpbGVDb250YWluZXIpLmFkZENsYXNzKHNlbGYuX2NsYXNzZXMucmV0cnlhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0aW5nLnNob3dSZXRyeShpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9jb250cm9sRmFpbHVyZVRleHREaXNwbGF5KGlkLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRSZXRWYWwgaW5zdGFuY2VvZiBxcS5Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFJldFZhbC5kb25lKGZ1bmN0aW9uKG5ld1Jlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVVcGxvYWQobmV3UmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVVcGxvYWQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudFJldFZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWFya0ZpbGVBc1N1Y2Nlc3NmdWw6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRpbmcgPSB0aGlzLl90ZW1wbGF0aW5nO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0RlbGV0ZVBvc3NpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGluZy5zaG93RGVsZXRlQnV0dG9uKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXEodGVtcGxhdGluZy5nZXRGaWxlQ29udGFpbmVyKGlkKSkuYWRkQ2xhc3ModGhpcy5fY2xhc3Nlcy5zdWNjZXNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXliZVVwZGF0ZVRodW1ibmFpbChpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uVXBsb2FkUHJlcDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQucHJvdG90eXBlLl9vblVwbG9hZFByZXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnNob3dTcGlubmVyKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25VcGxvYWQ6IGZ1bmN0aW9uKGlkLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFJldFZhbCA9IHRoaXMuX3BhcmVudC5wcm90b3R5cGUuX29uVXBsb2FkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5zaG93U3Bpbm5lcihpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudFJldFZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25VcGxvYWRDaHVuazogZnVuY3Rpb24oaWQsIGNodW5rRGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5wcm90b3R5cGUuX29uVXBsb2FkQ2h1bmsuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmtEYXRhLnBhcnRJbmRleCA+IDAgJiYgdGhpcy5faGFuZGxlci5pc1Jlc3VtYWJsZShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5hbGxvd1BhdXNlKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uQ2FuY2VsOiBmdW5jdGlvbihpZCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5wcm90b3R5cGUuX29uQ2FuY2VsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlRmlsZUl0ZW0oaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9nZXROb3RGaW5pc2hlZCgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcucmVzZXRUb3RhbFByb2dyZXNzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkJlZm9yZUF1dG9SZXRyeTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0cnlOdW1Gb3JEaXNwbGF5LCBtYXhBdXRvLCByZXRyeU5vdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnByb3RvdHlwZS5fb25CZWZvcmVBdXRvUmV0cnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG93Q2FuY2VsTGluayhpZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMucmV0cnkuc2hvd0F1dG9SZXRyeU5vdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlOdW1Gb3JEaXNwbGF5ID0gdGhpcy5fYXV0b1JldHJpZXNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBtYXhBdXRvID0gdGhpcy5fb3B0aW9ucy5yZXRyeS5tYXhBdXRvQXR0ZW1wdHM7XG4gICAgICAgICAgICAgICAgICAgIHJldHJ5Tm90ZSA9IHRoaXMuX29wdGlvbnMucmV0cnkuYXV0b1JldHJ5Tm90ZS5yZXBsYWNlKC9cXHtyZXRyeU51bVxcfS9nLCByZXRyeU51bUZvckRpc3BsYXkpO1xuICAgICAgICAgICAgICAgICAgICByZXRyeU5vdGUgPSByZXRyeU5vdGUucmVwbGFjZSgvXFx7bWF4QXV0b1xcfS9nLCBtYXhBdXRvKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5zZXRTdGF0dXNUZXh0KGlkLCByZXRyeU5vdGUpO1xuICAgICAgICAgICAgICAgICAgICBxcSh0aGlzLl90ZW1wbGF0aW5nLmdldEZpbGVDb250YWluZXIoaWQpKS5hZGRDbGFzcyh0aGlzLl9jbGFzc2VzLnJldHJ5aW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uQmVmb3JlTWFudWFsUmV0cnk6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudC5wcm90b3R5cGUuX29uQmVmb3JlTWFudWFsUmV0cnkuYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnJlc2V0UHJvZ3Jlc3MoaWQpO1xuICAgICAgICAgICAgICAgICAgICBxcSh0aGlzLl90ZW1wbGF0aW5nLmdldEZpbGVDb250YWluZXIoaWQpKS5yZW1vdmVDbGFzcyh0aGlzLl9jbGFzc2VzLmZhaWwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnNldFN0YXR1c1RleHQoaWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnNob3dTcGlubmVyKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvd0NhbmNlbExpbmsoaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxcSh0aGlzLl90ZW1wbGF0aW5nLmdldEZpbGVDb250YWluZXIoaWQpKS5hZGRDbGFzcyh0aGlzLl9jbGFzc2VzLnJldHJ5YWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuc2hvd1JldHJ5KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25TdWJtaXREZWxldGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9uU3VjY2Vzc0NhbGxiYWNrID0gcXEuYmluZCh0aGlzLl9vblN1Ym1pdERlbGV0ZVN1Y2Nlc3MsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5wcm90b3R5cGUuX29uU3VibWl0RGVsZXRlLmNhbGwodGhpcywgaWQsIG9uU3VjY2Vzc0NhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25TdWJtaXREZWxldGVTdWNjZXNzOiBmdW5jdGlvbihpZCwgdXVpZCwgYWRkaXRpb25hbE1hbmRhdGVkUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZGVsZXRlRmlsZS5mb3JjZUNvbmZpcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvd0RlbGV0ZUNvbmZpcm0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZW5kRGVsZXRlUmVxdWVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25EZWxldGVDb21wbGV0ZTogZnVuY3Rpb24oaWQsIHhociwgaXNFcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5wcm90b3R5cGUuX29uRGVsZXRlQ29tcGxldGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLmhpZGVTcGlubmVyKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnNldFN0YXR1c1RleHQoaWQsIHRoaXMuX29wdGlvbnMuZGVsZXRlRmlsZS5kZWxldGluZ0ZhaWxlZFRleHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnNob3dEZWxldGVCdXR0b24oaWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUZpbGVJdGVtKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NlbmREZWxldGVSZXF1ZXN0OiBmdW5jdGlvbihpZCwgdXVpZCwgYWRkaXRpb25hbE1hbmRhdGVkUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5oaWRlRGVsZXRlQnV0dG9uKGlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnNob3dTcGlubmVyKGlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnNldFN0YXR1c1RleHQoaWQsIHRoaXMuX29wdGlvbnMuZGVsZXRlRmlsZS5kZWxldGluZ1N0YXR1c1RleHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlbGV0ZUhhbmRsZXIuc2VuZERlbGV0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaG93RGVsZXRlQ29uZmlybTogZnVuY3Rpb24oaWQsIHV1aWQsIG1hbmRhdGVkUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gdGhpcy5nZXROYW1lKGlkKSwgY29uZmlybU1lc3NhZ2UgPSB0aGlzLl9vcHRpb25zLmRlbGV0ZUZpbGUuY29uZmlybU1lc3NhZ2UucmVwbGFjZSgvXFx7ZmlsZW5hbWVcXH0vZywgZmlsZU5hbWUpLCB1dWlkID0gdGhpcy5nZXRVdWlkKGlkKSwgZGVsZXRlUmVxdWVzdEFyZ3MgPSBhcmd1bWVudHMsIHNlbGYgPSB0aGlzLCByZXRWYWw7XG4gICAgICAgICAgICAgICAgcmV0VmFsID0gdGhpcy5fb3B0aW9ucy5zaG93Q29uZmlybShjb25maXJtTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKHFxLmlzR2VuZXJpY1Byb21pc2UocmV0VmFsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXRWYWwudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3NlbmREZWxldGVSZXF1ZXN0LmFwcGx5KHNlbGYsIGRlbGV0ZVJlcXVlc3RBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXRWYWwgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3NlbmREZWxldGVSZXF1ZXN0LmFwcGx5KHNlbGYsIGRlbGV0ZVJlcXVlc3RBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2FkZFRvTGlzdDogZnVuY3Rpb24oaWQsIG5hbWUsIGNhbm5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmVwZW5kRGF0YSwgcHJlcGVuZEluZGV4ID0gMCwgZG9udERpc3BsYXkgPSB0aGlzLl9oYW5kbGVyLmlzUHJveGllZChpZCkgJiYgdGhpcy5fb3B0aW9ucy5zY2FsaW5nLmhpZGVTY2FsZWQsIHJlY29yZDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5kaXNwbGF5LnByZXBlbmRGaWxlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG90YWxGaWxlc0luQmF0Y2ggPiAxICYmIHRoaXMuX2ZpbGVzSW5CYXRjaEFkZGVkVG9VaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXBlbmRJbmRleCA9IHRoaXMuX2ZpbGVzSW5CYXRjaEFkZGVkVG9VaSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJlcGVuZERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogcHJlcGVuZEluZGV4XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY2FubmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmRpc2FibGVDYW5jZWxGb3JGb3JtVXBsb2FkcyAmJiAhcXEuc3VwcG9ydGVkRmVhdHVyZXMuYWpheFVwbG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5kaXNhYmxlQ2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSB0aGlzLmdldFVwbG9hZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVkUHJveHlHcm91cCA9IHRoaXMuX2hhbmRsZWRQcm94eUdyb3VwIHx8IHJlY29yZC5wcm94eUdyb3VwSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLnByb3h5R3JvdXBJZCAhPT0gdGhpcy5faGFuZGxlZFByb3h5R3JvdXAgfHwgIXJlY29yZC5wcm94eUdyb3VwSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyLmNhbmNlbEFsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZWRQcm94eUdyb3VwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FubmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuYWRkRmlsZVRvQ2FjaGUoaWQsIHRoaXMuX29wdGlvbnMuZm9ybWF0RmlsZU5hbWUobmFtZSksIHByZXBlbmREYXRhLCBkb250RGlzcGxheSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcudXBkYXRlVGh1bWJuYWlsKGlkLCB0aGlzLl90aHVtYm5haWxVcmxzW2lkXSwgdHJ1ZSwgdGhpcy5fb3B0aW9ucy50aHVtYm5haWxzLmN1c3RvbVJlc2l6ZXIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuYWRkRmlsZShpZCwgdGhpcy5fb3B0aW9ucy5mb3JtYXRGaWxlTmFtZShuYW1lKSwgcHJlcGVuZERhdGEsIGRvbnREaXNwbGF5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5nZW5lcmF0ZVByZXZpZXcoaWQsIHRoaXMuZ2V0RmlsZShpZCksIHRoaXMuX29wdGlvbnMudGh1bWJuYWlscy5jdXN0b21SZXNpemVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsZXNJbkJhdGNoQWRkZWRUb1VpICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGNhbm5lZCB8fCB0aGlzLl9vcHRpb25zLmRpc3BsYXkuZmlsZVNpemVPblN1Ym1pdCAmJiBxcS5zdXBwb3J0ZWRGZWF0dXJlcy5hamF4VXBsb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlGaWxlU2l6ZShpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jbGVhckxpc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuY2xlYXJGaWxlcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJTdG9yZWRGaWxlcygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9kaXNwbGF5RmlsZVNpemU6IGZ1bmN0aW9uKGlkLCBsb2FkZWRTaXplLCB0b3RhbFNpemUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0U2l6ZShpZCksIHNpemVGb3JEaXNwbGF5ID0gdGhpcy5fZm9ybWF0U2l6ZShzaXplKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2FkZWRTaXplICE9PSB1bmRlZmluZWQgJiYgdG90YWxTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVGb3JEaXNwbGF5ID0gdGhpcy5fZm9ybWF0UHJvZ3Jlc3MobG9hZGVkU2l6ZSwgdG90YWxTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnVwZGF0ZVNpemUoaWQsIHNpemVGb3JEaXNwbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2Zvcm1hdFByb2dyZXNzOiBmdW5jdGlvbih1cGxvYWRlZFNpemUsIHRvdGFsU2l6ZSkge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5fb3B0aW9ucy50ZXh0LmZvcm1hdFByb2dyZXNzO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHIobmFtZSwgcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShuYW1lLCByZXBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHIoXCJ7cGVyY2VudH1cIiwgTWF0aC5yb3VuZCh1cGxvYWRlZFNpemUgLyB0b3RhbFNpemUgKiAxMDApKTtcbiAgICAgICAgICAgICAgICByKFwie3RvdGFsX3NpemV9XCIsIHRoaXMuX2Zvcm1hdFNpemUodG90YWxTaXplKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NvbnRyb2xGYWlsdXJlVGV4dERpc3BsYXk6IGZ1bmN0aW9uKGlkLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHZhciBtb2RlLCByZXNwb25zZVByb3BlcnR5LCBmYWlsdXJlUmVhc29uO1xuICAgICAgICAgICAgICAgIG1vZGUgPSB0aGlzLl9vcHRpb25zLmZhaWxlZFVwbG9hZFRleHREaXNwbGF5Lm1vZGU7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9wZXJ0eSA9IHRoaXMuX29wdGlvbnMuZmFpbGVkVXBsb2FkVGV4dERpc3BsYXkucmVzcG9uc2VQcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gXCJjdXN0b21cIikge1xuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlUmVhc29uID0gcmVzcG9uc2VbcmVzcG9uc2VQcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmFpbHVyZVJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZVJlYXNvbiA9IHRoaXMuX29wdGlvbnMudGV4dC5mYWlsVXBsb2FkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuc2V0U3RhdHVzVGV4dChpZCwgZmFpbHVyZVJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmZhaWxlZFVwbG9hZFRleHREaXNwbGF5LmVuYWJsZVRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dUb29sdGlwKGlkLCBmYWlsdXJlUmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5zZXRTdGF0dXNUZXh0KGlkLCB0aGlzLl9vcHRpb25zLnRleHQuZmFpbFVwbG9hZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlICE9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcImZhaWxlZFVwbG9hZFRleHREaXNwbGF5Lm1vZGUgdmFsdWUgb2YgJ1wiICsgbW9kZSArIFwiJyBpcyBub3QgdmFsaWRcIiwgXCJ3YXJuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2hvd1Rvb2x0aXA6IGZ1bmN0aW9uKGlkLCB0ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5nZXRGaWxlQ29udGFpbmVyKGlkKS50aXRsZSA9IHRleHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3Nob3dDYW5jZWxMaW5rOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5kaXNhYmxlQ2FuY2VsRm9yRm9ybVVwbG9hZHMgfHwgcXEuc3VwcG9ydGVkRmVhdHVyZXMuYWpheFVwbG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnNob3dDYW5jZWwoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaXRlbUVycm9yOiBmdW5jdGlvbihjb2RlLCBuYW1lLCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLl9wYXJlbnQucHJvdG90eXBlLl9pdGVtRXJyb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLnNob3dNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9iYXRjaEVycm9yOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnByb3RvdHlwZS5fYmF0Y2hFcnJvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuc2hvd01lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NldHVwUGFzdGVQcm9tcHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5vblBhc3RlUmVjZWl2ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBzZWxmLl9vcHRpb25zLnBhc3RlLm5hbWVQcm9tcHRNZXNzYWdlLCBkZWZhdWx0VmFsID0gc2VsZi5fb3B0aW9ucy5wYXN0ZS5kZWZhdWx0TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX29wdGlvbnMuc2hvd1Byb21wdChtZXNzYWdlLCBkZWZhdWx0VmFsKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9maWxlT3JCbG9iUmVqZWN0ZWQ6IGZ1bmN0aW9uKGlkLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG90YWxGaWxlc0luQmF0Y2ggLT0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQucHJvdG90eXBlLl9maWxlT3JCbG9iUmVqZWN0ZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcHJlcGFyZUl0ZW1zRm9yVXBsb2FkOiBmdW5jdGlvbihpdGVtcywgcGFyYW1zLCBlbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvdGFsRmlsZXNJbkJhdGNoID0gaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGVzSW5CYXRjaEFkZGVkVG9VaSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnByb3RvdHlwZS5fcHJlcGFyZUl0ZW1zRm9yVXBsb2FkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX21heWJlVXBkYXRlVGh1bWJuYWlsOiBmdW5jdGlvbihmaWxlSWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGh1bWJuYWlsVXJsID0gdGhpcy5fdGh1bWJuYWlsVXJsc1tmaWxlSWRdLCBmaWxlU3RhdHVzID0gdGhpcy5nZXRVcGxvYWRzKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGZpbGVJZFxuICAgICAgICAgICAgICAgIH0pLnN0YXR1cztcbiAgICAgICAgICAgICAgICBpZiAoZmlsZVN0YXR1cyAhPT0gcXEuc3RhdHVzLkRFTEVURUQgJiYgKHRodW1ibmFpbFVybCB8fCB0aGlzLl9vcHRpb25zLnRodW1ibmFpbHMucGxhY2Vob2xkZXJzLndhaXRVbnRpbFJlc3BvbnNlIHx8ICFxcS5zdXBwb3J0ZWRGZWF0dXJlcy5pbWFnZVByZXZpZXdzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnVwZGF0ZVRodW1ibmFpbChmaWxlSWQsIHRodW1ibmFpbFVybCwgdGhpcy5fb3B0aW9ucy50aHVtYm5haWxzLmN1c3RvbVJlc2l6ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYWRkQ2FubmVkRmlsZTogZnVuY3Rpb24oc2Vzc2lvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLl9wYXJlbnQucHJvdG90eXBlLl9hZGRDYW5uZWRGaWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVG9MaXN0KGlkLCB0aGlzLmdldE5hbWUoaWQpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLmhpZGVTcGlubmVyKGlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLmhpZGVDYW5jZWwoaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtGaWxlQXNTdWNjZXNzZnVsKGlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NldFNpemU6IGZ1bmN0aW9uKGlkLCBuZXdTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnByb3RvdHlwZS5fc2V0U2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcudXBkYXRlU2l6ZShpZCwgdGhpcy5fZm9ybWF0U2l6ZShuZXdTaXplKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3Nlc3Npb25SZXF1ZXN0Q29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuYWRkQ2FjaGVUb0RvbSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5wcm90b3R5cGUuX3Nlc3Npb25SZXF1ZXN0Q29tcGxldGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KSgpO1xuICAgIHFxLkZpbmVVcGxvYWRlciA9IGZ1bmN0aW9uKG8sIG5hbWVzcGFjZSkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBuYW1lc3BhY2UgPyBxcVtuYW1lc3BhY2VdLkZpbmVVcGxvYWRlckJhc2ljIDogcXEuRmluZVVwbG9hZGVyQmFzaWM7XG4gICAgICAgIHRoaXMuX3BhcmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBxcS5leHRlbmQodGhpcy5fb3B0aW9ucywge1xuICAgICAgICAgICAgZWxlbWVudDogbnVsbCxcbiAgICAgICAgICAgIGJ1dHRvbjogbnVsbCxcbiAgICAgICAgICAgIGxpc3RFbGVtZW50OiBudWxsLFxuICAgICAgICAgICAgZHJhZ0FuZERyb3A6IHtcbiAgICAgICAgICAgICAgICBleHRyYURyb3B6b25lczogW10sXG4gICAgICAgICAgICAgICAgcmVwb3J0RGlyZWN0b3J5UGF0aHM6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICAgIGZvcm1hdFByb2dyZXNzOiBcIntwZXJjZW50fSUgb2Yge3RvdGFsX3NpemV9XCIsXG4gICAgICAgICAgICAgICAgZmFpbFVwbG9hZDogXCJVcGxvYWQgZmFpbGVkXCIsXG4gICAgICAgICAgICAgICAgd2FpdGluZ0ZvclJlc3BvbnNlOiBcIlByb2Nlc3NpbmcuLi5cIixcbiAgICAgICAgICAgICAgICBwYXVzZWQ6IFwiUGF1c2VkXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJxcS10ZW1wbGF0ZVwiLFxuICAgICAgICAgICAgY2xhc3Nlczoge1xuICAgICAgICAgICAgICAgIHJldHJ5aW5nOiBcInFxLXVwbG9hZC1yZXRyeWluZ1wiLFxuICAgICAgICAgICAgICAgIHJldHJ5YWJsZTogXCJxcS11cGxvYWQtcmV0cnlhYmxlXCIsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogXCJxcS11cGxvYWQtc3VjY2Vzc1wiLFxuICAgICAgICAgICAgICAgIGZhaWw6IFwicXEtdXBsb2FkLWZhaWxcIixcbiAgICAgICAgICAgICAgICBlZGl0YWJsZTogXCJxcS1lZGl0YWJsZVwiLFxuICAgICAgICAgICAgICAgIGhpZGU6IFwicXEtaGlkZVwiLFxuICAgICAgICAgICAgICAgIGRyb3BBY3RpdmU6IFwicXEtdXBsb2FkLWRyb3AtYXJlYS1hY3RpdmVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZhaWxlZFVwbG9hZFRleHREaXNwbGF5OiB7XG4gICAgICAgICAgICAgICAgbW9kZTogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9wZXJ0eTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIGVuYWJsZVRvb2x0aXA6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXNzYWdlczoge1xuICAgICAgICAgICAgICAgIHRvb01hbnlGaWxlc0Vycm9yOiBcIllvdSBtYXkgb25seSBkcm9wIG9uZSBmaWxlXCIsXG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWRCcm93c2VyOiBcIlVucmVjb3ZlcmFibGUgZXJyb3IgLSB0aGlzIGJyb3dzZXIgZG9lcyBub3QgcGVybWl0IGZpbGUgdXBsb2FkaW5nIG9mIGFueSBraW5kLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmV0cnk6IHtcbiAgICAgICAgICAgICAgICBzaG93QXV0b1JldHJ5Tm90ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhdXRvUmV0cnlOb3RlOiBcIlJldHJ5aW5nIHtyZXRyeU51bX0ve21heEF1dG99Li4uXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVGaWxlOiB7XG4gICAgICAgICAgICAgICAgZm9yY2VDb25maXJtOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maXJtTWVzc2FnZTogXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHtmaWxlbmFtZX0/XCIsXG4gICAgICAgICAgICAgICAgZGVsZXRpbmdTdGF0dXNUZXh0OiBcIkRlbGV0aW5nLi4uXCIsXG4gICAgICAgICAgICAgICAgZGVsZXRpbmdGYWlsZWRUZXh0OiBcIkRlbGV0ZSBmYWlsZWRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgICAgICAgICBmaWxlU2l6ZU9uU3VibWl0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcmVwZW5kRmlsZXM6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFzdGU6IHtcbiAgICAgICAgICAgICAgICBwcm9tcHRGb3JOYW1lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBuYW1lUHJvbXB0TWVzc2FnZTogXCJQbGVhc2UgbmFtZSB0aGlzIGltYWdlXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aHVtYm5haWxzOiB7XG4gICAgICAgICAgICAgICAgY3VzdG9tUmVzaXplcjogbnVsbCxcbiAgICAgICAgICAgICAgICBtYXhDb3VudDogMCxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgd2FpdFVudGlsUmVzcG9uc2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBub3RBdmFpbGFibGVQYXRoOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB3YWl0aW5nUGF0aDogbnVsbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGltZUJldHdlZW5UaHVtYnM6IDc1MFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjYWxpbmc6IHtcbiAgICAgICAgICAgICAgICBoaWRlU2NhbGVkOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNob3dNZXNzYWdlOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3RlbXBsYXRpbmcuaGFzRGlhbG9nKFwiYWxlcnRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3RlbXBsYXRpbmcuc2hvd0RpYWxvZyhcImFsZXJ0XCIsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWxlcnQobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG93Q29uZmlybTogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl90ZW1wbGF0aW5nLmhhc0RpYWxvZyhcImNvbmZpcm1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3RlbXBsYXRpbmcuc2hvd0RpYWxvZyhcImNvbmZpcm1cIiwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG93UHJvbXB0OiBmdW5jdGlvbihtZXNzYWdlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fdGVtcGxhdGluZy5oYXNEaWFsb2coXCJwcm9tcHRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3RlbXBsYXRpbmcuc2hvd0RpYWxvZyhcInByb21wdFwiLCBtZXNzYWdlLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cucHJvbXB0KG1lc3NhZ2UsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMuX29wdGlvbnMsIG8sIHRydWUpO1xuICAgICAgICB0aGlzLl90ZW1wbGF0aW5nID0gbmV3IHFxLlRlbXBsYXRpbmcoe1xuICAgICAgICAgICAgbG9nOiBxcS5iaW5kKHRoaXMubG9nLCB0aGlzKSxcbiAgICAgICAgICAgIHRlbXBsYXRlSWRPckVsOiB0aGlzLl9vcHRpb25zLnRlbXBsYXRlLFxuICAgICAgICAgICAgY29udGFpbmVyRWw6IHRoaXMuX29wdGlvbnMuZWxlbWVudCxcbiAgICAgICAgICAgIGZpbGVDb250YWluZXJFbDogdGhpcy5fb3B0aW9ucy5saXN0RWxlbWVudCxcbiAgICAgICAgICAgIGJ1dHRvbjogdGhpcy5fb3B0aW9ucy5idXR0b24sXG4gICAgICAgICAgICBpbWFnZUdlbmVyYXRvcjogdGhpcy5faW1hZ2VHZW5lcmF0b3IsXG4gICAgICAgICAgICBjbGFzc2VzOiB7XG4gICAgICAgICAgICAgICAgaGlkZTogdGhpcy5fb3B0aW9ucy5jbGFzc2VzLmhpZGUsXG4gICAgICAgICAgICAgICAgZWRpdGFibGU6IHRoaXMuX29wdGlvbnMuY2xhc3Nlcy5lZGl0YWJsZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbWl0czoge1xuICAgICAgICAgICAgICAgIG1heFRodW1iczogdGhpcy5fb3B0aW9ucy50aHVtYm5haWxzLm1heENvdW50LFxuICAgICAgICAgICAgICAgIHRpbWVCZXR3ZWVuVGh1bWJzOiB0aGlzLl9vcHRpb25zLnRodW1ibmFpbHMudGltZUJldHdlZW5UaHVtYnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwbGFjZWhvbGRlcnM6IHtcbiAgICAgICAgICAgICAgICB3YWl0VW50aWxVcGRhdGU6IHRoaXMuX29wdGlvbnMudGh1bWJuYWlscy5wbGFjZWhvbGRlcnMud2FpdFVudGlsUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsTm90QXZhaWxhYmxlOiB0aGlzLl9vcHRpb25zLnRodW1ibmFpbHMucGxhY2Vob2xkZXJzLm5vdEF2YWlsYWJsZVBhdGgsXG4gICAgICAgICAgICAgICAgd2FpdGluZ0ZvclRodW1ibmFpbDogdGhpcy5fb3B0aW9ucy50aHVtYm5haWxzLnBsYWNlaG9sZGVycy53YWl0aW5nUGF0aFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHQ6IHRoaXMuX29wdGlvbnMudGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMud29ya2Fyb3VuZHMuaW9zOFNhZmFyaVVwbG9hZHMgJiYgcXEuaW9zODAwKCkgJiYgcXEuaW9zU2FmYXJpKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcucmVuZGVyRmFpbHVyZSh0aGlzLl9vcHRpb25zLm1lc3NhZ2VzLnVuc3VwcG9ydGVkQnJvd3NlcklvczhTYWZhcmkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFxcS5zdXBwb3J0ZWRGZWF0dXJlcy51cGxvYWRpbmcgfHwgdGhpcy5fb3B0aW9ucy5jb3JzLmV4cGVjdGVkICYmICFxcS5zdXBwb3J0ZWRGZWF0dXJlcy51cGxvYWRDb3JzKSB7XG4gICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnJlbmRlckZhaWx1cmUodGhpcy5fb3B0aW9ucy5tZXNzYWdlcy51bnN1cHBvcnRlZEJyb3dzZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fd3JhcENhbGxiYWNrcygpO1xuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5yZW5kZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9vcHRpb25zLmNsYXNzZXM7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMuYnV0dG9uICYmIHRoaXMuX3RlbXBsYXRpbmcuZ2V0QnV0dG9uKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWZhdWx0QnV0dG9uSWQgPSB0aGlzLl9jcmVhdGVVcGxvYWRCdXR0b24oe1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB0aGlzLl90ZW1wbGF0aW5nLmdldEJ1dHRvbigpLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGhpcy5fb3B0aW9ucy50ZXh0LmZpbGVJbnB1dFRpdGxlXG4gICAgICAgICAgICAgICAgfSkuZ2V0QnV0dG9uSWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldHVwQ2xpY2tBbmRFZGl0RXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgICAgaWYgKHFxLkRyYWdBbmREcm9wICYmIHFxLnN1cHBvcnRlZEZlYXR1cmVzLmZpbGVEcm9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG5kID0gdGhpcy5fc2V0dXBEcmFnQW5kRHJvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMucGFzdGUudGFyZ2V0RWxlbWVudCAmJiB0aGlzLl9vcHRpb25zLnBhc3RlLnByb21wdEZvck5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocXEuUGFzdGVTdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldHVwUGFzdGVQcm9tcHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcIlBhc3RlIHN1cHBvcnQgbW9kdWxlIG5vdCBmb3VuZC5cIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90b3RhbEZpbGVzSW5CYXRjaCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9maWxlc0luQmF0Y2hBZGRlZFRvVWkgPSAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBxcS5leHRlbmQocXEuRmluZVVwbG9hZGVyLnByb3RvdHlwZSwgcXEuYmFzZVB1YmxpY0FwaSk7XG4gICAgcXEuZXh0ZW5kKHFxLkZpbmVVcGxvYWRlci5wcm90b3R5cGUsIHFxLmJhc2VQcml2YXRlQXBpKTtcbiAgICBxcS5leHRlbmQocXEuRmluZVVwbG9hZGVyLnByb3RvdHlwZSwgcXEudWlQdWJsaWNBcGkpO1xuICAgIHFxLmV4dGVuZChxcS5GaW5lVXBsb2FkZXIucHJvdG90eXBlLCBxcS51aVByaXZhdGVBcGkpO1xuICAgIHFxLlRlbXBsYXRpbmcgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgRklMRV9JRF9BVFRSID0gXCJxcS1maWxlLWlkXCIsIEZJTEVfQ0xBU1NfUFJFRklYID0gXCJxcS1maWxlLWlkLVwiLCBUSFVNQk5BSUxfTUFYX1NJWkVfQVRUUiA9IFwicXEtbWF4LXNpemVcIiwgVEhVTUJOQUlMX1NFUlZFUl9TQ0FMRV9BVFRSID0gXCJxcS1zZXJ2ZXItc2NhbGVcIiwgSElERV9EUk9QWk9ORV9BVFRSID0gXCJxcS1oaWRlLWRyb3B6b25lXCIsIERST1BaUE9ORV9URVhUX0FUVFIgPSBcInFxLWRyb3AtYXJlYS10ZXh0XCIsIElOX1BST0dSRVNTX0NMQVNTID0gXCJxcS1pbi1wcm9ncmVzc1wiLCBISURERU5fRk9SRVZFUl9DTEFTUyA9IFwicXEtaGlkZGVuLWZvcmV2ZXJcIiwgZmlsZUJhdGNoID0ge1xuICAgICAgICAgICAgY29udGVudDogZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICAgICAgbWFwOiB7fVxuICAgICAgICB9LCBpc0NhbmNlbERpc2FibGVkID0gZmFsc2UsIGdlbmVyYXRlZFRodW1ibmFpbHMgPSAwLCB0aHVtYm5haWxRdWV1ZU1vbml0b3JSdW5uaW5nID0gZmFsc2UsIHRodW1iR2VuZXJhdGlvblF1ZXVlID0gW10sIHRodW1ibmFpbE1heFNpemUgPSAtMSwgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGxvZzogbnVsbCxcbiAgICAgICAgICAgIGxpbWl0czoge1xuICAgICAgICAgICAgICAgIG1heFRodW1iczogMCxcbiAgICAgICAgICAgICAgICB0aW1lQmV0d2VlblRodW1iczogNzUwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGVJZE9yRWw6IFwicXEtdGVtcGxhdGVcIixcbiAgICAgICAgICAgIGNvbnRhaW5lckVsOiBudWxsLFxuICAgICAgICAgICAgZmlsZUNvbnRhaW5lckVsOiBudWxsLFxuICAgICAgICAgICAgYnV0dG9uOiBudWxsLFxuICAgICAgICAgICAgaW1hZ2VHZW5lcmF0b3I6IG51bGwsXG4gICAgICAgICAgICBjbGFzc2VzOiB7XG4gICAgICAgICAgICAgICAgaGlkZTogXCJxcS1oaWRlXCIsXG4gICAgICAgICAgICAgICAgZWRpdGFibGU6IFwicXEtZWRpdGFibGVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyczoge1xuICAgICAgICAgICAgICAgIHdhaXRVbnRpbFVwZGF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsTm90QXZhaWxhYmxlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdhaXRpbmdGb3JUaHVtYm5haWw6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgICAgcGF1c2VkOiBcIlBhdXNlZFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHNlbGVjdG9yQ2xhc3NlcyA9IHtcbiAgICAgICAgICAgIGJ1dHRvbjogXCJxcS11cGxvYWQtYnV0dG9uLXNlbGVjdG9yXCIsXG4gICAgICAgICAgICBhbGVydERpYWxvZzogXCJxcS1hbGVydC1kaWFsb2ctc2VsZWN0b3JcIixcbiAgICAgICAgICAgIGRpYWxvZ0NhbmNlbEJ1dHRvbjogXCJxcS1jYW5jZWwtYnV0dG9uLXNlbGVjdG9yXCIsXG4gICAgICAgICAgICBjb25maXJtRGlhbG9nOiBcInFxLWNvbmZpcm0tZGlhbG9nLXNlbGVjdG9yXCIsXG4gICAgICAgICAgICBkaWFsb2dNZXNzYWdlOiBcInFxLWRpYWxvZy1tZXNzYWdlLXNlbGVjdG9yXCIsXG4gICAgICAgICAgICBkaWFsb2dPa0J1dHRvbjogXCJxcS1vay1idXR0b24tc2VsZWN0b3JcIixcbiAgICAgICAgICAgIHByb21wdERpYWxvZzogXCJxcS1wcm9tcHQtZGlhbG9nLXNlbGVjdG9yXCIsXG4gICAgICAgICAgICB1cGxvYWRlcjogXCJxcS11cGxvYWRlci1zZWxlY3RvclwiLFxuICAgICAgICAgICAgZHJvcDogXCJxcS11cGxvYWQtZHJvcC1hcmVhLXNlbGVjdG9yXCIsXG4gICAgICAgICAgICBsaXN0OiBcInFxLXVwbG9hZC1saXN0LXNlbGVjdG9yXCIsXG4gICAgICAgICAgICBwcm9ncmVzc0JhckNvbnRhaW5lcjogXCJxcS1wcm9ncmVzcy1iYXItY29udGFpbmVyLXNlbGVjdG9yXCIsXG4gICAgICAgICAgICBwcm9ncmVzc0JhcjogXCJxcS1wcm9ncmVzcy1iYXItc2VsZWN0b3JcIixcbiAgICAgICAgICAgIHRvdGFsUHJvZ3Jlc3NCYXJDb250YWluZXI6IFwicXEtdG90YWwtcHJvZ3Jlc3MtYmFyLWNvbnRhaW5lci1zZWxlY3RvclwiLFxuICAgICAgICAgICAgdG90YWxQcm9ncmVzc0JhcjogXCJxcS10b3RhbC1wcm9ncmVzcy1iYXItc2VsZWN0b3JcIixcbiAgICAgICAgICAgIGZpbGU6IFwicXEtdXBsb2FkLWZpbGUtc2VsZWN0b3JcIixcbiAgICAgICAgICAgIHNwaW5uZXI6IFwicXEtdXBsb2FkLXNwaW5uZXItc2VsZWN0b3JcIixcbiAgICAgICAgICAgIHNpemU6IFwicXEtdXBsb2FkLXNpemUtc2VsZWN0b3JcIixcbiAgICAgICAgICAgIGNhbmNlbDogXCJxcS11cGxvYWQtY2FuY2VsLXNlbGVjdG9yXCIsXG4gICAgICAgICAgICBwYXVzZTogXCJxcS11cGxvYWQtcGF1c2Utc2VsZWN0b3JcIixcbiAgICAgICAgICAgIGNvbnRpbnVlQnV0dG9uOiBcInFxLXVwbG9hZC1jb250aW51ZS1zZWxlY3RvclwiLFxuICAgICAgICAgICAgZGVsZXRlQnV0dG9uOiBcInFxLXVwbG9hZC1kZWxldGUtc2VsZWN0b3JcIixcbiAgICAgICAgICAgIHJldHJ5OiBcInFxLXVwbG9hZC1yZXRyeS1zZWxlY3RvclwiLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogXCJxcS11cGxvYWQtc3RhdHVzLXRleHQtc2VsZWN0b3JcIixcbiAgICAgICAgICAgIGVkaXRGaWxlbmFtZUlucHV0OiBcInFxLWVkaXQtZmlsZW5hbWUtc2VsZWN0b3JcIixcbiAgICAgICAgICAgIGVkaXROYW1lSWNvbjogXCJxcS1lZGl0LWZpbGVuYW1lLWljb24tc2VsZWN0b3JcIixcbiAgICAgICAgICAgIGRyb3BUZXh0OiBcInFxLXVwbG9hZC1kcm9wLWFyZWEtdGV4dC1zZWxlY3RvclwiLFxuICAgICAgICAgICAgZHJvcFByb2Nlc3Npbmc6IFwicXEtZHJvcC1wcm9jZXNzaW5nLXNlbGVjdG9yXCIsXG4gICAgICAgICAgICBkcm9wUHJvY2Vzc2luZ1NwaW5uZXI6IFwicXEtZHJvcC1wcm9jZXNzaW5nLXNwaW5uZXItc2VsZWN0b3JcIixcbiAgICAgICAgICAgIHRodW1ibmFpbDogXCJxcS10aHVtYm5haWwtc2VsZWN0b3JcIlxuICAgICAgICB9LCBwcmV2aWV3R2VuZXJhdGlvbiA9IHt9LCBjYWNoZWRUaHVtYm5haWxOb3RBdmFpbGFibGVJbWcgPSBuZXcgcXEuUHJvbWlzZSgpLCBjYWNoZWRXYWl0aW5nRm9yVGh1bWJuYWlsSW1nID0gbmV3IHFxLlByb21pc2UoKSwgbG9nLCBpc0VkaXRFbGVtZW50c0V4aXN0LCBpc1JldHJ5RWxlbWVudEV4aXN0LCB0ZW1wbGF0ZUh0bWwsIGNvbnRhaW5lciwgZmlsZUxpc3QsIHNob3dUaHVtYm5haWxzLCBzZXJ2ZXJTY2FsZSwgY2FjaGVUaHVtYm5haWxQbGFjZWhvbGRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBub3RBdmFpbGFibGVVcmwgPSBvcHRpb25zLnBsYWNlaG9sZGVycy50aHVtYm5haWxOb3RBdmFpbGFibGUsIHdhaXRpbmdVcmwgPSBvcHRpb25zLnBsYWNlaG9sZGVycy53YWl0aW5nRm9yVGh1bWJuYWlsLCBzcGVjID0ge1xuICAgICAgICAgICAgICAgIG1heFNpemU6IHRodW1ibmFpbE1heFNpemUsXG4gICAgICAgICAgICAgICAgc2NhbGU6IHNlcnZlclNjYWxlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHNob3dUaHVtYm5haWxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdEF2YWlsYWJsZVVybCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmltYWdlR2VuZXJhdG9yLmdlbmVyYXRlKG5vdEF2YWlsYWJsZVVybCwgbmV3IEltYWdlKCksIHNwZWMpLnRoZW4oZnVuY3Rpb24odXBkYXRlZEltZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkVGh1bWJuYWlsTm90QXZhaWxhYmxlSW1nLnN1Y2Nlc3ModXBkYXRlZEltZyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkVGh1bWJuYWlsTm90QXZhaWxhYmxlSW1nLmZhaWx1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhcIlByb2JsZW0gbG9hZGluZyAnbm90IGF2YWlsYWJsZScgcGxhY2Vob2xkZXIgaW1hZ2UgYXQgXCIgKyBub3RBdmFpbGFibGVVcmwsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZFRodW1ibmFpbE5vdEF2YWlsYWJsZUltZy5mYWlsdXJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh3YWl0aW5nVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaW1hZ2VHZW5lcmF0b3IuZ2VuZXJhdGUod2FpdGluZ1VybCwgbmV3IEltYWdlKCksIHNwZWMpLnRoZW4oZnVuY3Rpb24odXBkYXRlZEltZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkV2FpdGluZ0ZvclRodW1ibmFpbEltZy5zdWNjZXNzKHVwZGF0ZWRJbWcpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZFdhaXRpbmdGb3JUaHVtYm5haWxJbWcuZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKFwiUHJvYmxlbSBsb2FkaW5nICd3YWl0aW5nIGZvciB0aHVtYm5haWwnIHBsYWNlaG9sZGVyIGltYWdlIGF0IFwiICsgd2FpdGluZ1VybCwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkV2FpdGluZ0ZvclRodW1ibmFpbEltZy5mYWlsdXJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBkaXNwbGF5V2FpdGluZ0ltZyA9IGZ1bmN0aW9uKHRodW1ibmFpbCkge1xuICAgICAgICAgICAgdmFyIHdhaXRpbmdJbWdQbGFjZW1lbnQgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgY2FjaGVkV2FpdGluZ0ZvclRodW1ibmFpbEltZy50aGVuKGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgICAgICAgIG1heWJlU2NhbGVQbGFjZWhvbGRlclZpYUNzcyhpbWcsIHRodW1ibmFpbCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aHVtYm5haWwuc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIHRodW1ibmFpbC5zcmMgPSBpbWcuc3JjO1xuICAgICAgICAgICAgICAgICAgICB0aHVtYm5haWwub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYm5haWwub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3codGh1bWJuYWlsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRpbmdJbWdQbGFjZW1lbnQuc3VjY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdhaXRpbmdJbWdQbGFjZW1lbnQuc3VjY2VzcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGhpZGUodGh1bWJuYWlsKTtcbiAgICAgICAgICAgICAgICB3YWl0aW5nSW1nUGxhY2VtZW50LnN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHdhaXRpbmdJbWdQbGFjZW1lbnQ7XG4gICAgICAgIH0sIGdlbmVyYXRlTmV3UHJldmlldyA9IGZ1bmN0aW9uKGlkLCBibG9iLCBzcGVjKSB7XG4gICAgICAgICAgICB2YXIgdGh1bWJuYWlsID0gZ2V0VGh1bWJuYWlsKGlkKTtcbiAgICAgICAgICAgIGxvZyhcIkdlbmVyYXRpbmcgbmV3IHRodW1ibmFpbCBmb3IgXCIgKyBpZCk7XG4gICAgICAgICAgICBibG9iLnFxVGh1bWJuYWlsSWQgPSBpZDtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmltYWdlR2VuZXJhdG9yLmdlbmVyYXRlKGJsb2IsIHRodW1ibmFpbCwgc3BlYykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZWRUaHVtYm5haWxzKys7XG4gICAgICAgICAgICAgICAgc2hvdyh0aHVtYm5haWwpO1xuICAgICAgICAgICAgICAgIHByZXZpZXdHZW5lcmF0aW9uW2lkXS5zdWNjZXNzKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwcmV2aWV3R2VuZXJhdGlvbltpZF0uZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5wbGFjZWhvbGRlcnMud2FpdFVudGlsVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heWJlU2V0RGlzcGxheU5vdEF2YWlsYWJsZUltZyhpZCwgdGh1bWJuYWlsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZ2VuZXJhdGVOZXh0UXVldWVkUHJldmlldyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRodW1iR2VuZXJhdGlvblF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRodW1ibmFpbFF1ZXVlTW9uaXRvclJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBxdWV1ZWRUaHVtYlJlcXVlc3QgPSB0aHVtYkdlbmVyYXRpb25RdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZWRUaHVtYlJlcXVlc3QudXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZWRQcmV2aWV3UmVxdWVzdChxdWV1ZWRUaHVtYlJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NOZXdRdWV1ZWRQcmV2aWV3UmVxdWVzdChxdWV1ZWRUaHVtYlJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsUXVldWVNb25pdG9yUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBnZXRDYW5jZWwgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFRlbXBsYXRlRWwoZ2V0RmlsZShpZCksIHNlbGVjdG9yQ2xhc3Nlcy5jYW5jZWwpO1xuICAgICAgICB9LCBnZXRDb250aW51ZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VGVtcGxhdGVFbChnZXRGaWxlKGlkKSwgc2VsZWN0b3JDbGFzc2VzLmNvbnRpbnVlQnV0dG9uKTtcbiAgICAgICAgfSwgZ2V0RGlhbG9nID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFRlbXBsYXRlRWwoY29udGFpbmVyLCBzZWxlY3RvckNsYXNzZXNbdHlwZSArIFwiRGlhbG9nXCJdKTtcbiAgICAgICAgfSwgZ2V0RGVsZXRlID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRUZW1wbGF0ZUVsKGdldEZpbGUoaWQpLCBzZWxlY3RvckNsYXNzZXMuZGVsZXRlQnV0dG9uKTtcbiAgICAgICAgfSwgZ2V0RHJvcFByb2Nlc3NpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRUZW1wbGF0ZUVsKGNvbnRhaW5lciwgc2VsZWN0b3JDbGFzc2VzLmRyb3BQcm9jZXNzaW5nKTtcbiAgICAgICAgfSwgZ2V0RWRpdEljb24gPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFRlbXBsYXRlRWwoZ2V0RmlsZShpZCksIHNlbGVjdG9yQ2xhc3Nlcy5lZGl0TmFtZUljb24pO1xuICAgICAgICB9LCBnZXRGaWxlID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlQmF0Y2gubWFwW2lkXSB8fCBxcShmaWxlTGlzdCkuZ2V0Rmlyc3RCeUNsYXNzKEZJTEVfQ0xBU1NfUFJFRklYICsgaWQpO1xuICAgICAgICB9LCBnZXRGaWxlbmFtZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VGVtcGxhdGVFbChnZXRGaWxlKGlkKSwgc2VsZWN0b3JDbGFzc2VzLmZpbGUpO1xuICAgICAgICB9LCBnZXRQYXVzZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VGVtcGxhdGVFbChnZXRGaWxlKGlkKSwgc2VsZWN0b3JDbGFzc2VzLnBhdXNlKTtcbiAgICAgICAgfSwgZ2V0UHJvZ3Jlc3MgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VGVtcGxhdGVFbChjb250YWluZXIsIHNlbGVjdG9yQ2xhc3Nlcy50b3RhbFByb2dyZXNzQmFyQ29udGFpbmVyKSB8fCBnZXRUZW1wbGF0ZUVsKGNvbnRhaW5lciwgc2VsZWN0b3JDbGFzc2VzLnRvdGFsUHJvZ3Jlc3NCYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldFRlbXBsYXRlRWwoZ2V0RmlsZShpZCksIHNlbGVjdG9yQ2xhc3Nlcy5wcm9ncmVzc0JhckNvbnRhaW5lcikgfHwgZ2V0VGVtcGxhdGVFbChnZXRGaWxlKGlkKSwgc2VsZWN0b3JDbGFzc2VzLnByb2dyZXNzQmFyKTtcbiAgICAgICAgfSwgZ2V0UmV0cnkgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFRlbXBsYXRlRWwoZ2V0RmlsZShpZCksIHNlbGVjdG9yQ2xhc3Nlcy5yZXRyeSk7XG4gICAgICAgIH0sIGdldFNpemUgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFRlbXBsYXRlRWwoZ2V0RmlsZShpZCksIHNlbGVjdG9yQ2xhc3Nlcy5zaXplKTtcbiAgICAgICAgfSwgZ2V0U3Bpbm5lciA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VGVtcGxhdGVFbChnZXRGaWxlKGlkKSwgc2VsZWN0b3JDbGFzc2VzLnNwaW5uZXIpO1xuICAgICAgICB9LCBnZXRUZW1wbGF0ZUVsID0gZnVuY3Rpb24oY29udGV4dCwgY3NzQ2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0ICYmIHFxKGNvbnRleHQpLmdldEZpcnN0QnlDbGFzcyhjc3NDbGFzcyk7XG4gICAgICAgIH0sIGdldFRodW1ibmFpbCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hvd1RodW1ibmFpbHMgJiYgZ2V0VGVtcGxhdGVFbChnZXRGaWxlKGlkKSwgc2VsZWN0b3JDbGFzc2VzLnRodW1ibmFpbCk7XG4gICAgICAgIH0sIGhpZGUgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgZWwgJiYgcXEoZWwpLmFkZENsYXNzKG9wdGlvbnMuY2xhc3Nlcy5oaWRlKTtcbiAgICAgICAgfSwgbWF5YmVTY2FsZVBsYWNlaG9sZGVyVmlhQ3NzID0gZnVuY3Rpb24ocGxhY2Vob2xkZXIsIHRodW1ibmFpbCkge1xuICAgICAgICAgICAgdmFyIG1heFdpZHRoID0gcGxhY2Vob2xkZXIuc3R5bGUubWF4V2lkdGgsIG1heEhlaWdodCA9IHBsYWNlaG9sZGVyLnN0eWxlLm1heEhlaWdodDtcbiAgICAgICAgICAgIGlmIChtYXhIZWlnaHQgJiYgbWF4V2lkdGggJiYgIXRodW1ibmFpbC5zdHlsZS5tYXhXaWR0aCAmJiAhdGh1bWJuYWlsLnN0eWxlLm1heEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHFxKHRodW1ibmFpbCkuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6IG1heFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IG1heEhlaWdodFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBtYXliZVNldERpc3BsYXlOb3RBdmFpbGFibGVJbWcgPSBmdW5jdGlvbihpZCwgdGh1bWJuYWlsKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlld2luZyA9IHByZXZpZXdHZW5lcmF0aW9uW2lkXSB8fCBuZXcgcXEuUHJvbWlzZSgpLmZhaWx1cmUoKSwgbm90QXZhaWxhYmxlSW1nUGxhY2VtZW50ID0gbmV3IHFxLlByb21pc2UoKTtcbiAgICAgICAgICAgIGNhY2hlZFRodW1ibmFpbE5vdEF2YWlsYWJsZUltZy50aGVuKGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgICAgICAgIHByZXZpZXdpbmcudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbm90QXZhaWxhYmxlSW1nUGxhY2VtZW50LnN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVTY2FsZVBsYWNlaG9sZGVyVmlhQ3NzKGltZywgdGh1bWJuYWlsKTtcbiAgICAgICAgICAgICAgICAgICAgdGh1bWJuYWlsLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJuYWlsLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RBdmFpbGFibGVJbWdQbGFjZW1lbnQuc3VjY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aHVtYm5haWwuc3JjID0gaW1nLnNyYztcbiAgICAgICAgICAgICAgICAgICAgc2hvdyh0aHVtYm5haWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbm90QXZhaWxhYmxlSW1nUGxhY2VtZW50O1xuICAgICAgICB9LCBwYXJzZUFuZEdldFRlbXBsYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0RWwsIHNjcmlwdEh0bWwsIGZpbGVMaXN0Tm9kZSwgdGVtcFRlbXBsYXRlRWwsIGZpbGVMaXN0SHRtbCwgZGVmYXVsdEJ1dHRvbiwgZHJvcEFyZWEsIHRodW1ibmFpbCwgZHJvcFByb2Nlc3NpbmcsIGRyb3BUZXh0RWwsIHVwbG9hZGVyRWw7XG4gICAgICAgICAgICBsb2coXCJQYXJzaW5nIHRlbXBsYXRlXCIpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGVtcGxhdGVJZE9yRWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBNVVNUIHNwZWNpZnkgZWl0aGVyIGEgdGVtcGxhdGUgZWxlbWVudCBvciBJRCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocXEuaXNTdHJpbmcob3B0aW9ucy50ZW1wbGF0ZUlkT3JFbCkpIHtcbiAgICAgICAgICAgICAgICBzY3JpcHRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMudGVtcGxhdGVJZE9yRWwpO1xuICAgICAgICAgICAgICAgIGlmIChzY3JpcHRFbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocXEuZm9ybWF0KFwiQ2Fubm90IGZpbmQgdGVtcGxhdGUgc2NyaXB0IGF0IElEICd7fSchXCIsIG9wdGlvbnMudGVtcGxhdGVJZE9yRWwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2NyaXB0SHRtbCA9IHNjcmlwdEVsLmlubmVySFRNTDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGVtcGxhdGVJZE9yRWwuaW5uZXJIVE1MID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGhhdmUgc3BlY2lmaWVkIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSB0ZW1wbGF0ZSBvcHRpb24hICBcIiArIFwiSXQgbXVzdCBiZSBhbiBJRCBvciBhbiBFbGVtZW50LlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2NyaXB0SHRtbCA9IG9wdGlvbnMudGVtcGxhdGVJZE9yRWwuaW5uZXJIVE1MO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NyaXB0SHRtbCA9IHFxLnRyaW1TdHIoc2NyaXB0SHRtbCk7XG4gICAgICAgICAgICB0ZW1wVGVtcGxhdGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0ZW1wVGVtcGxhdGVFbC5hcHBlbmRDaGlsZChxcS50b0VsZW1lbnQoc2NyaXB0SHRtbCkpO1xuICAgICAgICAgICAgdXBsb2FkZXJFbCA9IHFxKHRlbXBUZW1wbGF0ZUVsKS5nZXRGaXJzdEJ5Q2xhc3Moc2VsZWN0b3JDbGFzc2VzLnVwbG9hZGVyKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmJ1dHRvbikge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRCdXR0b24gPSBxcSh0ZW1wVGVtcGxhdGVFbCkuZ2V0Rmlyc3RCeUNsYXNzKHNlbGVjdG9yQ2xhc3Nlcy5idXR0b24pO1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0QnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHFxKGRlZmF1bHRCdXR0b24pLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcXEuRHJhZ0FuZERyb3AgfHwgIXFxLnN1cHBvcnRlZEZlYXR1cmVzLmZpbGVEcm9wKSB7XG4gICAgICAgICAgICAgICAgZHJvcFByb2Nlc3NpbmcgPSBxcSh0ZW1wVGVtcGxhdGVFbCkuZ2V0Rmlyc3RCeUNsYXNzKHNlbGVjdG9yQ2xhc3Nlcy5kcm9wUHJvY2Vzc2luZyk7XG4gICAgICAgICAgICAgICAgaWYgKGRyb3BQcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHFxKGRyb3BQcm9jZXNzaW5nKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkcm9wQXJlYSA9IHFxKHRlbXBUZW1wbGF0ZUVsKS5nZXRGaXJzdEJ5Q2xhc3Moc2VsZWN0b3JDbGFzc2VzLmRyb3ApO1xuICAgICAgICAgICAgaWYgKGRyb3BBcmVhICYmICFxcS5EcmFnQW5kRHJvcCkge1xuICAgICAgICAgICAgICAgIGxvZyhcIkRuRCBtb2R1bGUgdW5hdmFpbGFibGUuXCIsIFwiaW5mb1wiKTtcbiAgICAgICAgICAgICAgICBxcShkcm9wQXJlYSkucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXFxLnN1cHBvcnRlZEZlYXR1cmVzLmZpbGVEcm9wKSB7XG4gICAgICAgICAgICAgICAgdXBsb2FkZXJFbC5yZW1vdmVBdHRyaWJ1dGUoRFJPUFpQT05FX1RFWFRfQVRUUik7XG4gICAgICAgICAgICAgICAgaWYgKGRyb3BBcmVhICYmIHFxKGRyb3BBcmVhKS5oYXNBdHRyaWJ1dGUoSElERV9EUk9QWk9ORV9BVFRSKSkge1xuICAgICAgICAgICAgICAgICAgICBxcShkcm9wQXJlYSkuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocXEodXBsb2FkZXJFbCkuaGFzQXR0cmlidXRlKERST1BaUE9ORV9URVhUX0FUVFIpICYmIGRyb3BBcmVhKSB7XG4gICAgICAgICAgICAgICAgZHJvcFRleHRFbCA9IHFxKGRyb3BBcmVhKS5nZXRGaXJzdEJ5Q2xhc3Moc2VsZWN0b3JDbGFzc2VzLmRyb3BUZXh0KTtcbiAgICAgICAgICAgICAgICBkcm9wVGV4dEVsICYmIHFxKGRyb3BUZXh0RWwpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGh1bWJuYWlsID0gcXEodGVtcFRlbXBsYXRlRWwpLmdldEZpcnN0QnlDbGFzcyhzZWxlY3RvckNsYXNzZXMudGh1bWJuYWlsKTtcbiAgICAgICAgICAgIGlmICghc2hvd1RodW1ibmFpbHMpIHtcbiAgICAgICAgICAgICAgICB0aHVtYm5haWwgJiYgcXEodGh1bWJuYWlsKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGh1bWJuYWlsKSB7XG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsTWF4U2l6ZSA9IHBhcnNlSW50KHRodW1ibmFpbC5nZXRBdHRyaWJ1dGUoVEhVTUJOQUlMX01BWF9TSVpFX0FUVFIpKTtcbiAgICAgICAgICAgICAgICB0aHVtYm5haWxNYXhTaXplID0gdGh1bWJuYWlsTWF4U2l6ZSA+IDAgPyB0aHVtYm5haWxNYXhTaXplIDogbnVsbDtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJTY2FsZSA9IHFxKHRodW1ibmFpbCkuaGFzQXR0cmlidXRlKFRIVU1CTkFJTF9TRVJWRVJfU0NBTEVfQVRUUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaG93VGh1bWJuYWlscyA9IHNob3dUaHVtYm5haWxzICYmIHRodW1ibmFpbDtcbiAgICAgICAgICAgIGlzRWRpdEVsZW1lbnRzRXhpc3QgPSBxcSh0ZW1wVGVtcGxhdGVFbCkuZ2V0QnlDbGFzcyhzZWxlY3RvckNsYXNzZXMuZWRpdEZpbGVuYW1lSW5wdXQpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICBpc1JldHJ5RWxlbWVudEV4aXN0ID0gcXEodGVtcFRlbXBsYXRlRWwpLmdldEJ5Q2xhc3Moc2VsZWN0b3JDbGFzc2VzLnJldHJ5KS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgZmlsZUxpc3ROb2RlID0gcXEodGVtcFRlbXBsYXRlRWwpLmdldEZpcnN0QnlDbGFzcyhzZWxlY3RvckNsYXNzZXMubGlzdCk7XG4gICAgICAgICAgICBpZiAoZmlsZUxpc3ROb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCB0aGUgZmlsZSBsaXN0IGNvbnRhaW5lciBpbiB0aGUgdGVtcGxhdGUhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZUxpc3RIdG1sID0gZmlsZUxpc3ROb2RlLmlubmVySFRNTDtcbiAgICAgICAgICAgIGZpbGVMaXN0Tm9kZS5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHRlbXBUZW1wbGF0ZUVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiRElBTE9HXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaWFsb2dcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2coXCJUZW1wbGF0ZSBwYXJzaW5nIGNvbXBsZXRlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogcXEudHJpbVN0cih0ZW1wVGVtcGxhdGVFbC5pbm5lckhUTUwpLFxuICAgICAgICAgICAgICAgIGZpbGVUZW1wbGF0ZTogcXEudHJpbVN0cihmaWxlTGlzdEh0bWwpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBwcmVwZW5kRmlsZSA9IGZ1bmN0aW9uKGVsLCBpbmRleCwgZmlsZUxpc3QpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRFbCA9IGZpbGVMaXN0LCBiZWZvcmVFbCA9IHBhcmVudEVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlRWwgPSBxcShwYXJlbnRFbCkuY2hpbGRyZW4oKVtpbmRleF0ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnRFbC5pbnNlcnRCZWZvcmUoZWwsIGJlZm9yZUVsKTtcbiAgICAgICAgfSwgcHJvY2Vzc05ld1F1ZXVlZFByZXZpZXdSZXF1ZXN0ID0gZnVuY3Rpb24ocXVldWVkVGh1bWJSZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBxdWV1ZWRUaHVtYlJlcXVlc3QuaWQsIG9wdEZpbGVPckJsb2IgPSBxdWV1ZWRUaHVtYlJlcXVlc3Qub3B0RmlsZU9yQmxvYiwgcmVsYXRlZFRodW1ibmFpbElkID0gb3B0RmlsZU9yQmxvYiAmJiBvcHRGaWxlT3JCbG9iLnFxVGh1bWJuYWlsSWQsIHRodW1ibmFpbCA9IGdldFRodW1ibmFpbChpZCksIHNwZWMgPSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tUmVzaXplRnVuY3Rpb246IHF1ZXVlZFRodW1iUmVxdWVzdC5jdXN0b21SZXNpemVGdW5jdGlvbixcbiAgICAgICAgICAgICAgICBtYXhTaXplOiB0aHVtYm5haWxNYXhTaXplLFxuICAgICAgICAgICAgICAgIG9yaWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzY2FsZTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChxcS5zdXBwb3J0ZWRGZWF0dXJlcy5pbWFnZVByZXZpZXdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRodW1ibmFpbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5saW1pdHMubWF4VGh1bWJzICYmIG9wdGlvbnMubGltaXRzLm1heFRodW1icyA8PSBnZW5lcmF0ZWRUaHVtYm5haWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVNldERpc3BsYXlOb3RBdmFpbGFibGVJbWcoaWQsIHRodW1ibmFpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZU5leHRRdWV1ZWRQcmV2aWV3KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5V2FpdGluZ0ltZyh0aHVtYm5haWwpLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlld0dlbmVyYXRpb25baWRdID0gbmV3IHFxLlByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3R2VuZXJhdGlvbltpZF0uZG9uZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChnZW5lcmF0ZU5leHRRdWV1ZWRQcmV2aWV3LCBvcHRpb25zLmxpbWl0cy50aW1lQmV0d2VlblRodW1icyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGF0ZWRUaHVtYm5haWxJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUNhY2hlZFByZXZpZXcoaWQsIHJlbGF0ZWRUaHVtYm5haWxJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVOZXdQcmV2aWV3KGlkLCBvcHRGaWxlT3JCbG9iLCBzcGVjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTmV4dFF1ZXVlZFByZXZpZXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRodW1ibmFpbCkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlXYWl0aW5nSW1nKHRodW1ibmFpbCk7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVOZXh0UXVldWVkUHJldmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBwcm9jZXNzVXBkYXRlUXVldWVkUHJldmlld1JlcXVlc3QgPSBmdW5jdGlvbihxdWV1ZWRUaHVtYlJlcXVlc3QpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHF1ZXVlZFRodW1iUmVxdWVzdC5pZCwgdGh1bWJuYWlsVXJsID0gcXVldWVkVGh1bWJSZXF1ZXN0LnRodW1ibmFpbFVybCwgc2hvd1dhaXRpbmdJbWcgPSBxdWV1ZWRUaHVtYlJlcXVlc3Quc2hvd1dhaXRpbmdJbWcsIHRodW1ibmFpbCA9IGdldFRodW1ibmFpbChpZCksIHNwZWMgPSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tUmVzaXplRnVuY3Rpb246IHF1ZXVlZFRodW1iUmVxdWVzdC5jdXN0b21SZXNpemVGdW5jdGlvbixcbiAgICAgICAgICAgICAgICBzY2FsZTogc2VydmVyU2NhbGUsXG4gICAgICAgICAgICAgICAgbWF4U2l6ZTogdGh1bWJuYWlsTWF4U2l6ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aHVtYm5haWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGh1bWJuYWlsVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmxpbWl0cy5tYXhUaHVtYnMgJiYgb3B0aW9ucy5saW1pdHMubWF4VGh1bWJzIDw9IGdlbmVyYXRlZFRodW1ibmFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlU2V0RGlzcGxheU5vdEF2YWlsYWJsZUltZyhpZCwgdGh1bWJuYWlsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTmV4dFF1ZXVlZFByZXZpZXcoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG93V2FpdGluZ0ltZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlXYWl0aW5nSW1nKHRodW1ibmFpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5pbWFnZUdlbmVyYXRvci5nZW5lcmF0ZSh0aHVtYm5haWxVcmwsIHRodW1ibmFpbCwgc3BlYykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93KHRodW1ibmFpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkVGh1bWJuYWlscysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZ2VuZXJhdGVOZXh0UXVldWVkUHJldmlldywgb3B0aW9ucy5saW1pdHMudGltZUJldHdlZW5UaHVtYnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVTZXREaXNwbGF5Tm90QXZhaWxhYmxlSW1nKGlkLCB0aHVtYm5haWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZ2VuZXJhdGVOZXh0UXVldWVkUHJldmlldywgb3B0aW9ucy5saW1pdHMudGltZUJldHdlZW5UaHVtYnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXliZVNldERpc3BsYXlOb3RBdmFpbGFibGVJbWcoaWQsIHRodW1ibmFpbCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTmV4dFF1ZXVlZFByZXZpZXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHNldFByb2dyZXNzQmFyV2lkdGggPSBmdW5jdGlvbihpZCwgcGVyY2VudCkge1xuICAgICAgICAgICAgdmFyIGJhciA9IGdldFByb2dyZXNzKGlkKSwgcHJvZ3Jlc3NCYXJTZWxlY3RvciA9IGlkID09IG51bGwgPyBzZWxlY3RvckNsYXNzZXMudG90YWxQcm9ncmVzc0JhciA6IHNlbGVjdG9yQ2xhc3Nlcy5wcm9ncmVzc0JhcjtcbiAgICAgICAgICAgIGlmIChiYXIgJiYgIXFxKGJhcikuaGFzQ2xhc3MocHJvZ3Jlc3NCYXJTZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICBiYXIgPSBxcShiYXIpLmdldEZpcnN0QnlDbGFzcyhwcm9ncmVzc0JhclNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiYXIpIHtcbiAgICAgICAgICAgICAgICBxcShiYXIpLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwZXJjZW50ICsgXCIlXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBiYXIuc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW5vd1wiLCBwZXJjZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc2hvdyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBlbCAmJiBxcShlbCkucmVtb3ZlQ2xhc3Mob3B0aW9ucy5jbGFzc2VzLmhpZGUpO1xuICAgICAgICB9LCB1c2VDYWNoZWRQcmV2aWV3ID0gZnVuY3Rpb24odGFyZ2V0VGh1bWJuYWlsSWQsIGNhY2hlZFRodW1ibmFpbElkKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0VGh1bWJuYWlsID0gZ2V0VGh1bWJuYWlsKHRhcmdldFRodW1ibmFpbElkKSwgY2FjaGVkVGh1bWJuYWlsID0gZ2V0VGh1bWJuYWlsKGNhY2hlZFRodW1ibmFpbElkKTtcbiAgICAgICAgICAgIGxvZyhxcS5mb3JtYXQoXCJJRCB7fSBpcyB0aGUgc2FtZSBmaWxlIGFzIElEIHt9LiAgV2lsbCB1c2UgZ2VuZXJhdGVkIHRodW1ibmFpbCBmcm9tIElEIHt9IGluc3RlYWQuXCIsIHRhcmdldFRodW1ibmFpbElkLCBjYWNoZWRUaHVtYm5haWxJZCwgY2FjaGVkVGh1bWJuYWlsSWQpKTtcbiAgICAgICAgICAgIHByZXZpZXdHZW5lcmF0aW9uW2NhY2hlZFRodW1ibmFpbElkXS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlZFRodW1ibmFpbHMrKztcbiAgICAgICAgICAgICAgICBwcmV2aWV3R2VuZXJhdGlvblt0YXJnZXRUaHVtYm5haWxJZF0uc3VjY2VzcygpO1xuICAgICAgICAgICAgICAgIGxvZyhxcS5mb3JtYXQoXCJOb3cgdXNpbmcgcHJldmlvdXNseSBnZW5lcmF0ZWQgdGh1bWJuYWlsIGNyZWF0ZWQgZm9yIElEIHt9IG9uIElEIHt9LlwiLCBjYWNoZWRUaHVtYm5haWxJZCwgdGFyZ2V0VGh1bWJuYWlsSWQpKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRUaHVtYm5haWwuc3JjID0gY2FjaGVkVGh1bWJuYWlsLnNyYztcbiAgICAgICAgICAgICAgICBzaG93KHRhcmdldFRodW1ibmFpbCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwcmV2aWV3R2VuZXJhdGlvblt0YXJnZXRUaHVtYm5haWxJZF0uZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5wbGFjZWhvbGRlcnMud2FpdFVudGlsVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heWJlU2V0RGlzcGxheU5vdEF2YWlsYWJsZUltZyh0YXJnZXRUaHVtYm5haWxJZCwgdGFyZ2V0VGh1bWJuYWlsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuZXh0ZW5kKG9wdGlvbnMsIHNwZWMpO1xuICAgICAgICBsb2cgPSBvcHRpb25zLmxvZztcbiAgICAgICAgaWYgKCFxcS5zdXBwb3J0ZWRGZWF0dXJlcy5pbWFnZVByZXZpZXdzKSB7XG4gICAgICAgICAgICBvcHRpb25zLmxpbWl0cy50aW1lQmV0d2VlblRodW1icyA9IDA7XG4gICAgICAgICAgICBvcHRpb25zLmxpbWl0cy5tYXhUaHVtYnMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyRWw7XG4gICAgICAgIHNob3dUaHVtYm5haWxzID0gb3B0aW9ucy5pbWFnZUdlbmVyYXRvciAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB0ZW1wbGF0ZUh0bWwgPSBwYXJzZUFuZEdldFRlbXBsYXRlKCk7XG4gICAgICAgIGNhY2hlVGh1bWJuYWlsUGxhY2Vob2xkZXJzKCk7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGxvZyhcIlJlbmRlcmluZyB0ZW1wbGF0ZSBpbiBET00uXCIpO1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlZFRodW1ibmFpbHMgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSB0ZW1wbGF0ZUh0bWwudGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgaGlkZShnZXREcm9wUHJvY2Vzc2luZygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVUb3RhbFByb2dyZXNzKCk7XG4gICAgICAgICAgICAgICAgZmlsZUxpc3QgPSBvcHRpb25zLmZpbGVDb250YWluZXJFbCB8fCBnZXRUZW1wbGF0ZUVsKGNvbnRhaW5lciwgc2VsZWN0b3JDbGFzc2VzLmxpc3QpO1xuICAgICAgICAgICAgICAgIGxvZyhcIlRlbXBsYXRlIHJlbmRlcmluZyBjb21wbGV0ZVwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW5kZXJGYWlsdXJlOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbnRSZW5kZXJFbCA9IHFxLnRvRWxlbWVudChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudFJlbmRlckVsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhckZpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmaWxlTGlzdC5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc2FibGVDYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlzQ2FuY2VsRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZEZpbGU6IGZ1bmN0aW9uKGlkLCBuYW1lLCBwcmVwZW5kSW5mbywgaGlkZUZvcmV2ZXIsIGJhdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVFbCA9IHFxLnRvRWxlbWVudCh0ZW1wbGF0ZUh0bWwuZmlsZVRlbXBsYXRlKSwgZmlsZU5hbWVFbCA9IGdldFRlbXBsYXRlRWwoZmlsZUVsLCBzZWxlY3RvckNsYXNzZXMuZmlsZSksIHVwbG9hZGVyRWwgPSBnZXRUZW1wbGF0ZUVsKGNvbnRhaW5lciwgc2VsZWN0b3JDbGFzc2VzLnVwbG9hZGVyKSwgZmlsZUNvbnRhaW5lciA9IGJhdGNoID8gZmlsZUJhdGNoLmNvbnRlbnQgOiBmaWxlTGlzdCwgdGh1bWI7XG4gICAgICAgICAgICAgICAgaWYgKGJhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVCYXRjaC5tYXBbaWRdID0gZmlsZUVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxcShmaWxlRWwpLmFkZENsYXNzKEZJTEVfQ0xBU1NfUFJFRklYICsgaWQpO1xuICAgICAgICAgICAgICAgIHVwbG9hZGVyRWwucmVtb3ZlQXR0cmlidXRlKERST1BaUE9ORV9URVhUX0FUVFIpO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlTmFtZUVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHFxKGZpbGVOYW1lRWwpLnNldFRleHQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lRWwuc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbGVFbC5zZXRBdHRyaWJ1dGUoRklMRV9JRF9BVFRSLCBpZCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXBlbmRJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXBlbmRGaWxlKGZpbGVFbCwgcHJlcGVuZEluZm8uaW5kZXgsIGZpbGVDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVDb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsZUVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhpZGVGb3JldmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVFbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgICAgIHFxKGZpbGVFbCkuYWRkQ2xhc3MoSElEREVOX0ZPUkVWRVJfQ0xBU1MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZGUoZ2V0UHJvZ3Jlc3MoaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZShnZXRTaXplKGlkKSk7XG4gICAgICAgICAgICAgICAgICAgIGhpZGUoZ2V0RGVsZXRlKGlkKSk7XG4gICAgICAgICAgICAgICAgICAgIGhpZGUoZ2V0UmV0cnkoaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZShnZXRQYXVzZShpZCkpO1xuICAgICAgICAgICAgICAgICAgICBoaWRlKGdldENvbnRpbnVlKGlkKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NhbmNlbERpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVDYW5jZWwoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRodW1iID0gZ2V0VGh1bWJuYWlsKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRodW1iICYmICF0aHVtYi5zcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZFdhaXRpbmdGb3JUaHVtYm5haWxJbWcudGhlbihmdW5jdGlvbih3YWl0aW5nSW1nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWIuc3JjID0gd2FpdGluZ0ltZy5zcmM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhaXRpbmdJbWcuc3R5bGUubWF4SGVpZ2h0ICYmIHdhaXRpbmdJbWcuc3R5bGUubWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXEodGh1bWIpLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IHdhaXRpbmdJbWcuc3R5bGUubWF4SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6IHdhaXRpbmdJbWcuc3R5bGUubWF4V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3codGh1bWIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkRmlsZVRvQ2FjaGU6IGZ1bmN0aW9uKGlkLCBuYW1lLCBwcmVwZW5kSW5mbywgaGlkZUZvcmV2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEZpbGUoaWQsIG5hbWUsIHByZXBlbmRJbmZvLCBoaWRlRm9yZXZlciwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkQ2FjaGVUb0RvbTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZmlsZUxpc3QuYXBwZW5kQ2hpbGQoZmlsZUJhdGNoLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGZpbGVCYXRjaC5jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIGZpbGVCYXRjaC5tYXAgPSB7fTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVGaWxlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHFxKGdldEZpbGUoaWQpKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRGaWxlSWQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gZWw7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoRklMRV9JRF9BVFRSKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGN1cnJlbnROb2RlLmdldEF0dHJpYnV0ZShGSUxFX0lEX0FUVFIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RmlsZUxpc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlTGlzdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXJrRmlsZW5hbWVFZGl0YWJsZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBnZXRGaWxlbmFtZShpZCk7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWUgJiYgcXEoZmlsZW5hbWUpLmFkZENsYXNzKG9wdGlvbnMuY2xhc3Nlcy5lZGl0YWJsZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlRmlsZW5hbWU6IGZ1bmN0aW9uKGlkLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVuYW1lRWwgPSBnZXRGaWxlbmFtZShpZCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVuYW1lRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEoZmlsZW5hbWVFbCkuc2V0VGV4dChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWVFbC5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGlkZUZpbGVuYW1lOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGhpZGUoZ2V0RmlsZW5hbWUoaWQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG93RmlsZW5hbWU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgc2hvdyhnZXRGaWxlbmFtZShpZCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzRmlsZU5hbWU6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHFxKGVsKS5oYXNDbGFzcyhzZWxlY3RvckNsYXNzZXMuZmlsZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0QnV0dG9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5idXR0b24gfHwgZ2V0VGVtcGxhdGVFbChjb250YWluZXIsIHNlbGVjdG9yQ2xhc3Nlcy5idXR0b24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhpZGVEcm9wUHJvY2Vzc2luZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaGlkZShnZXREcm9wUHJvY2Vzc2luZygpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG93RHJvcFByb2Nlc3Npbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNob3coZ2V0RHJvcFByb2Nlc3NpbmcoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RHJvcFpvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRUZW1wbGF0ZUVsKGNvbnRhaW5lciwgc2VsZWN0b3JDbGFzc2VzLmRyb3ApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzRWRpdEZpbGVuYW1lUG9zc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0VkaXRFbGVtZW50c0V4aXN0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhpZGVSZXRyeTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBoaWRlKGdldFJldHJ5KGlkKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNSZXRyeVBvc3NpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNSZXRyeUVsZW1lbnRFeGlzdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG93UmV0cnk6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgc2hvdyhnZXRSZXRyeShpZCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEZpbGVDb250YWluZXI6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEZpbGUoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNob3dFZGl0SWNvbjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWNvbiA9IGdldEVkaXRJY29uKGlkKTtcbiAgICAgICAgICAgICAgICBpY29uICYmIHFxKGljb24pLmFkZENsYXNzKG9wdGlvbnMuY2xhc3Nlcy5lZGl0YWJsZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNIaWRkZW5Gb3JldmVyOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxcShnZXRGaWxlKGlkKSkuaGFzQ2xhc3MoSElEREVOX0ZPUkVWRVJfQ0xBU1MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhpZGVFZGl0SWNvbjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWNvbiA9IGdldEVkaXRJY29uKGlkKTtcbiAgICAgICAgICAgICAgICBpY29uICYmIHFxKGljb24pLnJlbW92ZUNsYXNzKG9wdGlvbnMuY2xhc3Nlcy5lZGl0YWJsZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNFZGl0SWNvbjogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXEoZWwpLmhhc0NsYXNzKHNlbGVjdG9yQ2xhc3Nlcy5lZGl0TmFtZUljb24sIHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEVkaXRJbnB1dDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VGVtcGxhdGVFbChnZXRGaWxlKGlkKSwgc2VsZWN0b3JDbGFzc2VzLmVkaXRGaWxlbmFtZUlucHV0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0VkaXRJbnB1dDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXEoZWwpLmhhc0NsYXNzKHNlbGVjdG9yQ2xhc3Nlcy5lZGl0RmlsZW5hbWVJbnB1dCwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlUHJvZ3Jlc3M6IGZ1bmN0aW9uKGlkLCBsb2FkZWQsIHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhciA9IGdldFByb2dyZXNzKGlkKSwgcGVyY2VudDtcbiAgICAgICAgICAgICAgICBpZiAoYmFyICYmIHRvdGFsID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBwZXJjZW50ID0gTWF0aC5yb3VuZChsb2FkZWQgLyB0b3RhbCAqIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXJjZW50ID09PSAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGUoYmFyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3coYmFyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRQcm9ncmVzc0JhcldpZHRoKGlkLCBwZXJjZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlVG90YWxQcm9ncmVzczogZnVuY3Rpb24obG9hZGVkLCB0b3RhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvZ3Jlc3MobnVsbCwgbG9hZGVkLCB0b3RhbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGlkZVByb2dyZXNzOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciBiYXIgPSBnZXRQcm9ncmVzcyhpZCk7XG4gICAgICAgICAgICAgICAgYmFyICYmIGhpZGUoYmFyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoaWRlVG90YWxQcm9ncmVzczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlUHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldFByb2dyZXNzOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHNldFByb2dyZXNzQmFyV2lkdGgoaWQsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZVRvdGFsUHJvZ3Jlc3MoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0VG90YWxQcm9ncmVzczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldFByb2dyZXNzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd0NhbmNlbDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ2FuY2VsRGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbmNlbCA9IGdldENhbmNlbChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbCAmJiBxcShjYW5jZWwpLnJlbW92ZUNsYXNzKG9wdGlvbnMuY2xhc3Nlcy5oaWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGlkZUNhbmNlbDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBoaWRlKGdldENhbmNlbChpZCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzQ2FuY2VsOiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxcShlbCkuaGFzQ2xhc3Moc2VsZWN0b3JDbGFzc2VzLmNhbmNlbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWxsb3dQYXVzZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBzaG93KGdldFBhdXNlKGlkKSk7XG4gICAgICAgICAgICAgICAgaGlkZShnZXRDb250aW51ZShpZCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwbG9hZFBhdXNlZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1c1RleHQoaWQsIG9wdGlvbnMudGV4dC5wYXVzZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsb3dDb250aW51ZUJ1dHRvbihpZCk7XG4gICAgICAgICAgICAgICAgaGlkZShnZXRTcGlubmVyKGlkKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGlkZVBhdXNlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGhpZGUoZ2V0UGF1c2UoaWQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1BhdXNlOiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxcShlbCkuaGFzQ2xhc3Moc2VsZWN0b3JDbGFzc2VzLnBhdXNlLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0NvbnRpbnVlQnV0dG9uOiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxcShlbCkuaGFzQ2xhc3Moc2VsZWN0b3JDbGFzc2VzLmNvbnRpbnVlQnV0dG9uLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbGxvd0NvbnRpbnVlQnV0dG9uOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHNob3coZ2V0Q29udGludWUoaWQpKTtcbiAgICAgICAgICAgICAgICBoaWRlKGdldFBhdXNlKGlkKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBsb2FkQ29udGludWVkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzVGV4dChpZCwgXCJcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxvd1BhdXNlKGlkKTtcbiAgICAgICAgICAgICAgICBzaG93KGdldFNwaW5uZXIoaWQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG93RGVsZXRlQnV0dG9uOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHNob3coZ2V0RGVsZXRlKGlkKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGlkZURlbGV0ZUJ1dHRvbjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBoaWRlKGdldERlbGV0ZShpZCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzRGVsZXRlQnV0dG9uOiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxcShlbCkuaGFzQ2xhc3Moc2VsZWN0b3JDbGFzc2VzLmRlbGV0ZUJ1dHRvbiwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNSZXRyeTogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXEoZWwpLmhhc0NsYXNzKHNlbGVjdG9yQ2xhc3Nlcy5yZXRyeSwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlU2l6ZTogZnVuY3Rpb24oaWQsIHRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGdldFNpemUoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3coc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHFxKHNpemUpLnNldFRleHQodGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFN0YXR1c1RleHQ6IGZ1bmN0aW9uKGlkLCB0ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRFbCA9IGdldFRlbXBsYXRlRWwoZ2V0RmlsZShpZCksIHNlbGVjdG9yQ2xhc3Nlcy5zdGF0dXNUZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dEVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFxKHRleHRFbCkuY2xlYXJUZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxcSh0ZXh0RWwpLnNldFRleHQodGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGlkZVNwaW5uZXI6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcXEoZ2V0RmlsZShpZCkpLnJlbW92ZUNsYXNzKElOX1BST0dSRVNTX0NMQVNTKTtcbiAgICAgICAgICAgICAgICBoaWRlKGdldFNwaW5uZXIoaWQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG93U3Bpbm5lcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBxcShnZXRGaWxlKGlkKSkuYWRkQ2xhc3MoSU5fUFJPR1JFU1NfQ0xBU1MpO1xuICAgICAgICAgICAgICAgIHNob3coZ2V0U3Bpbm5lcihpZCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlUHJldmlldzogZnVuY3Rpb24oaWQsIG9wdEZpbGVPckJsb2IsIGN1c3RvbVJlc2l6ZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSGlkZGVuRm9yZXZlcihpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGh1bWJHZW5lcmF0aW9uUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21SZXNpemVGdW5jdGlvbjogY3VzdG9tUmVzaXplRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRGaWxlT3JCbG9iOiBvcHRGaWxlT3JCbG9iXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAhdGh1bWJuYWlsUXVldWVNb25pdG9yUnVubmluZyAmJiBnZW5lcmF0ZU5leHRRdWV1ZWRQcmV2aWV3KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZVRodW1ibmFpbDogZnVuY3Rpb24oaWQsIHRodW1ibmFpbFVybCwgc2hvd1dhaXRpbmdJbWcsIGN1c3RvbVJlc2l6ZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSGlkZGVuRm9yZXZlcihpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGh1bWJHZW5lcmF0aW9uUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21SZXNpemVGdW5jdGlvbjogY3VzdG9tUmVzaXplRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYm5haWxVcmw6IHRodW1ibmFpbFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dXYWl0aW5nSW1nOiBzaG93V2FpdGluZ0ltZ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgIXRodW1ibmFpbFF1ZXVlTW9uaXRvclJ1bm5pbmcgJiYgZ2VuZXJhdGVOZXh0UXVldWVkUHJldmlldygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXNEaWFsb2c6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXEuc3VwcG9ydGVkRmVhdHVyZXMuZGlhbG9nRWxlbWVudCAmJiAhIWdldERpYWxvZyh0eXBlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG93RGlhbG9nOiBmdW5jdGlvbih0eXBlLCBtZXNzYWdlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlhbG9nID0gZ2V0RGlhbG9nKHR5cGUpLCBtZXNzYWdlRWwgPSBnZXRUZW1wbGF0ZUVsKGRpYWxvZywgc2VsZWN0b3JDbGFzc2VzLmRpYWxvZ01lc3NhZ2UpLCBpbnB1dEVsID0gZGlhbG9nLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiSU5QVVRcIilbMF0sIGNhbmNlbEJ0biA9IGdldFRlbXBsYXRlRWwoZGlhbG9nLCBzZWxlY3RvckNsYXNzZXMuZGlhbG9nQ2FuY2VsQnV0dG9uKSwgb2tCdG4gPSBnZXRUZW1wbGF0ZUVsKGRpYWxvZywgc2VsZWN0b3JDbGFzc2VzLmRpYWxvZ09rQnV0dG9uKSwgcHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCksIGNsb3NlSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxCdG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGNhbmNlbENsaWNrSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIG9rQnRuICYmIG9rQnRuLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBva0NsaWNrSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgIH0sIGNhbmNlbENsaWNrSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxCdG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGNhbmNlbENsaWNrSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0sIG9rQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgY2xvc2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgb2tCdG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9rQ2xpY2tIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2Uuc3VjY2VzcyhpbnB1dEVsICYmIGlucHV0RWwudmFsdWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZGlhbG9nLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCBjbG9zZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIGNhbmNlbEJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgY2FuY2VsQ2xpY2tIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBva0J0biAmJiBva0J0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb2tDbGlja0hhbmRsZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dEVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0RWwudmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lc3NhZ2VFbC50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgZGlhbG9nLnNob3dNb2RhbCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHFxLlVpRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24ocywgcHJvdGVjdGVkQXBpKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgZGlzcG9zZXIgPSBuZXcgcXEuRGlzcG9zZVN1cHBvcnQoKSwgc3BlYyA9IHtcbiAgICAgICAgICAgIGV2ZW50VHlwZTogXCJjbGlja1wiLFxuICAgICAgICAgICAgYXR0YWNoVG86IG51bGwsXG4gICAgICAgICAgICBvbkhhbmRsZWQ6IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnQpIHt9XG4gICAgICAgIH07XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBhZGRIYW5kbGVyOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlcihlbGVtZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkaXNwb3Nlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBhZGRIYW5kbGVyKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGRpc3Bvc2VyLmF0dGFjaChlbGVtZW50LCBzcGVjLmV2ZW50VHlwZSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgc3BlYy5vbkhhbmRsZWQodGFyZ2V0LCBldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBxcS5leHRlbmQocHJvdGVjdGVkQXBpLCB7XG4gICAgICAgICAgICBnZXRGaWxlSWRGcm9tSXRlbTogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnFxRmlsZUlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldERpc3Bvc2VTdXBwb3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlzcG9zZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBxcS5leHRlbmQoc3BlYywgcyk7XG4gICAgICAgIGlmIChzcGVjLmF0dGFjaFRvKSB7XG4gICAgICAgICAgICBhZGRIYW5kbGVyKHNwZWMuYXR0YWNoVG8pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBxcS5GaWxlQnV0dG9uc0NsaWNrSGFuZGxlciA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBpbmhlcml0ZWRJbnRlcm5hbEFwaSA9IHt9LCBzcGVjID0ge1xuICAgICAgICAgICAgdGVtcGxhdGluZzogbnVsbCxcbiAgICAgICAgICAgIGxvZzogZnVuY3Rpb24obWVzc2FnZSwgbHZsKSB7fSxcbiAgICAgICAgICAgIG9uRGVsZXRlRmlsZTogZnVuY3Rpb24oZmlsZUlkKSB7fSxcbiAgICAgICAgICAgIG9uQ2FuY2VsOiBmdW5jdGlvbihmaWxlSWQpIHt9LFxuICAgICAgICAgICAgb25SZXRyeTogZnVuY3Rpb24oZmlsZUlkKSB7fSxcbiAgICAgICAgICAgIG9uUGF1c2U6IGZ1bmN0aW9uKGZpbGVJZCkge30sXG4gICAgICAgICAgICBvbkNvbnRpbnVlOiBmdW5jdGlvbihmaWxlSWQpIHt9LFxuICAgICAgICAgICAgb25HZXROYW1lOiBmdW5jdGlvbihmaWxlSWQpIHt9XG4gICAgICAgIH0sIGJ1dHRvbkhhbmRsZXJzID0ge1xuICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHNwZWMub25DYW5jZWwoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldHJ5OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHNwZWMub25SZXRyeShpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVsZXRlQnV0dG9uOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHNwZWMub25EZWxldGVGaWxlKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXVzZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBzcGVjLm9uUGF1c2UoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRpbnVlQnV0dG9uOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHNwZWMub25Db250aW51ZShpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGV4YW1pbmVFdmVudCh0YXJnZXQsIGV2ZW50KSB7XG4gICAgICAgICAgICBxcS5lYWNoKGJ1dHRvbkhhbmRsZXJzLCBmdW5jdGlvbihidXR0b25UeXBlLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0TGV0dGVyQ2FwQnV0dG9uVHlwZSA9IGJ1dHRvblR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBidXR0b25UeXBlLnNsaWNlKDEpLCBmaWxlSWQ7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWMudGVtcGxhdGluZ1tcImlzXCIgKyBmaXJzdExldHRlckNhcEJ1dHRvblR5cGVdKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZUlkID0gc3BlYy50ZW1wbGF0aW5nLmdldEZpbGVJZCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBxcS5wcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHNwZWMubG9nKHFxLmZvcm1hdChcIkRldGVjdGVkIHZhbGlkIGZpbGUgYnV0dG9uIGNsaWNrIGV2ZW50IG9uIGZpbGUgJ3t9JywgSUQ6IHt9LlwiLCBzcGVjLm9uR2V0TmFtZShmaWxlSWQpLCBmaWxlSWQpKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcihmaWxlSWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcXEuZXh0ZW5kKHNwZWMsIHMpO1xuICAgICAgICBzcGVjLmV2ZW50VHlwZSA9IFwiY2xpY2tcIjtcbiAgICAgICAgc3BlYy5vbkhhbmRsZWQgPSBleGFtaW5lRXZlbnQ7XG4gICAgICAgIHNwZWMuYXR0YWNoVG8gPSBzcGVjLnRlbXBsYXRpbmcuZ2V0RmlsZUxpc3QoKTtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIG5ldyBxcS5VaUV2ZW50SGFuZGxlcihzcGVjLCBpbmhlcml0ZWRJbnRlcm5hbEFwaSkpO1xuICAgIH07XG4gICAgcXEuRmlsZW5hbWVDbGlja0hhbmRsZXIgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgaW5oZXJpdGVkSW50ZXJuYWxBcGkgPSB7fSwgc3BlYyA9IHtcbiAgICAgICAgICAgIHRlbXBsYXRpbmc6IG51bGwsXG4gICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKG1lc3NhZ2UsIGx2bCkge30sXG4gICAgICAgICAgICBjbGFzc2VzOiB7XG4gICAgICAgICAgICAgICAgZmlsZTogXCJxcS11cGxvYWQtZmlsZVwiLFxuICAgICAgICAgICAgICAgIGVkaXROYW1lSWNvbjogXCJxcS1lZGl0LWZpbGVuYW1lLWljb25cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uR2V0VXBsb2FkU3RhdHVzOiBmdW5jdGlvbihmaWxlSWQpIHt9LFxuICAgICAgICAgICAgb25HZXROYW1lOiBmdW5jdGlvbihmaWxlSWQpIHt9XG4gICAgICAgIH07XG4gICAgICAgIHFxLmV4dGVuZChzcGVjLCBzKTtcbiAgICAgICAgZnVuY3Rpb24gZXhhbWluZUV2ZW50KHRhcmdldCwgZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChzcGVjLnRlbXBsYXRpbmcuaXNGaWxlTmFtZSh0YXJnZXQpIHx8IHNwZWMudGVtcGxhdGluZy5pc0VkaXRJY29uKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZUlkID0gc3BlYy50ZW1wbGF0aW5nLmdldEZpbGVJZCh0YXJnZXQpLCBzdGF0dXMgPSBzcGVjLm9uR2V0VXBsb2FkU3RhdHVzKGZpbGVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gcXEuc3RhdHVzLlNVQk1JVFRFRCkge1xuICAgICAgICAgICAgICAgICAgICBzcGVjLmxvZyhxcS5mb3JtYXQoXCJEZXRlY3RlZCB2YWxpZCBmaWxlbmFtZSBjbGljayBldmVudCBvbiBmaWxlICd7fScsIElEOiB7fS5cIiwgc3BlYy5vbkdldE5hbWUoZmlsZUlkKSwgZmlsZUlkKSk7XG4gICAgICAgICAgICAgICAgICAgIHFxLnByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaW5oZXJpdGVkSW50ZXJuYWxBcGkuaGFuZGxlRmlsZW5hbWVFZGl0KGZpbGVJZCwgdGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3BlYy5ldmVudFR5cGUgPSBcImNsaWNrXCI7XG4gICAgICAgIHNwZWMub25IYW5kbGVkID0gZXhhbWluZUV2ZW50O1xuICAgICAgICBxcS5leHRlbmQodGhpcywgbmV3IHFxLkZpbGVuYW1lRWRpdEhhbmRsZXIoc3BlYywgaW5oZXJpdGVkSW50ZXJuYWxBcGkpKTtcbiAgICB9O1xuICAgIHFxLkZpbGVuYW1lSW5wdXRGb2N1c0luSGFuZGxlciA9IGZ1bmN0aW9uKHMsIGluaGVyaXRlZEludGVybmFsQXBpKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgc3BlYyA9IHtcbiAgICAgICAgICAgIHRlbXBsYXRpbmc6IG51bGwsXG4gICAgICAgICAgICBvbkdldFVwbG9hZFN0YXR1czogZnVuY3Rpb24oZmlsZUlkKSB7fSxcbiAgICAgICAgICAgIGxvZzogZnVuY3Rpb24obWVzc2FnZSwgbHZsKSB7fVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWluaGVyaXRlZEludGVybmFsQXBpKSB7XG4gICAgICAgICAgICBpbmhlcml0ZWRJbnRlcm5hbEFwaSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUlucHV0Rm9jdXModGFyZ2V0LCBldmVudCkge1xuICAgICAgICAgICAgaWYgKHNwZWMudGVtcGxhdGluZy5pc0VkaXRJbnB1dCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVJZCA9IHNwZWMudGVtcGxhdGluZy5nZXRGaWxlSWQodGFyZ2V0KSwgc3RhdHVzID0gc3BlYy5vbkdldFVwbG9hZFN0YXR1cyhmaWxlSWQpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IHFxLnN0YXR1cy5TVUJNSVRURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BlYy5sb2cocXEuZm9ybWF0KFwiRGV0ZWN0ZWQgdmFsaWQgZmlsZW5hbWUgaW5wdXQgZm9jdXMgZXZlbnQgb24gZmlsZSAne30nLCBJRDoge30uXCIsIHNwZWMub25HZXROYW1lKGZpbGVJZCksIGZpbGVJZCkpO1xuICAgICAgICAgICAgICAgICAgICBpbmhlcml0ZWRJbnRlcm5hbEFwaS5oYW5kbGVGaWxlbmFtZUVkaXQoZmlsZUlkLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzcGVjLmV2ZW50VHlwZSA9IFwiZm9jdXNpblwiO1xuICAgICAgICBzcGVjLm9uSGFuZGxlZCA9IGhhbmRsZUlucHV0Rm9jdXM7XG4gICAgICAgIHFxLmV4dGVuZChzcGVjLCBzKTtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIG5ldyBxcS5GaWxlbmFtZUVkaXRIYW5kbGVyKHNwZWMsIGluaGVyaXRlZEludGVybmFsQXBpKSk7XG4gICAgfTtcbiAgICBxcS5GaWxlbmFtZUlucHV0Rm9jdXNIYW5kbGVyID0gZnVuY3Rpb24oc3BlYykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgc3BlYy5ldmVudFR5cGUgPSBcImZvY3VzXCI7XG4gICAgICAgIHNwZWMuYXR0YWNoVG8gPSBudWxsO1xuICAgICAgICBxcS5leHRlbmQodGhpcywgbmV3IHFxLkZpbGVuYW1lSW5wdXRGb2N1c0luSGFuZGxlcihzcGVjLCB7fSkpO1xuICAgIH07XG4gICAgcXEuRmlsZW5hbWVFZGl0SGFuZGxlciA9IGZ1bmN0aW9uKHMsIGluaGVyaXRlZEludGVybmFsQXBpKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgc3BlYyA9IHtcbiAgICAgICAgICAgIHRlbXBsYXRpbmc6IG51bGwsXG4gICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKG1lc3NhZ2UsIGx2bCkge30sXG4gICAgICAgICAgICBvbkdldFVwbG9hZFN0YXR1czogZnVuY3Rpb24oZmlsZUlkKSB7fSxcbiAgICAgICAgICAgIG9uR2V0TmFtZTogZnVuY3Rpb24oZmlsZUlkKSB7fSxcbiAgICAgICAgICAgIG9uU2V0TmFtZTogZnVuY3Rpb24oZmlsZUlkLCBuZXdOYW1lKSB7fSxcbiAgICAgICAgICAgIG9uRWRpdGluZ1N0YXR1c0NoYW5nZTogZnVuY3Rpb24oZmlsZUlkLCBpc0VkaXRpbmcpIHt9XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGdldEZpbGVuYW1lU2Fuc0V4dGVuc2lvbihmaWxlSWQpIHtcbiAgICAgICAgICAgIHZhciBmaWxlbmFtZVNhbnNFeHQgPSBzcGVjLm9uR2V0TmFtZShmaWxlSWQpLCBleHRJZHggPSBmaWxlbmFtZVNhbnNFeHQubGFzdEluZGV4T2YoXCIuXCIpO1xuICAgICAgICAgICAgaWYgKGV4dElkeCA+IDApIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZVNhbnNFeHQgPSBmaWxlbmFtZVNhbnNFeHQuc3Vic3RyKDAsIGV4dElkeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsZW5hbWVTYW5zRXh0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldE9yaWdpbmFsRXh0ZW5zaW9uKGZpbGVJZCkge1xuICAgICAgICAgICAgdmFyIG9yaWdOYW1lID0gc3BlYy5vbkdldE5hbWUoZmlsZUlkKTtcbiAgICAgICAgICAgIHJldHVybiBxcS5nZXRFeHRlbnNpb24ob3JpZ05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZU5hbWVVcGRhdGUobmV3RmlsZW5hbWVJbnB1dEVsLCBmaWxlSWQpIHtcbiAgICAgICAgICAgIHZhciBuZXdOYW1lID0gbmV3RmlsZW5hbWVJbnB1dEVsLnZhbHVlLCBvcmlnRXh0ZW5zaW9uO1xuICAgICAgICAgICAgaWYgKG5ld05hbWUgIT09IHVuZGVmaW5lZCAmJiBxcS50cmltU3RyKG5ld05hbWUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvcmlnRXh0ZW5zaW9uID0gZ2V0T3JpZ2luYWxFeHRlbnNpb24oZmlsZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ0V4dGVuc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld05hbWUgPSBuZXdOYW1lICsgXCIuXCIgKyBvcmlnRXh0ZW5zaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGVjLm9uU2V0TmFtZShmaWxlSWQsIG5ld05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3BlYy5vbkVkaXRpbmdTdGF0dXNDaGFuZ2UoZmlsZUlkLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJJbnB1dEJsdXJIYW5kbGVyKGlucHV0RWwsIGZpbGVJZCkge1xuICAgICAgICAgICAgaW5oZXJpdGVkSW50ZXJuYWxBcGkuZ2V0RGlzcG9zZVN1cHBvcnQoKS5hdHRhY2goaW5wdXRFbCwgXCJibHVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZU5hbWVVcGRhdGUoaW5wdXRFbCwgZmlsZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlZ2lzdGVySW5wdXRFbnRlcktleUhhbmRsZXIoaW5wdXRFbCwgZmlsZUlkKSB7XG4gICAgICAgICAgICBpbmhlcml0ZWRJbnRlcm5hbEFwaS5nZXREaXNwb3NlU3VwcG9ydCgpLmF0dGFjaChpbnB1dEVsLCBcImtleXVwXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBldmVudC5rZXlDb2RlIHx8IGV2ZW50LndoaWNoO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSAxMykge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVOYW1lVXBkYXRlKGlucHV0RWwsIGZpbGVJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcXEuZXh0ZW5kKHNwZWMsIHMpO1xuICAgICAgICBzcGVjLmF0dGFjaFRvID0gc3BlYy50ZW1wbGF0aW5nLmdldEZpbGVMaXN0KCk7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCBuZXcgcXEuVWlFdmVudEhhbmRsZXIoc3BlYywgaW5oZXJpdGVkSW50ZXJuYWxBcGkpKTtcbiAgICAgICAgcXEuZXh0ZW5kKGluaGVyaXRlZEludGVybmFsQXBpLCB7XG4gICAgICAgICAgICBoYW5kbGVGaWxlbmFtZUVkaXQ6IGZ1bmN0aW9uKGlkLCB0YXJnZXQsIGZvY3VzSW5wdXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RmlsZW5hbWVJbnB1dEVsID0gc3BlYy50ZW1wbGF0aW5nLmdldEVkaXRJbnB1dChpZCk7XG4gICAgICAgICAgICAgICAgc3BlYy5vbkVkaXRpbmdTdGF0dXNDaGFuZ2UoaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIG5ld0ZpbGVuYW1lSW5wdXRFbC52YWx1ZSA9IGdldEZpbGVuYW1lU2Fuc0V4dGVuc2lvbihpZCk7XG4gICAgICAgICAgICAgICAgaWYgKGZvY3VzSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RmlsZW5hbWVJbnB1dEVsLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlZ2lzdGVySW5wdXRCbHVySGFuZGxlcihuZXdGaWxlbmFtZUlucHV0RWwsIGlkKTtcbiAgICAgICAgICAgICAgICByZWdpc3RlcklucHV0RW50ZXJLZXlIYW5kbGVyKG5ld0ZpbGVuYW1lSW5wdXRFbCwgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHFxLnMzLkZpbmVVcGxvYWRlciA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGZhaWxlZFVwbG9hZFRleHREaXNwbGF5OiB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiY3VzdG9tXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcXEuZXh0ZW5kKG9wdGlvbnMsIG8sIHRydWUpO1xuICAgICAgICAgICAgcXEuRmluZVVwbG9hZGVyLmNhbGwodGhpcywgb3B0aW9ucywgXCJzM1wiKTtcbiAgICAgICAgICAgIGlmICghcXEuc3VwcG9ydGVkRmVhdHVyZXMuYWpheFVwbG9hZGluZyAmJiBvcHRpb25zLmlmcmFtZVN1cHBvcnQubG9jYWxCbGFua1BhZ2VQYXRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmVsZW1lbnQuaW5uZXJIVE1MID0gXCI8ZGl2PllvdSBNVVNUIHNldCB0aGUgPGNvZGU+bG9jYWxCbGFua1BhZ2VQYXRoPC9jb2RlPiBwcm9wZXJ0eSBcIiArIFwib2YgdGhlIDxjb2RlPmlmcmFtZVN1cHBvcnQ8L2NvZGU+IG9wdGlvbiBzaW5jZSB0aGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgRmlsZSBBUEkhPC9kaXY+XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHFxLmV4dGVuZChxcS5zMy5GaW5lVXBsb2FkZXIucHJvdG90eXBlLCBxcS5zMy5GaW5lVXBsb2FkZXJCYXNpYy5wcm90b3R5cGUpO1xuICAgICAgICBxcS5leHRlbmQocXEuczMuRmluZVVwbG9hZGVyLnByb3RvdHlwZSwgcXEudWlQdWJsaWNBcGkpO1xuICAgICAgICBxcS5leHRlbmQocXEuczMuRmluZVVwbG9hZGVyLnByb3RvdHlwZSwgcXEudWlQcml2YXRlQXBpKTtcbiAgICB9KSgpO1xufSkod2luZG93KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXMzLmZpbmUtdXBsb2FkZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZpbmUtdXBsb2FkZXIvczMuZmluZS11cGxvYWRlci9zMy5maW5lLXVwbG9hZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 17 */
/***/ function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2llZWU3NTQvaW5kZXguanM/NzBmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pZWVlNzU0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 18 */
/***/ function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2lzYXJyYXkvaW5kZXguanM/ZWFiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pc2FycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 19 */
/***/ function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

eval("/**\n * Creates a new factory with attributes, options, etc. to be used to build\n * objects. Generally you should use `Factory.define()` instead of this\n * constructor.\n *\n * @param {Function=} constructor\n * @class\n */\nvar Factory = function(constructor) {\n  this.construct = constructor;\n  this._attrs = {};\n  this.opts = {};\n  this.sequences = {};\n  this.callbacks = [];\n};\n\nFactory.prototype = {\n  /**\n   * Define an attribute on this factory. Attributes can optionally define a\n   * default value, either as a value (e.g. a string or number) or as a builder\n   * function. For example:\n   *\n   *   // no default value for age\n   *   Factory.define('Person').attr('age')\n   *\n   *   // static default value for age\n   *   Factory.define('Person').attr('age', 18)\n   *\n   *   // dynamic default value for age\n   *   Factory.define('Person').attr('age', function() {\n   *      return Math.random() * 100;\n   *   })\n   *\n   * Attributes with dynamic default values can depend on options or other\n   * attributes:\n   *\n   *   Factory.define('Person').attr('age', ['name'], function(name) {\n   *     return name === 'Brian' ? 30 : 18;\n   *   });\n   *\n   * By default if the consumer of your factory provides a value for an\n   * attribute your builder function will not be called. You can override this\n   * behavior by declaring that your attribute depends on itself:\n   *\n   *   Factory.define('Person').attr('spouse', ['spouse'], function(spouse) {\n   *     return Factory.build('Person', spouse);\n   *   });\n   *\n   * As in the example above, this can be a useful way to fill in\n   * partially-specified child objects.\n   *\n   * @param {string} attr\n   * @param {Array.<string>=} dependencies\n   * @param {*=} value\n   * @return {Factory}\n   */\n  attr: function(attr, dependencies, value) {\n    var builder;\n    if (arguments.length === 2) {\n      value = dependencies;\n      dependencies = null;\n    }\n\n    builder = typeof value === 'function' ? value : function() { return value; };\n    this._attrs[attr] = { dependencies: dependencies || [], builder: builder };\n    return this;\n  },\n\n  /**\n   * Convenience function for defining a set of attributes on this object as\n   * builder functions or static values. If you need to specify dependencies,\n   * use #attr instead.\n   *\n   * For example:\n   *\n   *   Factory.define('Person').attrs({\n   *     name: 'Michael',\n   *     age: function() { return Math.random() * 100; }\n   *   });\n   *\n   * @param {object} attributes\n   * @return {Factory}\n   */\n  attrs: function(attributes) {\n    for (var attr in attributes) {\n      if (Factory.util.hasOwnProp(attributes, attr)) {\n        this.attr(attr, attributes[attr]);\n      }\n    }\n    return this;\n  },\n\n  /**\n   * Define an option for this factory. Options are values that may inform\n   * dynamic attribute behavior but are not included in objects built by the\n   * factory. Like attributes, options may have dependencies. Unlike\n   * attributes, options may only depend on other options.\n   *\n   *   Factory.define('Person')\n   *     .option('includeRelationships', false)\n   *     .attr(\n   *       'spouse',\n   *       ['spouse', 'includeRelationships'],\n   *       function(spouse, includeRelationships) {\n   *         return includeRelationships ?\n   *           Factory.build('Person', spouse) :\n   *           null;\n   *       });\n   *\n   *   Factory.build('Person', null, { includeRelationships: true });\n   *\n   * Options may have either static or dynamic default values, just like\n   * attributes. Options without default values must have a value specified\n   * when building.\n   *\n   * @param {string} opt\n   * @param {Array.<string>=} dependencies\n   * @param {*=} value\n   * @return {Factory}\n   */\n  option: function(opt, dependencies, value) {\n    var builder;\n    if (arguments.length === 2) {\n      value = dependencies;\n      dependencies = null;\n    }\n    if (arguments.length > 1) {\n      builder = typeof value === 'function' ? value : function() { return value; };\n    }\n    this.opts[opt] = { dependencies: dependencies || [], builder: builder };\n    return this;\n  },\n\n  /**\n   * Defines an attribute that, by default, simply has an auto-incrementing\n   * numeric value starting at 1. You can provide your own builder function\n   * that accepts the number of the sequence and returns whatever value you'd\n   * like it to be.\n   *\n   * Sequence values are inherited such that a factory derived from another\n   * with a sequence will share the state of that sequence and they will never\n   * conflict.\n   *\n   *   Factory.define('Person').sequence('id');\n   *\n   * @param {string} attr\n   * @param {Array.<string>=} dependencies\n   * @param {function(number): *=} builder\n   * @return {Factory}\n   */\n  sequence: function(attr, dependencies, builder) {\n    var factory = this;\n\n    if (arguments.length === 2) {\n      builder = /** @type function(number): * */dependencies;\n      dependencies = null;\n    }\n    builder = builder || function(i) { return i; };\n    return this.attr(attr, dependencies, function() {\n      var args = [].slice.call(arguments);\n\n      factory.sequences[attr] = factory.sequences[attr] || 0;\n      args.unshift(++factory.sequences[attr]);\n      return builder.apply(null, args);\n    });\n  },\n\n  /**\n   * Sets a post-processor callback that will receive built objects and the\n   * options for the build just before they are returned from the #build\n   * function.\n   *\n   * @param {function(object, object=)} callback\n   * @return {Factory}\n   */\n  after: function(callback) {\n    this.callbacks.push(callback);\n    return this;\n  },\n\n  /**\n   * Sets the constructor for this factory to be another factory. This can be\n   * used to create more specific sub-types of factories.\n   *\n   * @param {Factory} parentFactory\n   * @return {Factory}\n   */\n  inherits: function(parentFactory) {\n    console.warn('Factory#inherits is deprecated and will be removed in rosie v2. Please use Factory#extends instead.'); // eslint-disable-line no-console\n    this.construct = function(attributes, options) {\n      return Factory.build(parentFactory, attributes, options);\n    };\n    return this;\n  },\n\n  /**\n   * Builds a plain object containing values for each of the declared\n   * attributes. The result of this is the same as the result when using #build\n   * when there is no constructor registered.\n   *\n   * @param {object=} attributes\n   * @param {object=} options\n   * @return {object}\n   */\n  attributes: function(attributes, options) {\n    attributes = Factory.util.extend({}, attributes);\n    options = this.options(options);\n    for (var attr in this._attrs) {\n      this._attrValue(attr, attributes, options, [attr]);\n    }\n    return attributes;\n  },\n\n  /**\n   * Generates a value for the given named attribute and adds the result to the\n   * given attributes list.\n   *\n   * @private\n   * @param {string} attr\n   * @param {object} attributes\n   * @param {object} options\n   * @param {Array.<string>} stack\n   * @return {*}\n   */\n  _attrValue: function(attr, attributes, options, stack) {\n    if (!this._alwaysCallBuilder(attr) && Factory.util.hasOwnProp(attributes, attr)) {\n      return attributes[attr];\n    }\n\n    var value = this._buildWithDependencies(this._attrs[attr], function(dep) {\n      if (Factory.util.hasOwnProp(options, dep)) {\n        return options[dep];\n      } else if (dep === attr) {\n        return attributes[dep];\n      } else if (stack.indexOf(dep) >= 0) {\n        throw new Error('detected a dependency cycle: ' + stack.concat([dep]).join(' -> '));\n      } else {\n        return this._attrValue(dep, attributes, options, stack.concat([dep]));\n      }\n    });\n    attributes[attr] = value;\n    return value;\n  },\n\n  /**\n   * Determines whether the given named attribute has listed itself as a\n   * dependency.\n   *\n   * @private\n   * @param {string} attr\n   * @return {boolean}\n   */\n  _alwaysCallBuilder: function(attr) {\n    var attrMeta = this._attrs[attr];\n    return attrMeta.dependencies.indexOf(attr) >= 0;\n  },\n\n  /**\n   * Generates values for all the registered options using the values given.\n   *\n   * @private\n   * @param {?object} options\n   * @return {object}\n   */\n  options: function(options) {\n    options = Factory.util.extend({}, options || {});\n    for (var opt in this.opts) {\n      options[opt] = this._optionValue(opt, options);\n    }\n    return options;\n  },\n\n  /**\n   * Generates a value for the given named option and adds the result to the\n   * given options list.\n   *\n   * @private\n   * @param {string} opt\n   * @param {object} options\n   * @return {*}\n   */\n  _optionValue: function(opt, options) {\n    if (Factory.util.hasOwnProp(options, opt)) {\n      return options[opt];\n    }\n\n    var optMeta = this.opts[opt];\n    if (!optMeta.builder) {\n      throw new Error('option `' + opt + '` has no default value and none was provided');\n    }\n\n    return this._buildWithDependencies(optMeta, function(dep) {\n      return this._optionValue(dep, options);\n    });\n  },\n\n  /**\n   * Calls the builder function with its dependencies as determined by the\n   * given dependency resolver.\n   *\n   * @private\n   * @param {{builder: function(...[*]): *, dependencies: Array.<string>}} meta\n   * @param {function(string): *} getDep\n   * @return {*}\n   */\n  _buildWithDependencies: function(meta, getDep) {\n    var deps = meta.dependencies;\n    var self = this;\n    var args = deps.map(function(){ return getDep.apply(self, arguments); });\n    return meta.builder.apply(this, args);\n  },\n\n  /**\n   * Builds objects by getting values for all attributes and optionally passing\n   * the result to a constructor function.\n   *\n   * @param {object=} attributes\n   * @param {object=} options\n   * @return {*}\n   */\n  build: function(attributes, options) {\n    var result = this.attributes(attributes, options);\n    var retval = null;\n\n    if (this.construct) {\n      var Constructor = this.construct;\n      retval = new Constructor(result);\n    } else {\n      retval = result;\n    }\n\n    for (var i = 0; i < this.callbacks.length; i++) {\n      this.callbacks[i](retval, this.options(options));\n    }\n    return retval;\n  },\n\n  buildList: function(size, attributes, options) {\n    var objs = [];\n    for (var i = 0; i < size; i++) {\n      objs.push(this.build(attributes, options));\n    }\n    return objs;\n  },\n\n  /**\n   * Extends a given factory by copying over its attributes, options,\n   * callbacks, and constructor. This can be useful when you want to make\n   * different types which all share certain attributes.\n   *\n   * @param {string|Factory} name The factory to extend.\n   * @return {Factory}\n   */\n  extend: function(name) {\n    var factory = (typeof name === 'string') ? Factory.factories[name] : name;\n    // Copy the parent's constructor\n    if (this.construct === undefined) { this.construct = factory.construct; }\n    Factory.util.extend(this._attrs, factory._attrs);\n    Factory.util.extend(this.opts, factory.opts);\n    // Copy the parent's callbacks\n    this.callbacks = factory.callbacks.slice();\n    return this;\n  }\n};\n\n/**\n * @private\n */\nFactory.util = (function() {\n  var hasOwnProp = Object.prototype.hasOwnProperty;\n\n  return {\n    /**\n     * Determines whether `object` has its own property named `prop`.\n     *\n     * @private\n     * @param {object} object\n     * @param {string} prop\n     * @return {boolean}\n     */\n    hasOwnProp: function(object, prop) {\n      return hasOwnProp.call(object, prop);\n    },\n\n    /**\n     * Extends `dest` with all of own properties of `source`.\n     *\n     * @private\n     * @param {object} dest\n     * @param {object=} source\n     * @return {object}\n     */\n    extend: function(dest, source) {\n      if (source) {\n        for (var key in source) {\n          if (hasOwnProp.call(source, key)) {\n            dest[key] = source[key];\n          }\n        }\n      }\n      return dest;\n    }\n  };\n})();\n\nFactory.factories = {};\n\n/**\n * Defines a factory by name and constructor function. Call #attr and #option\n * on the result to define the properties of this factory.\n *\n * @param {!string} name\n * @param {function(object): *=} constructor\n * @return {Factory}\n */\nFactory.define = function(name, constructor) {\n  var factory = new Factory(constructor);\n  this.factories[name] = factory;\n  return factory;\n};\n\n/**\n * Locates a factory by name and calls #build on it.\n *\n * @param {string} name\n * @param {object=} attributes\n * @param {object=} options\n * @return {*}\n */\nFactory.build = function(name, attributes, options) {\n  if (!this.factories[name]) {\n    throw new Error('The \"' + name + '\" factory is not defined.');\n  }\n  return this.factories[name].build(attributes, options);\n};\n\n/**\n * Builds a collection of objects using the named factory.\n *\n * @param {string} name\n * @param {number} size\n * @param {object=} attributes\n * @param {object=} options\n * @return {Array.<*>}\n */\nFactory.buildList = function(name, size, attributes, options) {\n  var objs = [];\n  for (var i = 0; i < size; i++) {\n    objs.push(Factory.build(name, attributes, options));\n  }\n  return objs;\n};\n\n/**\n * Locates a factory by name and calls #attributes on it.\n *\n * @param {string} name\n * @param {object} attributes\n * @param {object} options\n * @return {object}\n */\nFactory.attributes = function(name, attributes, options) {\n  return this.factories[name].attributes(attributes, options);\n};\n\nif (true) {\n  exports.Factory = Factory;\n} else if (typeof define === 'function' && define.amd) {\n  define([], function() { return {Factory: Factory}; });\n} else if (this) {\n  this.Factory = Factory;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Jvc2llL3NyYy9yb3NpZS5qcz80OTBiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmYWN0b3J5IHdpdGggYXR0cmlidXRlcywgb3B0aW9ucywgZXRjLiB0byBiZSB1c2VkIHRvIGJ1aWxkXG4gKiBvYmplY3RzLiBHZW5lcmFsbHkgeW91IHNob3VsZCB1c2UgYEZhY3RvcnkuZGVmaW5lKClgIGluc3RlYWQgb2YgdGhpc1xuICogY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbj19IGNvbnN0cnVjdG9yXG4gKiBAY2xhc3NcbiAqL1xudmFyIEZhY3RvcnkgPSBmdW5jdGlvbihjb25zdHJ1Y3Rvcikge1xuICB0aGlzLmNvbnN0cnVjdCA9IGNvbnN0cnVjdG9yO1xuICB0aGlzLl9hdHRycyA9IHt9O1xuICB0aGlzLm9wdHMgPSB7fTtcbiAgdGhpcy5zZXF1ZW5jZXMgPSB7fTtcbiAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbn07XG5cbkZhY3RvcnkucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogRGVmaW5lIGFuIGF0dHJpYnV0ZSBvbiB0aGlzIGZhY3RvcnkuIEF0dHJpYnV0ZXMgY2FuIG9wdGlvbmFsbHkgZGVmaW5lIGFcbiAgICogZGVmYXVsdCB2YWx1ZSwgZWl0aGVyIGFzIGEgdmFsdWUgKGUuZy4gYSBzdHJpbmcgb3IgbnVtYmVyKSBvciBhcyBhIGJ1aWxkZXJcbiAgICogZnVuY3Rpb24uIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgIC8vIG5vIGRlZmF1bHQgdmFsdWUgZm9yIGFnZVxuICAgKiAgIEZhY3RvcnkuZGVmaW5lKCdQZXJzb24nKS5hdHRyKCdhZ2UnKVxuICAgKlxuICAgKiAgIC8vIHN0YXRpYyBkZWZhdWx0IHZhbHVlIGZvciBhZ2VcbiAgICogICBGYWN0b3J5LmRlZmluZSgnUGVyc29uJykuYXR0cignYWdlJywgMTgpXG4gICAqXG4gICAqICAgLy8gZHluYW1pYyBkZWZhdWx0IHZhbHVlIGZvciBhZ2VcbiAgICogICBGYWN0b3J5LmRlZmluZSgnUGVyc29uJykuYXR0cignYWdlJywgZnVuY3Rpb24oKSB7XG4gICAqICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAxMDA7XG4gICAqICAgfSlcbiAgICpcbiAgICogQXR0cmlidXRlcyB3aXRoIGR5bmFtaWMgZGVmYXVsdCB2YWx1ZXMgY2FuIGRlcGVuZCBvbiBvcHRpb25zIG9yIG90aGVyXG4gICAqIGF0dHJpYnV0ZXM6XG4gICAqXG4gICAqICAgRmFjdG9yeS5kZWZpbmUoJ1BlcnNvbicpLmF0dHIoJ2FnZScsIFsnbmFtZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAqICAgICByZXR1cm4gbmFtZSA9PT0gJ0JyaWFuJyA/IDMwIDogMTg7XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgaWYgdGhlIGNvbnN1bWVyIG9mIHlvdXIgZmFjdG9yeSBwcm92aWRlcyBhIHZhbHVlIGZvciBhblxuICAgKiBhdHRyaWJ1dGUgeW91ciBidWlsZGVyIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGNhbGxlZC4gWW91IGNhbiBvdmVycmlkZSB0aGlzXG4gICAqIGJlaGF2aW9yIGJ5IGRlY2xhcmluZyB0aGF0IHlvdXIgYXR0cmlidXRlIGRlcGVuZHMgb24gaXRzZWxmOlxuICAgKlxuICAgKiAgIEZhY3RvcnkuZGVmaW5lKCdQZXJzb24nKS5hdHRyKCdzcG91c2UnLCBbJ3Nwb3VzZSddLCBmdW5jdGlvbihzcG91c2UpIHtcbiAgICogICAgIHJldHVybiBGYWN0b3J5LmJ1aWxkKCdQZXJzb24nLCBzcG91c2UpO1xuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBcyBpbiB0aGUgZXhhbXBsZSBhYm92ZSwgdGhpcyBjYW4gYmUgYSB1c2VmdWwgd2F5IHRvIGZpbGwgaW5cbiAgICogcGFydGlhbGx5LXNwZWNpZmllZCBjaGlsZCBvYmplY3RzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+PX0gZGVwZW5kZW5jaWVzXG4gICAqIEBwYXJhbSB7Kj19IHZhbHVlXG4gICAqIEByZXR1cm4ge0ZhY3Rvcnl9XG4gICAqL1xuICBhdHRyOiBmdW5jdGlvbihhdHRyLCBkZXBlbmRlbmNpZXMsIHZhbHVlKSB7XG4gICAgdmFyIGJ1aWxkZXI7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhbHVlID0gZGVwZW5kZW5jaWVzO1xuICAgICAgZGVwZW5kZW5jaWVzID0gbnVsbDtcbiAgICB9XG5cbiAgICBidWlsZGVyID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBmdW5jdGlvbigpIHsgcmV0dXJuIHZhbHVlOyB9O1xuICAgIHRoaXMuX2F0dHJzW2F0dHJdID0geyBkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llcyB8fCBbXSwgYnVpbGRlcjogYnVpbGRlciB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgZGVmaW5pbmcgYSBzZXQgb2YgYXR0cmlidXRlcyBvbiB0aGlzIG9iamVjdCBhc1xuICAgKiBidWlsZGVyIGZ1bmN0aW9ucyBvciBzdGF0aWMgdmFsdWVzLiBJZiB5b3UgbmVlZCB0byBzcGVjaWZ5IGRlcGVuZGVuY2llcyxcbiAgICogdXNlICNhdHRyIGluc3RlYWQuXG4gICAqXG4gICAqIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgIEZhY3RvcnkuZGVmaW5lKCdQZXJzb24nKS5hdHRycyh7XG4gICAqICAgICBuYW1lOiAnTWljaGFlbCcsXG4gICAqICAgICBhZ2U6IGZ1bmN0aW9uKCkgeyByZXR1cm4gTWF0aC5yYW5kb20oKSAqIDEwMDsgfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlc1xuICAgKiBAcmV0dXJuIHtGYWN0b3J5fVxuICAgKi9cbiAgYXR0cnM6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICBmb3IgKHZhciBhdHRyIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChGYWN0b3J5LnV0aWwuaGFzT3duUHJvcChhdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICB0aGlzLmF0dHIoYXR0ciwgYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYW4gb3B0aW9uIGZvciB0aGlzIGZhY3RvcnkuIE9wdGlvbnMgYXJlIHZhbHVlcyB0aGF0IG1heSBpbmZvcm1cbiAgICogZHluYW1pYyBhdHRyaWJ1dGUgYmVoYXZpb3IgYnV0IGFyZSBub3QgaW5jbHVkZWQgaW4gb2JqZWN0cyBidWlsdCBieSB0aGVcbiAgICogZmFjdG9yeS4gTGlrZSBhdHRyaWJ1dGVzLCBvcHRpb25zIG1heSBoYXZlIGRlcGVuZGVuY2llcy4gVW5saWtlXG4gICAqIGF0dHJpYnV0ZXMsIG9wdGlvbnMgbWF5IG9ubHkgZGVwZW5kIG9uIG90aGVyIG9wdGlvbnMuXG4gICAqXG4gICAqICAgRmFjdG9yeS5kZWZpbmUoJ1BlcnNvbicpXG4gICAqICAgICAub3B0aW9uKCdpbmNsdWRlUmVsYXRpb25zaGlwcycsIGZhbHNlKVxuICAgKiAgICAgLmF0dHIoXG4gICAqICAgICAgICdzcG91c2UnLFxuICAgKiAgICAgICBbJ3Nwb3VzZScsICdpbmNsdWRlUmVsYXRpb25zaGlwcyddLFxuICAgKiAgICAgICBmdW5jdGlvbihzcG91c2UsIGluY2x1ZGVSZWxhdGlvbnNoaXBzKSB7XG4gICAqICAgICAgICAgcmV0dXJuIGluY2x1ZGVSZWxhdGlvbnNoaXBzID9cbiAgICogICAgICAgICAgIEZhY3RvcnkuYnVpbGQoJ1BlcnNvbicsIHNwb3VzZSkgOlxuICAgKiAgICAgICAgICAgbnVsbDtcbiAgICogICAgICAgfSk7XG4gICAqXG4gICAqICAgRmFjdG9yeS5idWlsZCgnUGVyc29uJywgbnVsbCwgeyBpbmNsdWRlUmVsYXRpb25zaGlwczogdHJ1ZSB9KTtcbiAgICpcbiAgICogT3B0aW9ucyBtYXkgaGF2ZSBlaXRoZXIgc3RhdGljIG9yIGR5bmFtaWMgZGVmYXVsdCB2YWx1ZXMsIGp1c3QgbGlrZVxuICAgKiBhdHRyaWJ1dGVzLiBPcHRpb25zIHdpdGhvdXQgZGVmYXVsdCB2YWx1ZXMgbXVzdCBoYXZlIGEgdmFsdWUgc3BlY2lmaWVkXG4gICAqIHdoZW4gYnVpbGRpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRcbiAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPj19IGRlcGVuZGVuY2llc1xuICAgKiBAcGFyYW0geyo9fSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtGYWN0b3J5fVxuICAgKi9cbiAgb3B0aW9uOiBmdW5jdGlvbihvcHQsIGRlcGVuZGVuY2llcywgdmFsdWUpIHtcbiAgICB2YXIgYnVpbGRlcjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFsdWUgPSBkZXBlbmRlbmNpZXM7XG4gICAgICBkZXBlbmRlbmNpZXMgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGJ1aWxkZXIgPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdmFsdWU7IH07XG4gICAgfVxuICAgIHRoaXMub3B0c1tvcHRdID0geyBkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llcyB8fCBbXSwgYnVpbGRlcjogYnVpbGRlciB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGFuIGF0dHJpYnV0ZSB0aGF0LCBieSBkZWZhdWx0LCBzaW1wbHkgaGFzIGFuIGF1dG8taW5jcmVtZW50aW5nXG4gICAqIG51bWVyaWMgdmFsdWUgc3RhcnRpbmcgYXQgMS4gWW91IGNhbiBwcm92aWRlIHlvdXIgb3duIGJ1aWxkZXIgZnVuY3Rpb25cbiAgICogdGhhdCBhY2NlcHRzIHRoZSBudW1iZXIgb2YgdGhlIHNlcXVlbmNlIGFuZCByZXR1cm5zIHdoYXRldmVyIHZhbHVlIHlvdSdkXG4gICAqIGxpa2UgaXQgdG8gYmUuXG4gICAqXG4gICAqIFNlcXVlbmNlIHZhbHVlcyBhcmUgaW5oZXJpdGVkIHN1Y2ggdGhhdCBhIGZhY3RvcnkgZGVyaXZlZCBmcm9tIGFub3RoZXJcbiAgICogd2l0aCBhIHNlcXVlbmNlIHdpbGwgc2hhcmUgdGhlIHN0YXRlIG9mIHRoYXQgc2VxdWVuY2UgYW5kIHRoZXkgd2lsbCBuZXZlclxuICAgKiBjb25mbGljdC5cbiAgICpcbiAgICogICBGYWN0b3J5LmRlZmluZSgnUGVyc29uJykuc2VxdWVuY2UoJ2lkJyk7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz49fSBkZXBlbmRlbmNpZXNcbiAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpOiAqPX0gYnVpbGRlclxuICAgKiBAcmV0dXJuIHtGYWN0b3J5fVxuICAgKi9cbiAgc2VxdWVuY2U6IGZ1bmN0aW9uKGF0dHIsIGRlcGVuZGVuY2llcywgYnVpbGRlcikge1xuICAgIHZhciBmYWN0b3J5ID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBidWlsZGVyID0gLyoqIEB0eXBlIGZ1bmN0aW9uKG51bWJlcik6ICogKi9kZXBlbmRlbmNpZXM7XG4gICAgICBkZXBlbmRlbmNpZXMgPSBudWxsO1xuICAgIH1cbiAgICBidWlsZGVyID0gYnVpbGRlciB8fCBmdW5jdGlvbihpKSB7IHJldHVybiBpOyB9O1xuICAgIHJldHVybiB0aGlzLmF0dHIoYXR0ciwgZGVwZW5kZW5jaWVzLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICBmYWN0b3J5LnNlcXVlbmNlc1thdHRyXSA9IGZhY3Rvcnkuc2VxdWVuY2VzW2F0dHJdIHx8IDA7XG4gICAgICBhcmdzLnVuc2hpZnQoKytmYWN0b3J5LnNlcXVlbmNlc1thdHRyXSk7XG4gICAgICByZXR1cm4gYnVpbGRlci5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHBvc3QtcHJvY2Vzc29yIGNhbGxiYWNrIHRoYXQgd2lsbCByZWNlaXZlIGJ1aWx0IG9iamVjdHMgYW5kIHRoZVxuICAgKiBvcHRpb25zIGZvciB0aGUgYnVpbGQganVzdCBiZWZvcmUgdGhleSBhcmUgcmV0dXJuZWQgZnJvbSB0aGUgI2J1aWxkXG4gICAqIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCwgb2JqZWN0PSl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge0ZhY3Rvcnl9XG4gICAqL1xuICBhZnRlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB0aGlzLmNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgY29uc3RydWN0b3IgZm9yIHRoaXMgZmFjdG9yeSB0byBiZSBhbm90aGVyIGZhY3RvcnkuIFRoaXMgY2FuIGJlXG4gICAqIHVzZWQgdG8gY3JlYXRlIG1vcmUgc3BlY2lmaWMgc3ViLXR5cGVzIG9mIGZhY3Rvcmllcy5cbiAgICpcbiAgICogQHBhcmFtIHtGYWN0b3J5fSBwYXJlbnRGYWN0b3J5XG4gICAqIEByZXR1cm4ge0ZhY3Rvcnl9XG4gICAqL1xuICBpbmhlcml0czogZnVuY3Rpb24ocGFyZW50RmFjdG9yeSkge1xuICAgIGNvbnNvbGUud2FybignRmFjdG9yeSNpbmhlcml0cyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gcm9zaWUgdjIuIFBsZWFzZSB1c2UgRmFjdG9yeSNleHRlbmRzIGluc3RlYWQuJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIHRoaXMuY29uc3RydWN0ID0gZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIEZhY3RvcnkuYnVpbGQocGFyZW50RmFjdG9yeSwgYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQnVpbGRzIGEgcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgdmFsdWVzIGZvciBlYWNoIG9mIHRoZSBkZWNsYXJlZFxuICAgKiBhdHRyaWJ1dGVzLiBUaGUgcmVzdWx0IG9mIHRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIHJlc3VsdCB3aGVuIHVzaW5nICNidWlsZFxuICAgKiB3aGVuIHRoZXJlIGlzIG5vIGNvbnN0cnVjdG9yIHJlZ2lzdGVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0PX0gYXR0cmlidXRlc1xuICAgKiBAcGFyYW0ge29iamVjdD19IG9wdGlvbnNcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKi9cbiAgYXR0cmlidXRlczogZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIGF0dHJpYnV0ZXMgPSBGYWN0b3J5LnV0aWwuZXh0ZW5kKHt9LCBhdHRyaWJ1dGVzKTtcbiAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zKG9wdGlvbnMpO1xuICAgIGZvciAodmFyIGF0dHIgaW4gdGhpcy5fYXR0cnMpIHtcbiAgICAgIHRoaXMuX2F0dHJWYWx1ZShhdHRyLCBhdHRyaWJ1dGVzLCBvcHRpb25zLCBbYXR0cl0pO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfSxcblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgdmFsdWUgZm9yIHRoZSBnaXZlbiBuYW1lZCBhdHRyaWJ1dGUgYW5kIGFkZHMgdGhlIHJlc3VsdCB0byB0aGVcbiAgICogZ2l2ZW4gYXR0cmlidXRlcyBsaXN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBzdGFja1xuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgX2F0dHJWYWx1ZTogZnVuY3Rpb24oYXR0ciwgYXR0cmlidXRlcywgb3B0aW9ucywgc3RhY2spIHtcbiAgICBpZiAoIXRoaXMuX2Fsd2F5c0NhbGxCdWlsZGVyKGF0dHIpICYmIEZhY3RvcnkudXRpbC5oYXNPd25Qcm9wKGF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlc1thdHRyXTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSB0aGlzLl9idWlsZFdpdGhEZXBlbmRlbmNpZXModGhpcy5fYXR0cnNbYXR0cl0sIGZ1bmN0aW9uKGRlcCkge1xuICAgICAgaWYgKEZhY3RvcnkudXRpbC5oYXNPd25Qcm9wKG9wdGlvbnMsIGRlcCkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNbZGVwXTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwID09PSBhdHRyKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzW2RlcF07XG4gICAgICB9IGVsc2UgaWYgKHN0YWNrLmluZGV4T2YoZGVwKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGV0ZWN0ZWQgYSBkZXBlbmRlbmN5IGN5Y2xlOiAnICsgc3RhY2suY29uY2F0KFtkZXBdKS5qb2luKCcgLT4gJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dHJWYWx1ZShkZXAsIGF0dHJpYnV0ZXMsIG9wdGlvbnMsIHN0YWNrLmNvbmNhdChbZGVwXSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGF0dHJpYnV0ZXNbYXR0cl0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gbmFtZWQgYXR0cmlidXRlIGhhcyBsaXN0ZWQgaXRzZWxmIGFzIGFcbiAgICogZGVwZW5kZW5jeS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIF9hbHdheXNDYWxsQnVpbGRlcjogZnVuY3Rpb24oYXR0cikge1xuICAgIHZhciBhdHRyTWV0YSA9IHRoaXMuX2F0dHJzW2F0dHJdO1xuICAgIHJldHVybiBhdHRyTWV0YS5kZXBlbmRlbmNpZXMuaW5kZXhPZihhdHRyKSA+PSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdmFsdWVzIGZvciBhbGwgdGhlIHJlZ2lzdGVyZWQgb3B0aW9ucyB1c2luZyB0aGUgdmFsdWVzIGdpdmVuLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKi9cbiAgb3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBGYWN0b3J5LnV0aWwuZXh0ZW5kKHt9LCBvcHRpb25zIHx8IHt9KTtcbiAgICBmb3IgKHZhciBvcHQgaW4gdGhpcy5vcHRzKSB7XG4gICAgICBvcHRpb25zW29wdF0gPSB0aGlzLl9vcHRpb25WYWx1ZShvcHQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfSxcblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgdmFsdWUgZm9yIHRoZSBnaXZlbiBuYW1lZCBvcHRpb24gYW5kIGFkZHMgdGhlIHJlc3VsdCB0byB0aGVcbiAgICogZ2l2ZW4gb3B0aW9ucyBsaXN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBfb3B0aW9uVmFsdWU6IGZ1bmN0aW9uKG9wdCwgb3B0aW9ucykge1xuICAgIGlmIChGYWN0b3J5LnV0aWwuaGFzT3duUHJvcChvcHRpb25zLCBvcHQpKSB7XG4gICAgICByZXR1cm4gb3B0aW9uc1tvcHRdO1xuICAgIH1cblxuICAgIHZhciBvcHRNZXRhID0gdGhpcy5vcHRzW29wdF07XG4gICAgaWYgKCFvcHRNZXRhLmJ1aWxkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9uIGAnICsgb3B0ICsgJ2AgaGFzIG5vIGRlZmF1bHQgdmFsdWUgYW5kIG5vbmUgd2FzIHByb3ZpZGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2J1aWxkV2l0aERlcGVuZGVuY2llcyhvcHRNZXRhLCBmdW5jdGlvbihkZXApIHtcbiAgICAgIHJldHVybiB0aGlzLl9vcHRpb25WYWx1ZShkZXAsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxscyB0aGUgYnVpbGRlciBmdW5jdGlvbiB3aXRoIGl0cyBkZXBlbmRlbmNpZXMgYXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAgICogZ2l2ZW4gZGVwZW5kZW5jeSByZXNvbHZlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHt7YnVpbGRlcjogZnVuY3Rpb24oLi4uWypdKTogKiwgZGVwZW5kZW5jaWVzOiBBcnJheS48c3RyaW5nPn19IG1ldGFcbiAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpOiAqfSBnZXREZXBcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIF9idWlsZFdpdGhEZXBlbmRlbmNpZXM6IGZ1bmN0aW9uKG1ldGEsIGdldERlcCkge1xuICAgIHZhciBkZXBzID0gbWV0YS5kZXBlbmRlbmNpZXM7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gZGVwcy5tYXAoZnVuY3Rpb24oKXsgcmV0dXJuIGdldERlcC5hcHBseShzZWxmLCBhcmd1bWVudHMpOyB9KTtcbiAgICByZXR1cm4gbWV0YS5idWlsZGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBCdWlsZHMgb2JqZWN0cyBieSBnZXR0aW5nIHZhbHVlcyBmb3IgYWxsIGF0dHJpYnV0ZXMgYW5kIG9wdGlvbmFsbHkgcGFzc2luZ1xuICAgKiB0aGUgcmVzdWx0IHRvIGEgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0PX0gYXR0cmlidXRlc1xuICAgKiBAcGFyYW0ge29iamVjdD19IG9wdGlvbnNcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGJ1aWxkOiBmdW5jdGlvbihhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuYXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICB2YXIgcmV0dmFsID0gbnVsbDtcblxuICAgIGlmICh0aGlzLmNvbnN0cnVjdCkge1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3Q7XG4gICAgICByZXR2YWwgPSBuZXcgQ29uc3RydWN0b3IocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dmFsID0gcmVzdWx0O1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzW2ldKHJldHZhbCwgdGhpcy5vcHRpb25zKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHZhbDtcbiAgfSxcblxuICBidWlsZExpc3Q6IGZ1bmN0aW9uKHNpemUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBvYmpzLnB1c2godGhpcy5idWlsZChhdHRyaWJ1dGVzLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmpzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHRlbmRzIGEgZ2l2ZW4gZmFjdG9yeSBieSBjb3B5aW5nIG92ZXIgaXRzIGF0dHJpYnV0ZXMsIG9wdGlvbnMsXG4gICAqIGNhbGxiYWNrcywgYW5kIGNvbnN0cnVjdG9yLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBtYWtlXG4gICAqIGRpZmZlcmVudCB0eXBlcyB3aGljaCBhbGwgc2hhcmUgY2VydGFpbiBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xGYWN0b3J5fSBuYW1lIFRoZSBmYWN0b3J5IHRvIGV4dGVuZC5cbiAgICogQHJldHVybiB7RmFjdG9yeX1cbiAgICovXG4gIGV4dGVuZDogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBmYWN0b3J5ID0gKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykgPyBGYWN0b3J5LmZhY3Rvcmllc1tuYW1lXSA6IG5hbWU7XG4gICAgLy8gQ29weSB0aGUgcGFyZW50J3MgY29uc3RydWN0b3JcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3QgPT09IHVuZGVmaW5lZCkgeyB0aGlzLmNvbnN0cnVjdCA9IGZhY3RvcnkuY29uc3RydWN0OyB9XG4gICAgRmFjdG9yeS51dGlsLmV4dGVuZCh0aGlzLl9hdHRycywgZmFjdG9yeS5fYXR0cnMpO1xuICAgIEZhY3RvcnkudXRpbC5leHRlbmQodGhpcy5vcHRzLCBmYWN0b3J5Lm9wdHMpO1xuICAgIC8vIENvcHkgdGhlIHBhcmVudCdzIGNhbGxiYWNrc1xuICAgIHRoaXMuY2FsbGJhY2tzID0gZmFjdG9yeS5jYWxsYmFja3Muc2xpY2UoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5GYWN0b3J5LnV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBoYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBgb2JqZWN0YCBoYXMgaXRzIG93biBwcm9wZXJ0eSBuYW1lZCBgcHJvcGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzT3duUHJvcDogZnVuY3Rpb24ob2JqZWN0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gaGFzT3duUHJvcC5jYWxsKG9iamVjdCwgcHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZHMgYGRlc3RgIHdpdGggYWxsIG9mIG93biBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGVzdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gc291cmNlXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqL1xuICAgIGV4dGVuZDogZnVuY3Rpb24oZGVzdCwgc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcC5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgZGVzdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gIH07XG59KSgpO1xuXG5GYWN0b3J5LmZhY3RvcmllcyA9IHt9O1xuXG4vKipcbiAqIERlZmluZXMgYSBmYWN0b3J5IGJ5IG5hbWUgYW5kIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLiBDYWxsICNhdHRyIGFuZCAjb3B0aW9uXG4gKiBvbiB0aGUgcmVzdWx0IHRvIGRlZmluZSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIGZhY3RvcnkuXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICo9fSBjb25zdHJ1Y3RvclxuICogQHJldHVybiB7RmFjdG9yeX1cbiAqL1xuRmFjdG9yeS5kZWZpbmUgPSBmdW5jdGlvbihuYW1lLCBjb25zdHJ1Y3Rvcikge1xuICB2YXIgZmFjdG9yeSA9IG5ldyBGYWN0b3J5KGNvbnN0cnVjdG9yKTtcbiAgdGhpcy5mYWN0b3JpZXNbbmFtZV0gPSBmYWN0b3J5O1xuICByZXR1cm4gZmFjdG9yeTtcbn07XG5cbi8qKlxuICogTG9jYXRlcyBhIGZhY3RvcnkgYnkgbmFtZSBhbmQgY2FsbHMgI2J1aWxkIG9uIGl0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge29iamVjdD19IGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7Kn1cbiAqL1xuRmFjdG9yeS5idWlsZCA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgaWYgKCF0aGlzLmZhY3Rvcmllc1tuYW1lXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIFwiJyArIG5hbWUgKyAnXCIgZmFjdG9yeSBpcyBub3QgZGVmaW5lZC4nKTtcbiAgfVxuICByZXR1cm4gdGhpcy5mYWN0b3JpZXNbbmFtZV0uYnVpbGQoYXR0cmlidXRlcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIGNvbGxlY3Rpb24gb2Ygb2JqZWN0cyB1c2luZyB0aGUgbmFtZWQgZmFjdG9yeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IHNpemVcbiAqIEBwYXJhbSB7b2JqZWN0PX0gYXR0cmlidXRlc1xuICogQHBhcmFtIHtvYmplY3Q9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtBcnJheS48Kj59XG4gKi9cbkZhY3RvcnkuYnVpbGRMaXN0ID0gZnVuY3Rpb24obmFtZSwgc2l6ZSwgYXR0cmlidXRlcywgb3B0aW9ucykge1xuICB2YXIgb2JqcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIG9ianMucHVzaChGYWN0b3J5LmJ1aWxkKG5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpKTtcbiAgfVxuICByZXR1cm4gb2Jqcztcbn07XG5cbi8qKlxuICogTG9jYXRlcyBhIGZhY3RvcnkgYnkgbmFtZSBhbmQgY2FsbHMgI2F0dHJpYnV0ZXMgb24gaXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5GYWN0b3J5LmF0dHJpYnV0ZXMgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmZhY3Rvcmllc1tuYW1lXS5hdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xufTtcblxuaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICBleHBvcnRzLkZhY3RvcnkgPSBGYWN0b3J5O1xufSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIHtGYWN0b3J5OiBGYWN0b3J5fTsgfSk7XG59IGVsc2UgaWYgKHRoaXMpIHtcbiAgdGhpcy5GYWN0b3J5ID0gRmFjdG9yeTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yb3NpZS9zcmMvcm9zaWUuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

eval("var Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(9),\n  /* template */\n  __webpack_require__(27),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = \"/Users/craigw/JavascriptPackages/file-manager/components/file.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key !== \"__esModule\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] file.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-09a8c207\", Component.options)\n  } else {\n    if (module.hot.data.cssModules && JSON.stringify(module.hot.data.cssModules) !== JSON.stringify(cssModules)) {\n      delete Component.options._Ctor\n    }\n    hotAPI.reload(\"data-v-09a8c207\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    data.cssModules = cssModules\n  })\n})()}\n\nmodule.exports = Component.exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2ZpbGUudnVlPzAzNzciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFidWJsZS1sb2FkZXI/e1xcXCJvYmplY3RBc3NpZ25cXFwiOlxcXCJPYmplY3QuYXNzaWduXFxcIn0hLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL2ZpbGUudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj9pZD1kYXRhLXYtMDlhOGMyMDchLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vZmlsZS52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIi9Vc2Vycy9jcmFpZ3cvSmF2YXNjcmlwdFBhY2thZ2VzL2ZpbGUtbWFuYWdlci9jb21wb25lbnRzL2ZpbGUudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkgIT09IFwiX19lc01vZHVsZVwifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gZmlsZS52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMDlhOGMyMDdcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaWYgKG1vZHVsZS5ob3QuZGF0YS5jc3NNb2R1bGVzICYmIEpTT04uc3RyaW5naWZ5KG1vZHVsZS5ob3QuZGF0YS5jc3NNb2R1bGVzKSAhPT0gSlNPTi5zdHJpbmdpZnkoY3NzTW9kdWxlcykpIHtcbiAgICAgIGRlbGV0ZSBDb21wb25lbnQub3B0aW9ucy5fQ3RvclxuICAgIH1cbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTA5YThjMjA3XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRhdGEuY3NzTW9kdWxlcyA9IGNzc01vZHVsZXNcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9maWxlLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

eval("var Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(10),\n  /* template */\n  __webpack_require__(28),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = \"/Users/craigw/JavascriptPackages/file-manager/components/files.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key !== \"__esModule\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] files.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-2f1b1ffc\", Component.options)\n  } else {\n    if (module.hot.data.cssModules && JSON.stringify(module.hot.data.cssModules) !== JSON.stringify(cssModules)) {\n      delete Component.options._Ctor\n    }\n    hotAPI.reload(\"data-v-2f1b1ffc\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    data.cssModules = cssModules\n  })\n})()}\n\nmodule.exports = Component.exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2ZpbGVzLnZ1ZT85OGE1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYnVibGUtbG9hZGVyP3tcXFwib2JqZWN0QXNzaWduXFxcIjpcXFwiT2JqZWN0LmFzc2lnblxcXCJ9IS4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9maWxlcy52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP2lkPWRhdGEtdi0yZjFiMWZmYyEuLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9maWxlcy52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIi9Vc2Vycy9jcmFpZ3cvSmF2YXNjcmlwdFBhY2thZ2VzL2ZpbGUtbWFuYWdlci9jb21wb25lbnRzL2ZpbGVzLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIGZpbGVzLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0yZjFiMWZmY1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBpZiAobW9kdWxlLmhvdC5kYXRhLmNzc01vZHVsZXMgJiYgSlNPTi5zdHJpbmdpZnkobW9kdWxlLmhvdC5kYXRhLmNzc01vZHVsZXMpICE9PSBKU09OLnN0cmluZ2lmeShjc3NNb2R1bGVzKSkge1xuICAgICAgZGVsZXRlIENvbXBvbmVudC5vcHRpb25zLl9DdG9yXG4gICAgfVxuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMmYxYjFmZmNcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGF0YS5jc3NNb2R1bGVzID0gY3NzTW9kdWxlc1xuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL2ZpbGVzLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

eval("var Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(11),\n  /* template */\n  __webpack_require__(29),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = \"/Users/craigw/JavascriptPackages/file-manager/components/main.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key !== \"__esModule\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] main.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-34ff6bc4\", Component.options)\n  } else {\n    if (module.hot.data.cssModules && JSON.stringify(module.hot.data.cssModules) !== JSON.stringify(cssModules)) {\n      delete Component.options._Ctor\n    }\n    hotAPI.reload(\"data-v-34ff6bc4\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    data.cssModules = cssModules\n  })\n})()}\n\nmodule.exports = Component.exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL21haW4udnVlPzVmZTIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFidWJsZS1sb2FkZXI/e1xcXCJvYmplY3RBc3NpZ25cXFwiOlxcXCJPYmplY3QuYXNzaWduXFxcIn0hLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL21haW4udnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj9pZD1kYXRhLXYtMzRmZjZiYzQhLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vbWFpbi52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIi9Vc2Vycy9jcmFpZ3cvSmF2YXNjcmlwdFBhY2thZ2VzL2ZpbGUtbWFuYWdlci9jb21wb25lbnRzL21haW4udnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkgIT09IFwiX19lc01vZHVsZVwifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gbWFpbi52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMzRmZjZiYzRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaWYgKG1vZHVsZS5ob3QuZGF0YS5jc3NNb2R1bGVzICYmIEpTT04uc3RyaW5naWZ5KG1vZHVsZS5ob3QuZGF0YS5jc3NNb2R1bGVzKSAhPT0gSlNPTi5zdHJpbmdpZnkoY3NzTW9kdWxlcykpIHtcbiAgICAgIGRlbGV0ZSBDb21wb25lbnQub3B0aW9ucy5fQ3RvclxuICAgIH1cbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTM0ZmY2YmM0XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRhdGEuY3NzTW9kdWxlcyA9IGNzc01vZHVsZXNcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9tYWluLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

eval("var Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(12),\n  /* template */\n  __webpack_require__(26),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = \"/Users/craigw/JavascriptPackages/file-manager/components/modal.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key !== \"__esModule\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] modal.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-044d559c\", Component.options)\n  } else {\n    if (module.hot.data.cssModules && JSON.stringify(module.hot.data.cssModules) !== JSON.stringify(cssModules)) {\n      delete Component.options._Ctor\n    }\n    hotAPI.reload(\"data-v-044d559c\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    data.cssModules = cssModules\n  })\n})()}\n\nmodule.exports = Component.exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL21vZGFsLnZ1ZT9iNGMwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYnVibGUtbG9hZGVyP3tcXFwib2JqZWN0QXNzaWduXFxcIjpcXFwiT2JqZWN0LmFzc2lnblxcXCJ9IS4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9tb2RhbC52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP2lkPWRhdGEtdi0wNDRkNTU5YyEuLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9tb2RhbC52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIi9Vc2Vycy9jcmFpZ3cvSmF2YXNjcmlwdFBhY2thZ2VzL2ZpbGUtbWFuYWdlci9jb21wb25lbnRzL21vZGFsLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIG1vZGFsLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0wNDRkNTU5Y1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBpZiAobW9kdWxlLmhvdC5kYXRhLmNzc01vZHVsZXMgJiYgSlNPTi5zdHJpbmdpZnkobW9kdWxlLmhvdC5kYXRhLmNzc01vZHVsZXMpICE9PSBKU09OLnN0cmluZ2lmeShjc3NNb2R1bGVzKSkge1xuICAgICAgZGVsZXRlIENvbXBvbmVudC5vcHRpb25zLl9DdG9yXG4gICAgfVxuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMDQ0ZDU1OWNcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGF0YS5jc3NNb2R1bGVzID0gY3NzTW9kdWxlc1xuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL21vZGFsLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

eval("var Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(13),\n  /* template */\n  __webpack_require__(30),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = \"/Users/craigw/JavascriptPackages/file-manager/components/uploader.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key !== \"__esModule\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] uploader.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-59471f0e\", Component.options)\n  } else {\n    if (module.hot.data.cssModules && JSON.stringify(module.hot.data.cssModules) !== JSON.stringify(cssModules)) {\n      delete Component.options._Ctor\n    }\n    hotAPI.reload(\"data-v-59471f0e\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    data.cssModules = cssModules\n  })\n})()}\n\nmodule.exports = Component.exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3VwbG9hZGVyLnZ1ZT9lMTBhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYnVibGUtbG9hZGVyP3tcXFwib2JqZWN0QXNzaWduXFxcIjpcXFwiT2JqZWN0LmFzc2lnblxcXCJ9IS4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi91cGxvYWRlci52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP2lkPWRhdGEtdi01OTQ3MWYwZSEuLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi91cGxvYWRlci52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIi9Vc2Vycy9jcmFpZ3cvSmF2YXNjcmlwdFBhY2thZ2VzL2ZpbGUtbWFuYWdlci9jb21wb25lbnRzL3VwbG9hZGVyLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIHVwbG9hZGVyLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi01OTQ3MWYwZVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBpZiAobW9kdWxlLmhvdC5kYXRhLmNzc01vZHVsZXMgJiYgSlNPTi5zdHJpbmdpZnkobW9kdWxlLmhvdC5kYXRhLmNzc01vZHVsZXMpICE9PSBKU09OLnN0cmluZ2lmeShjc3NNb2R1bGVzKSkge1xuICAgICAgZGVsZXRlIENvbXBvbmVudC5vcHRpb25zLl9DdG9yXG4gICAgfVxuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNTk0NzFmMGVcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGF0YS5jc3NNb2R1bGVzID0gY3NzTW9kdWxlc1xuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL3VwbG9hZGVyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('transition', {\n    attrs: {\n      \"name\": \"fade\"\n    }\n  }, [(_vm.active) ? _c('div', {\n    staticClass: \"file-manager-modal\"\n  }, [_c('div', {\n    staticClass: \"file-manager-modal-inner\"\n  }, [_c('div', {\n    staticClass: \"header\"\n  }, [_c('div', {\n    staticClass: \"title\"\n  }, [_vm._t(\"title\", [_vm._v(\"\\n                                File Manager\\n                            \")])], 2), _vm._v(\" \"), _c('div', {\n    staticClass: \"close\",\n    on: {\n      \"click\": _vm.close\n    }\n  }, [_c('svg', {\n    attrs: {\n      \"version\": \"1.0\",\n      \"xmlns\": \"http://www.w3.org/2000/svg\",\n      \"width\": \"300.000000pt\",\n      \"height\": \"291.000000pt\",\n      \"viewBox\": \"0 0 300.000000 291.000000\",\n      \"preserveAspectRatio\": \"xMidYMid meet\"\n    }\n  }, [_c('metadata', [_c('rdf:rdf', {\n    attrs: {\n      \"xmlns:rdf\": \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n      \"xmlns:rdfs\": \"http://www.w3.org/2000/01/rdf-schema#\",\n      \"xmlns:dc\": \"http://purl.org/dc/elements/1.1/\"\n    }\n  }, [_c('rdf:description', {\n    attrs: {\n      \"dc:title\": \"x small\",\n      \"dc:publisher\": \"Hiox\",\n      \"dc:date\": \"2015-03-14\",\n      \"dc:format\": \"image/svg+xml\",\n      \"dc:language\": \"en\"\n    }\n  }, [_c('dc:creator', [_c('rdf:bag', [_c('rdf:li', [_vm._v(\"svgimages.com\")])], 1)], 1)], 1)], 1)], 1), _vm._v(\" \"), _c('g', {\n    attrs: {\n      \"transform\": \"translate(0.000000,291.000000) scale(0.100000,-0.100000)\",\n      \"fill\": \"#030303\",\n      \"stroke\": \"none\"\n    }\n  }, [_c('path', {\n    staticClass: \"node\",\n    attrs: {\n      \"d\": \"M1735 2040 l-280 -280 -275 275 c-151 151 -280 275 -285 275 -6 0\\n-77 -66 -158 -148 l-147 -147 275 -275 c151 -151 275 -279 275 -285 0 -5 -125\\n-135 -277 -287 l-277 -277 152 -153 151 -153 278 278 c153 152 283 277 288\\n277 6 0 134 -124 285 -275 l275 -275 147 147 c82 81 148 152 148 157 0 5 -124\\n133 -275 284 l-276 276 281 281 280 280 -153 153 -152 152 -280 -280z\",\n      \"id\": \"node1\",\n      \"stroke-width\": \"20\"\n    }\n  })]), _vm._v(\" \"), _c('g', {\n    attrs: {\n      \"transform\": \"translate(0.000000,291.000000) scale(0.100000,-0.100000)\",\n      \"fill\": \"#989898\",\n      \"stroke\": \"none\"\n    }\n  })], 1)])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"content\"\n  }, [_vm._t(\"default\")], 2)])]) : _vm._e()])], 1)\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-044d559c\", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL21vZGFsLnZ1ZT8wYmU5Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2JywgW19jKCd0cmFuc2l0aW9uJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcIm5hbWVcIjogXCJmYWRlXCJcbiAgICB9XG4gIH0sIFsoX3ZtLmFjdGl2ZSkgPyBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZpbGUtbWFuYWdlci1tb2RhbFwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZpbGUtbWFuYWdlci1tb2RhbC1pbm5lclwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImhlYWRlclwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcInRpdGxlXCJcbiAgfSwgW192bS5fdChcInRpdGxlXCIsIFtfdm0uX3YoXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpbGUgTWFuYWdlclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIildKV0sIDIpLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNsb3NlXCIsXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogX3ZtLmNsb3NlXG4gICAgfVxuICB9LCBbX2MoJ3N2ZycsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJ2ZXJzaW9uXCI6IFwiMS4wXCIsXG4gICAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICAgIFwid2lkdGhcIjogXCIzMDAuMDAwMDAwcHRcIixcbiAgICAgIFwiaGVpZ2h0XCI6IFwiMjkxLjAwMDAwMHB0XCIsXG4gICAgICBcInZpZXdCb3hcIjogXCIwIDAgMzAwLjAwMDAwMCAyOTEuMDAwMDAwXCIsXG4gICAgICBcInByZXNlcnZlQXNwZWN0UmF0aW9cIjogXCJ4TWlkWU1pZCBtZWV0XCJcbiAgICB9XG4gIH0sIFtfYygnbWV0YWRhdGEnLCBbX2MoJ3JkZjpyZGYnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwieG1sbnM6cmRmXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI1wiLFxuICAgICAgXCJ4bWxuczpyZGZzXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC8wMS9yZGYtc2NoZW1hI1wiLFxuICAgICAgXCJ4bWxuczpkY1wiOiBcImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXCJcbiAgICB9XG4gIH0sIFtfYygncmRmOmRlc2NyaXB0aW9uJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImRjOnRpdGxlXCI6IFwieCBzbWFsbFwiLFxuICAgICAgXCJkYzpwdWJsaXNoZXJcIjogXCJIaW94XCIsXG4gICAgICBcImRjOmRhdGVcIjogXCIyMDE1LTAzLTE0XCIsXG4gICAgICBcImRjOmZvcm1hdFwiOiBcImltYWdlL3N2Zyt4bWxcIixcbiAgICAgIFwiZGM6bGFuZ3VhZ2VcIjogXCJlblwiXG4gICAgfVxuICB9LCBbX2MoJ2RjOmNyZWF0b3InLCBbX2MoJ3JkZjpiYWcnLCBbX2MoJ3JkZjpsaScsIFtfdm0uX3YoXCJzdmdpbWFnZXMuY29tXCIpXSldLCAxKV0sIDEpXSwgMSldLCAxKV0sIDEpLCBfdm0uX3YoXCIgXCIpLCBfYygnZycsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJ0cmFuc2Zvcm1cIjogXCJ0cmFuc2xhdGUoMC4wMDAwMDAsMjkxLjAwMDAwMCkgc2NhbGUoMC4xMDAwMDAsLTAuMTAwMDAwKVwiLFxuICAgICAgXCJmaWxsXCI6IFwiIzAzMDMwM1wiLFxuICAgICAgXCJzdHJva2VcIjogXCJub25lXCJcbiAgICB9XG4gIH0sIFtfYygncGF0aCcsIHtcbiAgICBzdGF0aWNDbGFzczogXCJub2RlXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwiZFwiOiBcIk0xNzM1IDIwNDAgbC0yODAgLTI4MCAtMjc1IDI3NSBjLTE1MSAxNTEgLTI4MCAyNzUgLTI4NSAyNzUgLTYgMFxcbi03NyAtNjYgLTE1OCAtMTQ4IGwtMTQ3IC0xNDcgMjc1IC0yNzUgYzE1MSAtMTUxIDI3NSAtMjc5IDI3NSAtMjg1IDAgLTUgLTEyNVxcbi0xMzUgLTI3NyAtMjg3IGwtMjc3IC0yNzcgMTUyIC0xNTMgMTUxIC0xNTMgMjc4IDI3OCBjMTUzIDE1MiAyODMgMjc3IDI4OFxcbjI3NyA2IDAgMTM0IC0xMjQgMjg1IC0yNzUgbDI3NSAtMjc1IDE0NyAxNDcgYzgyIDgxIDE0OCAxNTIgMTQ4IDE1NyAwIDUgLTEyNFxcbjEzMyAtMjc1IDI4NCBsLTI3NiAyNzYgMjgxIDI4MSAyODAgMjgwIC0xNTMgMTUzIC0xNTIgMTUyIC0yODAgLTI4MHpcIixcbiAgICAgIFwiaWRcIjogXCJub2RlMVwiLFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjogXCIyMFwiXG4gICAgfVxuICB9KV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZycsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJ0cmFuc2Zvcm1cIjogXCJ0cmFuc2xhdGUoMC4wMDAwMDAsMjkxLjAwMDAwMCkgc2NhbGUoMC4xMDAwMDAsLTAuMTAwMDAwKVwiLFxuICAgICAgXCJmaWxsXCI6IFwiIzk4OTg5OFwiLFxuICAgICAgXCJzdHJva2VcIjogXCJub25lXCJcbiAgICB9XG4gIH0pXSwgMSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNvbnRlbnRcIlxuICB9LCBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sIDIpXSldKSA6IF92bS5fZSgpXSldLCAxKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi0wNDRkNTU5Y1wiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci5qcz9pZD1kYXRhLXYtMDQ0ZDU1OWMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2NvbXBvbmVudHMvbW9kYWwudnVlXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"file list-group-item\"\n  }, [_vm._v(\"\\n    \" + _vm._s(_vm.file.name) + \" \"), _c('span', {\n    staticClass: \"badge\"\n  }, [_vm._v(_vm._s(_vm.file.mime))])])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-09a8c207\", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2ZpbGUudnVlP2ExMTIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmlsZSBsaXN0LWdyb3VwLWl0ZW1cIlxuICB9LCBbX3ZtLl92KFwiXFxuICAgIFwiICsgX3ZtLl9zKF92bS5maWxlLm5hbWUpICsgXCIgXCIpLCBfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJiYWRnZVwiXG4gIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS5maWxlLm1pbWUpKV0pXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtMDlhOGMyMDdcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIuanM/aWQ9ZGF0YS12LTA5YThjMjA3IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9jb21wb25lbnRzL2ZpbGUudnVlXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": \"file-manager-files\"\n    }\n  }, [_c('div', {\n    staticClass: \"form-group\"\n  }, [_c('input', {\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: (_vm.search),\n      expression: \"search\"\n    }],\n    staticClass: \"form-control\",\n    attrs: {\n      \"type\": \"text\",\n      \"placeholder\": \"Filter\"\n    },\n    domProps: {\n      \"value\": _vm._s(_vm.search)\n    },\n    on: {\n      \"input\": function($event) {\n        if ($event.target.composing) { return; }\n        _vm.search = $event.target.value\n      }\n    }\n  })]), _vm._v(\" \"), _c('paginate', {\n    attrs: {\n      \"name\": \"filtered\",\n      \"list\": _vm.filtered,\n      \"per\": 10,\n      \"tag\": \"div\"\n    }\n  }, _vm._l((_vm.paginated('filtered')), function(file) {\n    return _c('file', {\n      attrs: {\n        \"file\": file\n      }\n    })\n  })), _vm._v(\" \"), _c('div', {\n    staticClass: \"text-center list-group\"\n  }, [_c('paginate-links', {\n    attrs: {\n      \"for\": \"filtered\",\n      \"show-step-links\": true,\n      \"classes\": {\n        'ul': 'pagination'\n      }\n    }\n  })], 1)], 1)\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-2f1b1ffc\", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2ZpbGVzLnZ1ZT85YTlmIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImlkXCI6IFwiZmlsZS1tYW5hZ2VyLWZpbGVzXCJcbiAgICB9XG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZvcm0tZ3JvdXBcIlxuICB9LCBbX2MoJ2lucHV0Jywge1xuICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgIHZhbHVlOiAoX3ZtLnNlYXJjaCksXG4gICAgICBleHByZXNzaW9uOiBcInNlYXJjaFwiXG4gICAgfV0sXG4gICAgc3RhdGljQ2xhc3M6IFwiZm9ybS1jb250cm9sXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwidHlwZVwiOiBcInRleHRcIixcbiAgICAgIFwicGxhY2Vob2xkZXJcIjogXCJGaWx0ZXJcIlxuICAgIH0sXG4gICAgZG9tUHJvcHM6IHtcbiAgICAgIFwidmFsdWVcIjogX3ZtLl9zKF92bS5zZWFyY2gpXG4gICAgfSxcbiAgICBvbjoge1xuICAgICAgXCJpbnB1dFwiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybjsgfVxuICAgICAgICBfdm0uc2VhcmNoID0gJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3BhZ2luYXRlJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcIm5hbWVcIjogXCJmaWx0ZXJlZFwiLFxuICAgICAgXCJsaXN0XCI6IF92bS5maWx0ZXJlZCxcbiAgICAgIFwicGVyXCI6IDEwLFxuICAgICAgXCJ0YWdcIjogXCJkaXZcIlxuICAgIH1cbiAgfSwgX3ZtLl9sKChfdm0ucGFnaW5hdGVkKCdmaWx0ZXJlZCcpKSwgZnVuY3Rpb24oZmlsZSkge1xuICAgIHJldHVybiBfYygnZmlsZScsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwiZmlsZVwiOiBmaWxlXG4gICAgICB9XG4gICAgfSlcbiAgfSkpLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcInRleHQtY2VudGVyIGxpc3QtZ3JvdXBcIlxuICB9LCBbX2MoJ3BhZ2luYXRlLWxpbmtzJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImZvclwiOiBcImZpbHRlcmVkXCIsXG4gICAgICBcInNob3ctc3RlcC1saW5rc1wiOiB0cnVlLFxuICAgICAgXCJjbGFzc2VzXCI6IHtcbiAgICAgICAgJ3VsJzogJ3BhZ2luYXRpb24nXG4gICAgICB9XG4gICAgfVxuICB9KV0sIDEpXSwgMSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtMmYxYjFmZmNcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIuanM/aWQ9ZGF0YS12LTJmMWIxZmZjIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9jb21wb25lbnRzL2ZpbGVzLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": \"file-manager\"\n    }\n  }, [_c('modal', {\n    ref: \"modal\",\n    attrs: {\n      \"active\": _vm.active\n    }\n  }, [_c('uploader'), _vm._v(\" \"), _c('hr'), _vm._v(\" \"), (_vm.files && _vm.files.length) ? _c('files', {\n    attrs: {\n      \"files\": _vm.files\n    }\n  }) : _vm._e()], 1)], 1)\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-34ff6bc4\", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL21haW4udnVlPzQ0N2QiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJmaWxlLW1hbmFnZXJcIlxuICAgIH1cbiAgfSwgW19jKCdtb2RhbCcsIHtcbiAgICByZWY6IFwibW9kYWxcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJhY3RpdmVcIjogX3ZtLmFjdGl2ZVxuICAgIH1cbiAgfSwgW19jKCd1cGxvYWRlcicpLCBfdm0uX3YoXCIgXCIpLCBfYygnaHInKSwgX3ZtLl92KFwiIFwiKSwgKF92bS5maWxlcyAmJiBfdm0uZmlsZXMubGVuZ3RoKSA/IF9jKCdmaWxlcycsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJmaWxlc1wiOiBfdm0uZmlsZXNcbiAgICB9XG4gIH0pIDogX3ZtLl9lKCldLCAxKV0sIDEpXG59LHN0YXRpY1JlbmRlckZuczogW119XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTM0ZmY2YmM0XCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyLmpzP2lkPWRhdGEtdi0zNGZmNmJjNCEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vY29tcG9uZW50cy9tYWluLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": \"uploader\"\n    }\n  }, [_c('div', {\n    ref: \"uploader\"\n  }), _vm._v(\" \"), _c('script', {\n    attrs: {\n      \"type\": \"text/template\",\n      \"id\": \"qq-template\"\n    }\n  }, [_vm._v(\"\\n        <div class=\\\"qq-uploader-selector qq-uploader qq-gallery\\\" qq-drop-area-text=\\\"Drop files here\\\">\\n            <div class=\\\"qq-total-progress-bar-container-selector qq-total-progress-bar-container progress\\\">\\n                <div role=\\\"progressbar\\\" aria-valuenow=\\\"0\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"100\\\" class=\\\"progress-bar qq-total-progress-bar-selector qq-progress-bar qq-total-progress-bar\\\"></div>\\n            </div>\\n            <div class=\\\"qq-upload-drop-area-selector qq-upload-drop-area\\\" qq-hide-dropzone>\\n                <span class=\\\"qq-upload-drop-area-text-selector\\\"></span>\\n            </div>\\n            <div class=\\\"qq-upload-button-selector qq-upload-button btn btn-default\\\">\\n                Upload a file\\n            </div>\\n            <span class=\\\"qq-drop-processing-selector qq-drop-processing\\\">\\n            <span>Processing dropped files...</span>\\n            <span class=\\\"qq-drop-processing-spinner-selector qq-drop-processing-spinner\\\">\\n                Processing\\n            </span>\\n        </span>\\n            <ul class=\\\"qq-upload-list-selector qq-upload-list list-group\\\" role=\\\"region\\\" aria-live=\\\"polite\\\" aria-relevant=\\\"additions removals\\\">\\n                <li class=\\\"list-group-item island\\\">\\n                    <p role=\\\"status\\\" class=\\\"qq-upload-status-text-selector qq-upload-status-text\\\"></p>\\n                    <div class=\\\"qq-progress-bar-container-selector qq-progress-bar-container\\\">\\n                        <div role=\\\"progressbar\\\" aria-valuenow=\\\"0\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"100\\\" class=\\\"qq-progress-bar-selector qq-progress-bar\\\"></div>\\n                    </div>\\n                    <span class=\\\"qq-upload-spinner-selector qq-upload-spinner\\\">\\n                        Loading\\n                    </span>\\n                    <div class=\\\"qq-thumbnail-wrapper\\\">\\n                        <img class=\\\"qq-thumbnail-selector\\\" qq-max-size=\\\"240\\\" qq-server-scale>\\n                    </div>\\n                    <div class=\\\"btn-group island\\\">\\n                        <button type=\\\"button\\\" class=\\\"qq-upload-cancel-selector qq-upload-cancel btn btn-default\\\">X</button>\\n                        <button type=\\\"button\\\" class=\\\"qq-upload-retry-selector qq-upload-retry btn btn-default\\\">\\n                            <span class=\\\"qq-btn qq-retry-icon\\\" aria-label=\\\"Retry\\\"></span>\\n                            Retry\\n                        </button>\\n                    </div>\\n\\n                    <div class=\\\"qq-file-info\\\">\\n                        <div class=\\\"qq-file-name\\\">\\n                            <span class=\\\"qq-upload-file-selector qq-upload-file\\\"></span>\\n                            <span class=\\\"qq-edit-filename-icon-selector qq-btn qq-edit-filename-icon\\\" aria-label=\\\"Edit filename\\\"></span>\\n                        </div>\\n                        <input class=\\\"qq-edit-filename-selector qq-edit-filename\\\" tabindex=\\\"0\\\" type=\\\"text\\\">\\n                        <span class=\\\"qq-upload-size-selector qq-upload-size\\\"></span>\\n                        <button type=\\\"button\\\" class=\\\"qq-btn qq-upload-delete-selector qq-upload-delete btn btn-danger\\\">\\n                            <span class=\\\"qq-btn qq-delete-icon\\\" aria-label=\\\"Delete\\\"></span>\\n                        </button>\\n                        <button type=\\\"button\\\" class=\\\"qq-btn qq-upload-pause-selector qq-upload-pause btn btn-warning\\\">\\n                            <span class=\\\"qq-btn qq-pause-icon\\\" aria-label=\\\"Pause\\\"></span>\\n                        </button>\\n                        <button type=\\\"button\\\" class=\\\"qq-btn qq-upload-continue-selector qq-upload-continue btn btn-success\\\">\\n                            <span class=\\\"qq-btn qq-continue-icon\\\" aria-label=\\\"Continue\\\"></span>\\n                        </button>\\n                    </div>\\n                </li>\\n            </ul>\\n\\n            <dialog class=\\\"qq-alert-dialog-selector\\\">\\n                <div class=\\\"qq-dialog-message-selector\\\"></div>\\n                <div class=\\\"qq-dialog-buttons\\\">\\n                    <button type=\\\"button\\\" class=\\\"qq-cancel-button-selector\\\">Close</button>\\n                </div>\\n            </dialog>\\n\\n            <dialog class=\\\"qq-confirm-dialog-selector\\\">\\n                <div class=\\\"qq-dialog-message-selector\\\"></div>\\n                <div class=\\\"qq-dialog-buttons\\\">\\n                    <button type=\\\"button\\\" class=\\\"qq-cancel-button-selector\\\">No</button>\\n                    <button type=\\\"button\\\" class=\\\"qq-ok-button-selector\\\">Yes</button>\\n                </div>\\n            </dialog>\\n\\n            <dialog class=\\\"qq-prompt-dialog-selector\\\">\\n                <div class=\\\"qq-dialog-message-selector\\\"></div>\\n                <input type=\\\"text\\\">\\n                <div class=\\\"qq-dialog-buttons\\\">\\n                    <button type=\\\"button\\\" class=\\\"qq-cancel-button-selector\\\">Cancel</button>\\n                    <button type=\\\"button\\\" class=\\\"qq-ok-button-selector\\\">Ok</button>\\n                </div>\\n            </dialog>\\n        </div>\\n    \")])])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-59471f0e\", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3VwbG9hZGVyLnZ1ZT82YTVlIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImlkXCI6IFwidXBsb2FkZXJcIlxuICAgIH1cbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgcmVmOiBcInVwbG9hZGVyXCJcbiAgfSksIF92bS5fdihcIiBcIiksIF9jKCdzY3JpcHQnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwidHlwZVwiOiBcInRleHQvdGVtcGxhdGVcIixcbiAgICAgIFwiaWRcIjogXCJxcS10ZW1wbGF0ZVwiXG4gICAgfVxuICB9LCBbX3ZtLl92KFwiXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJxcS11cGxvYWRlci1zZWxlY3RvciBxcS11cGxvYWRlciBxcS1nYWxsZXJ5XFxcIiBxcS1kcm9wLWFyZWEtdGV4dD1cXFwiRHJvcCBmaWxlcyBoZXJlXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJxcS10b3RhbC1wcm9ncmVzcy1iYXItY29udGFpbmVyLXNlbGVjdG9yIHFxLXRvdGFsLXByb2dyZXNzLWJhci1jb250YWluZXIgcHJvZ3Jlc3NcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IHJvbGU9XFxcInByb2dyZXNzYmFyXFxcIiBhcmlhLXZhbHVlbm93PVxcXCIwXFxcIiBhcmlhLXZhbHVlbWluPVxcXCIwXFxcIiBhcmlhLXZhbHVlbWF4PVxcXCIxMDBcXFwiIGNsYXNzPVxcXCJwcm9ncmVzcy1iYXIgcXEtdG90YWwtcHJvZ3Jlc3MtYmFyLXNlbGVjdG9yIHFxLXByb2dyZXNzLWJhciBxcS10b3RhbC1wcm9ncmVzcy1iYXJcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInFxLXVwbG9hZC1kcm9wLWFyZWEtc2VsZWN0b3IgcXEtdXBsb2FkLWRyb3AtYXJlYVxcXCIgcXEtaGlkZS1kcm9wem9uZT5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInFxLXVwbG9hZC1kcm9wLWFyZWEtdGV4dC1zZWxlY3RvclxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInFxLXVwbG9hZC1idXR0b24tc2VsZWN0b3IgcXEtdXBsb2FkLWJ1dHRvbiBidG4gYnRuLWRlZmF1bHRcXFwiPlxcbiAgICAgICAgICAgICAgICBVcGxvYWQgYSBmaWxlXFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInFxLWRyb3AtcHJvY2Vzc2luZy1zZWxlY3RvciBxcS1kcm9wLXByb2Nlc3NpbmdcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuPlByb2Nlc3NpbmcgZHJvcHBlZCBmaWxlcy4uLjwvc3Bhbj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicXEtZHJvcC1wcm9jZXNzaW5nLXNwaW5uZXItc2VsZWN0b3IgcXEtZHJvcC1wcm9jZXNzaW5nLXNwaW5uZXJcXFwiPlxcbiAgICAgICAgICAgICAgICBQcm9jZXNzaW5nXFxuICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwicXEtdXBsb2FkLWxpc3Qtc2VsZWN0b3IgcXEtdXBsb2FkLWxpc3QgbGlzdC1ncm91cFxcXCIgcm9sZT1cXFwicmVnaW9uXFxcIiBhcmlhLWxpdmU9XFxcInBvbGl0ZVxcXCIgYXJpYS1yZWxldmFudD1cXFwiYWRkaXRpb25zIHJlbW92YWxzXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJsaXN0LWdyb3VwLWl0ZW0gaXNsYW5kXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxwIHJvbGU9XFxcInN0YXR1c1xcXCIgY2xhc3M9XFxcInFxLXVwbG9hZC1zdGF0dXMtdGV4dC1zZWxlY3RvciBxcS11cGxvYWQtc3RhdHVzLXRleHRcXFwiPjwvcD5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInFxLXByb2dyZXNzLWJhci1jb250YWluZXItc2VsZWN0b3IgcXEtcHJvZ3Jlc3MtYmFyLWNvbnRhaW5lclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiByb2xlPVxcXCJwcm9ncmVzc2JhclxcXCIgYXJpYS12YWx1ZW5vdz1cXFwiMFxcXCIgYXJpYS12YWx1ZW1pbj1cXFwiMFxcXCIgYXJpYS12YWx1ZW1heD1cXFwiMTAwXFxcIiBjbGFzcz1cXFwicXEtcHJvZ3Jlc3MtYmFyLXNlbGVjdG9yIHFxLXByb2dyZXNzLWJhclxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJxcS11cGxvYWQtc3Bpbm5lci1zZWxlY3RvciBxcS11cGxvYWQtc3Bpbm5lclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgTG9hZGluZ1xcbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicXEtdGh1bWJuYWlsLXdyYXBwZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XFxcInFxLXRodW1ibmFpbC1zZWxlY3RvclxcXCIgcXEtbWF4LXNpemU9XFxcIjI0MFxcXCIgcXEtc2VydmVyLXNjYWxlPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJidG4tZ3JvdXAgaXNsYW5kXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcInFxLXVwbG9hZC1jYW5jZWwtc2VsZWN0b3IgcXEtdXBsb2FkLWNhbmNlbCBidG4gYnRuLWRlZmF1bHRcXFwiPlg8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcInFxLXVwbG9hZC1yZXRyeS1zZWxlY3RvciBxcS11cGxvYWQtcmV0cnkgYnRuIGJ0bi1kZWZhdWx0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInFxLWJ0biBxcS1yZXRyeS1pY29uXFxcIiBhcmlhLWxhYmVsPVxcXCJSZXRyeVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZXRyeVxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJxcS1maWxlLWluZm9cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInFxLWZpbGUtbmFtZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJxcS11cGxvYWQtZmlsZS1zZWxlY3RvciBxcS11cGxvYWQtZmlsZVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicXEtZWRpdC1maWxlbmFtZS1pY29uLXNlbGVjdG9yIHFxLWJ0biBxcS1lZGl0LWZpbGVuYW1lLWljb25cXFwiIGFyaWEtbGFiZWw9XFxcIkVkaXQgZmlsZW5hbWVcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XFxcInFxLWVkaXQtZmlsZW5hbWUtc2VsZWN0b3IgcXEtZWRpdC1maWxlbmFtZVxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiIHR5cGU9XFxcInRleHRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJxcS11cGxvYWQtc2l6ZS1zZWxlY3RvciBxcS11cGxvYWQtc2l6ZVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwicXEtYnRuIHFxLXVwbG9hZC1kZWxldGUtc2VsZWN0b3IgcXEtdXBsb2FkLWRlbGV0ZSBidG4gYnRuLWRhbmdlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJxcS1idG4gcXEtZGVsZXRlLWljb25cXFwiIGFyaWEtbGFiZWw9XFxcIkRlbGV0ZVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwicXEtYnRuIHFxLXVwbG9hZC1wYXVzZS1zZWxlY3RvciBxcS11cGxvYWQtcGF1c2UgYnRuIGJ0bi13YXJuaW5nXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInFxLWJ0biBxcS1wYXVzZS1pY29uXFxcIiBhcmlhLWxhYmVsPVxcXCJQYXVzZVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwicXEtYnRuIHFxLXVwbG9hZC1jb250aW51ZS1zZWxlY3RvciBxcS11cGxvYWQtY29udGludWUgYnRuIGJ0bi1zdWNjZXNzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInFxLWJ0biBxcS1jb250aW51ZS1pY29uXFxcIiBhcmlhLWxhYmVsPVxcXCJDb250aW51ZVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPC91bD5cXG5cXG4gICAgICAgICAgICA8ZGlhbG9nIGNsYXNzPVxcXCJxcS1hbGVydC1kaWFsb2ctc2VsZWN0b3JcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJxcS1kaWFsb2ctbWVzc2FnZS1zZWxlY3RvclxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInFxLWRpYWxvZy1idXR0b25zXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwicXEtY2FuY2VsLWJ1dHRvbi1zZWxlY3RvclxcXCI+Q2xvc2U8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaWFsb2c+XFxuXFxuICAgICAgICAgICAgPGRpYWxvZyBjbGFzcz1cXFwicXEtY29uZmlybS1kaWFsb2ctc2VsZWN0b3JcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJxcS1kaWFsb2ctbWVzc2FnZS1zZWxlY3RvclxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInFxLWRpYWxvZy1idXR0b25zXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwicXEtY2FuY2VsLWJ1dHRvbi1zZWxlY3RvclxcXCI+Tm88L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwicXEtb2stYnV0dG9uLXNlbGVjdG9yXFxcIj5ZZXM8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaWFsb2c+XFxuXFxuICAgICAgICAgICAgPGRpYWxvZyBjbGFzcz1cXFwicXEtcHJvbXB0LWRpYWxvZy1zZWxlY3RvclxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInFxLWRpYWxvZy1tZXNzYWdlLXNlbGVjdG9yXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJxcS1kaWFsb2ctYnV0dG9uc1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcInFxLWNhbmNlbC1idXR0b24tc2VsZWN0b3JcXFwiPkNhbmNlbDwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJxcS1vay1idXR0b24tc2VsZWN0b3JcXFwiPk9rPC9idXR0b24+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGlhbG9nPlxcbiAgICAgICAgPC9kaXY+XFxuICAgIFwiKV0pXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtNTk0NzFmMGVcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIuanM/aWQ9ZGF0YS12LTU5NDcxZjBlIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9jb21wb25lbnRzL3VwbG9hZGVyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * vue-paginate v3.4.0\n * (c) 2017 Taha Shashtari\n * @license MIT\n */\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.VuePaginate = factory());\n}(this, function () { 'use strict';\n\n\tvar warn = function () {}\n\tvar formatComponentName\n\n\tvar hasConsole = typeof console !== 'undefined'\n\n\twarn = function (msg, vm, type) {\n\t  if ( type === void 0 ) type = 'error';\n\n\t  if (hasConsole) {\n\t    console[type](\"[vue-paginate]: \" + msg + \" \" + (\n\t      vm ? formatLocation(formatComponentName(vm)) : ''\n\t      ))\n\t  }\n\t}\n\n\tformatComponentName = function (vm) {\n\t  if (vm.$root === vm) {\n\t    return 'root instance'\n\t  }\n\t  var name = vm._isVue\n\t  ? vm.$options.name || vm.$options._componentTag\n\t  : vm.name\n\t  return (\n\t    (name ? (\"component <\" + name + \">\") : \"anonymous component\") +\n\t    (vm._isVue && vm.$options.__file ? (\" at \" + (vm.$options.__file)) : '')\n\t    )\n\t}\n\n\tvar formatLocation = function (str) {\n\t  if (str === 'anonymous component') {\n\t    str += \" - use the \\\"name\\\" option for better debugging messages.\"\n\t  }\n\t  return (\"\\n(found in \" + str + \")\")\n\t}\n\n\tvar Paginate = {\n\t  name: 'paginate',\n\t  props: {\n\t    name: {\n\t      type: String,\n\t      required: true\n\t    },\n\t    list: {\n\t      type: Array,\n\t      required: true\n\t    },\n\t    per: {\n\t      type: Number,\n\t      default: 3,\n\t      validator: function validator (value) {\n\t        return value > 0\n\t      }\n\t    },\n\t    tag: {\n\t      type: String,\n\t      default: 'ul'\n\t    },\n\t    class: {\n\t      type: String\n\t    }\n\t  },\n\t  data: function data () {\n\t    return {}\n\t  },\n\t  computed: {\n\t    currentPage: {\n\t      get: function get () {\n\t        if (this.$parent.paginate[this.name]) {\n\t          return this.$parent.paginate[this.name].page\n\t        }\n\t      },\n\t      set: function set (page) {\n\t        this.$parent.paginate[this.name].page = page\n\t      }\n\t    }\n\t  },\n\t  mounted: function mounted () {\n\t    if (this.per <= 0) {\n\t      warn((\"<paginate name=\\\"\" + (this.name) + \"\\\"> 'per' prop can't be 0 or less.\"), this.$parent)\n\t    }\n\t    if (!this.$parent.paginate[this.name]) {\n\t      warn((\"'\" + (this.name) + \"' is not registered in 'paginate' array.\"), this.$parent)\n\t      return\n\t    }\n\t    this.paginateList()\n\t  },\n\t  watch: {\n\t    currentPage: function currentPage () {\n\t      this.paginateList()\n\t    },\n\t    list: function list () {\n\t      // On list change, refresh the paginated list\n\t      this.currentPage = 0\n\t      this.paginateList()\n\t    },\n\t    per: function per () {\n\t      this.currentPage = 0\n\t      this.paginateList()\n\t    }\n\t  },\n\t  methods: {\n\t    paginateList: function paginateList () {\n\t      var index = this.currentPage * this.per\n\t      var paginatedList = this.list.slice(index, index + this.per)\n\t      this.$parent.paginate[this.name].list = paginatedList\n\t    }\n\t  },\n\t  render: function render (h) {\n\t    var className = this.class ? this.class : ''\n\t    return h(this.tag, { class: className }, this.$slots.default)\n\t  }\n\t}\n\n\tvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\t/*  */\n\n\t/**\n\t * Convert a value to a string that is actually rendered.\n\t */\n\tfunction _toString (val) {\n\t  return val == null\n\t    ? ''\n\t    : typeof val === 'object'\n\t      ? JSON.stringify(val, null, 2)\n\t      : String(val)\n\t}\n\n\t/**\n\t * Convert a input value to a number for persistence.\n\t * If the conversion fails, return original string.\n\t */\n\tfunction toNumber (val) {\n\t  var n = parseFloat(val, 10);\n\t  return (n || n === 0) ? n : val\n\t}\n\n\t/**\n\t * Make a map and return a function for checking if a key\n\t * is in that map.\n\t */\n\tfunction makeMap (\n\t  str,\n\t  expectsLowerCase\n\t) {\n\t  var map = Object.create(null);\n\t  var list = str.split(',');\n\t  for (var i = 0; i < list.length; i++) {\n\t    map[list[i]] = true;\n\t  }\n\t  return expectsLowerCase\n\t    ? function (val) { return map[val.toLowerCase()]; }\n\t    : function (val) { return map[val]; }\n\t}\n\n\t/**\n\t * Check if a tag is a built-in tag.\n\t */\n\tvar isBuiltInTag = makeMap('slot,component', true);\n\n\t/**\n\t * Remove an item from an array\n\t */\n\tfunction remove$1 (arr, item) {\n\t  if (arr.length) {\n\t    var index = arr.indexOf(item);\n\t    if (index > -1) {\n\t      return arr.splice(index, 1)\n\t    }\n\t  }\n\t}\n\n\t/**\n\t * Check whether the object has the property.\n\t */\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\tfunction hasOwn (obj, key) {\n\t  return hasOwnProperty.call(obj, key)\n\t}\n\n\t/**\n\t * Check if value is primitive\n\t */\n\tfunction isPrimitive (value) {\n\t  return typeof value === 'string' || typeof value === 'number'\n\t}\n\n\t/**\n\t * Create a cached version of a pure function.\n\t */\n\tfunction cached (fn) {\n\t  var cache = Object.create(null);\n\t  return (function cachedFn (str) {\n\t    var hit = cache[str];\n\t    return hit || (cache[str] = fn(str))\n\t  })\n\t}\n\n\t/**\n\t * Camelize a hyphen-delmited string.\n\t */\n\tvar camelizeRE = /-(\\w)/g;\n\tvar camelize = cached(function (str) {\n\t  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n\t});\n\n\t/**\n\t * Capitalize a string.\n\t */\n\tvar capitalize = cached(function (str) {\n\t  return str.charAt(0).toUpperCase() + str.slice(1)\n\t});\n\n\t/**\n\t * Hyphenate a camelCase string.\n\t */\n\tvar hyphenateRE = /([^-])([A-Z])/g;\n\tvar hyphenate = cached(function (str) {\n\t  return str\n\t    .replace(hyphenateRE, '$1-$2')\n\t    .replace(hyphenateRE, '$1-$2')\n\t    .toLowerCase()\n\t});\n\n\t/**\n\t * Simple bind, faster than native\n\t */\n\tfunction bind$1 (fn, ctx) {\n\t  function boundFn (a) {\n\t    var l = arguments.length;\n\t    return l\n\t      ? l > 1\n\t        ? fn.apply(ctx, arguments)\n\t        : fn.call(ctx, a)\n\t      : fn.call(ctx)\n\t  }\n\t  // record original fn length\n\t  boundFn._length = fn.length;\n\t  return boundFn\n\t}\n\n\t/**\n\t * Convert an Array-like object to a real Array.\n\t */\n\tfunction toArray (list, start) {\n\t  start = start || 0;\n\t  var i = list.length - start;\n\t  var ret = new Array(i);\n\t  while (i--) {\n\t    ret[i] = list[i + start];\n\t  }\n\t  return ret\n\t}\n\n\t/**\n\t * Mix properties into target object.\n\t */\n\tfunction extend (to, _from) {\n\t  for (var key in _from) {\n\t    to[key] = _from[key];\n\t  }\n\t  return to\n\t}\n\n\t/**\n\t * Quick object check - this is primarily used to tell\n\t * Objects from primitive values when we know the value\n\t * is a JSON-compliant type.\n\t */\n\tfunction isObject (obj) {\n\t  return obj !== null && typeof obj === 'object'\n\t}\n\n\t/**\n\t * Strict object type check. Only returns true\n\t * for plain JavaScript objects.\n\t */\n\tvar toString = Object.prototype.toString;\n\tvar OBJECT_STRING = '[object Object]';\n\tfunction isPlainObject (obj) {\n\t  return toString.call(obj) === OBJECT_STRING\n\t}\n\n\t/**\n\t * Merge an Array of Objects into a single Object.\n\t */\n\tfunction toObject (arr) {\n\t  var res = {};\n\t  for (var i = 0; i < arr.length; i++) {\n\t    if (arr[i]) {\n\t      extend(res, arr[i]);\n\t    }\n\t  }\n\t  return res\n\t}\n\n\t/**\n\t * Perform no operation.\n\t */\n\tfunction noop () {}\n\n\t/**\n\t * Always return false.\n\t */\n\tvar no = function () { return false; };\n\n\t/**\n\t * Return same value\n\t */\n\tvar identity = function (_) { return _; };\n\n\t/**\n\t * Generate a static keys string from compiler modules.\n\t */\n\tfunction genStaticKeys (modules) {\n\t  return modules.reduce(function (keys, m) {\n\t    return keys.concat(m.staticKeys || [])\n\t  }, []).join(',')\n\t}\n\n\t/**\n\t * Check if two values are loosely equal - that is,\n\t * if they are plain objects, do they have the same shape?\n\t */\n\tfunction looseEqual (a, b) {\n\t  var isObjectA = isObject(a);\n\t  var isObjectB = isObject(b);\n\t  if (isObjectA && isObjectB) {\n\t    return JSON.stringify(a) === JSON.stringify(b)\n\t  } else if (!isObjectA && !isObjectB) {\n\t    return String(a) === String(b)\n\t  } else {\n\t    return false\n\t  }\n\t}\n\n\tfunction looseIndexOf (arr, val) {\n\t  for (var i = 0; i < arr.length; i++) {\n\t    if (looseEqual(arr[i], val)) { return i }\n\t  }\n\t  return -1\n\t}\n\n\t/*  */\n\n\tvar config = {\n\t  /**\n\t   * Option merge strategies (used in core/util/options)\n\t   */\n\t  optionMergeStrategies: Object.create(null),\n\n\t  /**\n\t   * Whether to suppress warnings.\n\t   */\n\t  silent: false,\n\n\t  /**\n\t   * Whether to enable devtools\n\t   */\n\t  devtools: \"production\" !== 'production',\n\n\t  /**\n\t   * Error handler for watcher errors\n\t   */\n\t  errorHandler: null,\n\n\t  /**\n\t   * Ignore certain custom elements\n\t   */\n\t  ignoredElements: [],\n\n\t  /**\n\t   * Custom user key aliases for v-on\n\t   */\n\t  keyCodes: Object.create(null),\n\n\t  /**\n\t   * Check if a tag is reserved so that it cannot be registered as a\n\t   * component. This is platform-dependent and may be overwritten.\n\t   */\n\t  isReservedTag: no,\n\n\t  /**\n\t   * Check if a tag is an unknown element.\n\t   * Platform-dependent.\n\t   */\n\t  isUnknownElement: no,\n\n\t  /**\n\t   * Get the namespace of an element\n\t   */\n\t  getTagNamespace: noop,\n\n\t  /**\n\t   * Parse the real tag name for the specific platform.\n\t   */\n\t  parsePlatformTagName: identity,\n\n\t  /**\n\t   * Check if an attribute must be bound using property, e.g. value\n\t   * Platform-dependent.\n\t   */\n\t  mustUseProp: no,\n\n\t  /**\n\t   * List of asset types that a component can own.\n\t   */\n\t  _assetTypes: [\n\t    'component',\n\t    'directive',\n\t    'filter'\n\t  ],\n\n\t  /**\n\t   * List of lifecycle hooks.\n\t   */\n\t  _lifecycleHooks: [\n\t    'beforeCreate',\n\t    'created',\n\t    'beforeMount',\n\t    'mounted',\n\t    'beforeUpdate',\n\t    'updated',\n\t    'beforeDestroy',\n\t    'destroyed',\n\t    'activated',\n\t    'deactivated'\n\t  ],\n\n\t  /**\n\t   * Max circular updates allowed in a scheduler flush cycle.\n\t   */\n\t  _maxUpdateCount: 100\n\t};\n\n\t/*  */\n\n\t/**\n\t * Check if a string starts with $ or _\n\t */\n\tfunction isReserved (str) {\n\t  var c = (str + '').charCodeAt(0);\n\t  return c === 0x24 || c === 0x5F\n\t}\n\n\t/**\n\t * Define a property.\n\t */\n\tfunction def (obj, key, val, enumerable) {\n\t  Object.defineProperty(obj, key, {\n\t    value: val,\n\t    enumerable: !!enumerable,\n\t    writable: true,\n\t    configurable: true\n\t  });\n\t}\n\n\t/**\n\t * Parse simple path.\n\t */\n\tvar bailRE = /[^\\w.$]/;\n\tfunction parsePath (path) {\n\t  if (bailRE.test(path)) {\n\t    return\n\t  } else {\n\t    var segments = path.split('.');\n\t    return function (obj) {\n\t      for (var i = 0; i < segments.length; i++) {\n\t        if (!obj) { return }\n\t        obj = obj[segments[i]];\n\t      }\n\t      return obj\n\t    }\n\t  }\n\t}\n\n\t/*  */\n\t/* globals MutationObserver */\n\n\t// can we use __proto__?\n\tvar hasProto = '__proto__' in {};\n\n\t// Browser environment sniffing\n\tvar inBrowser = typeof window !== 'undefined';\n\tvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\n\tvar isIE = UA && /msie|trident/.test(UA);\n\tvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n\tvar isEdge = UA && UA.indexOf('edge/') > 0;\n\tvar isAndroid = UA && UA.indexOf('android') > 0;\n\tvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\n\n\t// this needs to be lazy-evaled because vue may be required before\n\t// vue-server-renderer can set VUE_ENV\n\tvar _isServer;\n\tvar isServerRendering = function () {\n\t  if (_isServer === undefined) {\n\t    /* istanbul ignore if */\n\t    if (!inBrowser && typeof commonjsGlobal !== 'undefined') {\n\t      // detect presence of vue-server-renderer and avoid\n\t      // Webpack shimming the process\n\t      _isServer = commonjsGlobal['process'].env.VUE_ENV === 'server';\n\t    } else {\n\t      _isServer = false;\n\t    }\n\t  }\n\t  return _isServer\n\t};\n\n\t// detect devtools\n\tvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n\t/* istanbul ignore next */\n\tfunction isNative (Ctor) {\n\t  return /native code/.test(Ctor.toString())\n\t}\n\n\t/**\n\t * Defer a task to execute it asynchronously.\n\t */\n\tvar nextTick = (function () {\n\t  var callbacks = [];\n\t  var pending = false;\n\t  var timerFunc;\n\n\t  function nextTickHandler () {\n\t    pending = false;\n\t    var copies = callbacks.slice(0);\n\t    callbacks.length = 0;\n\t    for (var i = 0; i < copies.length; i++) {\n\t      copies[i]();\n\t    }\n\t  }\n\n\t  // the nextTick behavior leverages the microtask queue, which can be accessed\n\t  // via either native Promise.then or MutationObserver.\n\t  // MutationObserver has wider support, however it is seriously bugged in\n\t  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n\t  // completely stops working after triggering a few times... so, if native\n\t  // Promise is available, we will use it:\n\t  /* istanbul ignore if */\n\t  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n\t    var p = Promise.resolve();\n\t    var logError = function (err) { console.error(err); };\n\t    timerFunc = function () {\n\t      p.then(nextTickHandler).catch(logError);\n\t      // in problematic UIWebViews, Promise.then doesn't completely break, but\n\t      // it can get stuck in a weird state where callbacks are pushed into the\n\t      // microtask queue but the queue isn't being flushed, until the browser\n\t      // needs to do some other work, e.g. handle a timer. Therefore we can\n\t      // \"force\" the microtask queue to be flushed by adding an empty timer.\n\t      if (isIOS) { setTimeout(noop); }\n\t    };\n\t  } else if (typeof MutationObserver !== 'undefined' && (\n\t    isNative(MutationObserver) ||\n\t    // PhantomJS and iOS 7.x\n\t    MutationObserver.toString() === '[object MutationObserverConstructor]'\n\t  )) {\n\t    // use MutationObserver where native Promise is not available,\n\t    // e.g. PhantomJS IE11, iOS7, Android 4.4\n\t    var counter = 1;\n\t    var observer = new MutationObserver(nextTickHandler);\n\t    var textNode = document.createTextNode(String(counter));\n\t    observer.observe(textNode, {\n\t      characterData: true\n\t    });\n\t    timerFunc = function () {\n\t      counter = (counter + 1) % 2;\n\t      textNode.data = String(counter);\n\t    };\n\t  } else {\n\t    // fallback to setTimeout\n\t    /* istanbul ignore next */\n\t    timerFunc = function () {\n\t      setTimeout(nextTickHandler, 0);\n\t    };\n\t  }\n\n\t  return function queueNextTick (cb, ctx) {\n\t    var _resolve;\n\t    callbacks.push(function () {\n\t      if (cb) { cb.call(ctx); }\n\t      if (_resolve) { _resolve(ctx); }\n\t    });\n\t    if (!pending) {\n\t      pending = true;\n\t      timerFunc();\n\t    }\n\t    if (!cb && typeof Promise !== 'undefined') {\n\t      return new Promise(function (resolve) {\n\t        _resolve = resolve;\n\t      })\n\t    }\n\t  }\n\t})();\n\n\tvar _Set;\n\t/* istanbul ignore if */\n\tif (typeof Set !== 'undefined' && isNative(Set)) {\n\t  // use native Set when available.\n\t  _Set = Set;\n\t} else {\n\t  // a non-standard Set polyfill that only works with primitive keys.\n\t  _Set = (function () {\n\t    function Set () {\n\t      this.set = Object.create(null);\n\t    }\n\t    Set.prototype.has = function has (key) {\n\t      return this.set[key] === true\n\t    };\n\t    Set.prototype.add = function add (key) {\n\t      this.set[key] = true;\n\t    };\n\t    Set.prototype.clear = function clear () {\n\t      this.set = Object.create(null);\n\t    };\n\n\t    return Set;\n\t  }());\n\t}\n\n\tvar warn$1 = noop;\n\tvar formatComponentName$1;\n\n\t/*  */\n\n\n\tvar uid$1 = 0;\n\n\t/**\n\t * A dep is an observable that can have multiple\n\t * directives subscribing to it.\n\t */\n\tvar Dep = function Dep () {\n\t  this.id = uid$1++;\n\t  this.subs = [];\n\t};\n\n\tDep.prototype.addSub = function addSub (sub) {\n\t  this.subs.push(sub);\n\t};\n\n\tDep.prototype.removeSub = function removeSub (sub) {\n\t  remove$1(this.subs, sub);\n\t};\n\n\tDep.prototype.depend = function depend () {\n\t  if (Dep.target) {\n\t    Dep.target.addDep(this);\n\t  }\n\t};\n\n\tDep.prototype.notify = function notify () {\n\t  // stablize the subscriber list first\n\t  var subs = this.subs.slice();\n\t  for (var i = 0, l = subs.length; i < l; i++) {\n\t    subs[i].update();\n\t  }\n\t};\n\n\t// the current target watcher being evaluated.\n\t// this is globally unique because there could be only one\n\t// watcher being evaluated at any time.\n\tDep.target = null;\n\tvar targetStack = [];\n\n\tfunction pushTarget (_target) {\n\t  if (Dep.target) { targetStack.push(Dep.target); }\n\t  Dep.target = _target;\n\t}\n\n\tfunction popTarget () {\n\t  Dep.target = targetStack.pop();\n\t}\n\n\t/*\n\t * not type checking this file because flow doesn't play well with\n\t * dynamically accessing methods on Array prototype\n\t */\n\n\tvar arrayProto = Array.prototype;\n\tvar arrayMethods = Object.create(arrayProto);[\n\t  'push',\n\t  'pop',\n\t  'shift',\n\t  'unshift',\n\t  'splice',\n\t  'sort',\n\t  'reverse'\n\t]\n\t.forEach(function (method) {\n\t  // cache original method\n\t  var original = arrayProto[method];\n\t  def(arrayMethods, method, function mutator () {\n\t    var arguments$1 = arguments;\n\n\t    // avoid leaking arguments:\n\t    // http://jsperf.com/closure-with-arguments\n\t    var i = arguments.length;\n\t    var args = new Array(i);\n\t    while (i--) {\n\t      args[i] = arguments$1[i];\n\t    }\n\t    var result = original.apply(this, args);\n\t    var ob = this.__ob__;\n\t    var inserted;\n\t    switch (method) {\n\t      case 'push':\n\t        inserted = args;\n\t        break\n\t      case 'unshift':\n\t        inserted = args;\n\t        break\n\t      case 'splice':\n\t        inserted = args.slice(2);\n\t        break\n\t    }\n\t    if (inserted) { ob.observeArray(inserted); }\n\t    // notify change\n\t    ob.dep.notify();\n\t    return result\n\t  });\n\t});\n\n\t/*  */\n\n\tvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n\t/**\n\t * By default, when a reactive property is set, the new value is\n\t * also converted to become reactive. However when passing down props,\n\t * we don't want to force conversion because the value may be a nested value\n\t * under a frozen data structure. Converting it would defeat the optimization.\n\t */\n\tvar observerState = {\n\t  shouldConvert: true,\n\t  isSettingProps: false\n\t};\n\n\t/**\n\t * Observer class that are attached to each observed\n\t * object. Once attached, the observer converts target\n\t * object's property keys into getter/setters that\n\t * collect dependencies and dispatches updates.\n\t */\n\tvar Observer = function Observer (value) {\n\t  this.value = value;\n\t  this.dep = new Dep();\n\t  this.vmCount = 0;\n\t  def(value, '__ob__', this);\n\t  if (Array.isArray(value)) {\n\t    var augment = hasProto\n\t      ? protoAugment\n\t      : copyAugment;\n\t    augment(value, arrayMethods, arrayKeys);\n\t    this.observeArray(value);\n\t  } else {\n\t    this.walk(value);\n\t  }\n\t};\n\n\t/**\n\t * Walk through each property and convert them into\n\t * getter/setters. This method should only be called when\n\t * value type is Object.\n\t */\n\tObserver.prototype.walk = function walk (obj) {\n\t  var keys = Object.keys(obj);\n\t  for (var i = 0; i < keys.length; i++) {\n\t    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n\t  }\n\t};\n\n\t/**\n\t * Observe a list of Array items.\n\t */\n\tObserver.prototype.observeArray = function observeArray (items) {\n\t  for (var i = 0, l = items.length; i < l; i++) {\n\t    observe(items[i]);\n\t  }\n\t};\n\n\t// helpers\n\n\t/**\n\t * Augment an target Object or Array by intercepting\n\t * the prototype chain using __proto__\n\t */\n\tfunction protoAugment (target, src) {\n\t  /* eslint-disable no-proto */\n\t  target.__proto__ = src;\n\t  /* eslint-enable no-proto */\n\t}\n\n\t/**\n\t * Augment an target Object or Array by defining\n\t * hidden properties.\n\t */\n\t/* istanbul ignore next */\n\tfunction copyAugment (target, src, keys) {\n\t  for (var i = 0, l = keys.length; i < l; i++) {\n\t    var key = keys[i];\n\t    def(target, key, src[key]);\n\t  }\n\t}\n\n\t/**\n\t * Attempt to create an observer instance for a value,\n\t * returns the new observer if successfully observed,\n\t * or the existing observer if the value already has one.\n\t */\n\tfunction observe (value, asRootData) {\n\t  if (!isObject(value)) {\n\t    return\n\t  }\n\t  var ob;\n\t  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n\t    ob = value.__ob__;\n\t  } else if (\n\t    observerState.shouldConvert &&\n\t    !isServerRendering() &&\n\t    (Array.isArray(value) || isPlainObject(value)) &&\n\t    Object.isExtensible(value) &&\n\t    !value._isVue\n\t  ) {\n\t    ob = new Observer(value);\n\t  }\n\t  if (asRootData && ob) {\n\t    ob.vmCount++;\n\t  }\n\t  return ob\n\t}\n\n\t/**\n\t * Define a reactive property on an Object.\n\t */\n\tfunction defineReactive$$1 (\n\t  obj,\n\t  key,\n\t  val,\n\t  customSetter\n\t) {\n\t  var dep = new Dep();\n\n\t  var property = Object.getOwnPropertyDescriptor(obj, key);\n\t  if (property && property.configurable === false) {\n\t    return\n\t  }\n\n\t  // cater for pre-defined getter/setters\n\t  var getter = property && property.get;\n\t  var setter = property && property.set;\n\n\t  var childOb = observe(val);\n\t  Object.defineProperty(obj, key, {\n\t    enumerable: true,\n\t    configurable: true,\n\t    get: function reactiveGetter () {\n\t      var value = getter ? getter.call(obj) : val;\n\t      if (Dep.target) {\n\t        dep.depend();\n\t        if (childOb) {\n\t          childOb.dep.depend();\n\t        }\n\t        if (Array.isArray(value)) {\n\t          dependArray(value);\n\t        }\n\t      }\n\t      return value\n\t    },\n\t    set: function reactiveSetter (newVal) {\n\t      var value = getter ? getter.call(obj) : val;\n\t      /* eslint-disable no-self-compare */\n\t      if (newVal === value || (newVal !== newVal && value !== value)) {\n\t        return\n\t      }\n\t      /* eslint-enable no-self-compare */\n\t      if (false) {}\n\t      if (setter) {\n\t        setter.call(obj, newVal);\n\t      } else {\n\t        val = newVal;\n\t      }\n\t      childOb = observe(newVal);\n\t      dep.notify();\n\t    }\n\t  });\n\t}\n\n\t/**\n\t * Set a property on an object. Adds the new property and\n\t * triggers change notification if the property doesn't\n\t * already exist.\n\t */\n\tfunction set$1 (obj, key, val) {\n\t  if (Array.isArray(obj)) {\n\t    obj.length = Math.max(obj.length, key);\n\t    obj.splice(key, 1, val);\n\t    return val\n\t  }\n\t  if (hasOwn(obj, key)) {\n\t    obj[key] = val;\n\t    return\n\t  }\n\t  var ob = obj.__ob__;\n\t  if (obj._isVue || (ob && ob.vmCount)) {\n\t    \"production\" !== 'production' && warn$1(\n\t      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n\t      'at runtime - declare it upfront in the data option.'\n\t    );\n\t    return\n\t  }\n\t  if (!ob) {\n\t    obj[key] = val;\n\t    return\n\t  }\n\t  defineReactive$$1(ob.value, key, val);\n\t  ob.dep.notify();\n\t  return val\n\t}\n\n\t/**\n\t * Delete a property and trigger change if necessary.\n\t */\n\tfunction del (obj, key) {\n\t  var ob = obj.__ob__;\n\t  if (obj._isVue || (ob && ob.vmCount)) {\n\t    \"production\" !== 'production' && warn$1(\n\t      'Avoid deleting properties on a Vue instance or its root $data ' +\n\t      '- just set it to null.'\n\t    );\n\t    return\n\t  }\n\t  if (!hasOwn(obj, key)) {\n\t    return\n\t  }\n\t  delete obj[key];\n\t  if (!ob) {\n\t    return\n\t  }\n\t  ob.dep.notify();\n\t}\n\n\t/**\n\t * Collect dependencies on array elements when the array is touched, since\n\t * we cannot intercept array element access like property getters.\n\t */\n\tfunction dependArray (value) {\n\t  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n\t    e = value[i];\n\t    e && e.__ob__ && e.__ob__.dep.depend();\n\t    if (Array.isArray(e)) {\n\t      dependArray(e);\n\t    }\n\t  }\n\t}\n\n\t/*  */\n\n\t/**\n\t * Option overwriting strategies are functions that handle\n\t * how to merge a parent option value and a child option\n\t * value into the final value.\n\t */\n\tvar strats = config.optionMergeStrategies;\n\n\t/**\n\t * Helper that recursively merges two data objects together.\n\t */\n\tfunction mergeData (to, from) {\n\t  if (!from) { return to }\n\t  var key, toVal, fromVal;\n\t  var keys = Object.keys(from);\n\t  for (var i = 0; i < keys.length; i++) {\n\t    key = keys[i];\n\t    toVal = to[key];\n\t    fromVal = from[key];\n\t    if (!hasOwn(to, key)) {\n\t      set$1(to, key, fromVal);\n\t    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n\t      mergeData(toVal, fromVal);\n\t    }\n\t  }\n\t  return to\n\t}\n\n\t/**\n\t * Data\n\t */\n\tstrats.data = function (\n\t  parentVal,\n\t  childVal,\n\t  vm\n\t) {\n\t  if (!vm) {\n\t    // in a Vue.extend merge, both should be functions\n\t    if (!childVal) {\n\t      return parentVal\n\t    }\n\t    if (typeof childVal !== 'function') {\n\t      \"production\" !== 'production' && warn$1(\n\t        'The \"data\" option should be a function ' +\n\t        'that returns a per-instance value in component ' +\n\t        'definitions.',\n\t        vm\n\t      );\n\t      return parentVal\n\t    }\n\t    if (!parentVal) {\n\t      return childVal\n\t    }\n\t    // when parentVal & childVal are both present,\n\t    // we need to return a function that returns the\n\t    // merged result of both functions... no need to\n\t    // check if parentVal is a function here because\n\t    // it has to be a function to pass previous merges.\n\t    return function mergedDataFn () {\n\t      return mergeData(\n\t        childVal.call(this),\n\t        parentVal.call(this)\n\t      )\n\t    }\n\t  } else if (parentVal || childVal) {\n\t    return function mergedInstanceDataFn () {\n\t      // instance merge\n\t      var instanceData = typeof childVal === 'function'\n\t        ? childVal.call(vm)\n\t        : childVal;\n\t      var defaultData = typeof parentVal === 'function'\n\t        ? parentVal.call(vm)\n\t        : undefined;\n\t      if (instanceData) {\n\t        return mergeData(instanceData, defaultData)\n\t      } else {\n\t        return defaultData\n\t      }\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Hooks and param attributes are merged as arrays.\n\t */\n\tfunction mergeHook (\n\t  parentVal,\n\t  childVal\n\t) {\n\t  return childVal\n\t    ? parentVal\n\t      ? parentVal.concat(childVal)\n\t      : Array.isArray(childVal)\n\t        ? childVal\n\t        : [childVal]\n\t    : parentVal\n\t}\n\n\tconfig._lifecycleHooks.forEach(function (hook) {\n\t  strats[hook] = mergeHook;\n\t});\n\n\t/**\n\t * Assets\n\t *\n\t * When a vm is present (instance creation), we need to do\n\t * a three-way merge between constructor options, instance\n\t * options and parent options.\n\t */\n\tfunction mergeAssets (parentVal, childVal) {\n\t  var res = Object.create(parentVal || null);\n\t  return childVal\n\t    ? extend(res, childVal)\n\t    : res\n\t}\n\n\tconfig._assetTypes.forEach(function (type) {\n\t  strats[type + 's'] = mergeAssets;\n\t});\n\n\t/**\n\t * Watchers.\n\t *\n\t * Watchers hashes should not overwrite one\n\t * another, so we merge them as arrays.\n\t */\n\tstrats.watch = function (parentVal, childVal) {\n\t  /* istanbul ignore if */\n\t  if (!childVal) { return parentVal }\n\t  if (!parentVal) { return childVal }\n\t  var ret = {};\n\t  extend(ret, parentVal);\n\t  for (var key in childVal) {\n\t    var parent = ret[key];\n\t    var child = childVal[key];\n\t    if (parent && !Array.isArray(parent)) {\n\t      parent = [parent];\n\t    }\n\t    ret[key] = parent\n\t      ? parent.concat(child)\n\t      : [child];\n\t  }\n\t  return ret\n\t};\n\n\t/**\n\t * Other object hashes.\n\t */\n\tstrats.props =\n\tstrats.methods =\n\tstrats.computed = function (parentVal, childVal) {\n\t  if (!childVal) { return parentVal }\n\t  if (!parentVal) { return childVal }\n\t  var ret = Object.create(null);\n\t  extend(ret, parentVal);\n\t  extend(ret, childVal);\n\t  return ret\n\t};\n\n\t/**\n\t * Default strategy.\n\t */\n\tvar defaultStrat = function (parentVal, childVal) {\n\t  return childVal === undefined\n\t    ? parentVal\n\t    : childVal\n\t};\n\n\t/**\n\t * Ensure all props option syntax are normalized into the\n\t * Object-based format.\n\t */\n\tfunction normalizeProps (options) {\n\t  var props = options.props;\n\t  if (!props) { return }\n\t  var res = {};\n\t  var i, val, name;\n\t  if (Array.isArray(props)) {\n\t    i = props.length;\n\t    while (i--) {\n\t      val = props[i];\n\t      if (typeof val === 'string') {\n\t        name = camelize(val);\n\t        res[name] = { type: null };\n\t      } else if (false) {}\n\t    }\n\t  } else if (isPlainObject(props)) {\n\t    for (var key in props) {\n\t      val = props[key];\n\t      name = camelize(key);\n\t      res[name] = isPlainObject(val)\n\t        ? val\n\t        : { type: val };\n\t    }\n\t  }\n\t  options.props = res;\n\t}\n\n\t/**\n\t * Normalize raw function directives into object format.\n\t */\n\tfunction normalizeDirectives (options) {\n\t  var dirs = options.directives;\n\t  if (dirs) {\n\t    for (var key in dirs) {\n\t      var def = dirs[key];\n\t      if (typeof def === 'function') {\n\t        dirs[key] = { bind: def, update: def };\n\t      }\n\t    }\n\t  }\n\t}\n\n\t/**\n\t * Merge two option objects into a new one.\n\t * Core utility used in both instantiation and inheritance.\n\t */\n\tfunction mergeOptions (\n\t  parent,\n\t  child,\n\t  vm\n\t) {\n\t  if (false) {}\n\t  normalizeProps(child);\n\t  normalizeDirectives(child);\n\t  var extendsFrom = child.extends;\n\t  if (extendsFrom) {\n\t    parent = typeof extendsFrom === 'function'\n\t      ? mergeOptions(parent, extendsFrom.options, vm)\n\t      : mergeOptions(parent, extendsFrom, vm);\n\t  }\n\t  if (child.mixins) {\n\t    for (var i = 0, l = child.mixins.length; i < l; i++) {\n\t      var mixin = child.mixins[i];\n\t      if (mixin.prototype instanceof Vue$2) {\n\t        mixin = mixin.options;\n\t      }\n\t      parent = mergeOptions(parent, mixin, vm);\n\t    }\n\t  }\n\t  var options = {};\n\t  var key;\n\t  for (key in parent) {\n\t    mergeField(key);\n\t  }\n\t  for (key in child) {\n\t    if (!hasOwn(parent, key)) {\n\t      mergeField(key);\n\t    }\n\t  }\n\t  function mergeField (key) {\n\t    var strat = strats[key] || defaultStrat;\n\t    options[key] = strat(parent[key], child[key], vm, key);\n\t  }\n\t  return options\n\t}\n\n\t/**\n\t * Resolve an asset.\n\t * This function is used because child instances need access\n\t * to assets defined in its ancestor chain.\n\t */\n\tfunction resolveAsset (\n\t  options,\n\t  type,\n\t  id,\n\t  warnMissing\n\t) {\n\t  /* istanbul ignore if */\n\t  if (typeof id !== 'string') {\n\t    return\n\t  }\n\t  var assets = options[type];\n\t  // check local registration variations first\n\t  if (hasOwn(assets, id)) { return assets[id] }\n\t  var camelizedId = camelize(id);\n\t  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n\t  var PascalCaseId = capitalize(camelizedId);\n\t  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n\t  // fallback to prototype chain\n\t  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n\t  if (false) {}\n\t  return res\n\t}\n\n\t/*  */\n\n\tfunction validateProp (\n\t  key,\n\t  propOptions,\n\t  propsData,\n\t  vm\n\t) {\n\t  var prop = propOptions[key];\n\t  var absent = !hasOwn(propsData, key);\n\t  var value = propsData[key];\n\t  // handle boolean props\n\t  if (isType(Boolean, prop.type)) {\n\t    if (absent && !hasOwn(prop, 'default')) {\n\t      value = false;\n\t    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n\t      value = true;\n\t    }\n\t  }\n\t  // check default value\n\t  if (value === undefined) {\n\t    value = getPropDefaultValue(vm, prop, key);\n\t    // since the default value is a fresh copy,\n\t    // make sure to observe it.\n\t    var prevShouldConvert = observerState.shouldConvert;\n\t    observerState.shouldConvert = true;\n\t    observe(value);\n\t    observerState.shouldConvert = prevShouldConvert;\n\t  }\n\t  if (false) {}\n\t  return value\n\t}\n\n\t/**\n\t * Get the default value of a prop.\n\t */\n\tfunction getPropDefaultValue (vm, prop, key) {\n\t  // no default, return undefined\n\t  if (!hasOwn(prop, 'default')) {\n\t    return undefined\n\t  }\n\t  var def = prop.default;\n\t  // warn against non-factory defaults for Object & Array\n\t  if (isObject(def)) {\n\t    \"production\" !== 'production' && warn$1(\n\t      'Invalid default value for prop \"' + key + '\": ' +\n\t      'Props with type Object/Array must use a factory function ' +\n\t      'to return the default value.',\n\t      vm\n\t    );\n\t  }\n\t  // the raw prop value was also undefined from previous render,\n\t  // return previous default value to avoid unnecessary watcher trigger\n\t  if (vm && vm.$options.propsData &&\n\t    vm.$options.propsData[key] === undefined &&\n\t    vm[key] !== undefined) {\n\t    return vm[key]\n\t  }\n\t  // call factory function for non-Function types\n\t  return typeof def === 'function' && prop.type !== Function\n\t    ? def.call(vm)\n\t    : def\n\t}\n\n\t/**\n\t * Use function string name to check built-in types,\n\t * because a simple equality check will fail when running\n\t * across different vms / iframes.\n\t */\n\tfunction getType (fn) {\n\t  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n\t  return match && match[1]\n\t}\n\n\tfunction isType (type, fn) {\n\t  if (!Array.isArray(fn)) {\n\t    return getType(fn) === getType(type)\n\t  }\n\t  for (var i = 0, len = fn.length; i < len; i++) {\n\t    if (getType(fn[i]) === getType(type)) {\n\t      return true\n\t    }\n\t  }\n\t  /* istanbul ignore next */\n\t  return false\n\t}\n\n\n\n\tvar util = Object.freeze({\n\t\tdefineReactive: defineReactive$$1,\n\t\t_toString: _toString,\n\t\ttoNumber: toNumber,\n\t\tmakeMap: makeMap,\n\t\tisBuiltInTag: isBuiltInTag,\n\t\tremove: remove$1,\n\t\thasOwn: hasOwn,\n\t\tisPrimitive: isPrimitive,\n\t\tcached: cached,\n\t\tcamelize: camelize,\n\t\tcapitalize: capitalize,\n\t\thyphenate: hyphenate,\n\t\tbind: bind$1,\n\t\ttoArray: toArray,\n\t\textend: extend,\n\t\tisObject: isObject,\n\t\tisPlainObject: isPlainObject,\n\t\ttoObject: toObject,\n\t\tnoop: noop,\n\t\tno: no,\n\t\tidentity: identity,\n\t\tgenStaticKeys: genStaticKeys,\n\t\tlooseEqual: looseEqual,\n\t\tlooseIndexOf: looseIndexOf,\n\t\tisReserved: isReserved,\n\t\tdef: def,\n\t\tparsePath: parsePath,\n\t\thasProto: hasProto,\n\t\tinBrowser: inBrowser,\n\t\tUA: UA,\n\t\tisIE: isIE,\n\t\tisIE9: isIE9,\n\t\tisEdge: isEdge,\n\t\tisAndroid: isAndroid,\n\t\tisIOS: isIOS,\n\t\tisServerRendering: isServerRendering,\n\t\tdevtools: devtools,\n\t\tnextTick: nextTick,\n\t\tget _Set () { return _Set; },\n\t\tmergeOptions: mergeOptions,\n\t\tresolveAsset: resolveAsset,\n\t\tget warn () { return warn$1; },\n\t\tget formatComponentName () { return formatComponentName$1; },\n\t\tvalidateProp: validateProp\n\t});\n\n\t/*  */\n\n\n\tvar queue = [];\n\tvar has$1 = {};\n\tvar waiting = false;\n\tvar flushing = false;\n\tvar index = 0;\n\n\t/**\n\t * Reset the scheduler's state.\n\t */\n\tfunction resetSchedulerState () {\n\t  queue.length = 0;\n\t  has$1 = {};\n\t  if (false) {}\n\t  waiting = flushing = false;\n\t}\n\n\t/**\n\t * Flush both queues and run the watchers.\n\t */\n\tfunction flushSchedulerQueue () {\n\t  flushing = true;\n\n\t  // Sort queue before flush.\n\t  // This ensures that:\n\t  // 1. Components are updated from parent to child. (because parent is always\n\t  //    created before the child)\n\t  // 2. A component's user watchers are run before its render watcher (because\n\t  //    user watchers are created before the render watcher)\n\t  // 3. If a component is destroyed during a parent component's watcher run,\n\t  //    its watchers can be skipped.\n\t  queue.sort(function (a, b) { return a.id - b.id; });\n\n\t  // do not cache length because more watchers might be pushed\n\t  // as we run existing watchers\n\t  for (index = 0; index < queue.length; index++) {\n\t    var watcher = queue[index];\n\t    var id = watcher.id;\n\t    has$1[id] = null;\n\t    watcher.run();\n\t    // in dev build, check and stop circular updates.\n\t    if (false) {}\n\t  }\n\n\t  // devtool hook\n\t  /* istanbul ignore if */\n\t  if (devtools && config.devtools) {\n\t    devtools.emit('flush');\n\t  }\n\n\t  resetSchedulerState();\n\t}\n\n\t/**\n\t * Push a watcher into the watcher queue.\n\t * Jobs with duplicate IDs will be skipped unless it's\n\t * pushed when the queue is being flushed.\n\t */\n\tfunction queueWatcher (watcher) {\n\t  var id = watcher.id;\n\t  if (has$1[id] == null) {\n\t    has$1[id] = true;\n\t    if (!flushing) {\n\t      queue.push(watcher);\n\t    } else {\n\t      // if already flushing, splice the watcher based on its id\n\t      // if already past its id, it will be run next immediately.\n\t      var i = queue.length - 1;\n\t      while (i >= 0 && queue[i].id > watcher.id) {\n\t        i--;\n\t      }\n\t      queue.splice(Math.max(i, index) + 1, 0, watcher);\n\t    }\n\t    // queue the flush\n\t    if (!waiting) {\n\t      waiting = true;\n\t      nextTick(flushSchedulerQueue);\n\t    }\n\t  }\n\t}\n\n\t/*  */\n\n\tvar uid$2 = 0;\n\n\t/**\n\t * A watcher parses an expression, collects dependencies,\n\t * and fires callback when the expression value changes.\n\t * This is used for both the $watch() api and directives.\n\t */\n\tvar Watcher = function Watcher (\n\t  vm,\n\t  expOrFn,\n\t  cb,\n\t  options\n\t) {\n\t  this.vm = vm;\n\t  vm._watchers.push(this);\n\t  // options\n\t  if (options) {\n\t    this.deep = !!options.deep;\n\t    this.user = !!options.user;\n\t    this.lazy = !!options.lazy;\n\t    this.sync = !!options.sync;\n\t  } else {\n\t    this.deep = this.user = this.lazy = this.sync = false;\n\t  }\n\t  this.cb = cb;\n\t  this.id = ++uid$2; // uid for batching\n\t  this.active = true;\n\t  this.dirty = this.lazy; // for lazy watchers\n\t  this.deps = [];\n\t  this.newDeps = [];\n\t  this.depIds = new _Set();\n\t  this.newDepIds = new _Set();\n\t  this.expression = '';\n\t  // parse expression for getter\n\t  if (typeof expOrFn === 'function') {\n\t    this.getter = expOrFn;\n\t  } else {\n\t    this.getter = parsePath(expOrFn);\n\t    if (!this.getter) {\n\t      this.getter = function () {};\n\t      \"production\" !== 'production' && warn$1(\n\t        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n\t        'Watcher only accepts simple dot-delimited paths. ' +\n\t        'For full control, use a function instead.',\n\t        vm\n\t      );\n\t    }\n\t  }\n\t  this.value = this.lazy\n\t    ? undefined\n\t    : this.get();\n\t};\n\n\t/**\n\t * Evaluate the getter, and re-collect dependencies.\n\t */\n\tWatcher.prototype.get = function get () {\n\t  pushTarget(this);\n\t  var value = this.getter.call(this.vm, this.vm);\n\t  // \"touch\" every property so they are all tracked as\n\t  // dependencies for deep watching\n\t  if (this.deep) {\n\t    traverse(value);\n\t  }\n\t  popTarget();\n\t  this.cleanupDeps();\n\t  return value\n\t};\n\n\t/**\n\t * Add a dependency to this directive.\n\t */\n\tWatcher.prototype.addDep = function addDep (dep) {\n\t  var id = dep.id;\n\t  if (!this.newDepIds.has(id)) {\n\t    this.newDepIds.add(id);\n\t    this.newDeps.push(dep);\n\t    if (!this.depIds.has(id)) {\n\t      dep.addSub(this);\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Clean up for dependency collection.\n\t */\n\tWatcher.prototype.cleanupDeps = function cleanupDeps () {\n\t    var this$1 = this;\n\n\t  var i = this.deps.length;\n\t  while (i--) {\n\t    var dep = this$1.deps[i];\n\t    if (!this$1.newDepIds.has(dep.id)) {\n\t      dep.removeSub(this$1);\n\t    }\n\t  }\n\t  var tmp = this.depIds;\n\t  this.depIds = this.newDepIds;\n\t  this.newDepIds = tmp;\n\t  this.newDepIds.clear();\n\t  tmp = this.deps;\n\t  this.deps = this.newDeps;\n\t  this.newDeps = tmp;\n\t  this.newDeps.length = 0;\n\t};\n\n\t/**\n\t * Subscriber interface.\n\t * Will be called when a dependency changes.\n\t */\n\tWatcher.prototype.update = function update () {\n\t  /* istanbul ignore else */\n\t  if (this.lazy) {\n\t    this.dirty = true;\n\t  } else if (this.sync) {\n\t    this.run();\n\t  } else {\n\t    queueWatcher(this);\n\t  }\n\t};\n\n\t/**\n\t * Scheduler job interface.\n\t * Will be called by the scheduler.\n\t */\n\tWatcher.prototype.run = function run () {\n\t  if (this.active) {\n\t    var value = this.get();\n\t    if (\n\t      value !== this.value ||\n\t      // Deep watchers and watchers on Object/Arrays should fire even\n\t      // when the value is the same, because the value may\n\t      // have mutated.\n\t      isObject(value) ||\n\t      this.deep\n\t    ) {\n\t      // set new value\n\t      var oldValue = this.value;\n\t      this.value = value;\n\t      if (this.user) {\n\t        try {\n\t          this.cb.call(this.vm, value, oldValue);\n\t        } catch (e) {\n\t          /* istanbul ignore else */\n\t          if (config.errorHandler) {\n\t            config.errorHandler.call(null, e, this.vm);\n\t          } else {\n\t            \"production\" !== 'production' && warn$1(\n\t              (\"Error in watcher \\\"\" + (this.expression) + \"\\\"\"),\n\t              this.vm\n\t            );\n\t            throw e\n\t          }\n\t        }\n\t      } else {\n\t        this.cb.call(this.vm, value, oldValue);\n\t      }\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Evaluate the value of the watcher.\n\t * This only gets called for lazy watchers.\n\t */\n\tWatcher.prototype.evaluate = function evaluate () {\n\t  this.value = this.get();\n\t  this.dirty = false;\n\t};\n\n\t/**\n\t * Depend on all deps collected by this watcher.\n\t */\n\tWatcher.prototype.depend = function depend () {\n\t    var this$1 = this;\n\n\t  var i = this.deps.length;\n\t  while (i--) {\n\t    this$1.deps[i].depend();\n\t  }\n\t};\n\n\t/**\n\t * Remove self from all dependencies' subscriber list.\n\t */\n\tWatcher.prototype.teardown = function teardown () {\n\t    var this$1 = this;\n\n\t  if (this.active) {\n\t    // remove self from vm's watcher list\n\t    // this is a somewhat expensive operation so we skip it\n\t    // if the vm is being destroyed.\n\t    if (!this.vm._isBeingDestroyed) {\n\t      remove$1(this.vm._watchers, this);\n\t    }\n\t    var i = this.deps.length;\n\t    while (i--) {\n\t      this$1.deps[i].removeSub(this$1);\n\t    }\n\t    this.active = false;\n\t  }\n\t};\n\n\t/**\n\t * Recursively traverse an object to evoke all converted\n\t * getters, so that every nested property inside the object\n\t * is collected as a \"deep\" dependency.\n\t */\n\tvar seenObjects = new _Set();\n\tfunction traverse (val) {\n\t  seenObjects.clear();\n\t  _traverse(val, seenObjects);\n\t}\n\n\tfunction _traverse (val, seen) {\n\t  var i, keys;\n\t  var isA = Array.isArray(val);\n\t  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n\t    return\n\t  }\n\t  if (val.__ob__) {\n\t    var depId = val.__ob__.dep.id;\n\t    if (seen.has(depId)) {\n\t      return\n\t    }\n\t    seen.add(depId);\n\t  }\n\t  if (isA) {\n\t    i = val.length;\n\t    while (i--) { _traverse(val[i], seen); }\n\t  } else {\n\t    keys = Object.keys(val);\n\t    i = keys.length;\n\t    while (i--) { _traverse(val[keys[i]], seen); }\n\t  }\n\t}\n\n\t/*  */\n\n\tfunction initState (vm) {\n\t  vm._watchers = [];\n\t  var opts = vm.$options;\n\t  if (opts.props) { initProps(vm, opts.props); }\n\t  if (opts.methods) { initMethods(vm, opts.methods); }\n\t  if (opts.data) {\n\t    initData(vm);\n\t  } else {\n\t    observe(vm._data = {}, true /* asRootData */);\n\t  }\n\t  if (opts.computed) { initComputed(vm, opts.computed); }\n\t  if (opts.watch) { initWatch(vm, opts.watch); }\n\t}\n\n\tfunction initProps (vm, props) {\n\t  var propsData = vm.$options.propsData || {};\n\t  var keys = vm.$options._propKeys = Object.keys(props);\n\t  var isRoot = !vm.$parent;\n\t  // root instance props should be converted\n\t  observerState.shouldConvert = isRoot;\n\t  var loop = function ( i ) {\n\t    var key = keys[i];\n\t    /* istanbul ignore else */\n\t    if (false) {} else {\n\t      defineReactive$$1(vm, key, validateProp(key, props, propsData, vm));\n\t    }\n\t  };\n\n\t  for (var i = 0; i < keys.length; i++) { loop( i ); }\n\t  observerState.shouldConvert = true;\n\t}\n\n\tfunction initData (vm) {\n\t  var data = vm.$options.data;\n\t  data = vm._data = typeof data === 'function'\n\t    ? data.call(vm)\n\t    : data || {};\n\t  if (!isPlainObject(data)) {\n\t    data = {};\n\t    \"production\" !== 'production' && warn$1(\n\t      'data functions should return an object:\\n' +\n\t      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n\t      vm\n\t    );\n\t  }\n\t  // proxy data on instance\n\t  var keys = Object.keys(data);\n\t  var props = vm.$options.props;\n\t  var i = keys.length;\n\t  while (i--) {\n\t    if (props && hasOwn(props, keys[i])) {\n\t      \"production\" !== 'production' && warn$1(\n\t        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n\t        \"Use prop default value instead.\",\n\t        vm\n\t      );\n\t    } else {\n\t      proxy(vm, keys[i]);\n\t    }\n\t  }\n\t  // observe data\n\t  observe(data, true /* asRootData */);\n\t}\n\n\tvar computedSharedDefinition = {\n\t  enumerable: true,\n\t  configurable: true,\n\t  get: noop,\n\t  set: noop\n\t};\n\n\tfunction initComputed (vm, computed) {\n\t  for (var key in computed) {\n\t    /* istanbul ignore if */\n\t    if (false) {}\n\t    var userDef = computed[key];\n\t    if (typeof userDef === 'function') {\n\t      computedSharedDefinition.get = makeComputedGetter(userDef, vm);\n\t      computedSharedDefinition.set = noop;\n\t    } else {\n\t      computedSharedDefinition.get = userDef.get\n\t        ? userDef.cache !== false\n\t          ? makeComputedGetter(userDef.get, vm)\n\t          : bind$1(userDef.get, vm)\n\t        : noop;\n\t      computedSharedDefinition.set = userDef.set\n\t        ? bind$1(userDef.set, vm)\n\t        : noop;\n\t    }\n\t    Object.defineProperty(vm, key, computedSharedDefinition);\n\t  }\n\t}\n\n\tfunction makeComputedGetter (getter, owner) {\n\t  var watcher = new Watcher(owner, getter, noop, {\n\t    lazy: true\n\t  });\n\t  return function computedGetter () {\n\t    if (watcher.dirty) {\n\t      watcher.evaluate();\n\t    }\n\t    if (Dep.target) {\n\t      watcher.depend();\n\t    }\n\t    return watcher.value\n\t  }\n\t}\n\n\tfunction initMethods (vm, methods) {\n\t  for (var key in methods) {\n\t    vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);\n\t    if (false) {}\n\t  }\n\t}\n\n\tfunction initWatch (vm, watch) {\n\t  for (var key in watch) {\n\t    var handler = watch[key];\n\t    if (Array.isArray(handler)) {\n\t      for (var i = 0; i < handler.length; i++) {\n\t        createWatcher(vm, key, handler[i]);\n\t      }\n\t    } else {\n\t      createWatcher(vm, key, handler);\n\t    }\n\t  }\n\t}\n\n\tfunction createWatcher (vm, key, handler) {\n\t  var options;\n\t  if (isPlainObject(handler)) {\n\t    options = handler;\n\t    handler = handler.handler;\n\t  }\n\t  if (typeof handler === 'string') {\n\t    handler = vm[handler];\n\t  }\n\t  vm.$watch(key, handler, options);\n\t}\n\n\tfunction stateMixin (Vue) {\n\t  // flow somehow has problems with directly declared definition object\n\t  // when using Object.defineProperty, so we have to procedurally build up\n\t  // the object here.\n\t  var dataDef = {};\n\t  dataDef.get = function () {\n\t    return this._data\n\t  };\n\t  if (false) {}\n\t  Object.defineProperty(Vue.prototype, '$data', dataDef);\n\n\t  Vue.prototype.$set = set$1;\n\t  Vue.prototype.$delete = del;\n\n\t  Vue.prototype.$watch = function (\n\t    expOrFn,\n\t    cb,\n\t    options\n\t  ) {\n\t    var vm = this;\n\t    options = options || {};\n\t    options.user = true;\n\t    var watcher = new Watcher(vm, expOrFn, cb, options);\n\t    if (options.immediate) {\n\t      cb.call(vm, watcher.value);\n\t    }\n\t    return function unwatchFn () {\n\t      watcher.teardown();\n\t    }\n\t  };\n\t}\n\n\tfunction proxy (vm, key) {\n\t  if (!isReserved(key)) {\n\t    Object.defineProperty(vm, key, {\n\t      configurable: true,\n\t      enumerable: true,\n\t      get: function proxyGetter () {\n\t        return vm._data[key]\n\t      },\n\t      set: function proxySetter (val) {\n\t        vm._data[key] = val;\n\t      }\n\t    });\n\t  }\n\t}\n\n\t/*  */\n\n\tvar VNode = function VNode (\n\t  tag,\n\t  data,\n\t  children,\n\t  text,\n\t  elm,\n\t  context,\n\t  componentOptions\n\t) {\n\t  this.tag = tag;\n\t  this.data = data;\n\t  this.children = children;\n\t  this.text = text;\n\t  this.elm = elm;\n\t  this.ns = undefined;\n\t  this.context = context;\n\t  this.functionalContext = undefined;\n\t  this.key = data && data.key;\n\t  this.componentOptions = componentOptions;\n\t  this.child = undefined;\n\t  this.parent = undefined;\n\t  this.raw = false;\n\t  this.isStatic = false;\n\t  this.isRootInsert = true;\n\t  this.isComment = false;\n\t  this.isCloned = false;\n\t  this.isOnce = false;\n\t};\n\n\tvar createEmptyVNode = function () {\n\t  var node = new VNode();\n\t  node.text = '';\n\t  node.isComment = true;\n\t  return node\n\t};\n\n\tfunction createTextVNode (val) {\n\t  return new VNode(undefined, undefined, undefined, String(val))\n\t}\n\n\t// optimized shallow clone\n\t// used for static nodes and slot nodes because they may be reused across\n\t// multiple renders, cloning them avoids errors when DOM manipulations rely\n\t// on their elm reference.\n\tfunction cloneVNode (vnode) {\n\t  var cloned = new VNode(\n\t    vnode.tag,\n\t    vnode.data,\n\t    vnode.children,\n\t    vnode.text,\n\t    vnode.elm,\n\t    vnode.context,\n\t    vnode.componentOptions\n\t  );\n\t  cloned.ns = vnode.ns;\n\t  cloned.isStatic = vnode.isStatic;\n\t  cloned.key = vnode.key;\n\t  cloned.isCloned = true;\n\t  return cloned\n\t}\n\n\tfunction cloneVNodes (vnodes) {\n\t  var res = new Array(vnodes.length);\n\t  for (var i = 0; i < vnodes.length; i++) {\n\t    res[i] = cloneVNode(vnodes[i]);\n\t  }\n\t  return res\n\t}\n\n\t/*  */\n\n\tfunction mergeVNodeHook (def, hookKey, hook, key) {\n\t  key = key + hookKey;\n\t  var injectedHash = def.__injected || (def.__injected = {});\n\t  if (!injectedHash[key]) {\n\t    injectedHash[key] = true;\n\t    var oldHook = def[hookKey];\n\t    if (oldHook) {\n\t      def[hookKey] = function () {\n\t        oldHook.apply(this, arguments);\n\t        hook.apply(this, arguments);\n\t      };\n\t    } else {\n\t      def[hookKey] = hook;\n\t    }\n\t  }\n\t}\n\n\t/*  */\n\n\tfunction updateListeners (\n\t  on,\n\t  oldOn,\n\t  add,\n\t  remove$$1,\n\t  vm\n\t) {\n\t  var name, cur, old, fn, event, capture, once;\n\t  for (name in on) {\n\t    cur = on[name];\n\t    old = oldOn[name];\n\t    if (!cur) {\n\t      \"production\" !== 'production' && warn$1(\n\t        \"Invalid handler for event \\\"\" + name + \"\\\": got \" + String(cur),\n\t        vm\n\t      );\n\t    } else if (!old) {\n\t      once = name.charAt(0) === '~'; // Prefixed last, checked first\n\t      event = once ? name.slice(1) : name;\n\t      capture = event.charAt(0) === '!';\n\t      event = capture ? event.slice(1) : event;\n\t      if (Array.isArray(cur)) {\n\t        add(event, (cur.invoker = arrInvoker(cur)), once, capture);\n\t      } else {\n\t        if (!cur.invoker) {\n\t          fn = cur;\n\t          cur = on[name] = {};\n\t          cur.fn = fn;\n\t          cur.invoker = fnInvoker(cur);\n\t        }\n\t        add(event, cur.invoker, once, capture);\n\t      }\n\t    } else if (cur !== old) {\n\t      if (Array.isArray(old)) {\n\t        old.length = cur.length;\n\t        for (var i = 0; i < old.length; i++) { old[i] = cur[i]; }\n\t        on[name] = old;\n\t      } else {\n\t        old.fn = cur;\n\t        on[name] = old;\n\t      }\n\t    }\n\t  }\n\t  for (name in oldOn) {\n\t    if (!on[name]) {\n\t      once = name.charAt(0) === '~'; // Prefixed last, checked first\n\t      event = once ? name.slice(1) : name;\n\t      capture = event.charAt(0) === '!';\n\t      event = capture ? event.slice(1) : event;\n\t      remove$$1(event, oldOn[name].invoker, capture);\n\t    }\n\t  }\n\t}\n\n\tfunction arrInvoker (arr) {\n\t  return function (ev) {\n\t    var arguments$1 = arguments;\n\n\t    var single = arguments.length === 1;\n\t    for (var i = 0; i < arr.length; i++) {\n\t      single ? arr[i](ev) : arr[i].apply(null, arguments$1);\n\t    }\n\t  }\n\t}\n\n\tfunction fnInvoker (o) {\n\t  return function (ev) {\n\t    var single = arguments.length === 1;\n\t    single ? o.fn(ev) : o.fn.apply(null, arguments);\n\t  }\n\t}\n\n\t/*  */\n\n\t// The template compiler attempts to minimize the need for normalization by\n\t// statically analyzing the template at compile time.\n\t//\n\t// For plain HTML markup, normalization can be completely skipped because the\n\t// generated render function is guaranteed to return Array<VNode>. There are\n\t// two cases where extra normalization is needed:\n\n\t// 1. When the children contains components - because a functional component\n\t// may return an Array instead of a single root. In this case, just a simple\n\t// nomralization is needed - if any child is an Array, we flatten the whole\n\t// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n\t// because functional components already normalize their own children.\n\tfunction simpleNormalizeChildren (children) {\n\t  for (var i = 0; i < children.length; i++) {\n\t    if (Array.isArray(children[i])) {\n\t      return Array.prototype.concat.apply([], children)\n\t    }\n\t  }\n\t  return children\n\t}\n\n\t// 2. When the children contains constrcuts that always generated nested Arrays,\n\t// e.g. <template>, <slot>, v-for, or when the children is provided by user\n\t// with hand-written render functions / JSX. In such cases a full normalization\n\t// is needed to cater to all possible types of children values.\n\tfunction normalizeChildren (children) {\n\t  return isPrimitive(children)\n\t    ? [createTextVNode(children)]\n\t    : Array.isArray(children)\n\t      ? normalizeArrayChildren(children)\n\t      : undefined\n\t}\n\n\tfunction normalizeArrayChildren (children, nestedIndex) {\n\t  var res = [];\n\t  var i, c, last;\n\t  for (i = 0; i < children.length; i++) {\n\t    c = children[i];\n\t    if (c == null || typeof c === 'boolean') { continue }\n\t    last = res[res.length - 1];\n\t    //  nested\n\t    if (Array.isArray(c)) {\n\t      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n\t    } else if (isPrimitive(c)) {\n\t      if (last && last.text) {\n\t        last.text += String(c);\n\t      } else if (c !== '') {\n\t        // convert primitive to vnode\n\t        res.push(createTextVNode(c));\n\t      }\n\t    } else {\n\t      if (c.text && last && last.text) {\n\t        res[res.length - 1] = createTextVNode(last.text + c.text);\n\t      } else {\n\t        // default key for nested array children (likely generated by v-for)\n\t        if (c.tag && c.key == null && nestedIndex != null) {\n\t          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n\t        }\n\t        res.push(c);\n\t      }\n\t    }\n\t  }\n\t  return res\n\t}\n\n\t/*  */\n\n\tfunction getFirstComponentChild (children) {\n\t  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\n\t}\n\n\t/*  */\n\n\tfunction initEvents (vm) {\n\t  vm._events = Object.create(null);\n\t  vm._hasHookEvent = false;\n\t  // init parent attached events\n\t  var listeners = vm.$options._parentListeners;\n\t  if (listeners) {\n\t    updateComponentListeners(vm, listeners);\n\t  }\n\t}\n\n\tvar target;\n\n\tfunction add$1 (event, fn, once) {\n\t  if (once) {\n\t    target.$once(event, fn);\n\t  } else {\n\t    target.$on(event, fn);\n\t  }\n\t}\n\n\tfunction remove$2 (event, fn) {\n\t  target.$off(event, fn);\n\t}\n\n\tfunction updateComponentListeners (\n\t  vm,\n\t  listeners,\n\t  oldListeners\n\t) {\n\t  target = vm;\n\t  updateListeners(listeners, oldListeners || {}, add$1, remove$2, vm);\n\t}\n\n\tfunction eventsMixin (Vue) {\n\t  var hookRE = /^hook:/;\n\t  Vue.prototype.$on = function (event, fn) {\n\t    var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);\n\t    // optimize hook:event cost by using a boolean flag marked at registration\n\t    // instead of a hash lookup\n\t    if (hookRE.test(event)) {\n\t      vm._hasHookEvent = true;\n\t    }\n\t    return vm\n\t  };\n\n\t  Vue.prototype.$once = function (event, fn) {\n\t    var vm = this;\n\t    function on () {\n\t      vm.$off(event, on);\n\t      fn.apply(vm, arguments);\n\t    }\n\t    on.fn = fn;\n\t    vm.$on(event, on);\n\t    return vm\n\t  };\n\n\t  Vue.prototype.$off = function (event, fn) {\n\t    var vm = this;\n\t    // all\n\t    if (!arguments.length) {\n\t      vm._events = Object.create(null);\n\t      return vm\n\t    }\n\t    // specific event\n\t    var cbs = vm._events[event];\n\t    if (!cbs) {\n\t      return vm\n\t    }\n\t    if (arguments.length === 1) {\n\t      vm._events[event] = null;\n\t      return vm\n\t    }\n\t    // specific handler\n\t    var cb;\n\t    var i = cbs.length;\n\t    while (i--) {\n\t      cb = cbs[i];\n\t      if (cb === fn || cb.fn === fn) {\n\t        cbs.splice(i, 1);\n\t        break\n\t      }\n\t    }\n\t    return vm\n\t  };\n\n\t  Vue.prototype.$emit = function (event) {\n\t    var vm = this;\n\t    var cbs = vm._events[event];\n\t    if (cbs) {\n\t      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n\t      var args = toArray(arguments, 1);\n\t      for (var i = 0, l = cbs.length; i < l; i++) {\n\t        cbs[i].apply(vm, args);\n\t      }\n\t    }\n\t    return vm\n\t  };\n\t}\n\n\t/*  */\n\n\tvar activeInstance = null;\n\n\tfunction initLifecycle (vm) {\n\t  var options = vm.$options;\n\n\t  // locate first non-abstract parent\n\t  var parent = options.parent;\n\t  if (parent && !options.abstract) {\n\t    while (parent.$options.abstract && parent.$parent) {\n\t      parent = parent.$parent;\n\t    }\n\t    parent.$children.push(vm);\n\t  }\n\n\t  vm.$parent = parent;\n\t  vm.$root = parent ? parent.$root : vm;\n\n\t  vm.$children = [];\n\t  vm.$refs = {};\n\n\t  vm._watcher = null;\n\t  vm._inactive = false;\n\t  vm._isMounted = false;\n\t  vm._isDestroyed = false;\n\t  vm._isBeingDestroyed = false;\n\t}\n\n\tfunction lifecycleMixin (Vue) {\n\t  Vue.prototype._mount = function (\n\t    el,\n\t    hydrating\n\t  ) {\n\t    var vm = this;\n\t    vm.$el = el;\n\t    if (!vm.$options.render) {\n\t      vm.$options.render = createEmptyVNode;\n\t      if (false) {}\n\t    }\n\t    callHook(vm, 'beforeMount');\n\t    vm._watcher = new Watcher(vm, function () {\n\t      vm._update(vm._render(), hydrating);\n\t    }, noop);\n\t    hydrating = false;\n\t    // manually mounted instance, call mounted on self\n\t    // mounted is called for render-created child components in its inserted hook\n\t    if (vm.$vnode == null) {\n\t      vm._isMounted = true;\n\t      callHook(vm, 'mounted');\n\t    }\n\t    return vm\n\t  };\n\n\t  Vue.prototype._update = function (vnode, hydrating) {\n\t    var vm = this;\n\t    if (vm._isMounted) {\n\t      callHook(vm, 'beforeUpdate');\n\t    }\n\t    var prevEl = vm.$el;\n\t    var prevVnode = vm._vnode;\n\t    var prevActiveInstance = activeInstance;\n\t    activeInstance = vm;\n\t    vm._vnode = vnode;\n\t    // Vue.prototype.__patch__ is injected in entry points\n\t    // based on the rendering backend used.\n\t    if (!prevVnode) {\n\t      // initial render\n\t      vm.$el = vm.__patch__(\n\t        vm.$el, vnode, hydrating, false /* removeOnly */,\n\t        vm.$options._parentElm,\n\t        vm.$options._refElm\n\t      );\n\t    } else {\n\t      // updates\n\t      vm.$el = vm.__patch__(prevVnode, vnode);\n\t    }\n\t    activeInstance = prevActiveInstance;\n\t    // update __vue__ reference\n\t    if (prevEl) {\n\t      prevEl.__vue__ = null;\n\t    }\n\t    if (vm.$el) {\n\t      vm.$el.__vue__ = vm;\n\t    }\n\t    // if parent is an HOC, update its $el as well\n\t    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n\t      vm.$parent.$el = vm.$el;\n\t    }\n\t    if (vm._isMounted) {\n\t      callHook(vm, 'updated');\n\t    }\n\t  };\n\n\t  Vue.prototype._updateFromParent = function (\n\t    propsData,\n\t    listeners,\n\t    parentVnode,\n\t    renderChildren\n\t  ) {\n\t    var vm = this;\n\t    var hasChildren = !!(vm.$options._renderChildren || renderChildren);\n\t    vm.$options._parentVnode = parentVnode;\n\t    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\t    if (vm._vnode) { // update child tree's parent\n\t      vm._vnode.parent = parentVnode;\n\t    }\n\t    vm.$options._renderChildren = renderChildren;\n\t    // update props\n\t    if (propsData && vm.$options.props) {\n\t      observerState.shouldConvert = false;\n\t      if (false) {}\n\t      var propKeys = vm.$options._propKeys || [];\n\t      for (var i = 0; i < propKeys.length; i++) {\n\t        var key = propKeys[i];\n\t        vm[key] = validateProp(key, vm.$options.props, propsData, vm);\n\t      }\n\t      observerState.shouldConvert = true;\n\t      if (false) {}\n\t      vm.$options.propsData = propsData;\n\t    }\n\t    // update listeners\n\t    if (listeners) {\n\t      var oldListeners = vm.$options._parentListeners;\n\t      vm.$options._parentListeners = listeners;\n\t      updateComponentListeners(vm, listeners, oldListeners);\n\t    }\n\t    // resolve slots + force update if has children\n\t    if (hasChildren) {\n\t      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n\t      vm.$forceUpdate();\n\t    }\n\t  };\n\n\t  Vue.prototype.$forceUpdate = function () {\n\t    var vm = this;\n\t    if (vm._watcher) {\n\t      vm._watcher.update();\n\t    }\n\t  };\n\n\t  Vue.prototype.$destroy = function () {\n\t    var vm = this;\n\t    if (vm._isBeingDestroyed) {\n\t      return\n\t    }\n\t    callHook(vm, 'beforeDestroy');\n\t    vm._isBeingDestroyed = true;\n\t    // remove self from parent\n\t    var parent = vm.$parent;\n\t    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n\t      remove$1(parent.$children, vm);\n\t    }\n\t    // teardown watchers\n\t    if (vm._watcher) {\n\t      vm._watcher.teardown();\n\t    }\n\t    var i = vm._watchers.length;\n\t    while (i--) {\n\t      vm._watchers[i].teardown();\n\t    }\n\t    // remove reference from data ob\n\t    // frozen object may not have observer.\n\t    if (vm._data.__ob__) {\n\t      vm._data.__ob__.vmCount--;\n\t    }\n\t    // call the last hook...\n\t    vm._isDestroyed = true;\n\t    callHook(vm, 'destroyed');\n\t    // turn off all instance listeners.\n\t    vm.$off();\n\t    // remove __vue__ reference\n\t    if (vm.$el) {\n\t      vm.$el.__vue__ = null;\n\t    }\n\t    // invoke destroy hooks on current rendered tree\n\t    vm.__patch__(vm._vnode, null);\n\t  };\n\t}\n\n\tfunction callHook (vm, hook) {\n\t  var handlers = vm.$options[hook];\n\t  if (handlers) {\n\t    for (var i = 0, j = handlers.length; i < j; i++) {\n\t      handlers[i].call(vm);\n\t    }\n\t  }\n\t  if (vm._hasHookEvent) {\n\t    vm.$emit('hook:' + hook);\n\t  }\n\t}\n\n\t/*  */\n\n\tvar hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };\n\tvar hooksToMerge = Object.keys(hooks);\n\n\tfunction createComponent (\n\t  Ctor,\n\t  data,\n\t  context,\n\t  children,\n\t  tag\n\t) {\n\t  if (!Ctor) {\n\t    return\n\t  }\n\n\t  var baseCtor = context.$options._base;\n\t  if (isObject(Ctor)) {\n\t    Ctor = baseCtor.extend(Ctor);\n\t  }\n\n\t  if (typeof Ctor !== 'function') {\n\t    if (false) {}\n\t    return\n\t  }\n\n\t  // async component\n\t  if (!Ctor.cid) {\n\t    if (Ctor.resolved) {\n\t      Ctor = Ctor.resolved;\n\t    } else {\n\t      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {\n\t        // it's ok to queue this on every render because\n\t        // $forceUpdate is buffered by the scheduler.\n\t        context.$forceUpdate();\n\t      });\n\t      if (!Ctor) {\n\t        // return nothing if this is indeed an async component\n\t        // wait for the callback to trigger parent update.\n\t        return\n\t      }\n\t    }\n\t  }\n\n\t  // resolve constructor options in case global mixins are applied after\n\t  // component constructor creation\n\t  resolveConstructorOptions(Ctor);\n\n\t  data = data || {};\n\n\t  // extract props\n\t  var propsData = extractProps(data, Ctor);\n\n\t  // functional component\n\t  if (Ctor.options.functional) {\n\t    return createFunctionalComponent(Ctor, propsData, data, context, children)\n\t  }\n\n\t  // extract listeners, since these needs to be treated as\n\t  // child component listeners instead of DOM listeners\n\t  var listeners = data.on;\n\t  // replace with listeners with .native modifier\n\t  data.on = data.nativeOn;\n\n\t  if (Ctor.options.abstract) {\n\t    // abstract components do not keep anything\n\t    // other than props & listeners\n\t    data = {};\n\t  }\n\n\t  // merge component management hooks onto the placeholder node\n\t  mergeHooks(data);\n\n\t  // return a placeholder vnode\n\t  var name = Ctor.options.name || tag;\n\t  var vnode = new VNode(\n\t    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n\t    data, undefined, undefined, undefined, context,\n\t    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n\t  );\n\t  return vnode\n\t}\n\n\tfunction createFunctionalComponent (\n\t  Ctor,\n\t  propsData,\n\t  data,\n\t  context,\n\t  children\n\t) {\n\t  var props = {};\n\t  var propOptions = Ctor.options.props;\n\t  if (propOptions) {\n\t    for (var key in propOptions) {\n\t      props[key] = validateProp(key, propOptions, propsData);\n\t    }\n\t  }\n\t  // ensure the createElement function in functional components\n\t  // gets a unique context - this is necessary for correct named slot check\n\t  var _context = Object.create(context);\n\t  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n\t  var vnode = Ctor.options.render.call(null, h, {\n\t    props: props,\n\t    data: data,\n\t    parent: context,\n\t    children: children,\n\t    slots: function () { return resolveSlots(children, context); }\n\t  });\n\t  if (vnode instanceof VNode) {\n\t    vnode.functionalContext = context;\n\t    if (data.slot) {\n\t      (vnode.data || (vnode.data = {})).slot = data.slot;\n\t    }\n\t  }\n\t  return vnode\n\t}\n\n\tfunction createComponentInstanceForVnode (\n\t  vnode, // we know it's MountedComponentVNode but flow doesn't\n\t  parent, // activeInstance in lifecycle state\n\t  parentElm,\n\t  refElm\n\t) {\n\t  var vnodeComponentOptions = vnode.componentOptions;\n\t  var options = {\n\t    _isComponent: true,\n\t    parent: parent,\n\t    propsData: vnodeComponentOptions.propsData,\n\t    _componentTag: vnodeComponentOptions.tag,\n\t    _parentVnode: vnode,\n\t    _parentListeners: vnodeComponentOptions.listeners,\n\t    _renderChildren: vnodeComponentOptions.children,\n\t    _parentElm: parentElm || null,\n\t    _refElm: refElm || null\n\t  };\n\t  // check inline-template render functions\n\t  var inlineTemplate = vnode.data.inlineTemplate;\n\t  if (inlineTemplate) {\n\t    options.render = inlineTemplate.render;\n\t    options.staticRenderFns = inlineTemplate.staticRenderFns;\n\t  }\n\t  return new vnodeComponentOptions.Ctor(options)\n\t}\n\n\tfunction init (\n\t  vnode,\n\t  hydrating,\n\t  parentElm,\n\t  refElm\n\t) {\n\t  if (!vnode.child || vnode.child._isDestroyed) {\n\t    var child = vnode.child = createComponentInstanceForVnode(\n\t      vnode,\n\t      activeInstance,\n\t      parentElm,\n\t      refElm\n\t    );\n\t    child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n\t  } else if (vnode.data.keepAlive) {\n\t    // kept-alive components, treat as a patch\n\t    var mountedNode = vnode; // work around flow\n\t    prepatch(mountedNode, mountedNode);\n\t  }\n\t}\n\n\tfunction prepatch (\n\t  oldVnode,\n\t  vnode\n\t) {\n\t  var options = vnode.componentOptions;\n\t  var child = vnode.child = oldVnode.child;\n\t  child._updateFromParent(\n\t    options.propsData, // updated props\n\t    options.listeners, // updated listeners\n\t    vnode, // new parent vnode\n\t    options.children // new children\n\t  );\n\t}\n\n\tfunction insert (vnode) {\n\t  if (!vnode.child._isMounted) {\n\t    vnode.child._isMounted = true;\n\t    callHook(vnode.child, 'mounted');\n\t  }\n\t  if (vnode.data.keepAlive) {\n\t    vnode.child._inactive = false;\n\t    callHook(vnode.child, 'activated');\n\t  }\n\t}\n\n\tfunction destroy$1 (vnode) {\n\t  if (!vnode.child._isDestroyed) {\n\t    if (!vnode.data.keepAlive) {\n\t      vnode.child.$destroy();\n\t    } else {\n\t      vnode.child._inactive = true;\n\t      callHook(vnode.child, 'deactivated');\n\t    }\n\t  }\n\t}\n\n\tfunction resolveAsyncComponent (\n\t  factory,\n\t  baseCtor,\n\t  cb\n\t) {\n\t  if (factory.requested) {\n\t    // pool callbacks\n\t    factory.pendingCallbacks.push(cb);\n\t  } else {\n\t    factory.requested = true;\n\t    var cbs = factory.pendingCallbacks = [cb];\n\t    var sync = true;\n\n\t    var resolve = function (res) {\n\t      if (isObject(res)) {\n\t        res = baseCtor.extend(res);\n\t      }\n\t      // cache resolved\n\t      factory.resolved = res;\n\t      // invoke callbacks only if this is not a synchronous resolve\n\t      // (async resolves are shimmed as synchronous during SSR)\n\t      if (!sync) {\n\t        for (var i = 0, l = cbs.length; i < l; i++) {\n\t          cbs[i](res);\n\t        }\n\t      }\n\t    };\n\n\t    var reject = function (reason) {\n\t      \"production\" !== 'production' && warn$1(\n\t        \"Failed to resolve async component: \" + (String(factory)) +\n\t        (reason ? (\"\\nReason: \" + reason) : '')\n\t      );\n\t    };\n\n\t    var res = factory(resolve, reject);\n\n\t    // handle promise\n\t    if (res && typeof res.then === 'function' && !factory.resolved) {\n\t      res.then(resolve, reject);\n\t    }\n\n\t    sync = false;\n\t    // return in case resolved synchronously\n\t    return factory.resolved\n\t  }\n\t}\n\n\tfunction extractProps (data, Ctor) {\n\t  // we are only extracting raw values here.\n\t  // validation and default values are handled in the child\n\t  // component itself.\n\t  var propOptions = Ctor.options.props;\n\t  if (!propOptions) {\n\t    return\n\t  }\n\t  var res = {};\n\t  var attrs = data.attrs;\n\t  var props = data.props;\n\t  var domProps = data.domProps;\n\t  if (attrs || props || domProps) {\n\t    for (var key in propOptions) {\n\t      var altKey = hyphenate(key);\n\t      checkProp(res, props, key, altKey, true) ||\n\t      checkProp(res, attrs, key, altKey) ||\n\t      checkProp(res, domProps, key, altKey);\n\t    }\n\t  }\n\t  return res\n\t}\n\n\tfunction checkProp (\n\t  res,\n\t  hash,\n\t  key,\n\t  altKey,\n\t  preserve\n\t) {\n\t  if (hash) {\n\t    if (hasOwn(hash, key)) {\n\t      res[key] = hash[key];\n\t      if (!preserve) {\n\t        delete hash[key];\n\t      }\n\t      return true\n\t    } else if (hasOwn(hash, altKey)) {\n\t      res[key] = hash[altKey];\n\t      if (!preserve) {\n\t        delete hash[altKey];\n\t      }\n\t      return true\n\t    }\n\t  }\n\t  return false\n\t}\n\n\tfunction mergeHooks (data) {\n\t  if (!data.hook) {\n\t    data.hook = {};\n\t  }\n\t  for (var i = 0; i < hooksToMerge.length; i++) {\n\t    var key = hooksToMerge[i];\n\t    var fromParent = data.hook[key];\n\t    var ours = hooks[key];\n\t    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n\t  }\n\t}\n\n\tfunction mergeHook$1 (one, two) {\n\t  return function (a, b, c, d) {\n\t    one(a, b, c, d);\n\t    two(a, b, c, d);\n\t  }\n\t}\n\n\t/*  */\n\n\tvar SIMPLE_NORMALIZE = 1;\n\tvar ALWAYS_NORMALIZE = 2;\n\n\t// wrapper function for providing a more flexible interface\n\t// without getting yelled at by flow\n\tfunction createElement (\n\t  context,\n\t  tag,\n\t  data,\n\t  children,\n\t  normalizationType,\n\t  alwaysNormalize\n\t) {\n\t  if (Array.isArray(data) || isPrimitive(data)) {\n\t    normalizationType = children;\n\t    children = data;\n\t    data = undefined;\n\t  }\n\t  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }\n\t  return _createElement(context, tag, data, children, normalizationType)\n\t}\n\n\tfunction _createElement (\n\t  context,\n\t  tag,\n\t  data,\n\t  children,\n\t  normalizationType\n\t) {\n\t  if (data && data.__ob__) {\n\t    \"production\" !== 'production' && warn$1(\n\t      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n\t      'Always create fresh vnode data objects in each render!',\n\t      context\n\t    );\n\t    return createEmptyVNode()\n\t  }\n\t  if (!tag) {\n\t    // in case of component :is set to falsy value\n\t    return createEmptyVNode()\n\t  }\n\t  // support single function children as default scoped slot\n\t  if (Array.isArray(children) &&\n\t      typeof children[0] === 'function') {\n\t    data = data || {};\n\t    data.scopedSlots = { default: children[0] };\n\t    children.length = 0;\n\t  }\n\t  if (normalizationType === ALWAYS_NORMALIZE) {\n\t    children = normalizeChildren(children);\n\t  } else if (normalizationType === SIMPLE_NORMALIZE) {\n\t    children = simpleNormalizeChildren(children);\n\t  }\n\t  var vnode, ns;\n\t  if (typeof tag === 'string') {\n\t    var Ctor;\n\t    ns = config.getTagNamespace(tag);\n\t    if (config.isReservedTag(tag)) {\n\t      // platform built-in elements\n\t      vnode = new VNode(\n\t        config.parsePlatformTagName(tag), data, children,\n\t        undefined, undefined, context\n\t      );\n\t    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\n\t      // component\n\t      vnode = createComponent(Ctor, data, context, children, tag);\n\t    } else {\n\t      // unknown or unlisted namespaced elements\n\t      // check at runtime because it may get assigned a namespace when its\n\t      // parent normalizes children\n\t      vnode = new VNode(\n\t        tag, data, children,\n\t        undefined, undefined, context\n\t      );\n\t    }\n\t  } else {\n\t    // direct component options / constructor\n\t    vnode = createComponent(tag, data, context, children);\n\t  }\n\t  if (vnode) {\n\t    if (ns) { applyNS(vnode, ns); }\n\t    return vnode\n\t  } else {\n\t    return createEmptyVNode()\n\t  }\n\t}\n\n\tfunction applyNS (vnode, ns) {\n\t  vnode.ns = ns;\n\t  if (vnode.tag === 'foreignObject') {\n\t    // use default namespace inside foreignObject\n\t    return\n\t  }\n\t  if (vnode.children) {\n\t    for (var i = 0, l = vnode.children.length; i < l; i++) {\n\t      var child = vnode.children[i];\n\t      if (child.tag && !child.ns) {\n\t        applyNS(child, ns);\n\t      }\n\t    }\n\t  }\n\t}\n\n\t/*  */\n\n\tfunction initRender (vm) {\n\t  vm.$vnode = null; // the placeholder node in parent tree\n\t  vm._vnode = null; // the root of the child tree\n\t  vm._staticTrees = null;\n\t  var parentVnode = vm.$options._parentVnode;\n\t  var renderContext = parentVnode && parentVnode.context;\n\t  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n\t  vm.$scopedSlots = {};\n\t  // bind the createElement fn to this instance\n\t  // so that we get proper render context inside it.\n\t  // args order: tag, data, children, normalizationType, alwaysNormalize\n\t  // internal version is used by render functions compiled from templates\n\t  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n\t  // normalization is always applied for the public version, used in\n\t  // user-written render functions.\n\t  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\t  if (vm.$options.el) {\n\t    vm.$mount(vm.$options.el);\n\t  }\n\t}\n\n\tfunction renderMixin (Vue) {\n\t  Vue.prototype.$nextTick = function (fn) {\n\t    return nextTick(fn, this)\n\t  };\n\n\t  Vue.prototype._render = function () {\n\t    var vm = this;\n\t    var ref = vm.$options;\n\t    var render = ref.render;\n\t    var staticRenderFns = ref.staticRenderFns;\n\t    var _parentVnode = ref._parentVnode;\n\n\t    if (vm._isMounted) {\n\t      // clone slot nodes on re-renders\n\t      for (var key in vm.$slots) {\n\t        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n\t      }\n\t    }\n\n\t    if (_parentVnode && _parentVnode.data.scopedSlots) {\n\t      vm.$scopedSlots = _parentVnode.data.scopedSlots;\n\t    }\n\n\t    if (staticRenderFns && !vm._staticTrees) {\n\t      vm._staticTrees = [];\n\t    }\n\t    // set parent vnode. this allows render functions to have access\n\t    // to the data on the placeholder node.\n\t    vm.$vnode = _parentVnode;\n\t    // render self\n\t    var vnode;\n\t    try {\n\t      vnode = render.call(vm._renderProxy, vm.$createElement);\n\t    } catch (e) {\n\t      /* istanbul ignore else */\n\t      if (config.errorHandler) {\n\t        config.errorHandler.call(null, e, vm);\n\t      } else {\n\t        if (false) {}\n\t        throw e\n\t      }\n\t      // return previous vnode to prevent render error causing blank component\n\t      vnode = vm._vnode;\n\t    }\n\t    // return empty vnode in case the render function errored out\n\t    if (!(vnode instanceof VNode)) {\n\t      if (false) {}\n\t      vnode = createEmptyVNode();\n\t    }\n\t    // set parent\n\t    vnode.parent = _parentVnode;\n\t    return vnode\n\t  };\n\n\t  // toString for mustaches\n\t  Vue.prototype._s = _toString;\n\t  // convert text to vnode\n\t  Vue.prototype._v = createTextVNode;\n\t  // number conversion\n\t  Vue.prototype._n = toNumber;\n\t  // empty vnode\n\t  Vue.prototype._e = createEmptyVNode;\n\t  // loose equal\n\t  Vue.prototype._q = looseEqual;\n\t  // loose indexOf\n\t  Vue.prototype._i = looseIndexOf;\n\n\t  // render static tree by index\n\t  Vue.prototype._m = function renderStatic (\n\t    index,\n\t    isInFor\n\t  ) {\n\t    var tree = this._staticTrees[index];\n\t    // if has already-rendered static tree and not inside v-for,\n\t    // we can reuse the same tree by doing a shallow clone.\n\t    if (tree && !isInFor) {\n\t      return Array.isArray(tree)\n\t        ? cloneVNodes(tree)\n\t        : cloneVNode(tree)\n\t    }\n\t    // otherwise, render a fresh tree.\n\t    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n\t    markStatic(tree, (\"__static__\" + index), false);\n\t    return tree\n\t  };\n\n\t  // mark node as static (v-once)\n\t  Vue.prototype._o = function markOnce (\n\t    tree,\n\t    index,\n\t    key\n\t  ) {\n\t    markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n\t    return tree\n\t  };\n\n\t  function markStatic (tree, key, isOnce) {\n\t    if (Array.isArray(tree)) {\n\t      for (var i = 0; i < tree.length; i++) {\n\t        if (tree[i] && typeof tree[i] !== 'string') {\n\t          markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n\t        }\n\t      }\n\t    } else {\n\t      markStaticNode(tree, key, isOnce);\n\t    }\n\t  }\n\n\t  function markStaticNode (node, key, isOnce) {\n\t    node.isStatic = true;\n\t    node.key = key;\n\t    node.isOnce = isOnce;\n\t  }\n\n\t  // filter resolution helper\n\t  Vue.prototype._f = function resolveFilter (id) {\n\t    return resolveAsset(this.$options, 'filters', id, true) || identity\n\t  };\n\n\t  // render v-for\n\t  Vue.prototype._l = function renderList (\n\t    val,\n\t    render\n\t  ) {\n\t    var ret, i, l, keys, key;\n\t    if (Array.isArray(val) || typeof val === 'string') {\n\t      ret = new Array(val.length);\n\t      for (i = 0, l = val.length; i < l; i++) {\n\t        ret[i] = render(val[i], i);\n\t      }\n\t    } else if (typeof val === 'number') {\n\t      ret = new Array(val);\n\t      for (i = 0; i < val; i++) {\n\t        ret[i] = render(i + 1, i);\n\t      }\n\t    } else if (isObject(val)) {\n\t      keys = Object.keys(val);\n\t      ret = new Array(keys.length);\n\t      for (i = 0, l = keys.length; i < l; i++) {\n\t        key = keys[i];\n\t        ret[i] = render(val[key], key, i);\n\t      }\n\t    }\n\t    return ret\n\t  };\n\n\t  // renderSlot\n\t  Vue.prototype._t = function (\n\t    name,\n\t    fallback,\n\t    props,\n\t    bindObject\n\t  ) {\n\t    var scopedSlotFn = this.$scopedSlots[name];\n\t    if (scopedSlotFn) { // scoped slot\n\t      props = props || {};\n\t      if (bindObject) {\n\t        extend(props, bindObject);\n\t      }\n\t      return scopedSlotFn(props) || fallback\n\t    } else {\n\t      var slotNodes = this.$slots[name];\n\t      // warn duplicate slot usage\n\t      if (slotNodes && \"production\" !== 'production') {\n\t        slotNodes._rendered && warn$1(\n\t          \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n\t          \"- this will likely cause render errors.\",\n\t          this\n\t        );\n\t        slotNodes._rendered = true;\n\t      }\n\t      return slotNodes || fallback\n\t    }\n\t  };\n\n\t  // apply v-bind object\n\t  Vue.prototype._b = function bindProps (\n\t    data,\n\t    tag,\n\t    value,\n\t    asProp\n\t  ) {\n\t    if (value) {\n\t      if (!isObject(value)) {\n\t        \"production\" !== 'production' && warn$1(\n\t          'v-bind without argument expects an Object or Array value',\n\t          this\n\t        );\n\t      } else {\n\t        if (Array.isArray(value)) {\n\t          value = toObject(value);\n\t        }\n\t        for (var key in value) {\n\t          if (key === 'class' || key === 'style') {\n\t            data[key] = value[key];\n\t          } else {\n\t            var hash = asProp || config.mustUseProp(tag, key)\n\t              ? data.domProps || (data.domProps = {})\n\t              : data.attrs || (data.attrs = {});\n\t            hash[key] = value[key];\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return data\n\t  };\n\n\t  // check v-on keyCodes\n\t  Vue.prototype._k = function checkKeyCodes (\n\t    eventKeyCode,\n\t    key,\n\t    builtInAlias\n\t  ) {\n\t    var keyCodes = config.keyCodes[key] || builtInAlias;\n\t    if (Array.isArray(keyCodes)) {\n\t      return keyCodes.indexOf(eventKeyCode) === -1\n\t    } else {\n\t      return keyCodes !== eventKeyCode\n\t    }\n\t  };\n\t}\n\n\tfunction resolveSlots (\n\t  children,\n\t  context\n\t) {\n\t  var slots = {};\n\t  if (!children) {\n\t    return slots\n\t  }\n\t  var defaultSlot = [];\n\t  var name, child;\n\t  for (var i = 0, l = children.length; i < l; i++) {\n\t    child = children[i];\n\t    // named slots should only be respected if the vnode was rendered in the\n\t    // same context.\n\t    if ((child.context === context || child.functionalContext === context) &&\n\t        child.data && (name = child.data.slot)) {\n\t      var slot = (slots[name] || (slots[name] = []));\n\t      if (child.tag === 'template') {\n\t        slot.push.apply(slot, child.children);\n\t      } else {\n\t        slot.push(child);\n\t      }\n\t    } else {\n\t      defaultSlot.push(child);\n\t    }\n\t  }\n\t  // ignore single whitespace\n\t  if (defaultSlot.length && !(\n\t    defaultSlot.length === 1 &&\n\t    (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)\n\t  )) {\n\t    slots.default = defaultSlot;\n\t  }\n\t  return slots\n\t}\n\n\t/*  */\n\n\tvar uid = 0;\n\n\tfunction initMixin (Vue) {\n\t  Vue.prototype._init = function (options) {\n\t    var vm = this;\n\t    // a uid\n\t    vm._uid = uid++;\n\t    // a flag to avoid this being observed\n\t    vm._isVue = true;\n\t    // merge options\n\t    if (options && options._isComponent) {\n\t      // optimize internal component instantiation\n\t      // since dynamic options merging is pretty slow, and none of the\n\t      // internal component options needs special treatment.\n\t      initInternalComponent(vm, options);\n\t    } else {\n\t      vm.$options = mergeOptions(\n\t        resolveConstructorOptions(vm.constructor),\n\t        options || {},\n\t        vm\n\t      );\n\t    }\n\t    /* istanbul ignore else */\n\t    if (false) {} else {\n\t      vm._renderProxy = vm;\n\t    }\n\t    // expose real self\n\t    vm._self = vm;\n\t    initLifecycle(vm);\n\t    initEvents(vm);\n\t    callHook(vm, 'beforeCreate');\n\t    initState(vm);\n\t    callHook(vm, 'created');\n\t    initRender(vm);\n\t  };\n\t}\n\n\tfunction initInternalComponent (vm, options) {\n\t  var opts = vm.$options = Object.create(vm.constructor.options);\n\t  // doing this because it's faster than dynamic enumeration.\n\t  opts.parent = options.parent;\n\t  opts.propsData = options.propsData;\n\t  opts._parentVnode = options._parentVnode;\n\t  opts._parentListeners = options._parentListeners;\n\t  opts._renderChildren = options._renderChildren;\n\t  opts._componentTag = options._componentTag;\n\t  opts._parentElm = options._parentElm;\n\t  opts._refElm = options._refElm;\n\t  if (options.render) {\n\t    opts.render = options.render;\n\t    opts.staticRenderFns = options.staticRenderFns;\n\t  }\n\t}\n\n\tfunction resolveConstructorOptions (Ctor) {\n\t  var options = Ctor.options;\n\t  if (Ctor.super) {\n\t    var superOptions = Ctor.super.options;\n\t    var cachedSuperOptions = Ctor.superOptions;\n\t    var extendOptions = Ctor.extendOptions;\n\t    if (superOptions !== cachedSuperOptions) {\n\t      // super option changed\n\t      Ctor.superOptions = superOptions;\n\t      extendOptions.render = options.render;\n\t      extendOptions.staticRenderFns = options.staticRenderFns;\n\t      extendOptions._scopeId = options._scopeId;\n\t      options = Ctor.options = mergeOptions(superOptions, extendOptions);\n\t      if (options.name) {\n\t        options.components[options.name] = Ctor;\n\t      }\n\t    }\n\t  }\n\t  return options\n\t}\n\n\tfunction Vue$2 (options) {\n\t  if (false) {}\n\t  this._init(options);\n\t}\n\n\tinitMixin(Vue$2);\n\tstateMixin(Vue$2);\n\teventsMixin(Vue$2);\n\tlifecycleMixin(Vue$2);\n\trenderMixin(Vue$2);\n\n\t/*  */\n\n\tfunction initUse (Vue) {\n\t  Vue.use = function (plugin) {\n\t    /* istanbul ignore if */\n\t    if (plugin.installed) {\n\t      return\n\t    }\n\t    // additional parameters\n\t    var args = toArray(arguments, 1);\n\t    args.unshift(this);\n\t    if (typeof plugin.install === 'function') {\n\t      plugin.install.apply(plugin, args);\n\t    } else {\n\t      plugin.apply(null, args);\n\t    }\n\t    plugin.installed = true;\n\t    return this\n\t  };\n\t}\n\n\t/*  */\n\n\tfunction initMixin$1 (Vue) {\n\t  Vue.mixin = function (mixin) {\n\t    this.options = mergeOptions(this.options, mixin);\n\t  };\n\t}\n\n\t/*  */\n\n\tfunction initExtend (Vue) {\n\t  /**\n\t   * Each instance constructor, including Vue, has a unique\n\t   * cid. This enables us to create wrapped \"child\n\t   * constructors\" for prototypal inheritance and cache them.\n\t   */\n\t  Vue.cid = 0;\n\t  var cid = 1;\n\n\t  /**\n\t   * Class inheritance\n\t   */\n\t  Vue.extend = function (extendOptions) {\n\t    extendOptions = extendOptions || {};\n\t    var Super = this;\n\t    var SuperId = Super.cid;\n\t    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n\t    if (cachedCtors[SuperId]) {\n\t      return cachedCtors[SuperId]\n\t    }\n\t    var name = extendOptions.name || Super.options.name;\n\t    if (false) {}\n\t    var Sub = function VueComponent (options) {\n\t      this._init(options);\n\t    };\n\t    Sub.prototype = Object.create(Super.prototype);\n\t    Sub.prototype.constructor = Sub;\n\t    Sub.cid = cid++;\n\t    Sub.options = mergeOptions(\n\t      Super.options,\n\t      extendOptions\n\t    );\n\t    Sub['super'] = Super;\n\t    // allow further extension/mixin/plugin usage\n\t    Sub.extend = Super.extend;\n\t    Sub.mixin = Super.mixin;\n\t    Sub.use = Super.use;\n\t    // create asset registers, so extended classes\n\t    // can have their private assets too.\n\t    config._assetTypes.forEach(function (type) {\n\t      Sub[type] = Super[type];\n\t    });\n\t    // enable recursive self-lookup\n\t    if (name) {\n\t      Sub.options.components[name] = Sub;\n\t    }\n\t    // keep a reference to the super options at extension time.\n\t    // later at instantiation we can check if Super's options have\n\t    // been updated.\n\t    Sub.superOptions = Super.options;\n\t    Sub.extendOptions = extendOptions;\n\t    // cache constructor\n\t    cachedCtors[SuperId] = Sub;\n\t    return Sub\n\t  };\n\t}\n\n\t/*  */\n\n\tfunction initAssetRegisters (Vue) {\n\t  /**\n\t   * Create asset registration methods.\n\t   */\n\t  config._assetTypes.forEach(function (type) {\n\t    Vue[type] = function (\n\t      id,\n\t      definition\n\t    ) {\n\t      if (!definition) {\n\t        return this.options[type + 's'][id]\n\t      } else {\n\t        /* istanbul ignore if */\n\t        if (false) {}\n\t        if (type === 'component' && isPlainObject(definition)) {\n\t          definition.name = definition.name || id;\n\t          definition = this.options._base.extend(definition);\n\t        }\n\t        if (type === 'directive' && typeof definition === 'function') {\n\t          definition = { bind: definition, update: definition };\n\t        }\n\t        this.options[type + 's'][id] = definition;\n\t        return definition\n\t      }\n\t    };\n\t  });\n\t}\n\n\t/*  */\n\n\tvar patternTypes = [String, RegExp];\n\n\tfunction matches (pattern, name) {\n\t  if (typeof pattern === 'string') {\n\t    return pattern.split(',').indexOf(name) > -1\n\t  } else {\n\t    return pattern.test(name)\n\t  }\n\t}\n\n\tvar KeepAlive = {\n\t  name: 'keep-alive',\n\t  abstract: true,\n\t  props: {\n\t    include: patternTypes,\n\t    exclude: patternTypes\n\t  },\n\t  created: function created () {\n\t    this.cache = Object.create(null);\n\t  },\n\t  render: function render () {\n\t    var vnode = getFirstComponentChild(this.$slots.default);\n\t    if (vnode && vnode.componentOptions) {\n\t      var opts = vnode.componentOptions;\n\t      // check pattern\n\t      var name = opts.Ctor.options.name || opts.tag;\n\t      if (name && (\n\t        (this.include && !matches(this.include, name)) ||\n\t        (this.exclude && matches(this.exclude, name))\n\t      )) {\n\t        return vnode\n\t      }\n\t      var key = vnode.key == null\n\t        // same constructor may get registered as different local components\n\t        // so cid alone is not enough (#3269)\n\t        ? opts.Ctor.cid + (opts.tag ? (\"::\" + (opts.tag)) : '')\n\t        : vnode.key;\n\t      if (this.cache[key]) {\n\t        vnode.child = this.cache[key].child;\n\t      } else {\n\t        this.cache[key] = vnode;\n\t      }\n\t      vnode.data.keepAlive = true;\n\t    }\n\t    return vnode\n\t  },\n\t  destroyed: function destroyed () {\n\t    var this$1 = this;\n\n\t    for (var key in this.cache) {\n\t      var vnode = this$1.cache[key];\n\t      callHook(vnode.child, 'deactivated');\n\t      vnode.child.$destroy();\n\t    }\n\t  }\n\t};\n\n\tvar builtInComponents = {\n\t  KeepAlive: KeepAlive\n\t};\n\n\t/*  */\n\n\tfunction initGlobalAPI (Vue) {\n\t  // config\n\t  var configDef = {};\n\t  configDef.get = function () { return config; };\n\t  if (false) {}\n\t  Object.defineProperty(Vue, 'config', configDef);\n\t  Vue.util = util;\n\t  Vue.set = set$1;\n\t  Vue.delete = del;\n\t  Vue.nextTick = nextTick;\n\n\t  Vue.options = Object.create(null);\n\t  config._assetTypes.forEach(function (type) {\n\t    Vue.options[type + 's'] = Object.create(null);\n\t  });\n\n\t  // this is used to identify the \"base\" constructor to extend all plain-object\n\t  // components with in Weex's multi-instance scenarios.\n\t  Vue.options._base = Vue;\n\n\t  extend(Vue.options.components, builtInComponents);\n\n\t  initUse(Vue);\n\t  initMixin$1(Vue);\n\t  initExtend(Vue);\n\t  initAssetRegisters(Vue);\n\t}\n\n\tinitGlobalAPI(Vue$2);\n\n\tObject.defineProperty(Vue$2.prototype, '$isServer', {\n\t  get: isServerRendering\n\t});\n\n\tVue$2.version = '2.1.8';\n\n\t/*  */\n\n\t// attributes that should be using props for binding\n\tvar acceptValue = makeMap('input,textarea,option,select');\n\tvar mustUseProp = function (tag, attr) {\n\t  return (\n\t    (attr === 'value' && acceptValue(tag)) ||\n\t    (attr === 'selected' && tag === 'option') ||\n\t    (attr === 'checked' && tag === 'input') ||\n\t    (attr === 'muted' && tag === 'video')\n\t  )\n\t};\n\n\tvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\n\tvar isBooleanAttr = makeMap(\n\t  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n\t  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n\t  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n\t  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n\t  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n\t  'truespeed,typemustmatch,visible'\n\t);\n\n\tvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\n\tvar isXlink = function (name) {\n\t  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n\t};\n\n\tvar getXlinkProp = function (name) {\n\t  return isXlink(name) ? name.slice(6, name.length) : ''\n\t};\n\n\tvar isFalsyAttrValue = function (val) {\n\t  return val == null || val === false\n\t};\n\n\t/*  */\n\n\tfunction genClassForVnode (vnode) {\n\t  var data = vnode.data;\n\t  var parentNode = vnode;\n\t  var childNode = vnode;\n\t  while (childNode.child) {\n\t    childNode = childNode.child._vnode;\n\t    if (childNode.data) {\n\t      data = mergeClassData(childNode.data, data);\n\t    }\n\t  }\n\t  while ((parentNode = parentNode.parent)) {\n\t    if (parentNode.data) {\n\t      data = mergeClassData(data, parentNode.data);\n\t    }\n\t  }\n\t  return genClassFromData(data)\n\t}\n\n\tfunction mergeClassData (child, parent) {\n\t  return {\n\t    staticClass: concat(child.staticClass, parent.staticClass),\n\t    class: child.class\n\t      ? [child.class, parent.class]\n\t      : parent.class\n\t  }\n\t}\n\n\tfunction genClassFromData (data) {\n\t  var dynamicClass = data.class;\n\t  var staticClass = data.staticClass;\n\t  if (staticClass || dynamicClass) {\n\t    return concat(staticClass, stringifyClass(dynamicClass))\n\t  }\n\t  /* istanbul ignore next */\n\t  return ''\n\t}\n\n\tfunction concat (a, b) {\n\t  return a ? b ? (a + ' ' + b) : a : (b || '')\n\t}\n\n\tfunction stringifyClass (value) {\n\t  var res = '';\n\t  if (!value) {\n\t    return res\n\t  }\n\t  if (typeof value === 'string') {\n\t    return value\n\t  }\n\t  if (Array.isArray(value)) {\n\t    var stringified;\n\t    for (var i = 0, l = value.length; i < l; i++) {\n\t      if (value[i]) {\n\t        if ((stringified = stringifyClass(value[i]))) {\n\t          res += stringified + ' ';\n\t        }\n\t      }\n\t    }\n\t    return res.slice(0, -1)\n\t  }\n\t  if (isObject(value)) {\n\t    for (var key in value) {\n\t      if (value[key]) { res += key + ' '; }\n\t    }\n\t    return res.slice(0, -1)\n\t  }\n\t  /* istanbul ignore next */\n\t  return res\n\t}\n\n\t/*  */\n\n\tvar namespaceMap = {\n\t  svg: 'http://www.w3.org/2000/svg',\n\t  math: 'http://www.w3.org/1998/Math/MathML'\n\t};\n\n\tvar isHTMLTag = makeMap(\n\t  'html,body,base,head,link,meta,style,title,' +\n\t  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n\t  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n\t  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n\t  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n\t  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n\t  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n\t  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n\t  'output,progress,select,textarea,' +\n\t  'details,dialog,menu,menuitem,summary,' +\n\t  'content,element,shadow,template'\n\t);\n\n\t// this map is intentionally selective, only covering SVG elements that may\n\t// contain child elements.\n\tvar isSVG = makeMap(\n\t  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,' +\n\t  'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n\t  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n\t  true\n\t);\n\n\n\n\tvar isReservedTag = function (tag) {\n\t  return isHTMLTag(tag) || isSVG(tag)\n\t};\n\n\tfunction getTagNamespace (tag) {\n\t  if (isSVG(tag)) {\n\t    return 'svg'\n\t  }\n\t  // basic support for MathML\n\t  // note it doesn't support other MathML elements being component roots\n\t  if (tag === 'math') {\n\t    return 'math'\n\t  }\n\t}\n\n\tvar unknownElementCache = Object.create(null);\n\tfunction isUnknownElement (tag) {\n\t  /* istanbul ignore if */\n\t  if (!inBrowser) {\n\t    return true\n\t  }\n\t  if (isReservedTag(tag)) {\n\t    return false\n\t  }\n\t  tag = tag.toLowerCase();\n\t  /* istanbul ignore if */\n\t  if (unknownElementCache[tag] != null) {\n\t    return unknownElementCache[tag]\n\t  }\n\t  var el = document.createElement(tag);\n\t  if (tag.indexOf('-') > -1) {\n\t    // http://stackoverflow.com/a/28210364/1070244\n\t    return (unknownElementCache[tag] = (\n\t      el.constructor === window.HTMLUnknownElement ||\n\t      el.constructor === window.HTMLElement\n\t    ))\n\t  } else {\n\t    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n\t  }\n\t}\n\n\t/*  */\n\n\t/**\n\t * Query an element selector if it's not an element already.\n\t */\n\tfunction query (el) {\n\t  if (typeof el === 'string') {\n\t    var selector = el;\n\t    el = document.querySelector(el);\n\t    if (!el) {\n\t      \"production\" !== 'production' && warn$1(\n\t        'Cannot find element: ' + selector\n\t      );\n\t      return document.createElement('div')\n\t    }\n\t  }\n\t  return el\n\t}\n\n\t/*  */\n\n\tfunction createElement$1 (tagName, vnode) {\n\t  var elm = document.createElement(tagName);\n\t  if (tagName !== 'select') {\n\t    return elm\n\t  }\n\t  if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {\n\t    elm.setAttribute('multiple', 'multiple');\n\t  }\n\t  return elm\n\t}\n\n\tfunction createElementNS (namespace, tagName) {\n\t  return document.createElementNS(namespaceMap[namespace], tagName)\n\t}\n\n\tfunction createTextNode (text) {\n\t  return document.createTextNode(text)\n\t}\n\n\tfunction createComment (text) {\n\t  return document.createComment(text)\n\t}\n\n\tfunction insertBefore (parentNode, newNode, referenceNode) {\n\t  parentNode.insertBefore(newNode, referenceNode);\n\t}\n\n\tfunction removeChild (node, child) {\n\t  node.removeChild(child);\n\t}\n\n\tfunction appendChild (node, child) {\n\t  node.appendChild(child);\n\t}\n\n\tfunction parentNode (node) {\n\t  return node.parentNode\n\t}\n\n\tfunction nextSibling (node) {\n\t  return node.nextSibling\n\t}\n\n\tfunction tagName (node) {\n\t  return node.tagName\n\t}\n\n\tfunction setTextContent (node, text) {\n\t  node.textContent = text;\n\t}\n\n\tfunction setAttribute (node, key, val) {\n\t  node.setAttribute(key, val);\n\t}\n\n\n\tvar nodeOps = Object.freeze({\n\t\tcreateElement: createElement$1,\n\t\tcreateElementNS: createElementNS,\n\t\tcreateTextNode: createTextNode,\n\t\tcreateComment: createComment,\n\t\tinsertBefore: insertBefore,\n\t\tremoveChild: removeChild,\n\t\tappendChild: appendChild,\n\t\tparentNode: parentNode,\n\t\tnextSibling: nextSibling,\n\t\ttagName: tagName,\n\t\tsetTextContent: setTextContent,\n\t\tsetAttribute: setAttribute\n\t});\n\n\t/*  */\n\n\tvar ref = {\n\t  create: function create (_, vnode) {\n\t    registerRef(vnode);\n\t  },\n\t  update: function update (oldVnode, vnode) {\n\t    if (oldVnode.data.ref !== vnode.data.ref) {\n\t      registerRef(oldVnode, true);\n\t      registerRef(vnode);\n\t    }\n\t  },\n\t  destroy: function destroy (vnode) {\n\t    registerRef(vnode, true);\n\t  }\n\t};\n\n\tfunction registerRef (vnode, isRemoval) {\n\t  var key = vnode.data.ref;\n\t  if (!key) { return }\n\n\t  var vm = vnode.context;\n\t  var ref = vnode.child || vnode.elm;\n\t  var refs = vm.$refs;\n\t  if (isRemoval) {\n\t    if (Array.isArray(refs[key])) {\n\t      remove$1(refs[key], ref);\n\t    } else if (refs[key] === ref) {\n\t      refs[key] = undefined;\n\t    }\n\t  } else {\n\t    if (vnode.data.refInFor) {\n\t      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n\t        refs[key].push(ref);\n\t      } else {\n\t        refs[key] = [ref];\n\t      }\n\t    } else {\n\t      refs[key] = ref;\n\t    }\n\t  }\n\t}\n\n\t/**\n\t * Virtual DOM patching algorithm based on Snabbdom by\n\t * Simon Friis Vindum (@paldepind)\n\t * Licensed under the MIT License\n\t * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n\t *\n\t * modified by Evan You (@yyx990803)\n\t *\n\n\t/*\n\t * Not type-checking this because this file is perf-critical and the cost\n\t * of making flow understand it is not worth it.\n\t */\n\n\tvar emptyNode = new VNode('', {}, []);\n\n\tvar hooks$1 = ['create', 'activate', 'update', 'remove', 'destroy'];\n\n\tfunction isUndef (s) {\n\t  return s == null\n\t}\n\n\tfunction isDef (s) {\n\t  return s != null\n\t}\n\n\tfunction sameVnode (vnode1, vnode2) {\n\t  return (\n\t    vnode1.key === vnode2.key &&\n\t    vnode1.tag === vnode2.tag &&\n\t    vnode1.isComment === vnode2.isComment &&\n\t    !vnode1.data === !vnode2.data\n\t  )\n\t}\n\n\tfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n\t  var i, key;\n\t  var map = {};\n\t  for (i = beginIdx; i <= endIdx; ++i) {\n\t    key = children[i].key;\n\t    if (isDef(key)) { map[key] = i; }\n\t  }\n\t  return map\n\t}\n\n\tfunction createPatchFunction (backend) {\n\t  var i, j;\n\t  var cbs = {};\n\n\t  var modules = backend.modules;\n\t  var nodeOps = backend.nodeOps;\n\n\t  for (i = 0; i < hooks$1.length; ++i) {\n\t    cbs[hooks$1[i]] = [];\n\t    for (j = 0; j < modules.length; ++j) {\n\t      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }\n\t    }\n\t  }\n\n\t  function emptyNodeAt (elm) {\n\t    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n\t  }\n\n\t  function createRmCb (childElm, listeners) {\n\t    function remove$$1 () {\n\t      if (--remove$$1.listeners === 0) {\n\t        removeNode(childElm);\n\t      }\n\t    }\n\t    remove$$1.listeners = listeners;\n\t    return remove$$1\n\t  }\n\n\t  function removeNode (el) {\n\t    var parent = nodeOps.parentNode(el);\n\t    // element may have already been removed due to v-html / v-text\n\t    if (parent) {\n\t      nodeOps.removeChild(parent, el);\n\t    }\n\t  }\n\n\t  var inPre = 0;\n\t  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n\t    vnode.isRootInsert = !nested; // for transition enter check\n\t    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n\t      return\n\t    }\n\n\t    var data = vnode.data;\n\t    var children = vnode.children;\n\t    var tag = vnode.tag;\n\t    if (isDef(tag)) {\n\t      if (false) {}\n\t      vnode.elm = vnode.ns\n\t        ? nodeOps.createElementNS(vnode.ns, tag)\n\t        : nodeOps.createElement(tag, vnode);\n\t      setScope(vnode);\n\n\t      /* istanbul ignore if */\n\t      {\n\t        createChildren(vnode, children, insertedVnodeQueue);\n\t        if (isDef(data)) {\n\t          invokeCreateHooks(vnode, insertedVnodeQueue);\n\t        }\n\t        insert(parentElm, vnode.elm, refElm);\n\t      }\n\n\t      if (false) {}\n\t    } else if (vnode.isComment) {\n\t      vnode.elm = nodeOps.createComment(vnode.text);\n\t      insert(parentElm, vnode.elm, refElm);\n\t    } else {\n\t      vnode.elm = nodeOps.createTextNode(vnode.text);\n\t      insert(parentElm, vnode.elm, refElm);\n\t    }\n\t  }\n\n\t  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n\t    var i = vnode.data;\n\t    if (isDef(i)) {\n\t      var isReactivated = isDef(vnode.child) && i.keepAlive;\n\t      if (isDef(i = i.hook) && isDef(i = i.init)) {\n\t        i(vnode, false /* hydrating */, parentElm, refElm);\n\t      }\n\t      // after calling the init hook, if the vnode is a child component\n\t      // it should've created a child instance and mounted it. the child\n\t      // component also has set the placeholder vnode's elm.\n\t      // in that case we can just return the element and be done.\n\t      if (isDef(vnode.child)) {\n\t        initComponent(vnode, insertedVnodeQueue);\n\t        if (isReactivated) {\n\t          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n\t        }\n\t        return true\n\t      }\n\t    }\n\t  }\n\n\t  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n\t    var i;\n\t    // hack for #4339: a reactivated component with inner transition\n\t    // does not trigger because the inner node's created hooks are not called\n\t    // again. It's not ideal to involve module-specific logic in here but\n\t    // there doesn't seem to be a better way to do it.\n\t    var innerNode = vnode;\n\t    while (innerNode.child) {\n\t      innerNode = innerNode.child._vnode;\n\t      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n\t        for (i = 0; i < cbs.activate.length; ++i) {\n\t          cbs.activate[i](emptyNode, innerNode);\n\t        }\n\t        insertedVnodeQueue.push(innerNode);\n\t        break\n\t      }\n\t    }\n\t    // unlike a newly created component,\n\t    // a reactivated keep-alive component doesn't insert itself\n\t    insert(parentElm, vnode.elm, refElm);\n\t  }\n\n\t  function insert (parent, elm, ref) {\n\t    if (parent) {\n\t      if (ref) {\n\t        nodeOps.insertBefore(parent, elm, ref);\n\t      } else {\n\t        nodeOps.appendChild(parent, elm);\n\t      }\n\t    }\n\t  }\n\n\t  function createChildren (vnode, children, insertedVnodeQueue) {\n\t    if (Array.isArray(children)) {\n\t      for (var i = 0; i < children.length; ++i) {\n\t        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n\t      }\n\t    } else if (isPrimitive(vnode.text)) {\n\t      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n\t    }\n\t  }\n\n\t  function isPatchable (vnode) {\n\t    while (vnode.child) {\n\t      vnode = vnode.child._vnode;\n\t    }\n\t    return isDef(vnode.tag)\n\t  }\n\n\t  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n\t    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n\t      cbs.create[i$1](emptyNode, vnode);\n\t    }\n\t    i = vnode.data.hook; // Reuse variable\n\t    if (isDef(i)) {\n\t      if (i.create) { i.create(emptyNode, vnode); }\n\t      if (i.insert) { insertedVnodeQueue.push(vnode); }\n\t    }\n\t  }\n\n\t  function initComponent (vnode, insertedVnodeQueue) {\n\t    if (vnode.data.pendingInsert) {\n\t      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n\t    }\n\t    vnode.elm = vnode.child.$el;\n\t    if (isPatchable(vnode)) {\n\t      invokeCreateHooks(vnode, insertedVnodeQueue);\n\t      setScope(vnode);\n\t    } else {\n\t      // empty component root.\n\t      // skip all element-related modules except for ref (#3455)\n\t      registerRef(vnode);\n\t      // make sure to invoke the insert hook\n\t      insertedVnodeQueue.push(vnode);\n\t    }\n\t  }\n\n\t  // set scope id attribute for scoped CSS.\n\t  // this is implemented as a special case to avoid the overhead\n\t  // of going through the normal attribute patching process.\n\t  function setScope (vnode) {\n\t    var i;\n\t    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {\n\t      nodeOps.setAttribute(vnode.elm, i, '');\n\t    }\n\t    if (isDef(i = activeInstance) &&\n\t        i !== vnode.context &&\n\t        isDef(i = i.$options._scopeId)) {\n\t      nodeOps.setAttribute(vnode.elm, i, '');\n\t    }\n\t  }\n\n\t  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n\t    for (; startIdx <= endIdx; ++startIdx) {\n\t      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n\t    }\n\t  }\n\n\t  function invokeDestroyHook (vnode) {\n\t    var i, j;\n\t    var data = vnode.data;\n\t    if (isDef(data)) {\n\t      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n\t      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n\t    }\n\t    if (isDef(i = vnode.children)) {\n\t      for (j = 0; j < vnode.children.length; ++j) {\n\t        invokeDestroyHook(vnode.children[j]);\n\t      }\n\t    }\n\t  }\n\n\t  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n\t    for (; startIdx <= endIdx; ++startIdx) {\n\t      var ch = vnodes[startIdx];\n\t      if (isDef(ch)) {\n\t        if (isDef(ch.tag)) {\n\t          removeAndInvokeRemoveHook(ch);\n\t          invokeDestroyHook(ch);\n\t        } else { // Text node\n\t          removeNode(ch.elm);\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  function removeAndInvokeRemoveHook (vnode, rm) {\n\t    if (rm || isDef(vnode.data)) {\n\t      var listeners = cbs.remove.length + 1;\n\t      if (!rm) {\n\t        // directly removing\n\t        rm = createRmCb(vnode.elm, listeners);\n\t      } else {\n\t        // we have a recursively passed down rm callback\n\t        // increase the listeners count\n\t        rm.listeners += listeners;\n\t      }\n\t      // recursively invoke hooks on child component root node\n\t      if (isDef(i = vnode.child) && isDef(i = i._vnode) && isDef(i.data)) {\n\t        removeAndInvokeRemoveHook(i, rm);\n\t      }\n\t      for (i = 0; i < cbs.remove.length; ++i) {\n\t        cbs.remove[i](vnode, rm);\n\t      }\n\t      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n\t        i(vnode, rm);\n\t      } else {\n\t        rm();\n\t      }\n\t    } else {\n\t      removeNode(vnode.elm);\n\t    }\n\t  }\n\n\t  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n\t    var oldStartIdx = 0;\n\t    var newStartIdx = 0;\n\t    var oldEndIdx = oldCh.length - 1;\n\t    var oldStartVnode = oldCh[0];\n\t    var oldEndVnode = oldCh[oldEndIdx];\n\t    var newEndIdx = newCh.length - 1;\n\t    var newStartVnode = newCh[0];\n\t    var newEndVnode = newCh[newEndIdx];\n\t    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n\t    // removeOnly is a special flag used only by <transition-group>\n\t    // to ensure removed elements stay in correct relative positions\n\t    // during leaving transitions\n\t    var canMove = !removeOnly;\n\n\t    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n\t      if (isUndef(oldStartVnode)) {\n\t        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n\t      } else if (isUndef(oldEndVnode)) {\n\t        oldEndVnode = oldCh[--oldEndIdx];\n\t      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n\t        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n\t        oldStartVnode = oldCh[++oldStartIdx];\n\t        newStartVnode = newCh[++newStartIdx];\n\t      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n\t        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n\t        oldEndVnode = oldCh[--oldEndIdx];\n\t        newEndVnode = newCh[--newEndIdx];\n\t      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n\t        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n\t        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n\t        oldStartVnode = oldCh[++oldStartIdx];\n\t        newEndVnode = newCh[--newEndIdx];\n\t      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n\t        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n\t        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n\t        oldEndVnode = oldCh[--oldEndIdx];\n\t        newStartVnode = newCh[++newStartIdx];\n\t      } else {\n\t        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n\t        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n\t        if (isUndef(idxInOld)) { // New element\n\t          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n\t          newStartVnode = newCh[++newStartIdx];\n\t        } else {\n\t          elmToMove = oldCh[idxInOld];\n\t          /* istanbul ignore if */\n\t          if (false) {}\n\t          if (sameVnode(elmToMove, newStartVnode)) {\n\t            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n\t            oldCh[idxInOld] = undefined;\n\t            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n\t            newStartVnode = newCh[++newStartIdx];\n\t          } else {\n\t            // same key but different element. treat as new element\n\t            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n\t            newStartVnode = newCh[++newStartIdx];\n\t          }\n\t        }\n\t      }\n\t    }\n\t    if (oldStartIdx > oldEndIdx) {\n\t      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n\t      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n\t    } else if (newStartIdx > newEndIdx) {\n\t      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n\t    }\n\t  }\n\n\t  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n\t    if (oldVnode === vnode) {\n\t      return\n\t    }\n\t    // reuse element for static trees.\n\t    // note we only do this if the vnode is cloned -\n\t    // if the new node is not cloned it means the render functions have been\n\t    // reset by the hot-reload-api and we need to do a proper re-render.\n\t    if (vnode.isStatic &&\n\t        oldVnode.isStatic &&\n\t        vnode.key === oldVnode.key &&\n\t        (vnode.isCloned || vnode.isOnce)) {\n\t      vnode.elm = oldVnode.elm;\n\t      vnode.child = oldVnode.child;\n\t      return\n\t    }\n\t    var i;\n\t    var data = vnode.data;\n\t    var hasData = isDef(data);\n\t    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n\t      i(oldVnode, vnode);\n\t    }\n\t    var elm = vnode.elm = oldVnode.elm;\n\t    var oldCh = oldVnode.children;\n\t    var ch = vnode.children;\n\t    if (hasData && isPatchable(vnode)) {\n\t      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n\t      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n\t    }\n\t    if (isUndef(vnode.text)) {\n\t      if (isDef(oldCh) && isDef(ch)) {\n\t        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n\t      } else if (isDef(ch)) {\n\t        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n\t        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n\t      } else if (isDef(oldCh)) {\n\t        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n\t      } else if (isDef(oldVnode.text)) {\n\t        nodeOps.setTextContent(elm, '');\n\t      }\n\t    } else if (oldVnode.text !== vnode.text) {\n\t      nodeOps.setTextContent(elm, vnode.text);\n\t    }\n\t    if (hasData) {\n\t      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n\t    }\n\t  }\n\n\t  function invokeInsertHook (vnode, queue, initial) {\n\t    // delay insert hooks for component root nodes, invoke them after the\n\t    // element is really inserted\n\t    if (initial && vnode.parent) {\n\t      vnode.parent.data.pendingInsert = queue;\n\t    } else {\n\t      for (var i = 0; i < queue.length; ++i) {\n\t        queue[i].data.hook.insert(queue[i]);\n\t      }\n\t    }\n\t  }\n\n\t  var bailed = false;\n\t  // list of modules that can skip create hook during hydration because they\n\t  // are already rendered on the client or has no need for initialization\n\t  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n\t  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n\t  function hydrate (elm, vnode, insertedVnodeQueue) {\n\t    if (false) {}\n\t    vnode.elm = elm;\n\t    var tag = vnode.tag;\n\t    var data = vnode.data;\n\t    var children = vnode.children;\n\t    if (isDef(data)) {\n\t      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n\t      if (isDef(i = vnode.child)) {\n\t        // child component. it should have hydrated its own tree.\n\t        initComponent(vnode, insertedVnodeQueue);\n\t        return true\n\t      }\n\t    }\n\t    if (isDef(tag)) {\n\t      if (isDef(children)) {\n\t        // empty element, allow client to pick up and populate children\n\t        if (!elm.hasChildNodes()) {\n\t          createChildren(vnode, children, insertedVnodeQueue);\n\t        } else {\n\t          var childrenMatch = true;\n\t          var childNode = elm.firstChild;\n\t          for (var i$1 = 0; i$1 < children.length; i$1++) {\n\t            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n\t              childrenMatch = false;\n\t              break\n\t            }\n\t            childNode = childNode.nextSibling;\n\t          }\n\t          // if childNode is not null, it means the actual childNodes list is\n\t          // longer than the virtual children list.\n\t          if (!childrenMatch || childNode) {\n\t            if (false) {}\n\t            return false\n\t          }\n\t        }\n\t      }\n\t      if (isDef(data)) {\n\t        for (var key in data) {\n\t          if (!isRenderedModule(key)) {\n\t            invokeCreateHooks(vnode, insertedVnodeQueue);\n\t            break\n\t          }\n\t        }\n\t      }\n\t    } else if (elm.data !== vnode.text) {\n\t      elm.data = vnode.text;\n\t    }\n\t    return true\n\t  }\n\n\t  function assertNodeMatch (node, vnode) {\n\t    if (vnode.tag) {\n\t      return (\n\t        vnode.tag.indexOf('vue-component') === 0 ||\n\t        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n\t      )\n\t    } else {\n\t      return node.nodeType === (vnode.isComment ? 8 : 3)\n\t    }\n\t  }\n\n\t  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n\t    if (!vnode) {\n\t      if (oldVnode) { invokeDestroyHook(oldVnode); }\n\t      return\n\t    }\n\n\t    var elm, parent;\n\t    var isInitialPatch = false;\n\t    var insertedVnodeQueue = [];\n\n\t    if (!oldVnode) {\n\t      // empty mount (likely as component), create new root element\n\t      isInitialPatch = true;\n\t      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n\t    } else {\n\t      var isRealElement = isDef(oldVnode.nodeType);\n\t      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n\t        // patch existing root node\n\t        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n\t      } else {\n\t        if (isRealElement) {\n\t          // mounting to a real element\n\t          // check if this is server-rendered content and if we can perform\n\t          // a successful hydration.\n\t          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n\t            oldVnode.removeAttribute('server-rendered');\n\t            hydrating = true;\n\t          }\n\t          if (hydrating) {\n\t            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n\t              invokeInsertHook(vnode, insertedVnodeQueue, true);\n\t              return oldVnode\n\t            } else if (false) {}\n\t          }\n\t          // either not server-rendered, or hydration failed.\n\t          // create an empty node and replace it\n\t          oldVnode = emptyNodeAt(oldVnode);\n\t        }\n\t        // replacing existing element\n\t        elm = oldVnode.elm;\n\t        parent = nodeOps.parentNode(elm);\n\t        createElm(vnode, insertedVnodeQueue, parent, nodeOps.nextSibling(elm));\n\n\t        if (vnode.parent) {\n\t          // component root element replaced.\n\t          // update parent placeholder node element, recursively\n\t          var ancestor = vnode.parent;\n\t          while (ancestor) {\n\t            ancestor.elm = vnode.elm;\n\t            ancestor = ancestor.parent;\n\t          }\n\t          if (isPatchable(vnode)) {\n\t            for (var i = 0; i < cbs.create.length; ++i) {\n\t              cbs.create[i](emptyNode, vnode.parent);\n\t            }\n\t          }\n\t        }\n\n\t        if (parent !== null) {\n\t          removeVnodes(parent, [oldVnode], 0, 0);\n\t        } else if (isDef(oldVnode.tag)) {\n\t          invokeDestroyHook(oldVnode);\n\t        }\n\t      }\n\t    }\n\n\t    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n\t    return vnode.elm\n\t  }\n\t}\n\n\t/*  */\n\n\tvar directives = {\n\t  create: updateDirectives,\n\t  update: updateDirectives,\n\t  destroy: function unbindDirectives (vnode) {\n\t    updateDirectives(vnode, emptyNode);\n\t  }\n\t};\n\n\tfunction updateDirectives (oldVnode, vnode) {\n\t  if (oldVnode.data.directives || vnode.data.directives) {\n\t    _update(oldVnode, vnode);\n\t  }\n\t}\n\n\tfunction _update (oldVnode, vnode) {\n\t  var isCreate = oldVnode === emptyNode;\n\t  var isDestroy = vnode === emptyNode;\n\t  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n\t  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n\t  var dirsWithInsert = [];\n\t  var dirsWithPostpatch = [];\n\n\t  var key, oldDir, dir;\n\t  for (key in newDirs) {\n\t    oldDir = oldDirs[key];\n\t    dir = newDirs[key];\n\t    if (!oldDir) {\n\t      // new directive, bind\n\t      callHook$1(dir, 'bind', vnode, oldVnode);\n\t      if (dir.def && dir.def.inserted) {\n\t        dirsWithInsert.push(dir);\n\t      }\n\t    } else {\n\t      // existing directive, update\n\t      dir.oldValue = oldDir.value;\n\t      callHook$1(dir, 'update', vnode, oldVnode);\n\t      if (dir.def && dir.def.componentUpdated) {\n\t        dirsWithPostpatch.push(dir);\n\t      }\n\t    }\n\t  }\n\n\t  if (dirsWithInsert.length) {\n\t    var callInsert = function () {\n\t      for (var i = 0; i < dirsWithInsert.length; i++) {\n\t        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n\t      }\n\t    };\n\t    if (isCreate) {\n\t      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');\n\t    } else {\n\t      callInsert();\n\t    }\n\t  }\n\n\t  if (dirsWithPostpatch.length) {\n\t    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n\t      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n\t        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n\t      }\n\t    }, 'dir-postpatch');\n\t  }\n\n\t  if (!isCreate) {\n\t    for (key in oldDirs) {\n\t      if (!newDirs[key]) {\n\t        // no longer present, unbind\n\t        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n\t      }\n\t    }\n\t  }\n\t}\n\n\tvar emptyModifiers = Object.create(null);\n\n\tfunction normalizeDirectives$1 (\n\t  dirs,\n\t  vm\n\t) {\n\t  var res = Object.create(null);\n\t  if (!dirs) {\n\t    return res\n\t  }\n\t  var i, dir;\n\t  for (i = 0; i < dirs.length; i++) {\n\t    dir = dirs[i];\n\t    if (!dir.modifiers) {\n\t      dir.modifiers = emptyModifiers;\n\t    }\n\t    res[getRawDirName(dir)] = dir;\n\t    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n\t  }\n\t  return res\n\t}\n\n\tfunction getRawDirName (dir) {\n\t  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n\t}\n\n\tfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n\t  var fn = dir.def && dir.def[hook];\n\t  if (fn) {\n\t    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n\t  }\n\t}\n\n\tvar baseModules = [\n\t  ref,\n\t  directives\n\t];\n\n\t/*  */\n\n\tfunction updateAttrs (oldVnode, vnode) {\n\t  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n\t    return\n\t  }\n\t  var key, cur, old;\n\t  var elm = vnode.elm;\n\t  var oldAttrs = oldVnode.data.attrs || {};\n\t  var attrs = vnode.data.attrs || {};\n\t  // clone observed objects, as the user probably wants to mutate it\n\t  if (attrs.__ob__) {\n\t    attrs = vnode.data.attrs = extend({}, attrs);\n\t  }\n\n\t  for (key in attrs) {\n\t    cur = attrs[key];\n\t    old = oldAttrs[key];\n\t    if (old !== cur) {\n\t      setAttr(elm, key, cur);\n\t    }\n\t  }\n\t  // #4391: in IE9, setting type can reset value for input[type=radio]\n\t  /* istanbul ignore if */\n\t  if (isIE9 && attrs.value !== oldAttrs.value) {\n\t    setAttr(elm, 'value', attrs.value);\n\t  }\n\t  for (key in oldAttrs) {\n\t    if (attrs[key] == null) {\n\t      if (isXlink(key)) {\n\t        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n\t      } else if (!isEnumeratedAttr(key)) {\n\t        elm.removeAttribute(key);\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction setAttr (el, key, value) {\n\t  if (isBooleanAttr(key)) {\n\t    // set attribute for blank value\n\t    // e.g. <option disabled>Select one</option>\n\t    if (isFalsyAttrValue(value)) {\n\t      el.removeAttribute(key);\n\t    } else {\n\t      el.setAttribute(key, key);\n\t    }\n\t  } else if (isEnumeratedAttr(key)) {\n\t    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n\t  } else if (isXlink(key)) {\n\t    if (isFalsyAttrValue(value)) {\n\t      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n\t    } else {\n\t      el.setAttributeNS(xlinkNS, key, value);\n\t    }\n\t  } else {\n\t    if (isFalsyAttrValue(value)) {\n\t      el.removeAttribute(key);\n\t    } else {\n\t      el.setAttribute(key, value);\n\t    }\n\t  }\n\t}\n\n\tvar attrs = {\n\t  create: updateAttrs,\n\t  update: updateAttrs\n\t};\n\n\t/*  */\n\n\tfunction updateClass (oldVnode, vnode) {\n\t  var el = vnode.elm;\n\t  var data = vnode.data;\n\t  var oldData = oldVnode.data;\n\t  if (!data.staticClass && !data.class &&\n\t      (!oldData || (!oldData.staticClass && !oldData.class))) {\n\t    return\n\t  }\n\n\t  var cls = genClassForVnode(vnode);\n\n\t  // handle transition classes\n\t  var transitionClass = el._transitionClasses;\n\t  if (transitionClass) {\n\t    cls = concat(cls, stringifyClass(transitionClass));\n\t  }\n\n\t  // set the class\n\t  if (cls !== el._prevClass) {\n\t    el.setAttribute('class', cls);\n\t    el._prevClass = cls;\n\t  }\n\t}\n\n\tvar klass = {\n\t  create: updateClass,\n\t  update: updateClass\n\t};\n\n\t/*  */\n\n\tvar target$1;\n\n\tfunction add$2 (event, handler, once, capture) {\n\t  if (once) {\n\t    var oldHandler = handler;\n\t    handler = function (ev) {\n\t      remove$3(event, handler, capture);\n\t      arguments.length === 1\n\t        ? oldHandler(ev)\n\t        : oldHandler.apply(null, arguments);\n\t    };\n\t  }\n\t  target$1.addEventListener(event, handler, capture);\n\t}\n\n\tfunction remove$3 (event, handler, capture) {\n\t  target$1.removeEventListener(event, handler, capture);\n\t}\n\n\tfunction updateDOMListeners (oldVnode, vnode) {\n\t  if (!oldVnode.data.on && !vnode.data.on) {\n\t    return\n\t  }\n\t  var on = vnode.data.on || {};\n\t  var oldOn = oldVnode.data.on || {};\n\t  target$1 = vnode.elm;\n\t  updateListeners(on, oldOn, add$2, remove$3, vnode.context);\n\t}\n\n\tvar events = {\n\t  create: updateDOMListeners,\n\t  update: updateDOMListeners\n\t};\n\n\t/*  */\n\n\tfunction updateDOMProps (oldVnode, vnode) {\n\t  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n\t    return\n\t  }\n\t  var key, cur;\n\t  var elm = vnode.elm;\n\t  var oldProps = oldVnode.data.domProps || {};\n\t  var props = vnode.data.domProps || {};\n\t  // clone observed objects, as the user probably wants to mutate it\n\t  if (props.__ob__) {\n\t    props = vnode.data.domProps = extend({}, props);\n\t  }\n\n\t  for (key in oldProps) {\n\t    if (props[key] == null) {\n\t      elm[key] = '';\n\t    }\n\t  }\n\t  for (key in props) {\n\t    cur = props[key];\n\t    // ignore children if the node has textContent or innerHTML,\n\t    // as these will throw away existing DOM nodes and cause removal errors\n\t    // on subsequent patches (#3360)\n\t    if (key === 'textContent' || key === 'innerHTML') {\n\t      if (vnode.children) { vnode.children.length = 0; }\n\t      if (cur === oldProps[key]) { continue }\n\t    }\n\t    // #4521: if a click event triggers update before the change event is\n\t    // dispatched on a checkbox/radio input, the input's checked state will\n\t    // be reset and fail to trigger another update.\n\t    /* istanbul ignore next */\n\t    if (key === 'checked' && !isDirty(elm, cur)) {\n\t      continue\n\t    }\n\t    if (key === 'value') {\n\t      // store value as _value as well since\n\t      // non-string values will be stringified\n\t      elm._value = cur;\n\t      // avoid resetting cursor position when value is the same\n\t      var strCur = cur == null ? '' : String(cur);\n\t      if (shouldUpdateValue(elm, vnode, strCur)) {\n\t        elm.value = strCur;\n\t      }\n\t    } else {\n\t      elm[key] = cur;\n\t    }\n\t  }\n\t}\n\n\t// check platforms/web/util/attrs.js acceptValue\n\n\n\tfunction shouldUpdateValue (\n\t  elm,\n\t  vnode,\n\t  checkVal\n\t) {\n\t  if (!elm.composing && (\n\t    vnode.tag === 'option' ||\n\t    isDirty(elm, checkVal) ||\n\t    isInputChanged(vnode, checkVal)\n\t  )) {\n\t    return true\n\t  }\n\t  return false\n\t}\n\n\tfunction isDirty (elm, checkVal) {\n\t  return document.activeElement !== elm && elm.value !== checkVal\n\t}\n\n\tfunction isInputChanged (vnode, newVal) {\n\t  var value = vnode.elm.value;\n\t  var modifiers = vnode.elm._vModifiers; // injected by v-model runtime\n\t  if ((modifiers && modifiers.number) || vnode.elm.type === 'number') {\n\t    return toNumber(value) !== toNumber(newVal)\n\t  }\n\t  if (modifiers && modifiers.trim) {\n\t    return value.trim() !== newVal.trim()\n\t  }\n\t  return value !== newVal\n\t}\n\n\tvar domProps = {\n\t  create: updateDOMProps,\n\t  update: updateDOMProps\n\t};\n\n\t/*  */\n\n\tvar parseStyleText = cached(function (cssText) {\n\t  var res = {};\n\t  var listDelimiter = /;(?![^(]*\\))/g;\n\t  var propertyDelimiter = /:(.+)/;\n\t  cssText.split(listDelimiter).forEach(function (item) {\n\t    if (item) {\n\t      var tmp = item.split(propertyDelimiter);\n\t      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n\t    }\n\t  });\n\t  return res\n\t});\n\n\t// merge static and dynamic style data on the same vnode\n\tfunction normalizeStyleData (data) {\n\t  var style = normalizeStyleBinding(data.style);\n\t  // static style is pre-processed into an object during compilation\n\t  // and is always a fresh object, so it's safe to merge into it\n\t  return data.staticStyle\n\t    ? extend(data.staticStyle, style)\n\t    : style\n\t}\n\n\t// normalize possible array / string values into Object\n\tfunction normalizeStyleBinding (bindingStyle) {\n\t  if (Array.isArray(bindingStyle)) {\n\t    return toObject(bindingStyle)\n\t  }\n\t  if (typeof bindingStyle === 'string') {\n\t    return parseStyleText(bindingStyle)\n\t  }\n\t  return bindingStyle\n\t}\n\n\t/**\n\t * parent component style should be after child's\n\t * so that parent component's style could override it\n\t */\n\tfunction getStyle (vnode, checkChild) {\n\t  var res = {};\n\t  var styleData;\n\n\t  if (checkChild) {\n\t    var childNode = vnode;\n\t    while (childNode.child) {\n\t      childNode = childNode.child._vnode;\n\t      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n\t        extend(res, styleData);\n\t      }\n\t    }\n\t  }\n\n\t  if ((styleData = normalizeStyleData(vnode.data))) {\n\t    extend(res, styleData);\n\t  }\n\n\t  var parentNode = vnode;\n\t  while ((parentNode = parentNode.parent)) {\n\t    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n\t      extend(res, styleData);\n\t    }\n\t  }\n\t  return res\n\t}\n\n\t/*  */\n\n\tvar cssVarRE = /^--/;\n\tvar importantRE = /\\s*!important$/;\n\tvar setProp = function (el, name, val) {\n\t  /* istanbul ignore if */\n\t  if (cssVarRE.test(name)) {\n\t    el.style.setProperty(name, val);\n\t  } else if (importantRE.test(val)) {\n\t    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n\t  } else {\n\t    el.style[normalize(name)] = val;\n\t  }\n\t};\n\n\tvar prefixes = ['Webkit', 'Moz', 'ms'];\n\n\tvar testEl;\n\tvar normalize = cached(function (prop) {\n\t  testEl = testEl || document.createElement('div');\n\t  prop = camelize(prop);\n\t  if (prop !== 'filter' && (prop in testEl.style)) {\n\t    return prop\n\t  }\n\t  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n\t  for (var i = 0; i < prefixes.length; i++) {\n\t    var prefixed = prefixes[i] + upper;\n\t    if (prefixed in testEl.style) {\n\t      return prefixed\n\t    }\n\t  }\n\t});\n\n\tfunction updateStyle (oldVnode, vnode) {\n\t  var data = vnode.data;\n\t  var oldData = oldVnode.data;\n\n\t  if (!data.staticStyle && !data.style &&\n\t      !oldData.staticStyle && !oldData.style) {\n\t    return\n\t  }\n\n\t  var cur, name;\n\t  var el = vnode.elm;\n\t  var oldStaticStyle = oldVnode.data.staticStyle;\n\t  var oldStyleBinding = oldVnode.data.style || {};\n\n\t  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n\t  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n\t  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n\t  vnode.data.style = style.__ob__ ? extend({}, style) : style;\n\n\t  var newStyle = getStyle(vnode, true);\n\n\t  for (name in oldStyle) {\n\t    if (newStyle[name] == null) {\n\t      setProp(el, name, '');\n\t    }\n\t  }\n\t  for (name in newStyle) {\n\t    cur = newStyle[name];\n\t    if (cur !== oldStyle[name]) {\n\t      // ie9 setting to null has no effect, must use empty string\n\t      setProp(el, name, cur == null ? '' : cur);\n\t    }\n\t  }\n\t}\n\n\tvar style = {\n\t  create: updateStyle,\n\t  update: updateStyle\n\t};\n\n\t/*  */\n\n\t/**\n\t * Add class with compatibility for SVG since classList is not supported on\n\t * SVG elements in IE\n\t */\n\tfunction addClass (el, cls) {\n\t  /* istanbul ignore if */\n\t  if (!cls || !cls.trim()) {\n\t    return\n\t  }\n\n\t  /* istanbul ignore else */\n\t  if (el.classList) {\n\t    if (cls.indexOf(' ') > -1) {\n\t      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n\t    } else {\n\t      el.classList.add(cls);\n\t    }\n\t  } else {\n\t    var cur = ' ' + el.getAttribute('class') + ' ';\n\t    if (cur.indexOf(' ' + cls + ' ') < 0) {\n\t      el.setAttribute('class', (cur + cls).trim());\n\t    }\n\t  }\n\t}\n\n\t/**\n\t * Remove class with compatibility for SVG since classList is not supported on\n\t * SVG elements in IE\n\t */\n\tfunction removeClass (el, cls) {\n\t  /* istanbul ignore if */\n\t  if (!cls || !cls.trim()) {\n\t    return\n\t  }\n\n\t  /* istanbul ignore else */\n\t  if (el.classList) {\n\t    if (cls.indexOf(' ') > -1) {\n\t      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n\t    } else {\n\t      el.classList.remove(cls);\n\t    }\n\t  } else {\n\t    var cur = ' ' + el.getAttribute('class') + ' ';\n\t    var tar = ' ' + cls + ' ';\n\t    while (cur.indexOf(tar) >= 0) {\n\t      cur = cur.replace(tar, ' ');\n\t    }\n\t    el.setAttribute('class', cur.trim());\n\t  }\n\t}\n\n\t/*  */\n\n\tvar hasTransition = inBrowser && !isIE9;\n\tvar TRANSITION = 'transition';\n\tvar ANIMATION = 'animation';\n\n\t// Transition property/event sniffing\n\tvar transitionProp = 'transition';\n\tvar transitionEndEvent = 'transitionend';\n\tvar animationProp = 'animation';\n\tvar animationEndEvent = 'animationend';\n\tif (hasTransition) {\n\t  /* istanbul ignore if */\n\t  if (window.ontransitionend === undefined &&\n\t    window.onwebkittransitionend !== undefined) {\n\t    transitionProp = 'WebkitTransition';\n\t    transitionEndEvent = 'webkitTransitionEnd';\n\t  }\n\t  if (window.onanimationend === undefined &&\n\t    window.onwebkitanimationend !== undefined) {\n\t    animationProp = 'WebkitAnimation';\n\t    animationEndEvent = 'webkitAnimationEnd';\n\t  }\n\t}\n\n\tvar raf = (inBrowser && window.requestAnimationFrame) || setTimeout;\n\tfunction nextFrame (fn) {\n\t  raf(function () {\n\t    raf(fn);\n\t  });\n\t}\n\n\tfunction addTransitionClass (el, cls) {\n\t  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n\t  addClass(el, cls);\n\t}\n\n\tfunction removeTransitionClass (el, cls) {\n\t  if (el._transitionClasses) {\n\t    remove$1(el._transitionClasses, cls);\n\t  }\n\t  removeClass(el, cls);\n\t}\n\n\tfunction whenTransitionEnds (\n\t  el,\n\t  expectedType,\n\t  cb\n\t) {\n\t  var ref = getTransitionInfo(el, expectedType);\n\t  var type = ref.type;\n\t  var timeout = ref.timeout;\n\t  var propCount = ref.propCount;\n\t  if (!type) { return cb() }\n\t  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n\t  var ended = 0;\n\t  var end = function () {\n\t    el.removeEventListener(event, onEnd);\n\t    cb();\n\t  };\n\t  var onEnd = function (e) {\n\t    if (e.target === el) {\n\t      if (++ended >= propCount) {\n\t        end();\n\t      }\n\t    }\n\t  };\n\t  setTimeout(function () {\n\t    if (ended < propCount) {\n\t      end();\n\t    }\n\t  }, timeout + 1);\n\t  el.addEventListener(event, onEnd);\n\t}\n\n\tvar transformRE = /\\b(transform|all)(,|$)/;\n\n\tfunction getTransitionInfo (el, expectedType) {\n\t  var styles = window.getComputedStyle(el);\n\t  var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');\n\t  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n\t  var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);\n\t  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n\t  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n\t  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n\t  var type;\n\t  var timeout = 0;\n\t  var propCount = 0;\n\t  /* istanbul ignore if */\n\t  if (expectedType === TRANSITION) {\n\t    if (transitionTimeout > 0) {\n\t      type = TRANSITION;\n\t      timeout = transitionTimeout;\n\t      propCount = transitionDurations.length;\n\t    }\n\t  } else if (expectedType === ANIMATION) {\n\t    if (animationTimeout > 0) {\n\t      type = ANIMATION;\n\t      timeout = animationTimeout;\n\t      propCount = animationDurations.length;\n\t    }\n\t  } else {\n\t    timeout = Math.max(transitionTimeout, animationTimeout);\n\t    type = timeout > 0\n\t      ? transitionTimeout > animationTimeout\n\t        ? TRANSITION\n\t        : ANIMATION\n\t      : null;\n\t    propCount = type\n\t      ? type === TRANSITION\n\t        ? transitionDurations.length\n\t        : animationDurations.length\n\t      : 0;\n\t  }\n\t  var hasTransform =\n\t    type === TRANSITION &&\n\t    transformRE.test(styles[transitionProp + 'Property']);\n\t  return {\n\t    type: type,\n\t    timeout: timeout,\n\t    propCount: propCount,\n\t    hasTransform: hasTransform\n\t  }\n\t}\n\n\tfunction getTimeout (delays, durations) {\n\t  /* istanbul ignore next */\n\t  while (delays.length < durations.length) {\n\t    delays = delays.concat(delays);\n\t  }\n\n\t  return Math.max.apply(null, durations.map(function (d, i) {\n\t    return toMs(d) + toMs(delays[i])\n\t  }))\n\t}\n\n\tfunction toMs (s) {\n\t  return Number(s.slice(0, -1)) * 1000\n\t}\n\n\t/*  */\n\n\tfunction enter (vnode, toggleDisplay) {\n\t  var el = vnode.elm;\n\n\t  // call leave callback now\n\t  if (el._leaveCb) {\n\t    el._leaveCb.cancelled = true;\n\t    el._leaveCb();\n\t  }\n\n\t  var data = resolveTransition(vnode.data.transition);\n\t  if (!data) {\n\t    return\n\t  }\n\n\t  /* istanbul ignore if */\n\t  if (el._enterCb || el.nodeType !== 1) {\n\t    return\n\t  }\n\n\t  var css = data.css;\n\t  var type = data.type;\n\t  var enterClass = data.enterClass;\n\t  var enterToClass = data.enterToClass;\n\t  var enterActiveClass = data.enterActiveClass;\n\t  var appearClass = data.appearClass;\n\t  var appearToClass = data.appearToClass;\n\t  var appearActiveClass = data.appearActiveClass;\n\t  var beforeEnter = data.beforeEnter;\n\t  var enter = data.enter;\n\t  var afterEnter = data.afterEnter;\n\t  var enterCancelled = data.enterCancelled;\n\t  var beforeAppear = data.beforeAppear;\n\t  var appear = data.appear;\n\t  var afterAppear = data.afterAppear;\n\t  var appearCancelled = data.appearCancelled;\n\n\t  // activeInstance will always be the <transition> component managing this\n\t  // transition. One edge case to check is when the <transition> is placed\n\t  // as the root node of a child component. In that case we need to check\n\t  // <transition>'s parent for appear check.\n\t  var context = activeInstance;\n\t  var transitionNode = activeInstance.$vnode;\n\t  while (transitionNode && transitionNode.parent) {\n\t    transitionNode = transitionNode.parent;\n\t    context = transitionNode.context;\n\t  }\n\n\t  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n\t  if (isAppear && !appear && appear !== '') {\n\t    return\n\t  }\n\n\t  var startClass = isAppear ? appearClass : enterClass;\n\t  var activeClass = isAppear ? appearActiveClass : enterActiveClass;\n\t  var toClass = isAppear ? appearToClass : enterToClass;\n\t  var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;\n\t  var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;\n\t  var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;\n\t  var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;\n\n\t  var expectsCSS = css !== false && !isIE9;\n\t  var userWantsControl =\n\t    enterHook &&\n\t    // enterHook may be a bound method which exposes\n\t    // the length of original fn as _length\n\t    (enterHook._length || enterHook.length) > 1;\n\n\t  var cb = el._enterCb = once(function () {\n\t    if (expectsCSS) {\n\t      removeTransitionClass(el, toClass);\n\t      removeTransitionClass(el, activeClass);\n\t    }\n\t    if (cb.cancelled) {\n\t      if (expectsCSS) {\n\t        removeTransitionClass(el, startClass);\n\t      }\n\t      enterCancelledHook && enterCancelledHook(el);\n\t    } else {\n\t      afterEnterHook && afterEnterHook(el);\n\t    }\n\t    el._enterCb = null;\n\t  });\n\n\t  if (!vnode.data.show) {\n\t    // remove pending leave element on enter by injecting an insert hook\n\t    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n\t      var parent = el.parentNode;\n\t      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n\t      if (pendingNode &&\n\t          pendingNode.context === vnode.context &&\n\t          pendingNode.tag === vnode.tag &&\n\t          pendingNode.elm._leaveCb) {\n\t        pendingNode.elm._leaveCb();\n\t      }\n\t      enterHook && enterHook(el, cb);\n\t    }, 'transition-insert');\n\t  }\n\n\t  // start enter transition\n\t  beforeEnterHook && beforeEnterHook(el);\n\t  if (expectsCSS) {\n\t    addTransitionClass(el, startClass);\n\t    addTransitionClass(el, activeClass);\n\t    nextFrame(function () {\n\t      addTransitionClass(el, toClass);\n\t      removeTransitionClass(el, startClass);\n\t      if (!cb.cancelled && !userWantsControl) {\n\t        whenTransitionEnds(el, type, cb);\n\t      }\n\t    });\n\t  }\n\n\t  if (vnode.data.show) {\n\t    toggleDisplay && toggleDisplay();\n\t    enterHook && enterHook(el, cb);\n\t  }\n\n\t  if (!expectsCSS && !userWantsControl) {\n\t    cb();\n\t  }\n\t}\n\n\tfunction leave (vnode, rm) {\n\t  var el = vnode.elm;\n\n\t  // call enter callback now\n\t  if (el._enterCb) {\n\t    el._enterCb.cancelled = true;\n\t    el._enterCb();\n\t  }\n\n\t  var data = resolveTransition(vnode.data.transition);\n\t  if (!data) {\n\t    return rm()\n\t  }\n\n\t  /* istanbul ignore if */\n\t  if (el._leaveCb || el.nodeType !== 1) {\n\t    return\n\t  }\n\n\t  var css = data.css;\n\t  var type = data.type;\n\t  var leaveClass = data.leaveClass;\n\t  var leaveToClass = data.leaveToClass;\n\t  var leaveActiveClass = data.leaveActiveClass;\n\t  var beforeLeave = data.beforeLeave;\n\t  var leave = data.leave;\n\t  var afterLeave = data.afterLeave;\n\t  var leaveCancelled = data.leaveCancelled;\n\t  var delayLeave = data.delayLeave;\n\n\t  var expectsCSS = css !== false && !isIE9;\n\t  var userWantsControl =\n\t    leave &&\n\t    // leave hook may be a bound method which exposes\n\t    // the length of original fn as _length\n\t    (leave._length || leave.length) > 1;\n\n\t  var cb = el._leaveCb = once(function () {\n\t    if (el.parentNode && el.parentNode._pending) {\n\t      el.parentNode._pending[vnode.key] = null;\n\t    }\n\t    if (expectsCSS) {\n\t      removeTransitionClass(el, leaveToClass);\n\t      removeTransitionClass(el, leaveActiveClass);\n\t    }\n\t    if (cb.cancelled) {\n\t      if (expectsCSS) {\n\t        removeTransitionClass(el, leaveClass);\n\t      }\n\t      leaveCancelled && leaveCancelled(el);\n\t    } else {\n\t      rm();\n\t      afterLeave && afterLeave(el);\n\t    }\n\t    el._leaveCb = null;\n\t  });\n\n\t  if (delayLeave) {\n\t    delayLeave(performLeave);\n\t  } else {\n\t    performLeave();\n\t  }\n\n\t  function performLeave () {\n\t    // the delayed leave may have already been cancelled\n\t    if (cb.cancelled) {\n\t      return\n\t    }\n\t    // record leaving element\n\t    if (!vnode.data.show) {\n\t      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n\t    }\n\t    beforeLeave && beforeLeave(el);\n\t    if (expectsCSS) {\n\t      addTransitionClass(el, leaveClass);\n\t      addTransitionClass(el, leaveActiveClass);\n\t      nextFrame(function () {\n\t        addTransitionClass(el, leaveToClass);\n\t        removeTransitionClass(el, leaveClass);\n\t        if (!cb.cancelled && !userWantsControl) {\n\t          whenTransitionEnds(el, type, cb);\n\t        }\n\t      });\n\t    }\n\t    leave && leave(el, cb);\n\t    if (!expectsCSS && !userWantsControl) {\n\t      cb();\n\t    }\n\t  }\n\t}\n\n\tfunction resolveTransition (def$$1) {\n\t  if (!def$$1) {\n\t    return\n\t  }\n\t  /* istanbul ignore else */\n\t  if (typeof def$$1 === 'object') {\n\t    var res = {};\n\t    if (def$$1.css !== false) {\n\t      extend(res, autoCssTransition(def$$1.name || 'v'));\n\t    }\n\t    extend(res, def$$1);\n\t    return res\n\t  } else if (typeof def$$1 === 'string') {\n\t    return autoCssTransition(def$$1)\n\t  }\n\t}\n\n\tvar autoCssTransition = cached(function (name) {\n\t  return {\n\t    enterClass: (name + \"-enter\"),\n\t    leaveClass: (name + \"-leave\"),\n\t    appearClass: (name + \"-enter\"),\n\t    enterToClass: (name + \"-enter-to\"),\n\t    leaveToClass: (name + \"-leave-to\"),\n\t    appearToClass: (name + \"-enter-to\"),\n\t    enterActiveClass: (name + \"-enter-active\"),\n\t    leaveActiveClass: (name + \"-leave-active\"),\n\t    appearActiveClass: (name + \"-enter-active\")\n\t  }\n\t});\n\n\tfunction once (fn) {\n\t  var called = false;\n\t  return function () {\n\t    if (!called) {\n\t      called = true;\n\t      fn();\n\t    }\n\t  }\n\t}\n\n\tfunction _enter (_, vnode) {\n\t  if (!vnode.data.show) {\n\t    enter(vnode);\n\t  }\n\t}\n\n\tvar transition = inBrowser ? {\n\t  create: _enter,\n\t  activate: _enter,\n\t  remove: function remove (vnode, rm) {\n\t    /* istanbul ignore else */\n\t    if (!vnode.data.show) {\n\t      leave(vnode, rm);\n\t    } else {\n\t      rm();\n\t    }\n\t  }\n\t} : {};\n\n\tvar platformModules = [\n\t  attrs,\n\t  klass,\n\t  events,\n\t  domProps,\n\t  style,\n\t  transition\n\t];\n\n\t/*  */\n\n\t// the directive module should be applied last, after all\n\t// built-in modules have been applied.\n\tvar modules = platformModules.concat(baseModules);\n\n\tvar patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n\t/* istanbul ignore if */\n\tif (isIE9) {\n\t  // http://www.matts411.com/post/internet-explorer-9-oninput/\n\t  document.addEventListener('selectionchange', function () {\n\t    var el = document.activeElement;\n\t    if (el && el.vmodel) {\n\t      trigger(el, 'input');\n\t    }\n\t  });\n\t}\n\n\tvar model = {\n\t  inserted: function inserted (el, binding, vnode) {\n\t    if (false) {}\n\t    if (vnode.tag === 'select') {\n\t      var cb = function () {\n\t        setSelected(el, binding, vnode.context);\n\t      };\n\t      cb();\n\t      /* istanbul ignore if */\n\t      if (isIE || isEdge) {\n\t        setTimeout(cb, 0);\n\t      }\n\t    } else if (vnode.tag === 'textarea' || el.type === 'text') {\n\t      el._vModifiers = binding.modifiers;\n\t      if (!binding.modifiers.lazy) {\n\t        if (!isAndroid) {\n\t          el.addEventListener('compositionstart', onCompositionStart);\n\t          el.addEventListener('compositionend', onCompositionEnd);\n\t        }\n\t        /* istanbul ignore if */\n\t        if (isIE9) {\n\t          el.vmodel = true;\n\t        }\n\t      }\n\t    }\n\t  },\n\t  componentUpdated: function componentUpdated (el, binding, vnode) {\n\t    if (vnode.tag === 'select') {\n\t      setSelected(el, binding, vnode.context);\n\t      // in case the options rendered by v-for have changed,\n\t      // it's possible that the value is out-of-sync with the rendered options.\n\t      // detect such cases and filter out values that no longer has a matching\n\t      // option in the DOM.\n\t      var needReset = el.multiple\n\t        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n\t        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n\t      if (needReset) {\n\t        trigger(el, 'change');\n\t      }\n\t    }\n\t  }\n\t};\n\n\tfunction setSelected (el, binding, vm) {\n\t  var value = binding.value;\n\t  var isMultiple = el.multiple;\n\t  if (isMultiple && !Array.isArray(value)) {\n\t    \"production\" !== 'production' && warn$1(\n\t      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n\t      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n\t      vm\n\t    );\n\t    return\n\t  }\n\t  var selected, option;\n\t  for (var i = 0, l = el.options.length; i < l; i++) {\n\t    option = el.options[i];\n\t    if (isMultiple) {\n\t      selected = looseIndexOf(value, getValue(option)) > -1;\n\t      if (option.selected !== selected) {\n\t        option.selected = selected;\n\t      }\n\t    } else {\n\t      if (looseEqual(getValue(option), value)) {\n\t        if (el.selectedIndex !== i) {\n\t          el.selectedIndex = i;\n\t        }\n\t        return\n\t      }\n\t    }\n\t  }\n\t  if (!isMultiple) {\n\t    el.selectedIndex = -1;\n\t  }\n\t}\n\n\tfunction hasNoMatchingOption (value, options) {\n\t  for (var i = 0, l = options.length; i < l; i++) {\n\t    if (looseEqual(getValue(options[i]), value)) {\n\t      return false\n\t    }\n\t  }\n\t  return true\n\t}\n\n\tfunction getValue (option) {\n\t  return '_value' in option\n\t    ? option._value\n\t    : option.value\n\t}\n\n\tfunction onCompositionStart (e) {\n\t  e.target.composing = true;\n\t}\n\n\tfunction onCompositionEnd (e) {\n\t  e.target.composing = false;\n\t  trigger(e.target, 'input');\n\t}\n\n\tfunction trigger (el, type) {\n\t  var e = document.createEvent('HTMLEvents');\n\t  e.initEvent(type, true, true);\n\t  el.dispatchEvent(e);\n\t}\n\n\t/*  */\n\n\t// recursively search for possible transition defined inside the component root\n\tfunction locateNode (vnode) {\n\t  return vnode.child && (!vnode.data || !vnode.data.transition)\n\t    ? locateNode(vnode.child._vnode)\n\t    : vnode\n\t}\n\n\tvar show = {\n\t  bind: function bind (el, ref, vnode) {\n\t    var value = ref.value;\n\n\t    vnode = locateNode(vnode);\n\t    var transition = vnode.data && vnode.data.transition;\n\t    var originalDisplay = el.__vOriginalDisplay =\n\t      el.style.display === 'none' ? '' : el.style.display;\n\t    if (value && transition && !isIE9) {\n\t      vnode.data.show = true;\n\t      enter(vnode, function () {\n\t        el.style.display = originalDisplay;\n\t      });\n\t    } else {\n\t      el.style.display = value ? originalDisplay : 'none';\n\t    }\n\t  },\n\n\t  update: function update (el, ref, vnode) {\n\t    var value = ref.value;\n\t    var oldValue = ref.oldValue;\n\n\t    /* istanbul ignore if */\n\t    if (value === oldValue) { return }\n\t    vnode = locateNode(vnode);\n\t    var transition = vnode.data && vnode.data.transition;\n\t    if (transition && !isIE9) {\n\t      vnode.data.show = true;\n\t      if (value) {\n\t        enter(vnode, function () {\n\t          el.style.display = el.__vOriginalDisplay;\n\t        });\n\t      } else {\n\t        leave(vnode, function () {\n\t          el.style.display = 'none';\n\t        });\n\t      }\n\t    } else {\n\t      el.style.display = value ? el.__vOriginalDisplay : 'none';\n\t    }\n\t  },\n\n\t  unbind: function unbind (\n\t    el,\n\t    binding,\n\t    vnode,\n\t    oldVnode,\n\t    isDestroy\n\t  ) {\n\t    if (!isDestroy) {\n\t      el.style.display = el.__vOriginalDisplay;\n\t    }\n\t  }\n\t};\n\n\tvar platformDirectives = {\n\t  model: model,\n\t  show: show\n\t};\n\n\t/*  */\n\n\t// Provides transition support for a single element/component.\n\t// supports transition mode (out-in / in-out)\n\n\tvar transitionProps = {\n\t  name: String,\n\t  appear: Boolean,\n\t  css: Boolean,\n\t  mode: String,\n\t  type: String,\n\t  enterClass: String,\n\t  leaveClass: String,\n\t  enterToClass: String,\n\t  leaveToClass: String,\n\t  enterActiveClass: String,\n\t  leaveActiveClass: String,\n\t  appearClass: String,\n\t  appearActiveClass: String,\n\t  appearToClass: String\n\t};\n\n\t// in case the child is also an abstract component, e.g. <keep-alive>\n\t// we want to recursively retrieve the real component to be rendered\n\tfunction getRealChild (vnode) {\n\t  var compOptions = vnode && vnode.componentOptions;\n\t  if (compOptions && compOptions.Ctor.options.abstract) {\n\t    return getRealChild(getFirstComponentChild(compOptions.children))\n\t  } else {\n\t    return vnode\n\t  }\n\t}\n\n\tfunction extractTransitionData (comp) {\n\t  var data = {};\n\t  var options = comp.$options;\n\t  // props\n\t  for (var key in options.propsData) {\n\t    data[key] = comp[key];\n\t  }\n\t  // events.\n\t  // extract listeners and pass them directly to the transition methods\n\t  var listeners = options._parentListeners;\n\t  for (var key$1 in listeners) {\n\t    data[camelize(key$1)] = listeners[key$1].fn;\n\t  }\n\t  return data\n\t}\n\n\tfunction placeholder (h, rawChild) {\n\t  return /\\d-keep-alive$/.test(rawChild.tag)\n\t    ? h('keep-alive')\n\t    : null\n\t}\n\n\tfunction hasParentTransition (vnode) {\n\t  while ((vnode = vnode.parent)) {\n\t    if (vnode.data.transition) {\n\t      return true\n\t    }\n\t  }\n\t}\n\n\tfunction isSameChild (child, oldChild) {\n\t  return oldChild.key === child.key && oldChild.tag === child.tag\n\t}\n\n\tvar Transition = {\n\t  name: 'transition',\n\t  props: transitionProps,\n\t  abstract: true,\n\t  render: function render (h) {\n\t    var this$1 = this;\n\n\t    var children = this.$slots.default;\n\t    if (!children) {\n\t      return\n\t    }\n\n\t    // filter out text nodes (possible whitespaces)\n\t    children = children.filter(function (c) { return c.tag; });\n\t    /* istanbul ignore if */\n\t    if (!children.length) {\n\t      return\n\t    }\n\n\t    // warn multiple elements\n\t    if (false) {}\n\n\t    var mode = this.mode;\n\n\t    // warn invalid mode\n\t    if (false) {}\n\n\t    var rawChild = children[0];\n\n\t    // if this is a component root node and the component's\n\t    // parent container node also has transition, skip.\n\t    if (hasParentTransition(this.$vnode)) {\n\t      return rawChild\n\t    }\n\n\t    // apply transition data to child\n\t    // use getRealChild() to ignore abstract components e.g. keep-alive\n\t    var child = getRealChild(rawChild);\n\t    /* istanbul ignore if */\n\t    if (!child) {\n\t      return rawChild\n\t    }\n\n\t    if (this._leaving) {\n\t      return placeholder(h, rawChild)\n\t    }\n\n\t    var key = child.key = child.key == null || child.isStatic\n\t      ? (\"__v\" + (child.tag + this._uid) + \"__\")\n\t      : child.key;\n\t    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n\t    var oldRawChild = this._vnode;\n\t    var oldChild = getRealChild(oldRawChild);\n\n\t    // mark v-show\n\t    // so that the transition module can hand over the control to the directive\n\t    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n\t      child.data.show = true;\n\t    }\n\n\t    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n\t      // replace old child transition data with fresh one\n\t      // important for dynamic transitions!\n\t      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n\t      // handle transition mode\n\t      if (mode === 'out-in') {\n\t        // return placeholder node and queue update when leave finishes\n\t        this._leaving = true;\n\t        mergeVNodeHook(oldData, 'afterLeave', function () {\n\t          this$1._leaving = false;\n\t          this$1.$forceUpdate();\n\t        }, key);\n\t        return placeholder(h, rawChild)\n\t      } else if (mode === 'in-out') {\n\t        var delayedLeave;\n\t        var performLeave = function () { delayedLeave(); };\n\t        mergeVNodeHook(data, 'afterEnter', performLeave, key);\n\t        mergeVNodeHook(data, 'enterCancelled', performLeave, key);\n\t        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n\t          delayedLeave = leave;\n\t        }, key);\n\t      }\n\t    }\n\n\t    return rawChild\n\t  }\n\t};\n\n\t/*  */\n\n\t// Provides transition support for list items.\n\t// supports move transitions using the FLIP technique.\n\n\t// Because the vdom's children update algorithm is \"unstable\" - i.e.\n\t// it doesn't guarantee the relative positioning of removed elements,\n\t// we force transition-group to update its children into two passes:\n\t// in the first pass, we remove all nodes that need to be removed,\n\t// triggering their leaving transition; in the second pass, we insert/move\n\t// into the final disired state. This way in the second pass removed\n\t// nodes will remain where they should be.\n\n\tvar props = extend({\n\t  tag: String,\n\t  moveClass: String\n\t}, transitionProps);\n\n\tdelete props.mode;\n\n\tvar TransitionGroup = {\n\t  props: props,\n\n\t  render: function render (h) {\n\t    var tag = this.tag || this.$vnode.data.tag || 'span';\n\t    var map = Object.create(null);\n\t    var prevChildren = this.prevChildren = this.children;\n\t    var rawChildren = this.$slots.default || [];\n\t    var children = this.children = [];\n\t    var transitionData = extractTransitionData(this);\n\n\t    for (var i = 0; i < rawChildren.length; i++) {\n\t      var c = rawChildren[i];\n\t      if (c.tag) {\n\t        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n\t          children.push(c);\n\t          map[c.key] = c\n\t          ;(c.data || (c.data = {})).transition = transitionData;\n\t        } else if (false) {}\n\t      }\n\t    }\n\n\t    if (prevChildren) {\n\t      var kept = [];\n\t      var removed = [];\n\t      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n\t        var c$1 = prevChildren[i$1];\n\t        c$1.data.transition = transitionData;\n\t        c$1.data.pos = c$1.elm.getBoundingClientRect();\n\t        if (map[c$1.key]) {\n\t          kept.push(c$1);\n\t        } else {\n\t          removed.push(c$1);\n\t        }\n\t      }\n\t      this.kept = h(tag, null, kept);\n\t      this.removed = removed;\n\t    }\n\n\t    return h(tag, null, children)\n\t  },\n\n\t  beforeUpdate: function beforeUpdate () {\n\t    // force removing pass\n\t    this.__patch__(\n\t      this._vnode,\n\t      this.kept,\n\t      false, // hydrating\n\t      true // removeOnly (!important, avoids unnecessary moves)\n\t    );\n\t    this._vnode = this.kept;\n\t  },\n\n\t  updated: function updated () {\n\t    var children = this.prevChildren;\n\t    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n\t    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n\t      return\n\t    }\n\n\t    // we divide the work into three loops to avoid mixing DOM reads and writes\n\t    // in each iteration - which helps prevent layout thrashing.\n\t    children.forEach(callPendingCbs);\n\t    children.forEach(recordPosition);\n\t    children.forEach(applyTranslation);\n\n\t    // force reflow to put everything in position\n\t    var f = document.body.offsetHeight; // eslint-disable-line\n\n\t    children.forEach(function (c) {\n\t      if (c.data.moved) {\n\t        var el = c.elm;\n\t        var s = el.style;\n\t        addTransitionClass(el, moveClass);\n\t        s.transform = s.WebkitTransform = s.transitionDuration = '';\n\t        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n\t          if (!e || /transform$/.test(e.propertyName)) {\n\t            el.removeEventListener(transitionEndEvent, cb);\n\t            el._moveCb = null;\n\t            removeTransitionClass(el, moveClass);\n\t          }\n\t        });\n\t      }\n\t    });\n\t  },\n\n\t  methods: {\n\t    hasMove: function hasMove (el, moveClass) {\n\t      /* istanbul ignore if */\n\t      if (!hasTransition) {\n\t        return false\n\t      }\n\t      if (this._hasMove != null) {\n\t        return this._hasMove\n\t      }\n\t      addTransitionClass(el, moveClass);\n\t      var info = getTransitionInfo(el);\n\t      removeTransitionClass(el, moveClass);\n\t      return (this._hasMove = info.hasTransform)\n\t    }\n\t  }\n\t};\n\n\tfunction callPendingCbs (c) {\n\t  /* istanbul ignore if */\n\t  if (c.elm._moveCb) {\n\t    c.elm._moveCb();\n\t  }\n\t  /* istanbul ignore if */\n\t  if (c.elm._enterCb) {\n\t    c.elm._enterCb();\n\t  }\n\t}\n\n\tfunction recordPosition (c) {\n\t  c.data.newPos = c.elm.getBoundingClientRect();\n\t}\n\n\tfunction applyTranslation (c) {\n\t  var oldPos = c.data.pos;\n\t  var newPos = c.data.newPos;\n\t  var dx = oldPos.left - newPos.left;\n\t  var dy = oldPos.top - newPos.top;\n\t  if (dx || dy) {\n\t    c.data.moved = true;\n\t    var s = c.elm.style;\n\t    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n\t    s.transitionDuration = '0s';\n\t  }\n\t}\n\n\tvar platformComponents = {\n\t  Transition: Transition,\n\t  TransitionGroup: TransitionGroup\n\t};\n\n\t/*  */\n\n\t// install platform specific utils\n\tVue$2.config.isUnknownElement = isUnknownElement;\n\tVue$2.config.isReservedTag = isReservedTag;\n\tVue$2.config.getTagNamespace = getTagNamespace;\n\tVue$2.config.mustUseProp = mustUseProp;\n\n\t// install platform runtime directives & components\n\textend(Vue$2.options.directives, platformDirectives);\n\textend(Vue$2.options.components, platformComponents);\n\n\t// install platform patch function\n\tVue$2.prototype.__patch__ = inBrowser ? patch$1 : noop;\n\n\t// wrap mount\n\tVue$2.prototype.$mount = function (\n\t  el,\n\t  hydrating\n\t) {\n\t  el = el && inBrowser ? query(el) : undefined;\n\t  return this._mount(el, hydrating)\n\t};\n\n\t// devtools global hook\n\t/* istanbul ignore next */\n\tsetTimeout(function () {\n\t  if (config.devtools) {\n\t    if (devtools) {\n\t      devtools.emit('init', Vue$2);\n\t    } else if (\n\t      false\n\t    ) {}\n\t  }\n\t}, 0);\n\n\tvar vue_runtime_common = Vue$2;\n\n\tvar LEFT_ARROW = ''\n\tvar RIGHT_ARROW = ''\n\tvar ELLIPSES = ''\n\n\tvar LimitedLinksGenerator = function LimitedLinksGenerator (listOfPages, currentPage, limit) {\n\t  this.listOfPages = listOfPages\n\t  this.lastPage = listOfPages.length - 1\n\t  this.currentPage = currentPage === this.lastPage\n\t    ? this.lastPage - 1\n\t    : currentPage\n\t  this.limit = limit\n\t};\n\n\tLimitedLinksGenerator.prototype.generate = function generate () {\n\t  var firstHalf = this._buildFirstHalf()\n\t  var secondHalf = this._buildSecondHalf()\n\t  return firstHalf.concat( secondHalf)\n\t};\n\n\tLimitedLinksGenerator.prototype._buildFirstHalf = function _buildFirstHalf () {\n\t  var firstHalf = this._allPagesButLast()\n\t    .slice(\n\t      this._currentChunkIndex(),\n\t      this._currentChunkIndex() + this.limit\n\t    )\n\t  // Add backward ellipses with first page if needed\n\t  if (this.currentPage >= this.limit) {\n\t    firstHalf.unshift(ELLIPSES)\n\t    firstHalf.unshift(0)\n\t  }\n\t  // Add ellipses if needed\n\t  if (this.lastPage - this.limit > this._currentChunkIndex()) {\n\t    firstHalf.push(ELLIPSES)\n\t  }\n\t  return firstHalf\n\t};\n\n\tLimitedLinksGenerator.prototype._buildSecondHalf = function _buildSecondHalf () {\n\t  var secondHalf = [this.lastPage]\n\t  return secondHalf\n\t};\n\n\tLimitedLinksGenerator.prototype._currentChunkIndex = function _currentChunkIndex () {\n\t  var currentChunk = Math.floor(this.currentPage / this.limit)\n\t  return currentChunk * this.limit \n\t};\n\n\tLimitedLinksGenerator.prototype._allPagesButLast = function _allPagesButLast () {\n\t    var this$1 = this;\n\n\t  return this.listOfPages.filter(function (n) { return n !== this$1.lastPage; })\n\t};\n\n\tvar PaginateLinks = {\n\t  name: 'paginate-links',\n\t  props: {\n\t    for: {\n\t      type: String,\n\t      required: true\n\t    },\n\t    limit: {\n\t      type: Number,\n\t      default: 0\n\t    },\n\t    simple: {\n\t      type: Object,\n\t      default: null,\n\t      validator: function validator (obj) {\n\t        return obj.prev && obj.next\n\t      }\n\t    },\n\t    stepLinks: {\n\t      type: Object,\n\t      default: function () {\n\t        return {\n\t          prev: LEFT_ARROW,\n\t          next: RIGHT_ARROW\n\t        }\n\t      },\n\t      validator: function validator$1 (obj) {\n\t        return obj.prev && obj.next\n\t      }\n\t    },\n\t    showStepLinks: {\n\t      type: Boolean\n\t    },\n\t    hideSinglePage: {\n\t      type: Boolean\n\t    },\n\t    classes: {\n\t      type: Object,\n\t      default: null\n\t    }\n\t  },\n\t  data: function data () {\n\t    return {\n\t      listOfPages: [],\n\t      numberOfPages: 0\n\t    }\n\t  },\n\t  computed: {\n\t    currentPage: {\n\t      get: function get () {\n\t        if (this.$parent.paginate[this.for]) {\n\t          return this.$parent.paginate[this.for].page\n\t        }\n\t      },\n\t      set: function set (page) {\n\t        this.$parent.paginate[this.for].page = page\n\t      }\n\t    }\n\t  },\n\t  mounted: function mounted () {\n\t    var this$1 = this;\n\n\t    if (this.simple && this.limit) {\n\t      warn((\"<paginate-links for=\\\"\" + (this.for) + \"\\\"> 'simple' and 'limit' props can't be used at the same time. In this case, 'simple' will take precedence, and 'limit' will be ignored.\"), this.$parent, 'warn')\n\t    }\n\t    if (this.simple && !this.simple.next) {\n\t      warn((\"<paginate-links for=\\\"\" + (this.for) + \"\\\"> 'simple' prop doesn't contain 'next' value.\"), this.$parent)\n\t    }\n\t    if (this.simple && !this.simple.prev) {\n\t      warn((\"<paginate-links for=\\\"\" + (this.for) + \"\\\"> 'simple' prop doesn't contain 'prev' value.\"), this.$parent)\n\t    }\n\t    if (this.stepLinks && !this.stepLinks.next) {\n\t      warn((\"<paginate-links for=\\\"\" + (this.for) + \"\\\"> 'step-links' prop doesn't contain 'next' value.\"), this.$parent)\n\t    }\n\t    if (this.stepLinks && !this.stepLinks.prev) {\n\t      warn((\"<paginate-links for=\\\"\" + (this.for) + \"\\\"> 'step-links' prop doesn't contain 'prev' value.\"), this.$parent)\n\t    }\n\t    vue_runtime_common.nextTick(function () {\n\t      this$1.updateListOfPages()\n\t    })\n\t  },\n\t  watch: {\n\t    '$parent.paginate': {\n\t      handler: function handler () {\n\t        this.updateListOfPages()\n\t      },\n\t      deep: true\n\t    },\n\t    currentPage: function currentPage (toPage, fromPage) {\n\t      this.$emit('change', toPage + 1, fromPage + 1)\n\t    }\n\t  },\n\t  methods: {\n\t    updateListOfPages: function updateListOfPages () {\n\t      var target = getTargetPaginateComponent(this.$parent.$children, this.for)\n\t      if (!target) {\n\t        warn((\"<paginate-links for=\\\"\" + (this.for) + \"\\\"> can't be used without its companion <paginate name=\\\"\" + (this.for) + \"\\\">\"), this.$parent)\n\t        return\n\t      }\n\t      this.numberOfPages = Math.ceil(target.list.length / target.per)\n\t      this.listOfPages = getListOfPageNumbers(this.numberOfPages)\n\t    }\n\t  },\n\t  render: function render (h) {\n\t    var this$1 = this;\n\n\t    var links = this.simple\n\t      ? getSimpleLinks(this, h)\n\t      : this.limit > 1\n\t      ? getLimitedLinks(this, h)\n\t      : getFullLinks(this, h)\n\n\t    if (this.hideSinglePage && this.numberOfPages <= 1) {\n\t      return null\n\t    }\n\n\t    var el = h('ul', {\n\t      class: ['paginate-links', this.for]\n\t    }, links)\n\n\t    if (this.classes) {\n\t      vue_runtime_common.nextTick(function () {\n\t        addAdditionalClasses(el.elm, this$1.classes)\n\t      })\n\t    }\n\t    return el\n\t  }\n\t}\n\n\tfunction getFullLinks (vm, h) {\n\t  var allLinks = vm.showStepLinks\n\t    ? [vm.stepLinks.prev ].concat( vm.listOfPages, [vm.stepLinks.next])\n\t    : vm.listOfPages\n\t  return allLinks.map(function (link) {\n\t    var data = {\n\t      on: {\n\t        click: function (e) {\n\t          e.preventDefault()\n\t          vm.currentPage = getTargetPageForLink(\n\t            link,\n\t            vm.limit,\n\t            vm.currentPage,\n\t            vm.listOfPages,\n\t            vm.stepLinks\n\t          )\n\t        }\n\t      }\n\t    }\n\t    var liClasses = getClassesForLink(\n\t      link,\n\t      vm.currentPage,\n\t      vm.listOfPages.length - 1,\n\t      vm.stepLinks\n\t    )\n\t    var linkText = link === vm.stepLinks.next || link === vm.stepLinks.prev\n\t      ? link\n\t      : link + 1 // it means it's a number\n\t    return h('li', { class: liClasses }, [h('a', data, linkText)])\n\t  })\n\t}\n\n\tfunction getLimitedLinks (vm, h) {\n\t  var limitedLinks = new LimitedLinksGenerator(\n\t    vm.listOfPages,\n\t    vm.currentPage,\n\t    vm.limit,\n\t    vm.stepLinks\n\t  ).generate()\n\n\t  limitedLinks = vm.showStepLinks\n\t    ? [vm.stepLinks.prev ].concat( limitedLinks, [vm.stepLinks.next])\n\t    : limitedLinks\n\n\t  var limitedLinksMetadata = getLimitedLinksMetadata(limitedLinks)\n\n\t  return limitedLinks.map(function (link, index) {\n\t    var data = {\n\t      on: {\n\t        click: function (e) {\n\t          e.preventDefault()\n\t          vm.currentPage = getTargetPageForLink(\n\t            link,\n\t            vm.limit,\n\t            vm.currentPage,\n\t            vm.listOfPages,\n\t            vm.stepLinks,\n\t            limitedLinksMetadata[index]\n\t          )\n\t        }\n\t      }\n\t    }\n\t    var liClasses = getClassesForLink(\n\t      link,\n\t      vm.currentPage,\n\t      vm.listOfPages.length - 1,\n\t      vm.stepLinks\n\t    )\n\t    // If the link is a number,\n\t    // then incremented by 1 (since it's 0 based).\n\t    // otherwise, do nothing (so, it's a symbol). \n\t    var text = Number.isInteger(link) ? link + 1 : link\n\t    return h('li', { class: liClasses }, [h('a', data, text)])\n\t  })\n\t}\n\n\tfunction getSimpleLinks (vm, h) {\n\t  var lastPage = vm.listOfPages.length - 1\n\t  var prevData = {\n\t    on: {\n\t      click: function (e) {\n\t        e.preventDefault()\n\t        if (vm.currentPage > 0) { vm.currentPage -= 1 }\n\t      }\n\t    }\n\t  }\n\t  var nextData = {\n\t    on: {\n\t      click: function (e) {\n\t        e.preventDefault()\n\t        if (vm.currentPage < lastPage) { vm.currentPage += 1 }\n\t      }\n\t    }\n\t  }\n\t  var nextListData = { class: ['next', vm.currentPage >= lastPage ? 'disabled' : ''] }\n\t  var prevListData = { class: ['prev', vm.currentPage <= 0 ? 'disabled' : ''] }\n\t  var prevLink = h('li', prevListData, [h('a', prevData, vm.simple.prev)])\n\t  var nextLink = h('li', nextListData, [h('a', nextData, vm.simple.next)])\n\t  return [prevLink, nextLink]\n\t}\n\n\tfunction getTargetPaginateComponent (children, targetName) {\n\t  return children\n\t    .filter(function (child) { return (child.$vnode.componentOptions.tag === 'paginate'); })\n\t    .find(function (child) { return child.name === targetName; })\n\t}\n\n\tfunction getListOfPageNumbers (numberOfPages) {\n\t  // converts number of pages into an array\n\t  // that contains each individual page number\n\t  // For Example: 4 => [0, 1, 2, 3]\n\t  return Array.apply(null, { length: numberOfPages })\n\t    .map(function (val, index) { return index; })\n\t}\n\n\tfunction getClassesForLink(link, currentPage, lastPage, ref) {\n\t  var prev = ref.prev;\n\t  var next = ref.next;\n\n\t  var liClass = []\n\t  if (link === prev) {\n\t    liClass.push('left-arrow')\n\t  } else if (link === next) {\n\t    liClass.push('right-arrow')\n\t  } else if (link === ELLIPSES) {\n\t    liClass.push('ellipses')\n\t  } else {\n\t    liClass.push('number')\n\t  }\n\n\t  if (link === currentPage) {\n\t    liClass.push('active')\n\t  }\n\n\t  if (link === prev && currentPage <= 0) {\n\t    liClass.push('disabled')\n\t  } else if (link === next && currentPage >= lastPage) {\n\t    liClass.push('disabled')\n\t  }\n\t  return liClass\n\t}\n\n\tfunction getTargetPageForLink (link, limit, currentPage, listOfPages, ref, metaData) {\n\t  var prev = ref.prev;\n\t  var next = ref.next;\n\t  if ( metaData === void 0 ) metaData = null;\n\n\t  var currentChunk = Math.floor(currentPage / limit)\n\t  if (link === prev) {\n\t    return (currentPage - 1) < 0 ? 0 : currentPage - 1\n\t  } else if (link === next) {\n\t    return (currentPage + 1 > listOfPages.length - 1)\n\t      ? listOfPages.length - 1\n\t      : currentPage + 1\n\t  } else if (metaData && metaData === 'right-ellipses') {\n\t    return (currentChunk + 1) * limit\n\t  } else if (metaData && metaData === 'left-ellipses') {\n\t    var chunkContent = listOfPages.slice(currentChunk * limit, currentChunk * limit + limit)\n\t    var isLastPage = currentPage === listOfPages.length - 1\n\t    if (isLastPage && chunkContent.length === 1) {\n\t      currentChunk--\n\t    }\n\t    return (currentChunk - 1) * limit + limit - 1\n\t  }\n\t  // which is number\n\t  return link\n\t}\n\n\t/**\n\t * Mainly used here to check whether the displayed\n\t * ellipses is for showing previous or next links\n\t */\n\tfunction getLimitedLinksMetadata (limitedLinks) {\n\t  return limitedLinks.map(function (link, index) {\n\t    if (link === ELLIPSES && limitedLinks[index - 1] === 0) {\n\t      return 'left-ellipses'\n\t    } else if (link === ELLIPSES && limitedLinks[index - 1] !== 0) {\n\t      return 'right-ellipses'\n\t    }\n\t    return link\n\t  })\n\t}\n\n\tfunction addAdditionalClasses (linksContainer, classes) {\n\t  Object.keys(classes).forEach(function (selector) {\n\t    if (selector === 'ul') {\n\t      var selectorValue = classes['ul']\n\t      if (Array.isArray(selectorValue)) {\n\t        selectorValue.forEach(function (c) { return linksContainer.classList.add(c); })\n\t      } else {\n\t        linksContainer.classList.add(selectorValue)\n\t      }\n\t    }\n\t    linksContainer.querySelectorAll(selector).forEach(function (node) {\n\t      var selectorValue = classes[selector]\n\t      if (Array.isArray(selectorValue)) {\n\t        selectorValue.forEach(function (c) { return node.classList.add(c); })\n\t      } else {\n\t        node.classList.add(selectorValue)\n\t      }\n\t    })\n\t  })\n\t}\n\n\tfunction paginateDataGenerator (listNames) {\n\t  if ( listNames === void 0 ) listNames = [];\n\n\t  return listNames.reduce(function (curr, listName) {\n\t    curr[listName] = {\n\t      list: [],\n\t      page: 0\n\t    }\n\t    return curr\n\t  }, {})\n\t}\n\n\tvar vuePaginate = {}\n\n\tvuePaginate.install = function (Vue) {\n\t  Vue.mixin({\n\t    created: function created () {\n\t      if (this.paginate !== 'undefined' && this.paginate instanceof Array) {\n\t        this.paginate = paginateDataGenerator(this.paginate)\n\t      }\n\t    },\n\t    methods: {\n\t      paginated: function paginated (listName) {\n\t        if (!this.paginate || !this.paginate[listName]) {\n\t          warn((\"'\" + listName + \"' is not registered in 'paginate' array.\"), this)\n\t          return\n\t        }\n\t        return this.paginate[listName].list\n\t      }\n\t    }\n\t  })\n\t  Vue.component('paginate', Paginate)\n\t  Vue.component('paginate-links', PaginateLinks)\n\t}\n\n\tif (typeof window !== 'undefined' && window.Vue) {\n\t  window.Vue.use(vuePaginate)\n\t}\n\n\treturn vuePaginate;\n\n}));\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1wYWdpbmF0ZS9kaXN0L3Z1ZS1wYWdpbmF0ZS5qcz82YmM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdnVlLXBhZ2luYXRlIHYzLjQuMFxuICogKGMpIDIwMTcgVGFoYSBTaGFzaHRhcmlcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuVnVlUGFnaW5hdGUgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuXHR2YXIgd2FybiA9IGZ1bmN0aW9uICgpIHt9XG5cdHZhciBmb3JtYXRDb21wb25lbnROYW1lXG5cblx0dmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcblxuXHR3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0sIHR5cGUpIHtcblx0ICBpZiAoIHR5cGUgPT09IHZvaWQgMCApIHR5cGUgPSAnZXJyb3InO1xuXG5cdCAgaWYgKGhhc0NvbnNvbGUpIHtcblx0ICAgIGNvbnNvbGVbdHlwZV0oXCJbdnVlLXBhZ2luYXRlXTogXCIgKyBtc2cgKyBcIiBcIiArIChcblx0ICAgICAgdm0gPyBmb3JtYXRMb2NhdGlvbihmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgOiAnJ1xuXHQgICAgICApKVxuXHQgIH1cblx0fVxuXG5cdGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0pIHtcblx0ICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG5cdCAgICByZXR1cm4gJ3Jvb3QgaW5zdGFuY2UnXG5cdCAgfVxuXHQgIHZhciBuYW1lID0gdm0uX2lzVnVlXG5cdCAgPyB2bS4kb3B0aW9ucy5uYW1lIHx8IHZtLiRvcHRpb25zLl9jb21wb25lbnRUYWdcblx0ICA6IHZtLm5hbWVcblx0ICByZXR1cm4gKFxuXHQgICAgKG5hbWUgPyAoXCJjb21wb25lbnQgPFwiICsgbmFtZSArIFwiPlwiKSA6IFwiYW5vbnltb3VzIGNvbXBvbmVudFwiKSArXG5cdCAgICAodm0uX2lzVnVlICYmIHZtLiRvcHRpb25zLl9fZmlsZSA/IChcIiBhdCBcIiArICh2bS4kb3B0aW9ucy5fX2ZpbGUpKSA6ICcnKVxuXHQgICAgKVxuXHR9XG5cblx0dmFyIGZvcm1hdExvY2F0aW9uID0gZnVuY3Rpb24gKHN0cikge1xuXHQgIGlmIChzdHIgPT09ICdhbm9ueW1vdXMgY29tcG9uZW50Jykge1xuXHQgICAgc3RyICs9IFwiIC0gdXNlIHRoZSBcXFwibmFtZVxcXCIgb3B0aW9uIGZvciBiZXR0ZXIgZGVidWdnaW5nIG1lc3NhZ2VzLlwiXG5cdCAgfVxuXHQgIHJldHVybiAoXCJcXG4oZm91bmQgaW4gXCIgKyBzdHIgKyBcIilcIilcblx0fVxuXG5cdHZhciBQYWdpbmF0ZSA9IHtcblx0ICBuYW1lOiAncGFnaW5hdGUnLFxuXHQgIHByb3BzOiB7XG5cdCAgICBuYW1lOiB7XG5cdCAgICAgIHR5cGU6IFN0cmluZyxcblx0ICAgICAgcmVxdWlyZWQ6IHRydWVcblx0ICAgIH0sXG5cdCAgICBsaXN0OiB7XG5cdCAgICAgIHR5cGU6IEFycmF5LFxuXHQgICAgICByZXF1aXJlZDogdHJ1ZVxuXHQgICAgfSxcblx0ICAgIHBlcjoge1xuXHQgICAgICB0eXBlOiBOdW1iZXIsXG5cdCAgICAgIGRlZmF1bHQ6IDMsXG5cdCAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiB2YWx1ZSA+IDBcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHRhZzoge1xuXHQgICAgICB0eXBlOiBTdHJpbmcsXG5cdCAgICAgIGRlZmF1bHQ6ICd1bCdcblx0ICAgIH0sXG5cdCAgICBjbGFzczoge1xuXHQgICAgICB0eXBlOiBTdHJpbmdcblx0ICAgIH1cblx0ICB9LFxuXHQgIGRhdGE6IGZ1bmN0aW9uIGRhdGEgKCkge1xuXHQgICAgcmV0dXJuIHt9XG5cdCAgfSxcblx0ICBjb21wdXRlZDoge1xuXHQgICAgY3VycmVudFBhZ2U6IHtcblx0ICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuXHQgICAgICAgIGlmICh0aGlzLiRwYXJlbnQucGFnaW5hdGVbdGhpcy5uYW1lXSkge1xuXHQgICAgICAgICAgcmV0dXJuIHRoaXMuJHBhcmVudC5wYWdpbmF0ZVt0aGlzLm5hbWVdLnBhZ2Vcblx0ICAgICAgICB9XG5cdCAgICAgIH0sXG5cdCAgICAgIHNldDogZnVuY3Rpb24gc2V0IChwYWdlKSB7XG5cdCAgICAgICAgdGhpcy4kcGFyZW50LnBhZ2luYXRlW3RoaXMubmFtZV0ucGFnZSA9IHBhZ2Vcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCAoKSB7XG5cdCAgICBpZiAodGhpcy5wZXIgPD0gMCkge1xuXHQgICAgICB3YXJuKChcIjxwYWdpbmF0ZSBuYW1lPVxcXCJcIiArICh0aGlzLm5hbWUpICsgXCJcXFwiPiAncGVyJyBwcm9wIGNhbid0IGJlIDAgb3IgbGVzcy5cIiksIHRoaXMuJHBhcmVudClcblx0ICAgIH1cblx0ICAgIGlmICghdGhpcy4kcGFyZW50LnBhZ2luYXRlW3RoaXMubmFtZV0pIHtcblx0ICAgICAgd2FybigoXCInXCIgKyAodGhpcy5uYW1lKSArIFwiJyBpcyBub3QgcmVnaXN0ZXJlZCBpbiAncGFnaW5hdGUnIGFycmF5LlwiKSwgdGhpcy4kcGFyZW50KVxuXHQgICAgICByZXR1cm5cblx0ICAgIH1cblx0ICAgIHRoaXMucGFnaW5hdGVMaXN0KClcblx0ICB9LFxuXHQgIHdhdGNoOiB7XG5cdCAgICBjdXJyZW50UGFnZTogZnVuY3Rpb24gY3VycmVudFBhZ2UgKCkge1xuXHQgICAgICB0aGlzLnBhZ2luYXRlTGlzdCgpXG5cdCAgICB9LFxuXHQgICAgbGlzdDogZnVuY3Rpb24gbGlzdCAoKSB7XG5cdCAgICAgIC8vIE9uIGxpc3QgY2hhbmdlLCByZWZyZXNoIHRoZSBwYWdpbmF0ZWQgbGlzdFxuXHQgICAgICB0aGlzLmN1cnJlbnRQYWdlID0gMFxuXHQgICAgICB0aGlzLnBhZ2luYXRlTGlzdCgpXG5cdCAgICB9LFxuXHQgICAgcGVyOiBmdW5jdGlvbiBwZXIgKCkge1xuXHQgICAgICB0aGlzLmN1cnJlbnRQYWdlID0gMFxuXHQgICAgICB0aGlzLnBhZ2luYXRlTGlzdCgpXG5cdCAgICB9XG5cdCAgfSxcblx0ICBtZXRob2RzOiB7XG5cdCAgICBwYWdpbmF0ZUxpc3Q6IGZ1bmN0aW9uIHBhZ2luYXRlTGlzdCAoKSB7XG5cdCAgICAgIHZhciBpbmRleCA9IHRoaXMuY3VycmVudFBhZ2UgKiB0aGlzLnBlclxuXHQgICAgICB2YXIgcGFnaW5hdGVkTGlzdCA9IHRoaXMubGlzdC5zbGljZShpbmRleCwgaW5kZXggKyB0aGlzLnBlcilcblx0ICAgICAgdGhpcy4kcGFyZW50LnBhZ2luYXRlW3RoaXMubmFtZV0ubGlzdCA9IHBhZ2luYXRlZExpc3Rcblx0ICAgIH1cblx0ICB9LFxuXHQgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG5cdCAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5jbGFzcyA/IHRoaXMuY2xhc3MgOiAnJ1xuXHQgICAgcmV0dXJuIGgodGhpcy50YWcsIHsgY2xhc3M6IGNsYXNzTmFtZSB9LCB0aGlzLiRzbG90cy5kZWZhdWx0KVxuXHQgIH1cblx0fVxuXG5cdHZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cblx0LyogICovXG5cblx0LyoqXG5cdCAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuXHQgKi9cblx0ZnVuY3Rpb24gX3RvU3RyaW5nICh2YWwpIHtcblx0ICByZXR1cm4gdmFsID09IG51bGxcblx0ICAgID8gJydcblx0ICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcblx0ICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG5cdCAgICAgIDogU3RyaW5nKHZhbClcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuXHQgKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcblx0ICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsLCAxMCk7XG5cdCAgcmV0dXJuIChuIHx8IG4gPT09IDApID8gbiA6IHZhbFxuXHR9XG5cblx0LyoqXG5cdCAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuXHQgKiBpcyBpbiB0aGF0IG1hcC5cblx0ICovXG5cdGZ1bmN0aW9uIG1ha2VNYXAgKFxuXHQgIHN0cixcblx0ICBleHBlY3RzTG93ZXJDYXNlXG5cdCkge1xuXHQgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHQgIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuXHQgIH1cblx0ICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuXHQgICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG5cdCAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG5cdCAqL1xuXHR2YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuXHQvKipcblx0ICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuXHQgKi9cblx0ZnVuY3Rpb24gcmVtb3ZlJDEgKGFyciwgaXRlbSkge1xuXHQgIGlmIChhcnIubGVuZ3RoKSB7XG5cdCAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcblx0ICAgIGlmIChpbmRleCA+IC0xKSB7XG5cdCAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cblx0ICovXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdGZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcblx0ICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcblx0ICovXG5cdGZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuXHQgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG5cdCAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0ICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcblx0ICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuXHQgICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG5cdCAgfSlcblx0fVxuXG5cdC8qKlxuXHQgKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxtaXRlZCBzdHJpbmcuXG5cdCAqL1xuXHR2YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcblx0dmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcblx0ICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcblx0fSk7XG5cblx0LyoqXG5cdCAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG5cdCAqL1xuXHR2YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG5cdCAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxuXHR9KTtcblxuXHQvKipcblx0ICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cblx0ICovXG5cdHZhciBoeXBoZW5hdGVSRSA9IC8oW14tXSkoW0EtWl0pL2c7XG5cdHZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuXHQgIHJldHVybiBzdHJcblx0ICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuXHQgICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG5cdCAgICAudG9Mb3dlckNhc2UoKVxuXHR9KTtcblxuXHQvKipcblx0ICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYmluZCQxIChmbiwgY3R4KSB7XG5cdCAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuXHQgICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHQgICAgcmV0dXJuIGxcblx0ICAgICAgPyBsID4gMVxuXHQgICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG5cdCAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcblx0ICAgICAgOiBmbi5jYWxsKGN0eClcblx0ICB9XG5cdCAgLy8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxuXHQgIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcblx0ICByZXR1cm4gYm91bmRGblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcblx0ICBzdGFydCA9IHN0YXJ0IHx8IDA7XG5cdCAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuXHQgIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG5cdCAgd2hpbGUgKGktLSkge1xuXHQgICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuXHQgIH1cblx0ICByZXR1cm4gcmV0XG5cdH1cblxuXHQvKipcblx0ICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuXHQgKi9cblx0ZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcblx0ICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcblx0ICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuXHQgIH1cblx0ICByZXR1cm4gdG9cblx0fVxuXG5cdC8qKlxuXHQgKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcblx0ICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuXHQgKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG5cdCAqL1xuXHRmdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG5cdCAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcblx0ICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cblx0ICovXG5cdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdHZhciBPQkpFQ1RfU1RSSU5HID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cdGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuXHQgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9TVFJJTkdcblx0fVxuXG5cdC8qKlxuXHQgKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuXHQgIHZhciByZXMgPSB7fTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKGFycltpXSkge1xuXHQgICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzXG5cdH1cblxuXHQvKipcblx0ICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBub29wICgpIHt9XG5cblx0LyoqXG5cdCAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG5cdCAqL1xuXHR2YXIgbm8gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcblxuXHQvKipcblx0ICogUmV0dXJuIHNhbWUgdmFsdWVcblx0ICovXG5cdHZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG5cdCAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XG5cdCAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuXHQgIH0sIFtdKS5qb2luKCcsJylcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcblx0ICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuXHQgKi9cblx0ZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuXHQgIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcblx0ICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG5cdCAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcblx0ICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYilcblx0ICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuXHQgICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiBmYWxzZVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cblx0ICB9XG5cdCAgcmV0dXJuIC0xXG5cdH1cblxuXHQvKiAgKi9cblxuXHR2YXIgY29uZmlnID0ge1xuXHQgIC8qKlxuXHQgICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuXHQgICAqL1xuXHQgIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuXHQgIC8qKlxuXHQgICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG5cdCAgICovXG5cdCAgc2lsZW50OiBmYWxzZSxcblxuXHQgIC8qKlxuXHQgICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG5cdCAgICovXG5cdCAgZGV2dG9vbHM6IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicsXG5cblx0ICAvKipcblx0ICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuXHQgICAqL1xuXHQgIGVycm9ySGFuZGxlcjogbnVsbCxcblxuXHQgIC8qKlxuXHQgICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuXHQgICAqL1xuXHQgIGlnbm9yZWRFbGVtZW50czogW10sXG5cblx0ICAvKipcblx0ICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuXHQgICAqL1xuXHQgIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG5cdCAgLyoqXG5cdCAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG5cdCAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuXHQgICAqL1xuXHQgIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG5cdCAgLyoqXG5cdCAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuXHQgICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cblx0ICAgKi9cblx0ICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuXHQgIC8qKlxuXHQgICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcblx0ICAgKi9cblx0ICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cblx0ICAvKipcblx0ICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuXHQgICAqL1xuXHQgIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuXHQgIC8qKlxuXHQgICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG5cdCAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuXHQgICAqL1xuXHQgIG11c3RVc2VQcm9wOiBubyxcblxuXHQgIC8qKlxuXHQgICAqIExpc3Qgb2YgYXNzZXQgdHlwZXMgdGhhdCBhIGNvbXBvbmVudCBjYW4gb3duLlxuXHQgICAqL1xuXHQgIF9hc3NldFR5cGVzOiBbXG5cdCAgICAnY29tcG9uZW50Jyxcblx0ICAgICdkaXJlY3RpdmUnLFxuXHQgICAgJ2ZpbHRlcidcblx0ICBdLFxuXG5cdCAgLyoqXG5cdCAgICogTGlzdCBvZiBsaWZlY3ljbGUgaG9va3MuXG5cdCAgICovXG5cdCAgX2xpZmVjeWNsZUhvb2tzOiBbXG5cdCAgICAnYmVmb3JlQ3JlYXRlJyxcblx0ICAgICdjcmVhdGVkJyxcblx0ICAgICdiZWZvcmVNb3VudCcsXG5cdCAgICAnbW91bnRlZCcsXG5cdCAgICAnYmVmb3JlVXBkYXRlJyxcblx0ICAgICd1cGRhdGVkJyxcblx0ICAgICdiZWZvcmVEZXN0cm95Jyxcblx0ICAgICdkZXN0cm95ZWQnLFxuXHQgICAgJ2FjdGl2YXRlZCcsXG5cdCAgICAnZGVhY3RpdmF0ZWQnXG5cdCAgXSxcblxuXHQgIC8qKlxuXHQgICAqIE1heCBjaXJjdWxhciB1cGRhdGVzIGFsbG93ZWQgaW4gYSBzY2hlZHVsZXIgZmx1c2ggY3ljbGUuXG5cdCAgICovXG5cdCAgX21heFVwZGF0ZUNvdW50OiAxMDBcblx0fTtcblxuXHQvKiAgKi9cblxuXHQvKipcblx0ICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG5cdCAqL1xuXHRmdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcblx0ICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcblx0ICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG5cdH1cblxuXHQvKipcblx0ICogRGVmaW5lIGEgcHJvcGVydHkuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcblx0ICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcblx0ICAgIHZhbHVlOiB2YWwsXG5cdCAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG5cdCAgICB3cml0YWJsZTogdHJ1ZSxcblx0ICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgIH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuXHQgKi9cblx0dmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XG5cdGZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuXHQgIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuXHQgICAgcmV0dXJuXG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuXHQgICAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG9ialxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdC8qICAqL1xuXHQvKiBnbG9iYWxzIE11dGF0aW9uT2JzZXJ2ZXIgKi9cblxuXHQvLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cblx0dmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cblx0Ly8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xuXHR2YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cdHZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuXHR2YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xuXHR2YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcblx0dmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xuXHR2YXIgaXNBbmRyb2lkID0gVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMDtcblx0dmFyIGlzSU9TID0gVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKTtcblxuXHQvLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcblx0Ly8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcblx0dmFyIF9pc1NlcnZlcjtcblx0dmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdCAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgY29tbW9uanNHbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuXHQgICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG5cdCAgICAgIF9pc1NlcnZlciA9IGNvbW1vbmpzR2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBfaXNTZXJ2ZXJcblx0fTtcblxuXHQvLyBkZXRlY3QgZGV2dG9vbHNcblx0dmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdGZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG5cdCAgcmV0dXJuIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG5cdH1cblxuXHQvKipcblx0ICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuXG5cdCAqL1xuXHR2YXIgbmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuXHQgIHZhciBjYWxsYmFja3MgPSBbXTtcblx0ICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuXHQgIHZhciB0aW1lckZ1bmM7XG5cblx0ICBmdW5jdGlvbiBuZXh0VGlja0hhbmRsZXIgKCkge1xuXHQgICAgcGVuZGluZyA9IGZhbHNlO1xuXHQgICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcblx0ICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgY29waWVzW2ldKCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gdGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcblx0ICAvLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cblx0ICAvLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cblx0ICAvLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuXHQgIC8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcblx0ICAvLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG5cdCAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdCAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuXHQgICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcblx0ICAgIHZhciBsb2dFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB9O1xuXHQgICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICBwLnRoZW4obmV4dFRpY2tIYW5kbGVyKS5jYXRjaChsb2dFcnJvcik7XG5cdCAgICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuXHQgICAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcblx0ICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcblx0ICAgICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG5cdCAgICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuXHQgICAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuXHQgICAgfTtcblx0ICB9IGVsc2UgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG5cdCAgICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuXHQgICAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG5cdCAgICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG5cdCAgKSkge1xuXHQgICAgLy8gdXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcblx0ICAgIC8vIGUuZy4gUGhhbnRvbUpTIElFMTEsIGlPUzcsIEFuZHJvaWQgNC40XG5cdCAgICB2YXIgY291bnRlciA9IDE7XG5cdCAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihuZXh0VGlja0hhbmRsZXIpO1xuXHQgICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcblx0ICAgIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcblx0ICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcblx0ICAgICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcblx0ICAgIH07XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIGZhbGxiYWNrIHRvIHNldFRpbWVvdXRcblx0ICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdCAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHNldFRpbWVvdXQobmV4dFRpY2tIYW5kbGVyLCAwKTtcblx0ICAgIH07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGZ1bmN0aW9uIHF1ZXVlTmV4dFRpY2sgKGNiLCBjdHgpIHtcblx0ICAgIHZhciBfcmVzb2x2ZTtcblx0ICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKGNiKSB7IGNiLmNhbGwoY3R4KTsgfVxuXHQgICAgICBpZiAoX3Jlc29sdmUpIHsgX3Jlc29sdmUoY3R4KTsgfVxuXHQgICAgfSk7XG5cdCAgICBpZiAoIXBlbmRpbmcpIHtcblx0ICAgICAgcGVuZGluZyA9IHRydWU7XG5cdCAgICAgIHRpbWVyRnVuYygpO1xuXHQgICAgfVxuXHQgICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdCAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuXHQgICAgICB9KVxuXHQgICAgfVxuXHQgIH1cblx0fSkoKTtcblxuXHR2YXIgX1NldDtcblx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdGlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG5cdCAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG5cdCAgX1NldCA9IFNldDtcblx0fSBlbHNlIHtcblx0ICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG5cdCAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBTZXQgKCkge1xuXHQgICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdCAgICB9XG5cdCAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG5cdCAgICB9O1xuXHQgICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuXHQgICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcblx0ICAgIH07XG5cdCAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuXHQgICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdCAgICB9O1xuXG5cdCAgICByZXR1cm4gU2V0O1xuXHQgIH0oKSk7XG5cdH1cblxuXHR2YXIgd2FybiQxID0gbm9vcDtcblx0dmFyIGZvcm1hdENvbXBvbmVudE5hbWUkMTtcblxuXHQvKiAgKi9cblxuXG5cdHZhciB1aWQkMSA9IDA7XG5cblx0LyoqXG5cdCAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuXHQgKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuXHQgKi9cblx0dmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG5cdCAgdGhpcy5pZCA9IHVpZCQxKys7XG5cdCAgdGhpcy5zdWJzID0gW107XG5cdH07XG5cblx0RGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuXHQgIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG5cdH07XG5cblx0RGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuXHQgIHJlbW92ZSQxKHRoaXMuc3Vicywgc3ViKTtcblx0fTtcblxuXHREZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG5cdCAgaWYgKERlcC50YXJnZXQpIHtcblx0ICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuXHQgIH1cblx0fTtcblxuXHREZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG5cdCAgLy8gc3RhYmxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuXHQgIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG5cdCAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHQgICAgc3Vic1tpXS51cGRhdGUoKTtcblx0ICB9XG5cdH07XG5cblx0Ly8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuXHQvLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG5cdC8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuXHREZXAudGFyZ2V0ID0gbnVsbDtcblx0dmFyIHRhcmdldFN0YWNrID0gW107XG5cblx0ZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuXHQgIGlmIChEZXAudGFyZ2V0KSB7IHRhcmdldFN0YWNrLnB1c2goRGVwLnRhcmdldCk7IH1cblx0ICBEZXAudGFyZ2V0ID0gX3RhcmdldDtcblx0fVxuXG5cdGZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG5cdCAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrLnBvcCgpO1xuXHR9XG5cblx0Lypcblx0ICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG5cdCAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuXHQgKi9cblxuXHR2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblx0dmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuXHQgICdwdXNoJyxcblx0ICAncG9wJyxcblx0ICAnc2hpZnQnLFxuXHQgICd1bnNoaWZ0Jyxcblx0ICAnc3BsaWNlJyxcblx0ICAnc29ydCcsXG5cdCAgJ3JldmVyc2UnXG5cdF1cblx0LmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuXHQgIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuXHQgIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcblx0ICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuXHQgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG5cdCAgICAvLyBhdm9pZCBsZWFraW5nIGFyZ3VtZW50czpcblx0ICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcblx0ICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aDtcblx0ICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGkpO1xuXHQgICAgd2hpbGUgKGktLSkge1xuXHQgICAgICBhcmdzW2ldID0gYXJndW1lbnRzJDFbaV07XG5cdCAgICB9XG5cdCAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG5cdCAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcblx0ICAgIHZhciBpbnNlcnRlZDtcblx0ICAgIHN3aXRjaCAobWV0aG9kKSB7XG5cdCAgICAgIGNhc2UgJ3B1c2gnOlxuXHQgICAgICAgIGluc2VydGVkID0gYXJncztcblx0ICAgICAgICBicmVha1xuXHQgICAgICBjYXNlICd1bnNoaWZ0Jzpcblx0ICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG5cdCAgICAgICAgYnJlYWtcblx0ICAgICAgY2FzZSAnc3BsaWNlJzpcblx0ICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG5cdCAgICAgICAgYnJlYWtcblx0ICAgIH1cblx0ICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG5cdCAgICAvLyBub3RpZnkgY2hhbmdlXG5cdCAgICBvYi5kZXAubm90aWZ5KCk7XG5cdCAgICByZXR1cm4gcmVzdWx0XG5cdCAgfSk7XG5cdH0pO1xuXG5cdC8qICAqL1xuXG5cdHZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG5cdC8qKlxuXHQgKiBCeSBkZWZhdWx0LCB3aGVuIGEgcmVhY3RpdmUgcHJvcGVydHkgaXMgc2V0LCB0aGUgbmV3IHZhbHVlIGlzXG5cdCAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciB3aGVuIHBhc3NpbmcgZG93biBwcm9wcyxcblx0ICogd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBjb252ZXJzaW9uIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZVxuXHQgKiB1bmRlciBhIGZyb3plbiBkYXRhIHN0cnVjdHVyZS4gQ29udmVydGluZyBpdCB3b3VsZCBkZWZlYXQgdGhlIG9wdGltaXphdGlvbi5cblx0ICovXG5cdHZhciBvYnNlcnZlclN0YXRlID0ge1xuXHQgIHNob3VsZENvbnZlcnQ6IHRydWUsXG5cdCAgaXNTZXR0aW5nUHJvcHM6IGZhbHNlXG5cdH07XG5cblx0LyoqXG5cdCAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcblx0ICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG5cdCAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG5cdCAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG5cdCAqL1xuXHR2YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcblx0ICB0aGlzLnZhbHVlID0gdmFsdWU7XG5cdCAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG5cdCAgdGhpcy52bUNvdW50ID0gMDtcblx0ICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcblx0ICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG9cblx0ICAgICAgPyBwcm90b0F1Z21lbnRcblx0ICAgICAgOiBjb3B5QXVnbWVudDtcblx0ICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcblx0ICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy53YWxrKHZhbHVlKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuXHQgKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cblx0ICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG5cdCAqL1xuXHRPYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuXHQgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuXHQgKi9cblx0T2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHQgICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG5cdCAgfVxuXHR9O1xuXG5cdC8vIGhlbHBlcnNcblxuXHQvKipcblx0ICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuXHQgKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuXHQgKi9cblx0ZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuXHQgIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cdCAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcblx0ICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG5cdH1cblxuXHQvKipcblx0ICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG5cdCAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG5cdCAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHQgICAgdmFyIGtleSA9IGtleXNbaV07XG5cdCAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG5cdCAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG5cdCAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuXHQgKi9cblx0ZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcblx0ICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuXHQgICAgcmV0dXJuXG5cdCAgfVxuXHQgIHZhciBvYjtcblx0ICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcblx0ICAgIG9iID0gdmFsdWUuX19vYl9fO1xuXHQgIH0gZWxzZSBpZiAoXG5cdCAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgJiZcblx0ICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG5cdCAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG5cdCAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuXHQgICAgIXZhbHVlLl9pc1Z1ZVxuXHQgICkge1xuXHQgICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuXHQgIH1cblx0ICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuXHQgICAgb2Iudm1Db3VudCsrO1xuXHQgIH1cblx0ICByZXR1cm4gb2Jcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG5cdCAgb2JqLFxuXHQgIGtleSxcblx0ICB2YWwsXG5cdCAgY3VzdG9tU2V0dGVyXG5cdCkge1xuXHQgIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cblx0ICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcblx0ICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuXHQgICAgcmV0dXJuXG5cdCAgfVxuXG5cdCAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG5cdCAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcblx0ICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG5cdCAgdmFyIGNoaWxkT2IgPSBvYnNlcnZlKHZhbCk7XG5cdCAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG5cdCAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG5cdCAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG5cdCAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG5cdCAgICAgICAgZGVwLmRlcGVuZCgpO1xuXHQgICAgICAgIGlmIChjaGlsZE9iKSB7XG5cdCAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB2YWx1ZVxuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuXHQgICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuXHQgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cblx0ICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcblx0ICAgICAgICByZXR1cm5cblx0ICAgICAgfVxuXHQgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuXHQgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHt9XG5cdCAgICAgIGlmIChzZXR0ZXIpIHtcblx0ICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFsID0gbmV3VmFsO1xuXHQgICAgICB9XG5cdCAgICAgIGNoaWxkT2IgPSBvYnNlcnZlKG5ld1ZhbCk7XG5cdCAgICAgIGRlcC5ub3RpZnkoKTtcblx0ICAgIH1cblx0ICB9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcblx0ICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuXHQgKiBhbHJlYWR5IGV4aXN0LlxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0JDEgKG9iaiwga2V5LCB2YWwpIHtcblx0ICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG5cdCAgICBvYmoubGVuZ3RoID0gTWF0aC5tYXgob2JqLmxlbmd0aCwga2V5KTtcblx0ICAgIG9iai5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuXHQgICAgcmV0dXJuIHZhbFxuXHQgIH1cblx0ICBpZiAoaGFzT3duKG9iaiwga2V5KSkge1xuXHQgICAgb2JqW2tleV0gPSB2YWw7XG5cdCAgICByZXR1cm5cblx0ICB9XG5cdCAgdmFyIG9iID0gb2JqLl9fb2JfXztcblx0ICBpZiAob2JqLl9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcblx0ICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQxKFxuXHQgICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG5cdCAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG5cdCAgICApO1xuXHQgICAgcmV0dXJuXG5cdCAgfVxuXHQgIGlmICghb2IpIHtcblx0ICAgIG9ialtrZXldID0gdmFsO1xuXHQgICAgcmV0dXJuXG5cdCAgfVxuXHQgIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG5cdCAgb2IuZGVwLm5vdGlmeSgpO1xuXHQgIHJldHVybiB2YWxcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVsIChvYmosIGtleSkge1xuXHQgIHZhciBvYiA9IG9iai5fX29iX187XG5cdCAgaWYgKG9iai5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG5cdCAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMShcblx0ICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG5cdCAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuXHQgICAgKTtcblx0ICAgIHJldHVyblxuXHQgIH1cblx0ICBpZiAoIWhhc093bihvYmosIGtleSkpIHtcblx0ICAgIHJldHVyblxuXHQgIH1cblx0ICBkZWxldGUgb2JqW2tleV07XG5cdCAgaWYgKCFvYikge1xuXHQgICAgcmV0dXJuXG5cdCAgfVxuXHQgIG9iLmRlcC5ub3RpZnkoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuXHQgKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuXHQgIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0ICAgIGUgPSB2YWx1ZVtpXTtcblx0ICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcblx0ICAgICAgZGVwZW5kQXJyYXkoZSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0LyogICovXG5cblx0LyoqXG5cdCAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcblx0ICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cblx0ICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG5cdCAqL1xuXHR2YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuXHQvKipcblx0ICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG5cdCAqL1xuXHRmdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG5cdCAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG5cdCAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG5cdCAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIGtleSA9IGtleXNbaV07XG5cdCAgICB0b1ZhbCA9IHRvW2tleV07XG5cdCAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuXHQgICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcblx0ICAgICAgc2V0JDEodG8sIGtleSwgZnJvbVZhbCk7XG5cdCAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodG9WYWwpICYmIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcblx0ICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHRvXG5cdH1cblxuXHQvKipcblx0ICogRGF0YVxuXHQgKi9cblx0c3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG5cdCAgcGFyZW50VmFsLFxuXHQgIGNoaWxkVmFsLFxuXHQgIHZtXG5cdCkge1xuXHQgIGlmICghdm0pIHtcblx0ICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG5cdCAgICBpZiAoIWNoaWxkVmFsKSB7XG5cdCAgICAgIHJldHVybiBwYXJlbnRWYWxcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDEoXG5cdCAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG5cdCAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG5cdCAgICAgICAgJ2RlZmluaXRpb25zLicsXG5cdCAgICAgICAgdm1cblx0ICAgICAgKTtcblx0ICAgICAgcmV0dXJuIHBhcmVudFZhbFxuXHQgICAgfVxuXHQgICAgaWYgKCFwYXJlbnRWYWwpIHtcblx0ICAgICAgcmV0dXJuIGNoaWxkVmFsXG5cdCAgICB9XG5cdCAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG5cdCAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcblx0ICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuXHQgICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG5cdCAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cblx0ICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuXHQgICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuXHQgICAgICAgIGNoaWxkVmFsLmNhbGwodGhpcyksXG5cdCAgICAgICAgcGFyZW50VmFsLmNhbGwodGhpcylcblx0ICAgICAgKVxuXHQgICAgfVxuXHQgIH0gZWxzZSBpZiAocGFyZW50VmFsIHx8IGNoaWxkVmFsKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuXHQgICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuXHQgICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG5cdCAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtKVxuXHQgICAgICAgIDogY2hpbGRWYWw7XG5cdCAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcblx0ICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtKVxuXHQgICAgICAgIDogdW5kZWZpbmVkO1xuXHQgICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG5cdCAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBIb29rcyBhbmQgcGFyYW0gYXR0cmlidXRlcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cblx0ICovXG5cdGZ1bmN0aW9uIG1lcmdlSG9vayAoXG5cdCAgcGFyZW50VmFsLFxuXHQgIGNoaWxkVmFsXG5cdCkge1xuXHQgIHJldHVybiBjaGlsZFZhbFxuXHQgICAgPyBwYXJlbnRWYWxcblx0ICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuXHQgICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG5cdCAgICAgICAgPyBjaGlsZFZhbFxuXHQgICAgICAgIDogW2NoaWxkVmFsXVxuXHQgICAgOiBwYXJlbnRWYWxcblx0fVxuXG5cdGNvbmZpZy5fbGlmZWN5Y2xlSG9va3MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuXHQgIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcblx0fSk7XG5cblx0LyoqXG5cdCAqIEFzc2V0c1xuXHQgKlxuXHQgKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG5cdCAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2Vcblx0ICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG5cdCAqL1xuXHRmdW5jdGlvbiBtZXJnZUFzc2V0cyAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuXHQgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcblx0ICByZXR1cm4gY2hpbGRWYWxcblx0ICAgID8gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG5cdCAgICA6IHJlc1xuXHR9XG5cblx0Y29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcblx0ICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcblx0fSk7XG5cblx0LyoqXG5cdCAqIFdhdGNoZXJzLlxuXHQgKlxuXHQgKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG5cdCAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuXHQgKi9cblx0c3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcblx0ICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBwYXJlbnRWYWwgfVxuXHQgIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG5cdCAgdmFyIHJldCA9IHt9O1xuXHQgIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG5cdCAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG5cdCAgICB2YXIgcGFyZW50ID0gcmV0W2tleV07XG5cdCAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuXHQgICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG5cdCAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuXHQgICAgfVxuXHQgICAgcmV0W2tleV0gPSBwYXJlbnRcblx0ICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuXHQgICAgICA6IFtjaGlsZF07XG5cdCAgfVxuXHQgIHJldHVybiByZXRcblx0fTtcblxuXHQvKipcblx0ICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cblx0ICovXG5cdHN0cmF0cy5wcm9wcyA9XG5cdHN0cmF0cy5tZXRob2RzID1cblx0c3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcblx0ICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBwYXJlbnRWYWwgfVxuXHQgIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG5cdCAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdCAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcblx0ICBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG5cdCAgcmV0dXJuIHJldFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZWZhdWx0IHN0cmF0ZWd5LlxuXHQgKi9cblx0dmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG5cdCAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcblx0ICAgID8gcGFyZW50VmFsXG5cdCAgICA6IGNoaWxkVmFsXG5cdH07XG5cblx0LyoqXG5cdCAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuXHQgKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuXHQgKi9cblx0ZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMpIHtcblx0ICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuXHQgIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cblx0ICB2YXIgcmVzID0ge307XG5cdCAgdmFyIGksIHZhbCwgbmFtZTtcblx0ICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcblx0ICAgIGkgPSBwcm9wcy5sZW5ndGg7XG5cdCAgICB3aGlsZSAoaS0tKSB7XG5cdCAgICAgIHZhbCA9IHByb3BzW2ldO1xuXHQgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcblx0ICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcblx0ICAgICAgfSBlbHNlIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7fVxuXHQgICAgfVxuXHQgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcblx0ICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuXHQgICAgICB2YWwgPSBwcm9wc1trZXldO1xuXHQgICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcblx0ICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG5cdCAgICAgICAgPyB2YWxcblx0ICAgICAgICA6IHsgdHlwZTogdmFsIH07XG5cdCAgICB9XG5cdCAgfVxuXHQgIG9wdGlvbnMucHJvcHMgPSByZXM7XG5cdH1cblxuXHQvKipcblx0ICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cblx0ICovXG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcblx0ICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcblx0ICBpZiAoZGlycykge1xuXHQgICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcblx0ICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcblx0ICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG5cdCAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuXHQgIHBhcmVudCxcblx0ICBjaGlsZCxcblx0ICB2bVxuXHQpIHtcblx0ICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge31cblx0ICBub3JtYWxpemVQcm9wcyhjaGlsZCk7XG5cdCAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG5cdCAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcblx0ICBpZiAoZXh0ZW5kc0Zyb20pIHtcblx0ICAgIHBhcmVudCA9IHR5cGVvZiBleHRlbmRzRnJvbSA9PT0gJ2Z1bmN0aW9uJ1xuXHQgICAgICA/IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLm9wdGlvbnMsIHZtKVxuXHQgICAgICA6IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG5cdCAgfVxuXHQgIGlmIChjaGlsZC5taXhpbnMpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHQgICAgICB2YXIgbWl4aW4gPSBjaGlsZC5taXhpbnNbaV07XG5cdCAgICAgIGlmIChtaXhpbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBWdWUkMikge1xuXHQgICAgICAgIG1peGluID0gbWl4aW4ub3B0aW9ucztcblx0ICAgICAgfVxuXHQgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBtaXhpbiwgdm0pO1xuXHQgICAgfVxuXHQgIH1cblx0ICB2YXIgb3B0aW9ucyA9IHt9O1xuXHQgIHZhciBrZXk7XG5cdCAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG5cdCAgICBtZXJnZUZpZWxkKGtleSk7XG5cdCAgfVxuXHQgIGZvciAoa2V5IGluIGNoaWxkKSB7XG5cdCAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcblx0ICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuXHQgICAgfVxuXHQgIH1cblx0ICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcblx0ICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcblx0ICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcblx0ICB9XG5cdCAgcmV0dXJuIG9wdGlvbnNcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNvbHZlIGFuIGFzc2V0LlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3Ncblx0ICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuXHQgKi9cblx0ZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcblx0ICBvcHRpb25zLFxuXHQgIHR5cGUsXG5cdCAgaWQsXG5cdCAgd2Fybk1pc3Npbmdcblx0KSB7XG5cdCAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdCAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVyblxuXHQgIH1cblx0ICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcblx0ICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuXHQgIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuXHQgIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcblx0ICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cblx0ICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG5cdCAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cblx0ICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cblx0ICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuXHQgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHt9XG5cdCAgcmV0dXJuIHJlc1xuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcblx0ICBrZXksXG5cdCAgcHJvcE9wdGlvbnMsXG5cdCAgcHJvcHNEYXRhLFxuXHQgIHZtXG5cdCkge1xuXHQgIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcblx0ICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG5cdCAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG5cdCAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcblx0ICBpZiAoaXNUeXBlKEJvb2xlYW4sIHByb3AudHlwZSkpIHtcblx0ICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG5cdCAgICAgIHZhbHVlID0gZmFsc2U7XG5cdCAgICB9IGVsc2UgaWYgKCFpc1R5cGUoU3RyaW5nLCBwcm9wLnR5cGUpICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuXHQgICAgICB2YWx1ZSA9IHRydWU7XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcblx0ICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuXHQgICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuXHQgICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG5cdCAgICB2YXIgcHJldlNob3VsZENvbnZlcnQgPSBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQ7XG5cdCAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuXHQgICAgb2JzZXJ2ZSh2YWx1ZSk7XG5cdCAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBwcmV2U2hvdWxkQ29udmVydDtcblx0ICB9XG5cdCAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHt9XG5cdCAgcmV0dXJuIHZhbHVlXG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cblx0ICovXG5cdGZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcblx0ICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG5cdCAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuXHQgICAgcmV0dXJuIHVuZGVmaW5lZFxuXHQgIH1cblx0ICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuXHQgIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcblx0ICBpZiAoaXNPYmplY3QoZGVmKSkge1xuXHQgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDEoXG5cdCAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcblx0ICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuXHQgICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG5cdCAgICAgIHZtXG5cdCAgICApO1xuXHQgIH1cblx0ICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuXHQgIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuXHQgIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcblx0ICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcblx0ICAgIHZtW2tleV0gIT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuIHZtW2tleV1cblx0ICB9XG5cdCAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcblx0ICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wLnR5cGUgIT09IEZ1bmN0aW9uXG5cdCAgICA/IGRlZi5jYWxsKHZtKVxuXHQgICAgOiBkZWZcblx0fVxuXG5cdC8qKlxuXHQgKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG5cdCAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuXHQgKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRUeXBlIChmbikge1xuXHQgIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG5cdCAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdXG5cdH1cblxuXHRmdW5jdGlvbiBpc1R5cGUgKHR5cGUsIGZuKSB7XG5cdCAgaWYgKCFBcnJheS5pc0FycmF5KGZuKSkge1xuXHQgICAgcmV0dXJuIGdldFR5cGUoZm4pID09PSBnZXRUeXBlKHR5cGUpXG5cdCAgfVxuXHQgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgaWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG5cdCAgICAgIHJldHVybiB0cnVlXG5cdCAgICB9XG5cdCAgfVxuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdCAgcmV0dXJuIGZhbHNlXG5cdH1cblxuXG5cblx0dmFyIHV0aWwgPSBPYmplY3QuZnJlZXplKHtcblx0XHRkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDEsXG5cdFx0X3RvU3RyaW5nOiBfdG9TdHJpbmcsXG5cdFx0dG9OdW1iZXI6IHRvTnVtYmVyLFxuXHRcdG1ha2VNYXA6IG1ha2VNYXAsXG5cdFx0aXNCdWlsdEluVGFnOiBpc0J1aWx0SW5UYWcsXG5cdFx0cmVtb3ZlOiByZW1vdmUkMSxcblx0XHRoYXNPd246IGhhc093bixcblx0XHRpc1ByaW1pdGl2ZTogaXNQcmltaXRpdmUsXG5cdFx0Y2FjaGVkOiBjYWNoZWQsXG5cdFx0Y2FtZWxpemU6IGNhbWVsaXplLFxuXHRcdGNhcGl0YWxpemU6IGNhcGl0YWxpemUsXG5cdFx0aHlwaGVuYXRlOiBoeXBoZW5hdGUsXG5cdFx0YmluZDogYmluZCQxLFxuXHRcdHRvQXJyYXk6IHRvQXJyYXksXG5cdFx0ZXh0ZW5kOiBleHRlbmQsXG5cdFx0aXNPYmplY3Q6IGlzT2JqZWN0LFxuXHRcdGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG5cdFx0dG9PYmplY3Q6IHRvT2JqZWN0LFxuXHRcdG5vb3A6IG5vb3AsXG5cdFx0bm86IG5vLFxuXHRcdGlkZW50aXR5OiBpZGVudGl0eSxcblx0XHRnZW5TdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzLFxuXHRcdGxvb3NlRXF1YWw6IGxvb3NlRXF1YWwsXG5cdFx0bG9vc2VJbmRleE9mOiBsb29zZUluZGV4T2YsXG5cdFx0aXNSZXNlcnZlZDogaXNSZXNlcnZlZCxcblx0XHRkZWY6IGRlZixcblx0XHRwYXJzZVBhdGg6IHBhcnNlUGF0aCxcblx0XHRoYXNQcm90bzogaGFzUHJvdG8sXG5cdFx0aW5Ccm93c2VyOiBpbkJyb3dzZXIsXG5cdFx0VUE6IFVBLFxuXHRcdGlzSUU6IGlzSUUsXG5cdFx0aXNJRTk6IGlzSUU5LFxuXHRcdGlzRWRnZTogaXNFZGdlLFxuXHRcdGlzQW5kcm9pZDogaXNBbmRyb2lkLFxuXHRcdGlzSU9TOiBpc0lPUyxcblx0XHRpc1NlcnZlclJlbmRlcmluZzogaXNTZXJ2ZXJSZW5kZXJpbmcsXG5cdFx0ZGV2dG9vbHM6IGRldnRvb2xzLFxuXHRcdG5leHRUaWNrOiBuZXh0VGljayxcblx0XHRnZXQgX1NldCAoKSB7IHJldHVybiBfU2V0OyB9LFxuXHRcdG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuXHRcdHJlc29sdmVBc3NldDogcmVzb2x2ZUFzc2V0LFxuXHRcdGdldCB3YXJuICgpIHsgcmV0dXJuIHdhcm4kMTsgfSxcblx0XHRnZXQgZm9ybWF0Q29tcG9uZW50TmFtZSAoKSB7IHJldHVybiBmb3JtYXRDb21wb25lbnROYW1lJDE7IH0sXG5cdFx0dmFsaWRhdGVQcm9wOiB2YWxpZGF0ZVByb3Bcblx0fSk7XG5cblx0LyogICovXG5cblxuXHR2YXIgcXVldWUgPSBbXTtcblx0dmFyIGhhcyQxID0ge307XG5cdHZhciB3YWl0aW5nID0gZmFsc2U7XG5cdHZhciBmbHVzaGluZyA9IGZhbHNlO1xuXHR2YXIgaW5kZXggPSAwO1xuXG5cdC8qKlxuXHQgKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG5cdCAqL1xuXHRmdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcblx0ICBxdWV1ZS5sZW5ndGggPSAwO1xuXHQgIGhhcyQxID0ge307XG5cdCAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHt9XG5cdCAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG5cdCAqL1xuXHRmdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcblx0ICBmbHVzaGluZyA9IHRydWU7XG5cblx0ICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cblx0ICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcblx0ICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG5cdCAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuXHQgIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2Vcblx0ICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG5cdCAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcblx0ICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG5cdCAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG5cdCAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG5cdCAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG5cdCAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG5cdCAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcblx0ICAgIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG5cdCAgICBoYXMkMVtpZF0gPSBudWxsO1xuXHQgICAgd2F0Y2hlci5ydW4oKTtcblx0ICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cblx0ICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhcyQxW2lkXSAhPSBudWxsKSB7fVxuXHQgIH1cblxuXHQgIC8vIGRldnRvb2wgaG9va1xuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHQgIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcblx0ICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG5cdCAgfVxuXG5cdCAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG5cdCAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuXHQgKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cblx0ICovXG5cdGZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuXHQgIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG5cdCAgaWYgKGhhcyQxW2lkXSA9PSBudWxsKSB7XG5cdCAgICBoYXMkMVtpZF0gPSB0cnVlO1xuXHQgICAgaWYgKCFmbHVzaGluZykge1xuXHQgICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuXHQgICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuXHQgICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG5cdCAgICAgIHdoaWxlIChpID49IDAgJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG5cdCAgICAgICAgaS0tO1xuXHQgICAgICB9XG5cdCAgICAgIHF1ZXVlLnNwbGljZShNYXRoLm1heChpLCBpbmRleCkgKyAxLCAwLCB3YXRjaGVyKTtcblx0ICAgIH1cblx0ICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuXHQgICAgaWYgKCF3YWl0aW5nKSB7XG5cdCAgICAgIHdhaXRpbmcgPSB0cnVlO1xuXHQgICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHQvKiAgKi9cblxuXHR2YXIgdWlkJDIgPSAwO1xuXG5cdC8qKlxuXHQgKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcblx0ICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cblx0ICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG5cdCAqL1xuXHR2YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuXHQgIHZtLFxuXHQgIGV4cE9yRm4sXG5cdCAgY2IsXG5cdCAgb3B0aW9uc1xuXHQpIHtcblx0ICB0aGlzLnZtID0gdm07XG5cdCAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG5cdCAgLy8gb3B0aW9uc1xuXHQgIGlmIChvcHRpb25zKSB7XG5cdCAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcblx0ICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuXHQgICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG5cdCAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG5cdCAgfVxuXHQgIHRoaXMuY2IgPSBjYjtcblx0ICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuXHQgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcblx0ICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuXHQgIHRoaXMuZGVwcyA9IFtdO1xuXHQgIHRoaXMubmV3RGVwcyA9IFtdO1xuXHQgIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcblx0ICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG5cdCAgdGhpcy5leHByZXNzaW9uID0gJyc7XG5cdCAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG5cdCAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuXHQgICAgaWYgKCF0aGlzLmdldHRlcikge1xuXHQgICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMShcblx0ICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcblx0ICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuXHQgICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG5cdCAgICAgICAgdm1cblx0ICAgICAgKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuXHQgICAgPyB1bmRlZmluZWRcblx0ICAgIDogdGhpcy5nZXQoKTtcblx0fTtcblxuXHQvKipcblx0ICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblx0V2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcblx0ICBwdXNoVGFyZ2V0KHRoaXMpO1xuXHQgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodGhpcy52bSwgdGhpcy52bSk7XG5cdCAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG5cdCAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG5cdCAgaWYgKHRoaXMuZGVlcCkge1xuXHQgICAgdHJhdmVyc2UodmFsdWUpO1xuXHQgIH1cblx0ICBwb3BUYXJnZXQoKTtcblx0ICB0aGlzLmNsZWFudXBEZXBzKCk7XG5cdCAgcmV0dXJuIHZhbHVlXG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG5cdCAqL1xuXHRXYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuXHQgIHZhciBpZCA9IGRlcC5pZDtcblx0ICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcblx0ICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG5cdCAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuXHQgICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG5cdCAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuXHQgKi9cblx0V2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG5cdCAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXHQgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcblx0ICB3aGlsZSAoaS0tKSB7XG5cdCAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG5cdCAgICBpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcblx0ICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzJDEpO1xuXHQgICAgfVxuXHQgIH1cblx0ICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG5cdCAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcblx0ICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcblx0ICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuXHQgIHRtcCA9IHRoaXMuZGVwcztcblx0ICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG5cdCAgdGhpcy5uZXdEZXBzID0gdG1wO1xuXHQgIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cblx0ICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cblx0ICovXG5cdFdhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG5cdCAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0ICBpZiAodGhpcy5sYXp5KSB7XG5cdCAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblx0ICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuXHQgICAgdGhpcy5ydW4oKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG5cdCAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG5cdCAqL1xuXHRXYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuXHQgIGlmICh0aGlzLmFjdGl2ZSkge1xuXHQgICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcblx0ICAgIGlmIChcblx0ICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcblx0ICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG5cdCAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcblx0ICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuXHQgICAgICBpc09iamVjdCh2YWx1ZSkgfHxcblx0ICAgICAgdGhpcy5kZWVwXG5cdCAgICApIHtcblx0ICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuXHQgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuXHQgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG5cdCAgICAgIGlmICh0aGlzLnVzZXIpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0ICAgICAgICAgIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG5cdCAgICAgICAgICAgIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlLCB0aGlzLnZtKTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQxKFxuXHQgICAgICAgICAgICAgIChcIkVycm9yIGluIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIiksXG5cdCAgICAgICAgICAgICAgdGhpcy52bVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICB0aHJvdyBlXG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG5cdCAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cblx0ICovXG5cdFdhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuXHQgIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuXHQgIHRoaXMuZGlydHkgPSBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG5cdCAqL1xuXHRXYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG5cdCAgd2hpbGUgKGktLSkge1xuXHQgICAgdGhpcyQxLmRlcHNbaV0uZGVwZW5kKCk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cblx0ICovXG5cdFdhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICBpZiAodGhpcy5hY3RpdmUpIHtcblx0ICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3Rcblx0ICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcblx0ICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG5cdCAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcblx0ICAgICAgcmVtb3ZlJDEodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuXHQgICAgfVxuXHQgICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuXHQgICAgd2hpbGUgKGktLSkge1xuXHQgICAgICB0aGlzJDEuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyQxKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuXHQgKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuXHQgKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuXHQgKi9cblx0dmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblx0ZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuXHQgIHNlZW5PYmplY3RzLmNsZWFyKCk7XG5cdCAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcblx0ICB2YXIgaSwga2V5cztcblx0ICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuXHQgIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xuXHQgICAgcmV0dXJuXG5cdCAgfVxuXHQgIGlmICh2YWwuX19vYl9fKSB7XG5cdCAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcblx0ICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcblx0ICAgICAgcmV0dXJuXG5cdCAgICB9XG5cdCAgICBzZWVuLmFkZChkZXBJZCk7XG5cdCAgfVxuXHQgIGlmIChpc0EpIHtcblx0ICAgIGkgPSB2YWwubGVuZ3RoO1xuXHQgICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcblx0ICAgIGkgPSBrZXlzLmxlbmd0aDtcblx0ICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cblx0ICB9XG5cdH1cblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG5cdCAgdm0uX3dhdGNoZXJzID0gW107XG5cdCAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcblx0ICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG5cdCAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuXHQgIGlmIChvcHRzLmRhdGEpIHtcblx0ICAgIGluaXREYXRhKHZtKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuXHQgIH1cblx0ICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG5cdCAgaWYgKG9wdHMud2F0Y2gpIHsgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTsgfVxuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHMpIHtcblx0ICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuXHQgIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuXHQgIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcblx0ICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcblx0ICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBpc1Jvb3Q7XG5cdCAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XG5cdCAgICB2YXIga2V5ID0ga2V5c1tpXTtcblx0ICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cdCAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge30gZWxzZSB7XG5cdCAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHZhbGlkYXRlUHJvcChrZXksIHByb3BzLCBwcm9wc0RhdGEsIHZtKSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykgeyBsb29wKCBpICk7IH1cblx0ICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG5cdCAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuXHQgIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXG5cdCAgICA/IGRhdGEuY2FsbCh2bSlcblx0ICAgIDogZGF0YSB8fCB7fTtcblx0ICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcblx0ICAgIGRhdGEgPSB7fTtcblx0ICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQxKFxuXHQgICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG5cdCAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuXHQgICAgICB2bVxuXHQgICAgKTtcblx0ICB9XG5cdCAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuXHQgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG5cdCAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG5cdCAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcblx0ICB3aGlsZSAoaS0tKSB7XG5cdCAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXlzW2ldKSkge1xuXHQgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMShcblx0ICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIChrZXlzW2ldKSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuXHQgICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuXHQgICAgICAgIHZtXG5cdCAgICAgICk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBwcm94eSh2bSwga2V5c1tpXSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8vIG9ic2VydmUgZGF0YVxuXHQgIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcblx0fVxuXG5cdHZhciBjb21wdXRlZFNoYXJlZERlZmluaXRpb24gPSB7XG5cdCAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICBjb25maWd1cmFibGU6IHRydWUsXG5cdCAgZ2V0OiBub29wLFxuXHQgIHNldDogbm9vcFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG5cdCAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGtleSBpbiB2bSkge31cblx0ICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcblx0ICAgIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBjb21wdXRlZFNoYXJlZERlZmluaXRpb24uZ2V0ID0gbWFrZUNvbXB1dGVkR2V0dGVyKHVzZXJEZWYsIHZtKTtcblx0ICAgICAgY29tcHV0ZWRTaGFyZWREZWZpbml0aW9uLnNldCA9IG5vb3A7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBjb21wdXRlZFNoYXJlZERlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcblx0ICAgICAgICA/IHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG5cdCAgICAgICAgICA/IG1ha2VDb21wdXRlZEdldHRlcih1c2VyRGVmLmdldCwgdm0pXG5cdCAgICAgICAgICA6IGJpbmQkMSh1c2VyRGVmLmdldCwgdm0pXG5cdCAgICAgICAgOiBub29wO1xuXHQgICAgICBjb21wdXRlZFNoYXJlZERlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcblx0ICAgICAgICA/IGJpbmQkMSh1c2VyRGVmLnNldCwgdm0pXG5cdCAgICAgICAgOiBub29wO1xuXHQgICAgfVxuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZtLCBrZXksIGNvbXB1dGVkU2hhcmVkRGVmaW5pdGlvbik7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZUNvbXB1dGVkR2V0dGVyIChnZXR0ZXIsIG93bmVyKSB7XG5cdCAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcihvd25lciwgZ2V0dGVyLCBub29wLCB7XG5cdCAgICBsYXp5OiB0cnVlXG5cdCAgfSk7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcblx0ICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG5cdCAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcblx0ICAgIH1cblx0ICAgIGlmIChEZXAudGFyZ2V0KSB7XG5cdCAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuXHQgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG5cdCAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZCQxKG1ldGhvZHNba2V5XSwgdm0pO1xuXHQgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgJiYgbWV0aG9kc1trZXldID09IG51bGwpIHt9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcblx0ICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcblx0ICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcblx0ICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAodm0sIGtleSwgaGFuZGxlcikge1xuXHQgIHZhciBvcHRpb25zO1xuXHQgIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG5cdCAgICBvcHRpb25zID0gaGFuZGxlcjtcblx0ICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG5cdCAgfVxuXHQgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcblx0ICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcblx0ICB9XG5cdCAgdm0uJHdhdGNoKGtleSwgaGFuZGxlciwgb3B0aW9ucyk7XG5cdH1cblxuXHRmdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcblx0ICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3Rcblx0ICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcblx0ICAvLyB0aGUgb2JqZWN0IGhlcmUuXG5cdCAgdmFyIGRhdGFEZWYgPSB7fTtcblx0ICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9kYXRhXG5cdCAgfTtcblx0ICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge31cblx0ICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG5cblx0ICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQkMTtcblx0ICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cblx0ICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcblx0ICAgIGV4cE9yRm4sXG5cdCAgICBjYixcblx0ICAgIG9wdGlvbnNcblx0ICApIHtcblx0ICAgIHZhciB2bSA9IHRoaXM7XG5cdCAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0ICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG5cdCAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG5cdCAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcblx0ICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcblx0ICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuXHQgICAgfVxuXHQgIH07XG5cdH1cblxuXHRmdW5jdGlvbiBwcm94eSAodm0sIGtleSkge1xuXHQgIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodm0sIGtleSwge1xuXHQgICAgICBjb25maWd1cmFibGU6IHRydWUsXG5cdCAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgIGdldDogZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuXHQgICAgICAgIHJldHVybiB2bS5fZGF0YVtrZXldXG5cdCAgICAgIH0sXG5cdCAgICAgIHNldDogZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuXHQgICAgICAgIHZtLl9kYXRhW2tleV0gPSB2YWw7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcblx0ICB0YWcsXG5cdCAgZGF0YSxcblx0ICBjaGlsZHJlbixcblx0ICB0ZXh0LFxuXHQgIGVsbSxcblx0ICBjb250ZXh0LFxuXHQgIGNvbXBvbmVudE9wdGlvbnNcblx0KSB7XG5cdCAgdGhpcy50YWcgPSB0YWc7XG5cdCAgdGhpcy5kYXRhID0gZGF0YTtcblx0ICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG5cdCAgdGhpcy50ZXh0ID0gdGV4dDtcblx0ICB0aGlzLmVsbSA9IGVsbTtcblx0ICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuXHQgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cdCAgdGhpcy5mdW5jdGlvbmFsQ29udGV4dCA9IHVuZGVmaW5lZDtcblx0ICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG5cdCAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcblx0ICB0aGlzLmNoaWxkID0gdW5kZWZpbmVkO1xuXHQgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuXHQgIHRoaXMucmF3ID0gZmFsc2U7XG5cdCAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuXHQgIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcblx0ICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuXHQgIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcblx0ICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuXHR9O1xuXG5cdHZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG5cdCAgbm9kZS50ZXh0ID0gJyc7XG5cdCAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuXHQgIHJldHVybiBub2RlXG5cdH07XG5cblx0ZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcblx0ICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxuXHR9XG5cblx0Ly8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcblx0Ly8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuXHQvLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcblx0Ly8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cblx0ZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcblx0ICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuXHQgICAgdm5vZGUudGFnLFxuXHQgICAgdm5vZGUuZGF0YSxcblx0ICAgIHZub2RlLmNoaWxkcmVuLFxuXHQgICAgdm5vZGUudGV4dCxcblx0ICAgIHZub2RlLmVsbSxcblx0ICAgIHZub2RlLmNvbnRleHQsXG5cdCAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zXG5cdCAgKTtcblx0ICBjbG9uZWQubnMgPSB2bm9kZS5ucztcblx0ICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcblx0ICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuXHQgIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG5cdCAgcmV0dXJuIGNsb25lZFxuXHR9XG5cblx0ZnVuY3Rpb24gY2xvbmVWTm9kZXMgKHZub2Rlcykge1xuXHQgIHZhciByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldKTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc1xuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaywga2V5KSB7XG5cdCAga2V5ID0ga2V5ICsgaG9va0tleTtcblx0ICB2YXIgaW5qZWN0ZWRIYXNoID0gZGVmLl9faW5qZWN0ZWQgfHwgKGRlZi5fX2luamVjdGVkID0ge30pO1xuXHQgIGlmICghaW5qZWN0ZWRIYXNoW2tleV0pIHtcblx0ICAgIGluamVjdGVkSGFzaFtrZXldID0gdHJ1ZTtcblx0ICAgIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXHQgICAgaWYgKG9sZEhvb2spIHtcblx0ICAgICAgZGVmW2hvb2tLZXldID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIG9sZEhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBkZWZbaG9va0tleV0gPSBob29rO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG5cdCAgb24sXG5cdCAgb2xkT24sXG5cdCAgYWRkLFxuXHQgIHJlbW92ZSQkMSxcblx0ICB2bVxuXHQpIHtcblx0ICB2YXIgbmFtZSwgY3VyLCBvbGQsIGZuLCBldmVudCwgY2FwdHVyZSwgb25jZTtcblx0ICBmb3IgKG5hbWUgaW4gb24pIHtcblx0ICAgIGN1ciA9IG9uW25hbWVdO1xuXHQgICAgb2xkID0gb2xkT25bbmFtZV07XG5cdCAgICBpZiAoIWN1cikge1xuXHQgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMShcblx0ICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgbmFtZSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG5cdCAgICAgICAgdm1cblx0ICAgICAgKTtcblx0ICAgIH0gZWxzZSBpZiAoIW9sZCkge1xuXHQgICAgICBvbmNlID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuXHQgICAgICBldmVudCA9IG9uY2UgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcblx0ICAgICAgY2FwdHVyZSA9IGV2ZW50LmNoYXJBdCgwKSA9PT0gJyEnO1xuXHQgICAgICBldmVudCA9IGNhcHR1cmUgPyBldmVudC5zbGljZSgxKSA6IGV2ZW50O1xuXHQgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXIpKSB7XG5cdCAgICAgICAgYWRkKGV2ZW50LCAoY3VyLmludm9rZXIgPSBhcnJJbnZva2VyKGN1cikpLCBvbmNlLCBjYXB0dXJlKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBpZiAoIWN1ci5pbnZva2VyKSB7XG5cdCAgICAgICAgICBmbiA9IGN1cjtcblx0ICAgICAgICAgIGN1ciA9IG9uW25hbWVdID0ge307XG5cdCAgICAgICAgICBjdXIuZm4gPSBmbjtcblx0ICAgICAgICAgIGN1ci5pbnZva2VyID0gZm5JbnZva2VyKGN1cik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGFkZChldmVudCwgY3VyLmludm9rZXIsIG9uY2UsIGNhcHR1cmUpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG5cdCAgICAgIGlmIChBcnJheS5pc0FycmF5KG9sZCkpIHtcblx0ICAgICAgICBvbGQubGVuZ3RoID0gY3VyLmxlbmd0aDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7IGkrKykgeyBvbGRbaV0gPSBjdXJbaV07IH1cblx0ICAgICAgICBvbltuYW1lXSA9IG9sZDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBvbGQuZm4gPSBjdXI7XG5cdCAgICAgICAgb25bbmFtZV0gPSBvbGQ7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG5cdCAgICBpZiAoIW9uW25hbWVdKSB7XG5cdCAgICAgIG9uY2UgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG5cdCAgICAgIGV2ZW50ID0gb25jZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuXHQgICAgICBjYXB0dXJlID0gZXZlbnQuY2hhckF0KDApID09PSAnISc7XG5cdCAgICAgIGV2ZW50ID0gY2FwdHVyZSA/IGV2ZW50LnNsaWNlKDEpIDogZXZlbnQ7XG5cdCAgICAgIHJlbW92ZSQkMShldmVudCwgb2xkT25bbmFtZV0uaW52b2tlciwgY2FwdHVyZSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gYXJySW52b2tlciAoYXJyKSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIChldikge1xuXHQgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG5cdCAgICB2YXIgc2luZ2xlID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHNpbmdsZSA/IGFycltpXShldikgOiBhcnJbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGZuSW52b2tlciAobykge1xuXHQgIHJldHVybiBmdW5jdGlvbiAoZXYpIHtcblx0ICAgIHZhciBzaW5nbGUgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxO1xuXHQgICAgc2luZ2xlID8gby5mbihldikgOiBvLmZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXHR9XG5cblx0LyogICovXG5cblx0Ly8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG5cdC8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG5cdC8vXG5cdC8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG5cdC8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcblx0Ly8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG5cdC8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcblx0Ly8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuXHQvLyBub21yYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcblx0Ly8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG5cdC8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cblx0ZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG5cdCAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIGNoaWxkcmVuXG5cdH1cblxuXHQvLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJjdXRzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuXHQvLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcblx0Ly8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuXHQvLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cblx0ZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG5cdCAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuXHQgICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cblx0ICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcblx0ICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuXHQgICAgICA6IHVuZGVmaW5lZFxuXHR9XG5cblx0ZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG5cdCAgdmFyIHJlcyA9IFtdO1xuXHQgIHZhciBpLCBjLCBsYXN0O1xuXHQgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHQgICAgYyA9IGNoaWxkcmVuW2ldO1xuXHQgICAgaWYgKGMgPT0gbnVsbCB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cblx0ICAgIGxhc3QgPSByZXNbcmVzLmxlbmd0aCAtIDFdO1xuXHQgICAgLy8gIG5lc3RlZFxuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcblx0ICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSkpO1xuXHQgICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuXHQgICAgICBpZiAobGFzdCAmJiBsYXN0LnRleHQpIHtcblx0ICAgICAgICBsYXN0LnRleHQgKz0gU3RyaW5nKGMpO1xuXHQgICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG5cdCAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcblx0ICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAoYy50ZXh0ICYmIGxhc3QgJiYgbGFzdC50ZXh0KSB7XG5cdCAgICAgICAgcmVzW3Jlcy5sZW5ndGggLSAxXSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG5cdCAgICAgICAgaWYgKGMudGFnICYmIGMua2V5ID09IG51bGwgJiYgbmVzdGVkSW5kZXggIT0gbnVsbCkge1xuXHQgICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXMucHVzaChjKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzXG5cdH1cblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuXHQgIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgJiYgYy5jb21wb25lbnRPcHRpb25zOyB9KVswXVxuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcblx0ICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0ICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG5cdCAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG5cdCAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG5cdCAgaWYgKGxpc3RlbmVycykge1xuXHQgICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuXHQgIH1cblx0fVxuXG5cdHZhciB0YXJnZXQ7XG5cblx0ZnVuY3Rpb24gYWRkJDEgKGV2ZW50LCBmbiwgb25jZSkge1xuXHQgIGlmIChvbmNlKSB7XG5cdCAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbW92ZSQyIChldmVudCwgZm4pIHtcblx0ICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcblx0ICB2bSxcblx0ICBsaXN0ZW5lcnMsXG5cdCAgb2xkTGlzdGVuZXJzXG5cdCkge1xuXHQgIHRhcmdldCA9IHZtO1xuXHQgIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkJDEsIHJlbW92ZSQyLCB2bSk7XG5cdH1cblxuXHRmdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG5cdCAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuXHQgIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuXHQgICAgdmFyIHZtID0gdGhpczsodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcblx0ICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG5cdCAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcblx0ICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcblx0ICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdm1cblx0ICB9O1xuXG5cdCAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcblx0ICAgIHZhciB2bSA9IHRoaXM7XG5cdCAgICBmdW5jdGlvbiBvbiAoKSB7XG5cdCAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcblx0ICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG5cdCAgICB9XG5cdCAgICBvbi5mbiA9IGZuO1xuXHQgICAgdm0uJG9uKGV2ZW50LCBvbik7XG5cdCAgICByZXR1cm4gdm1cblx0ICB9O1xuXG5cdCAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuXHQgICAgdmFyIHZtID0gdGhpcztcblx0ICAgIC8vIGFsbFxuXHQgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdCAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHQgICAgICByZXR1cm4gdm1cblx0ICAgIH1cblx0ICAgIC8vIHNwZWNpZmljIGV2ZW50XG5cdCAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG5cdCAgICBpZiAoIWNicykge1xuXHQgICAgICByZXR1cm4gdm1cblx0ICAgIH1cblx0ICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcblx0ICAgICAgcmV0dXJuIHZtXG5cdCAgICB9XG5cdCAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG5cdCAgICB2YXIgY2I7XG5cdCAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG5cdCAgICB3aGlsZSAoaS0tKSB7XG5cdCAgICAgIGNiID0gY2JzW2ldO1xuXHQgICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuXHQgICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgYnJlYWtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZtXG5cdCAgfTtcblxuXHQgIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgIHZhciB2bSA9IHRoaXM7XG5cdCAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG5cdCAgICBpZiAoY2JzKSB7XG5cdCAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuXHQgICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcblx0ICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdCAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZtXG5cdCAgfTtcblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5cblx0ZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcblx0ICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG5cdCAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcblx0ICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG5cdCAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuXHQgICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuXHQgICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcblx0ICAgIH1cblx0ICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG5cdCAgfVxuXG5cdCAgdm0uJHBhcmVudCA9IHBhcmVudDtcblx0ICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG5cdCAgdm0uJGNoaWxkcmVuID0gW107XG5cdCAgdm0uJHJlZnMgPSB7fTtcblxuXHQgIHZtLl93YXRjaGVyID0gbnVsbDtcblx0ICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcblx0ICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG5cdCAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG5cdCAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcblx0ICBWdWUucHJvdG90eXBlLl9tb3VudCA9IGZ1bmN0aW9uIChcblx0ICAgIGVsLFxuXHQgICAgaHlkcmF0aW5nXG5cdCAgKSB7XG5cdCAgICB2YXIgdm0gPSB0aGlzO1xuXHQgICAgdm0uJGVsID0gZWw7XG5cdCAgICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuXHQgICAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuXHQgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge31cblx0ICAgIH1cblx0ICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblx0ICAgIHZtLl93YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG5cdCAgICB9LCBub29wKTtcblx0ICAgIGh5ZHJhdGluZyA9IGZhbHNlO1xuXHQgICAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcblx0ICAgIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG5cdCAgICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcblx0ICAgICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG5cdCAgICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZtXG5cdCAgfTtcblxuXHQgIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG5cdCAgICB2YXIgdm0gPSB0aGlzO1xuXHQgICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcblx0ICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcblx0ICAgIH1cblx0ICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG5cdCAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuXHQgICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuXHQgICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcblx0ICAgIHZtLl92bm9kZSA9IHZub2RlO1xuXHQgICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG5cdCAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cblx0ICAgIGlmICghcHJldlZub2RlKSB7XG5cdCAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG5cdCAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcblx0ICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG5cdCAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcblx0ICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXG5cdCAgICAgICk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyB1cGRhdGVzXG5cdCAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcblx0ICAgIH1cblx0ICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuXHQgICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG5cdCAgICBpZiAocHJldkVsKSB7XG5cdCAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcblx0ICAgIH1cblx0ICAgIGlmICh2bS4kZWwpIHtcblx0ICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcblx0ICAgIH1cblx0ICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcblx0ICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG5cdCAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuXHQgICAgfVxuXHQgICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcblx0ICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZUZyb21QYXJlbnQgPSBmdW5jdGlvbiAoXG5cdCAgICBwcm9wc0RhdGEsXG5cdCAgICBsaXN0ZW5lcnMsXG5cdCAgICBwYXJlbnRWbm9kZSxcblx0ICAgIHJlbmRlckNoaWxkcmVuXG5cdCAgKSB7XG5cdCAgICB2YXIgdm0gPSB0aGlzO1xuXHQgICAgdmFyIGhhc0NoaWxkcmVuID0gISEodm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8IHJlbmRlckNoaWxkcmVuKTtcblx0ICAgIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuXHQgICAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblx0ICAgIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcblx0ICAgICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuXHQgICAgfVxuXHQgICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cdCAgICAvLyB1cGRhdGUgcHJvcHNcblx0ICAgIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcblx0ICAgICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG5cdCAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7fVxuXHQgICAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG5cdCAgICAgICAgdm1ba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHZtLiRvcHRpb25zLnByb3BzLCBwcm9wc0RhdGEsIHZtKTtcblx0ICAgICAgfVxuXHQgICAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuXHQgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge31cblx0ICAgICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuXHQgICAgfVxuXHQgICAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuXHQgICAgaWYgKGxpc3RlbmVycykge1xuXHQgICAgICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcblx0ICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcblx0ICAgICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG5cdCAgICB9XG5cdCAgICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuXHQgICAgaWYgKGhhc0NoaWxkcmVuKSB7XG5cdCAgICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG5cdCAgICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciB2bSA9IHRoaXM7XG5cdCAgICBpZiAodm0uX3dhdGNoZXIpIHtcblx0ICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgdm0gPSB0aGlzO1xuXHQgICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG5cdCAgICAgIHJldHVyblxuXHQgICAgfVxuXHQgICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG5cdCAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG5cdCAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuXHQgICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG5cdCAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG5cdCAgICAgIHJlbW92ZSQxKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcblx0ICAgIH1cblx0ICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG5cdCAgICBpZiAodm0uX3dhdGNoZXIpIHtcblx0ICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcblx0ICAgIH1cblx0ICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcblx0ICAgIHdoaWxlIChpLS0pIHtcblx0ICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG5cdCAgICB9XG5cdCAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuXHQgICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG5cdCAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG5cdCAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG5cdCAgICB9XG5cdCAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cblx0ICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG5cdCAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuXHQgICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cblx0ICAgIHZtLiRvZmYoKTtcblx0ICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuXHQgICAgaWYgKHZtLiRlbCkge1xuXHQgICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG5cdCAgICB9XG5cdCAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcblx0ICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuXHQgIH07XG5cdH1cblxuXHRmdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcblx0ICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcblx0ICBpZiAoaGFuZGxlcnMpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdCAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuXHQgICAgfVxuXHQgIH1cblx0ICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuXHQgICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuXHQgIH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciBob29rcyA9IHsgaW5pdDogaW5pdCwgcHJlcGF0Y2g6IHByZXBhdGNoLCBpbnNlcnQ6IGluc2VydCwgZGVzdHJveTogZGVzdHJveSQxIH07XG5cdHZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhob29rcyk7XG5cblx0ZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcblx0ICBDdG9yLFxuXHQgIGRhdGEsXG5cdCAgY29udGV4dCxcblx0ICBjaGlsZHJlbixcblx0ICB0YWdcblx0KSB7XG5cdCAgaWYgKCFDdG9yKSB7XG5cdCAgICByZXR1cm5cblx0ICB9XG5cblx0ICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXHQgIGlmIChpc09iamVjdChDdG9yKSkge1xuXHQgICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcblx0ICB9XG5cblx0ICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7fVxuXHQgICAgcmV0dXJuXG5cdCAgfVxuXG5cdCAgLy8gYXN5bmMgY29tcG9uZW50XG5cdCAgaWYgKCFDdG9yLmNpZCkge1xuXHQgICAgaWYgKEN0b3IucmVzb2x2ZWQpIHtcblx0ICAgICAgQ3RvciA9IEN0b3IucmVzb2x2ZWQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KEN0b3IsIGJhc2VDdG9yLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy8gaXQncyBvayB0byBxdWV1ZSB0aGlzIG9uIGV2ZXJ5IHJlbmRlciBiZWNhdXNlXG5cdCAgICAgICAgLy8gJGZvcmNlVXBkYXRlIGlzIGJ1ZmZlcmVkIGJ5IHRoZSBzY2hlZHVsZXIuXG5cdCAgICAgICAgY29udGV4dC4kZm9yY2VVcGRhdGUoKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIGlmICghQ3Rvcikge1xuXHQgICAgICAgIC8vIHJldHVybiBub3RoaW5nIGlmIHRoaXMgaXMgaW5kZWVkIGFuIGFzeW5jIGNvbXBvbmVudFxuXHQgICAgICAgIC8vIHdhaXQgZm9yIHRoZSBjYWxsYmFjayB0byB0cmlnZ2VyIHBhcmVudCB1cGRhdGUuXG5cdCAgICAgICAgcmV0dXJuXG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG5cdCAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG5cdCAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuXHQgIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG5cdCAgLy8gZXh0cmFjdCBwcm9wc1xuXHQgIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHMoZGF0YSwgQ3Rvcik7XG5cblx0ICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuXHQgIGlmIChDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkge1xuXHQgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcblx0ICB9XG5cblx0ICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuXHQgIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG5cdCAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG5cdCAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcblx0ICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuXHQgIGlmIChDdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcblx0ICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcblx0ICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnNcblx0ICAgIGRhdGEgPSB7fTtcblx0ICB9XG5cblx0ICAvLyBtZXJnZSBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG5cdCAgbWVyZ2VIb29rcyhkYXRhKTtcblxuXHQgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG5cdCAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG5cdCAgdmFyIHZub2RlID0gbmV3IFZOb2RlKFxuXHQgICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcblx0ICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG5cdCAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9XG5cdCAgKTtcblx0ICByZXR1cm4gdm5vZGVcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuXHQgIEN0b3IsXG5cdCAgcHJvcHNEYXRhLFxuXHQgIGRhdGEsXG5cdCAgY29udGV4dCxcblx0ICBjaGlsZHJlblxuXHQpIHtcblx0ICB2YXIgcHJvcHMgPSB7fTtcblx0ICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG5cdCAgaWYgKHByb3BPcHRpb25zKSB7XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcblx0ICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEpO1xuXHQgICAgfVxuXHQgIH1cblx0ICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG5cdCAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuXHQgIHZhciBfY29udGV4dCA9IE9iamVjdC5jcmVhdGUoY29udGV4dCk7XG5cdCAgdmFyIGggPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChfY29udGV4dCwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cdCAgdmFyIHZub2RlID0gQ3Rvci5vcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIGgsIHtcblx0ICAgIHByb3BzOiBwcm9wcyxcblx0ICAgIGRhdGE6IGRhdGEsXG5cdCAgICBwYXJlbnQ6IGNvbnRleHQsXG5cdCAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG5cdCAgICBzbG90czogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBjb250ZXh0KTsgfVxuXHQgIH0pO1xuXHQgIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG5cdCAgICB2bm9kZS5mdW5jdGlvbmFsQ29udGV4dCA9IGNvbnRleHQ7XG5cdCAgICBpZiAoZGF0YS5zbG90KSB7XG5cdCAgICAgICh2bm9kZS5kYXRhIHx8ICh2bm9kZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gdm5vZGVcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuXHQgIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3Rcblx0ICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuXHQgIHBhcmVudEVsbSxcblx0ICByZWZFbG1cblx0KSB7XG5cdCAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG5cdCAgdmFyIG9wdGlvbnMgPSB7XG5cdCAgICBfaXNDb21wb25lbnQ6IHRydWUsXG5cdCAgICBwYXJlbnQ6IHBhcmVudCxcblx0ICAgIHByb3BzRGF0YTogdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YSxcblx0ICAgIF9jb21wb25lbnRUYWc6IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWcsXG5cdCAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuXHQgICAgX3BhcmVudExpc3RlbmVyczogdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycyxcblx0ICAgIF9yZW5kZXJDaGlsZHJlbjogdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLFxuXHQgICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG5cdCAgICBfcmVmRWxtOiByZWZFbG0gfHwgbnVsbFxuXHQgIH07XG5cdCAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcblx0ICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuXHQgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuXHQgICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG5cdCAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcblx0ICB9XG5cdCAgcmV0dXJuIG5ldyB2bm9kZUNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdCAoXG5cdCAgdm5vZGUsXG5cdCAgaHlkcmF0aW5nLFxuXHQgIHBhcmVudEVsbSxcblx0ICByZWZFbG1cblx0KSB7XG5cdCAgaWYgKCF2bm9kZS5jaGlsZCB8fCB2bm9kZS5jaGlsZC5faXNEZXN0cm95ZWQpIHtcblx0ICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcblx0ICAgICAgdm5vZGUsXG5cdCAgICAgIGFjdGl2ZUluc3RhbmNlLFxuXHQgICAgICBwYXJlbnRFbG0sXG5cdCAgICAgIHJlZkVsbVxuXHQgICAgKTtcblx0ICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG5cdCAgfSBlbHNlIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuXHQgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG5cdCAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuXHQgICAgcHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBwcmVwYXRjaCAoXG5cdCAgb2xkVm5vZGUsXG5cdCAgdm5vZGVcblx0KSB7XG5cdCAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuXHQgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkID0gb2xkVm5vZGUuY2hpbGQ7XG5cdCAgY2hpbGQuX3VwZGF0ZUZyb21QYXJlbnQoXG5cdCAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuXHQgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG5cdCAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuXHQgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cblx0ICApO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuXHQgIGlmICghdm5vZGUuY2hpbGQuX2lzTW91bnRlZCkge1xuXHQgICAgdm5vZGUuY2hpbGQuX2lzTW91bnRlZCA9IHRydWU7XG5cdCAgICBjYWxsSG9vayh2bm9kZS5jaGlsZCwgJ21vdW50ZWQnKTtcblx0ICB9XG5cdCAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG5cdCAgICB2bm9kZS5jaGlsZC5faW5hY3RpdmUgPSBmYWxzZTtcblx0ICAgIGNhbGxIb29rKHZub2RlLmNoaWxkLCAnYWN0aXZhdGVkJyk7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gZGVzdHJveSQxICh2bm9kZSkge1xuXHQgIGlmICghdm5vZGUuY2hpbGQuX2lzRGVzdHJveWVkKSB7XG5cdCAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG5cdCAgICAgIHZub2RlLmNoaWxkLiRkZXN0cm95KCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2bm9kZS5jaGlsZC5faW5hY3RpdmUgPSB0cnVlO1xuXHQgICAgICBjYWxsSG9vayh2bm9kZS5jaGlsZCwgJ2RlYWN0aXZhdGVkJyk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcblx0ICBmYWN0b3J5LFxuXHQgIGJhc2VDdG9yLFxuXHQgIGNiXG5cdCkge1xuXHQgIGlmIChmYWN0b3J5LnJlcXVlc3RlZCkge1xuXHQgICAgLy8gcG9vbCBjYWxsYmFja3Ncblx0ICAgIGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNiKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgZmFjdG9yeS5yZXF1ZXN0ZWQgPSB0cnVlO1xuXHQgICAgdmFyIGNicyA9IGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcyA9IFtjYl07XG5cdCAgICB2YXIgc3luYyA9IHRydWU7XG5cblx0ICAgIHZhciByZXNvbHZlID0gZnVuY3Rpb24gKHJlcykge1xuXHQgICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuXHQgICAgICAgIHJlcyA9IGJhc2VDdG9yLmV4dGVuZChyZXMpO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG5cdCAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSByZXM7XG5cdCAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcblx0ICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG5cdCAgICAgIGlmICghc3luYykge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHQgICAgICAgICAgY2JzW2ldKHJlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICB2YXIgcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuXHQgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMShcblx0ICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG5cdCAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG5cdCAgICAgICk7XG5cdCAgICB9O1xuXG5cdCAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG5cdCAgICAvLyBoYW5kbGUgcHJvbWlzZVxuXHQgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicgJiYgIWZhY3RvcnkucmVzb2x2ZWQpIHtcblx0ICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0ICAgIH1cblxuXHQgICAgc3luYyA9IGZhbHNlO1xuXHQgICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuXHQgICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBleHRyYWN0UHJvcHMgKGRhdGEsIEN0b3IpIHtcblx0ICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cblx0ICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcblx0ICAvLyBjb21wb25lbnQgaXRzZWxmLlxuXHQgIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcblx0ICBpZiAoIXByb3BPcHRpb25zKSB7XG5cdCAgICByZXR1cm5cblx0ICB9XG5cdCAgdmFyIHJlcyA9IHt9O1xuXHQgIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG5cdCAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcblx0ICB2YXIgZG9tUHJvcHMgPSBkYXRhLmRvbVByb3BzO1xuXHQgIGlmIChhdHRycyB8fCBwcm9wcyB8fCBkb21Qcm9wcykge1xuXHQgICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG5cdCAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcblx0ICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuXHQgICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXkpIHx8XG5cdCAgICAgIGNoZWNrUHJvcChyZXMsIGRvbVByb3BzLCBrZXksIGFsdEtleSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXNcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrUHJvcCAoXG5cdCAgcmVzLFxuXHQgIGhhc2gsXG5cdCAga2V5LFxuXHQgIGFsdEtleSxcblx0ICBwcmVzZXJ2ZVxuXHQpIHtcblx0ICBpZiAoaGFzaCkge1xuXHQgICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG5cdCAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuXHQgICAgICBpZiAoIXByZXNlcnZlKSB7XG5cdCAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gdHJ1ZVxuXHQgICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuXHQgICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcblx0ICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuXHQgICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHRydWVcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIGZhbHNlXG5cdH1cblxuXHRmdW5jdGlvbiBtZXJnZUhvb2tzIChkYXRhKSB7XG5cdCAgaWYgKCFkYXRhLmhvb2spIHtcblx0ICAgIGRhdGEuaG9vayA9IHt9O1xuXHQgIH1cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcblx0ICAgIHZhciBmcm9tUGFyZW50ID0gZGF0YS5ob29rW2tleV07XG5cdCAgICB2YXIgb3VycyA9IGhvb2tzW2tleV07XG5cdCAgICBkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gbWVyZ2VIb29rJDEgKG9uZSwgdHdvKSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG5cdCAgICBvbmUoYSwgYiwgYywgZCk7XG5cdCAgICB0d28oYSwgYiwgYywgZCk7XG5cdCAgfVxuXHR9XG5cblx0LyogICovXG5cblx0dmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xuXHR2YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cblx0Ly8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcblx0Ly8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuXHQgIGNvbnRleHQsXG5cdCAgdGFnLFxuXHQgIGRhdGEsXG5cdCAgY2hpbGRyZW4sXG5cdCAgbm9ybWFsaXphdGlvblR5cGUsXG5cdCAgYWx3YXlzTm9ybWFsaXplXG5cdCkge1xuXHQgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG5cdCAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuXHQgICAgY2hpbGRyZW4gPSBkYXRhO1xuXHQgICAgZGF0YSA9IHVuZGVmaW5lZDtcblx0ICB9XG5cdCAgaWYgKGFsd2F5c05vcm1hbGl6ZSkgeyBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7IH1cblx0ICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG5cdH1cblxuXHRmdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG5cdCAgY29udGV4dCxcblx0ICB0YWcsXG5cdCAgZGF0YSxcblx0ICBjaGlsZHJlbixcblx0ICBub3JtYWxpemF0aW9uVHlwZVxuXHQpIHtcblx0ICBpZiAoZGF0YSAmJiBkYXRhLl9fb2JfXykge1xuXHQgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDEoXG5cdCAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG5cdCAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuXHQgICAgICBjb250ZXh0XG5cdCAgICApO1xuXHQgICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuXHQgIH1cblx0ICBpZiAoIXRhZykge1xuXHQgICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuXHQgICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuXHQgIH1cblx0ICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG5cdCAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG5cdCAgICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgZGF0YSA9IGRhdGEgfHwge307XG5cdCAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuXHQgICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcblx0ICB9XG5cdCAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG5cdCAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcblx0ICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG5cdCAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcblx0ICB9XG5cdCAgdmFyIHZub2RlLCBucztcblx0ICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcblx0ICAgIHZhciBDdG9yO1xuXHQgICAgbnMgPSBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cdCAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuXHQgICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuXHQgICAgICB2bm9kZSA9IG5ldyBWTm9kZShcblx0ICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG5cdCAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcblx0ICAgICAgKTtcblx0ICAgIH0gZWxzZSBpZiAoKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuXHQgICAgICAvLyBjb21wb25lbnRcblx0ICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcblx0ICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcblx0ICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cblx0ICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG5cdCAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcblx0ICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuXHQgICAgICApO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuXHQgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG5cdCAgfVxuXHQgIGlmICh2bm9kZSkge1xuXHQgICAgaWYgKG5zKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuXHQgICAgcmV0dXJuIHZub2RlXG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMpIHtcblx0ICB2bm9kZS5ucyA9IG5zO1xuXHQgIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuXHQgICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG5cdCAgICByZXR1cm5cblx0ICB9XG5cdCAgaWYgKHZub2RlLmNoaWxkcmVuKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHQgICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcblx0ICAgICAgaWYgKGNoaWxkLnRhZyAmJiAhY2hpbGQubnMpIHtcblx0ICAgICAgICBhcHBseU5TKGNoaWxkLCBucyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuXHQgIHZtLiR2bm9kZSA9IG51bGw7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG5cdCAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcblx0ICB2bS5fc3RhdGljVHJlZXMgPSBudWxsO1xuXHQgIHZhciBwYXJlbnRWbm9kZSA9IHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZTtcblx0ICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG5cdCAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG5cdCAgdm0uJHNjb3BlZFNsb3RzID0ge307XG5cdCAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG5cdCAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cblx0ICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG5cdCAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcblx0ICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG5cdCAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG5cdCAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG5cdCAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cdCAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG5cdCAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcblx0ICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuXHQgICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuXHQgIH07XG5cblx0ICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgdm0gPSB0aGlzO1xuXHQgICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuXHQgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG5cdCAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcblx0ICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG5cdCAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuXHQgICAgICAvLyBjbG9uZSBzbG90IG5vZGVzIG9uIHJlLXJlbmRlcnNcblx0ICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuXHQgICAgICAgIHZtLiRzbG90c1trZXldID0gY2xvbmVWTm9kZXModm0uJHNsb3RzW2tleV0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChfcGFyZW50Vm5vZGUgJiYgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMpIHtcblx0ICAgICAgdm0uJHNjb3BlZFNsb3RzID0gX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHM7XG5cdCAgICB9XG5cblx0ICAgIGlmIChzdGF0aWNSZW5kZXJGbnMgJiYgIXZtLl9zdGF0aWNUcmVlcykge1xuXHQgICAgICB2bS5fc3RhdGljVHJlZXMgPSBbXTtcblx0ICAgIH1cblx0ICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3Ncblx0ICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuXHQgICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuXHQgICAgLy8gcmVuZGVyIHNlbGZcblx0ICAgIHZhciB2bm9kZTtcblx0ICAgIHRyeSB7XG5cdCAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cdCAgICAgIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG5cdCAgICAgICAgY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGUsIHZtKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge31cblx0ICAgICAgICB0aHJvdyBlXG5cdCAgICAgIH1cblx0ICAgICAgLy8gcmV0dXJuIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG5cdCAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuXHQgICAgfVxuXHQgICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuXHQgICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcblx0ICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHt9XG5cdCAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuXHQgICAgfVxuXHQgICAgLy8gc2V0IHBhcmVudFxuXHQgICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuXHQgICAgcmV0dXJuIHZub2RlXG5cdCAgfTtcblxuXHQgIC8vIHRvU3RyaW5nIGZvciBtdXN0YWNoZXNcblx0ICBWdWUucHJvdG90eXBlLl9zID0gX3RvU3RyaW5nO1xuXHQgIC8vIGNvbnZlcnQgdGV4dCB0byB2bm9kZVxuXHQgIFZ1ZS5wcm90b3R5cGUuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG5cdCAgLy8gbnVtYmVyIGNvbnZlcnNpb25cblx0ICBWdWUucHJvdG90eXBlLl9uID0gdG9OdW1iZXI7XG5cdCAgLy8gZW1wdHkgdm5vZGVcblx0ICBWdWUucHJvdG90eXBlLl9lID0gY3JlYXRlRW1wdHlWTm9kZTtcblx0ICAvLyBsb29zZSBlcXVhbFxuXHQgIFZ1ZS5wcm90b3R5cGUuX3EgPSBsb29zZUVxdWFsO1xuXHQgIC8vIGxvb3NlIGluZGV4T2Zcblx0ICBWdWUucHJvdG90eXBlLl9pID0gbG9vc2VJbmRleE9mO1xuXG5cdCAgLy8gcmVuZGVyIHN0YXRpYyB0cmVlIGJ5IGluZGV4XG5cdCAgVnVlLnByb3RvdHlwZS5fbSA9IGZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG5cdCAgICBpbmRleCxcblx0ICAgIGlzSW5Gb3Jcblx0ICApIHtcblx0ICAgIHZhciB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdO1xuXHQgICAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG5cdCAgICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZSBieSBkb2luZyBhIHNoYWxsb3cgY2xvbmUuXG5cdCAgICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuXHQgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxuXHQgICAgICAgID8gY2xvbmVWTm9kZXModHJlZSlcblx0ICAgICAgICA6IGNsb25lVk5vZGUodHJlZSlcblx0ICAgIH1cblx0ICAgIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cblx0ICAgIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSk7XG5cdCAgICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuXHQgICAgcmV0dXJuIHRyZWVcblx0ICB9O1xuXG5cdCAgLy8gbWFyayBub2RlIGFzIHN0YXRpYyAodi1vbmNlKVxuXHQgIFZ1ZS5wcm90b3R5cGUuX28gPSBmdW5jdGlvbiBtYXJrT25jZSAoXG5cdCAgICB0cmVlLFxuXHQgICAgaW5kZXgsXG5cdCAgICBrZXlcblx0ICApIHtcblx0ICAgIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuXHQgICAgcmV0dXJuIHRyZWVcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gbWFya1N0YXRpYyAodHJlZSwga2V5LCBpc09uY2UpIHtcblx0ICAgIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG5cdCAgICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcblx0ICAgIG5vZGUua2V5ID0ga2V5O1xuXHQgICAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG5cdCAgfVxuXG5cdCAgLy8gZmlsdGVyIHJlc29sdXRpb24gaGVscGVyXG5cdCAgVnVlLnByb3RvdHlwZS5fZiA9IGZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG5cdCAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG5cdCAgfTtcblxuXHQgIC8vIHJlbmRlciB2LWZvclxuXHQgIFZ1ZS5wcm90b3R5cGUuX2wgPSBmdW5jdGlvbiByZW5kZXJMaXN0IChcblx0ICAgIHZhbCxcblx0ICAgIHJlbmRlclxuXHQgICkge1xuXHQgICAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuXHQgICAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG5cdCAgICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdCAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuXHQgICAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuXHQgICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcblx0ICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcblx0ICAgICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdCAgICAgICAga2V5ID0ga2V5c1tpXTtcblx0ICAgICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiByZXRcblx0ICB9O1xuXG5cdCAgLy8gcmVuZGVyU2xvdFxuXHQgIFZ1ZS5wcm90b3R5cGUuX3QgPSBmdW5jdGlvbiAoXG5cdCAgICBuYW1lLFxuXHQgICAgZmFsbGJhY2ssXG5cdCAgICBwcm9wcyxcblx0ICAgIGJpbmRPYmplY3Rcblx0ICApIHtcblx0ICAgIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcblx0ICAgIGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3Rcblx0ICAgICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcblx0ICAgICAgaWYgKGJpbmRPYmplY3QpIHtcblx0ICAgICAgICBleHRlbmQocHJvcHMsIGJpbmRPYmplY3QpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrXG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG5cdCAgICAgIC8vIHdhcm4gZHVwbGljYXRlIHNsb3QgdXNhZ2Vcblx0ICAgICAgaWYgKHNsb3ROb2RlcyAmJiBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG5cdCAgICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCAmJiB3YXJuJDEoXG5cdCAgICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuXHQgICAgICAgICAgXCItIHRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgcmVuZGVyIGVycm9ycy5cIixcblx0ICAgICAgICAgIHRoaXNcblx0ICAgICAgICApO1xuXHQgICAgICAgIHNsb3ROb2Rlcy5fcmVuZGVyZWQgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBzbG90Tm9kZXMgfHwgZmFsbGJhY2tcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgLy8gYXBwbHkgdi1iaW5kIG9iamVjdFxuXHQgIFZ1ZS5wcm90b3R5cGUuX2IgPSBmdW5jdGlvbiBiaW5kUHJvcHMgKFxuXHQgICAgZGF0YSxcblx0ICAgIHRhZyxcblx0ICAgIHZhbHVlLFxuXHQgICAgYXNQcm9wXG5cdCAgKSB7XG5cdCAgICBpZiAodmFsdWUpIHtcblx0ICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcblx0ICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMShcblx0ICAgICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG5cdCAgICAgICAgICB0aGlzXG5cdCAgICAgICAgKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcblx0ICAgICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnKSB7XG5cdCAgICAgICAgICAgIGRhdGFba2V5XSA9IHZhbHVlW2tleV07XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCBrZXkpXG5cdCAgICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG5cdCAgICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuXHQgICAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGRhdGFcblx0ICB9O1xuXG5cdCAgLy8gY2hlY2sgdi1vbiBrZXlDb2Rlc1xuXHQgIFZ1ZS5wcm90b3R5cGUuX2sgPSBmdW5jdGlvbiBjaGVja0tleUNvZGVzIChcblx0ICAgIGV2ZW50S2V5Q29kZSxcblx0ICAgIGtleSxcblx0ICAgIGJ1aWx0SW5BbGlhc1xuXHQgICkge1xuXHQgICAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5Q29kZXMpKSB7XG5cdCAgICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4ga2V5Q29kZXMgIT09IGV2ZW50S2V5Q29kZVxuXHQgICAgfVxuXHQgIH07XG5cdH1cblxuXHRmdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuXHQgIGNoaWxkcmVuLFxuXHQgIGNvbnRleHRcblx0KSB7XG5cdCAgdmFyIHNsb3RzID0ge307XG5cdCAgaWYgKCFjaGlsZHJlbikge1xuXHQgICAgcmV0dXJuIHNsb3RzXG5cdCAgfVxuXHQgIHZhciBkZWZhdWx0U2xvdCA9IFtdO1xuXHQgIHZhciBuYW1lLCBjaGlsZDtcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHQgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcblx0ICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuXHQgICAgLy8gc2FtZSBjb250ZXh0LlxuXHQgICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZ1bmN0aW9uYWxDb250ZXh0ID09PSBjb250ZXh0KSAmJlxuXHQgICAgICAgIGNoaWxkLmRhdGEgJiYgKG5hbWUgPSBjaGlsZC5kYXRhLnNsb3QpKSB7XG5cdCAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG5cdCAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcblx0ICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4pO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGRlZmF1bHRTbG90LnB1c2goY2hpbGQpO1xuXHQgICAgfVxuXHQgIH1cblx0ICAvLyBpZ25vcmUgc2luZ2xlIHdoaXRlc3BhY2Vcblx0ICBpZiAoZGVmYXVsdFNsb3QubGVuZ3RoICYmICEoXG5cdCAgICBkZWZhdWx0U2xvdC5sZW5ndGggPT09IDEgJiZcblx0ICAgIChkZWZhdWx0U2xvdFswXS50ZXh0ID09PSAnICcgfHwgZGVmYXVsdFNsb3RbMF0uaXNDb21tZW50KVxuXHQgICkpIHtcblx0ICAgIHNsb3RzLmRlZmF1bHQgPSBkZWZhdWx0U2xvdDtcblx0ICB9XG5cdCAgcmV0dXJuIHNsb3RzXG5cdH1cblxuXHQvKiAgKi9cblxuXHR2YXIgdWlkID0gMDtcblxuXHRmdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuXHQgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgdmFyIHZtID0gdGhpcztcblx0ICAgIC8vIGEgdWlkXG5cdCAgICB2bS5fdWlkID0gdWlkKys7XG5cdCAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuXHQgICAgdm0uX2lzVnVlID0gdHJ1ZTtcblx0ICAgIC8vIG1lcmdlIG9wdGlvbnNcblx0ICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG5cdCAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG5cdCAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcblx0ICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG5cdCAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcblx0ICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcblx0ICAgICAgICBvcHRpb25zIHx8IHt9LFxuXHQgICAgICAgIHZtXG5cdCAgICAgICk7XG5cdCAgICB9XG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXHQgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHt9IGVsc2Uge1xuXHQgICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcblx0ICAgIH1cblx0ICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcblx0ICAgIHZtLl9zZWxmID0gdm07XG5cdCAgICBpbml0TGlmZWN5Y2xlKHZtKTtcblx0ICAgIGluaXRFdmVudHModm0pO1xuXHQgICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcblx0ICAgIGluaXRTdGF0ZSh2bSk7XG5cdCAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblx0ICAgIGluaXRSZW5kZXIodm0pO1xuXHQgIH07XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG5cdCAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG5cdCAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cblx0ICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuXHQgIG9wdHMucHJvcHNEYXRhID0gb3B0aW9ucy5wcm9wc0RhdGE7XG5cdCAgb3B0cy5fcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcblx0ICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG5cdCAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSBvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcblx0ICBvcHRzLl9jb21wb25lbnRUYWcgPSBvcHRpb25zLl9jb21wb25lbnRUYWc7XG5cdCAgb3B0cy5fcGFyZW50RWxtID0gb3B0aW9ucy5fcGFyZW50RWxtO1xuXHQgIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcblx0ICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcblx0ICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG5cdCAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcblx0ICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcblx0ICBpZiAoQ3Rvci5zdXBlcikge1xuXHQgICAgdmFyIHN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXIub3B0aW9ucztcblx0ICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcblx0ICAgIHZhciBleHRlbmRPcHRpb25zID0gQ3Rvci5leHRlbmRPcHRpb25zO1xuXHQgICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG5cdCAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkXG5cdCAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuXHQgICAgICBleHRlbmRPcHRpb25zLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuXHQgICAgICBleHRlbmRPcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuXHQgICAgICBleHRlbmRPcHRpb25zLl9zY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcblx0ICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIGV4dGVuZE9wdGlvbnMpO1xuXHQgICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG5cdCAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBvcHRpb25zXG5cdH1cblxuXHRmdW5jdGlvbiBWdWUkMiAob3B0aW9ucykge1xuXHQgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG5cdCAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUkMikpIHt9XG5cdCAgdGhpcy5faW5pdChvcHRpb25zKTtcblx0fVxuXG5cdGluaXRNaXhpbihWdWUkMik7XG5cdHN0YXRlTWl4aW4oVnVlJDIpO1xuXHRldmVudHNNaXhpbihWdWUkMik7XG5cdGxpZmVjeWNsZU1peGluKFZ1ZSQyKTtcblx0cmVuZGVyTWl4aW4oVnVlJDIpO1xuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuXHQgIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG5cdCAgICAgIHJldHVyblxuXHQgICAgfVxuXHQgICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG5cdCAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcblx0ICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcblx0ICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcblx0ICAgIH1cblx0ICAgIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlO1xuXHQgICAgcmV0dXJuIHRoaXNcblx0ICB9O1xuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuXHQgIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuXHQgICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuXHQgIH07XG5cdH1cblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcblx0ICAvKipcblx0ICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcblx0ICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG5cdCAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG5cdCAgICovXG5cdCAgVnVlLmNpZCA9IDA7XG5cdCAgdmFyIGNpZCA9IDE7XG5cblx0ICAvKipcblx0ICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuXHQgICAqL1xuXHQgIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuXHQgICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG5cdCAgICB2YXIgU3VwZXIgPSB0aGlzO1xuXHQgICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG5cdCAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuXHQgICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG5cdCAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuXHQgICAgfVxuXHQgICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuXHQgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHt9XG5cdCAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG5cdCAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG5cdCAgICB9O1xuXHQgICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcblx0ICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG5cdCAgICBTdWIuY2lkID0gY2lkKys7XG5cdCAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcblx0ICAgICAgU3VwZXIub3B0aW9ucyxcblx0ICAgICAgZXh0ZW5kT3B0aW9uc1xuXHQgICAgKTtcblx0ICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXHQgICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG5cdCAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuXHQgICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG5cdCAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXHQgICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuXHQgICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuXHQgICAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG5cdCAgICB9KTtcblx0ICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcblx0ICAgIGlmIChuYW1lKSB7XG5cdCAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG5cdCAgICB9XG5cdCAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuXHQgICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcblx0ICAgIC8vIGJlZW4gdXBkYXRlZC5cblx0ICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuXHQgICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuXHQgICAgLy8gY2FjaGUgY29uc3RydWN0b3Jcblx0ICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuXHQgICAgcmV0dXJuIFN1YlxuXHQgIH07XG5cdH1cblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuXHQgIC8qKlxuXHQgICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cblx0ICAgKi9cblx0ICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuXHQgICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuXHQgICAgICBpZCxcblx0ICAgICAgZGVmaW5pdGlvblxuXHQgICAgKSB7XG5cdCAgICAgIGlmICghZGVmaW5pdGlvbikge1xuXHQgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdCAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHt9XG5cdCAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcblx0ICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcblx0ICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcblx0ICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH0pO1xuXHR9XG5cblx0LyogICovXG5cblx0dmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cF07XG5cblx0ZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuXHQgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcblx0ICB9XG5cdH1cblxuXHR2YXIgS2VlcEFsaXZlID0ge1xuXHQgIG5hbWU6ICdrZWVwLWFsaXZlJyxcblx0ICBhYnN0cmFjdDogdHJ1ZSxcblx0ICBwcm9wczoge1xuXHQgICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuXHQgICAgZXhjbHVkZTogcGF0dGVyblR5cGVzXG5cdCAgfSxcblx0ICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcblx0ICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHQgIH0sXG5cdCAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuXHQgICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCh0aGlzLiRzbG90cy5kZWZhdWx0KTtcblx0ICAgIGlmICh2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zKSB7XG5cdCAgICAgIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcblx0ICAgICAgLy8gY2hlY2sgcGF0dGVyblxuXHQgICAgICB2YXIgbmFtZSA9IG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWc7XG5cdCAgICAgIGlmIChuYW1lICYmIChcblx0ICAgICAgICAodGhpcy5pbmNsdWRlICYmICFtYXRjaGVzKHRoaXMuaW5jbHVkZSwgbmFtZSkpIHx8XG5cdCAgICAgICAgKHRoaXMuZXhjbHVkZSAmJiBtYXRjaGVzKHRoaXMuZXhjbHVkZSwgbmFtZSkpXG5cdCAgICAgICkpIHtcblx0ICAgICAgICByZXR1cm4gdm5vZGVcblx0ICAgICAgfVxuXHQgICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcblx0ICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuXHQgICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcblx0ICAgICAgICA/IG9wdHMuQ3Rvci5jaWQgKyAob3B0cy50YWcgPyAoXCI6OlwiICsgKG9wdHMudGFnKSkgOiAnJylcblx0ICAgICAgICA6IHZub2RlLmtleTtcblx0ICAgICAgaWYgKHRoaXMuY2FjaGVba2V5XSkge1xuXHQgICAgICAgIHZub2RlLmNoaWxkID0gdGhpcy5jYWNoZVtrZXldLmNoaWxkO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuY2FjaGVba2V5XSA9IHZub2RlO1xuXHQgICAgICB9XG5cdCAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2bm9kZVxuXHQgIH0sXG5cdCAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNhY2hlKSB7XG5cdCAgICAgIHZhciB2bm9kZSA9IHRoaXMkMS5jYWNoZVtrZXldO1xuXHQgICAgICBjYWxsSG9vayh2bm9kZS5jaGlsZCwgJ2RlYWN0aXZhdGVkJyk7XG5cdCAgICAgIHZub2RlLmNoaWxkLiRkZXN0cm95KCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcblx0ICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxuXHR9O1xuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuXHQgIC8vIGNvbmZpZ1xuXHQgIHZhciBjb25maWdEZWYgPSB7fTtcblx0ICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuXHQgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7fVxuXHQgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXHQgIFZ1ZS51dGlsID0gdXRpbDtcblx0ICBWdWUuc2V0ID0gc2V0JDE7XG5cdCAgVnVlLmRlbGV0ZSA9IGRlbDtcblx0ICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuXHQgIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0ICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuXHQgICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHQgIH0pO1xuXG5cdCAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuXHQgIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuXHQgIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG5cdCAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuXHQgIGluaXRVc2UoVnVlKTtcblx0ICBpbml0TWl4aW4kMShWdWUpO1xuXHQgIGluaXRFeHRlbmQoVnVlKTtcblx0ICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcblx0fVxuXG5cdGluaXRHbG9iYWxBUEkoVnVlJDIpO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMi5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG5cdCAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xuXHR9KTtcblxuXHRWdWUkMi52ZXJzaW9uID0gJzIuMS44JztcblxuXHQvKiAgKi9cblxuXHQvLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG5cdHZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QnKTtcblx0dmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgYXR0cikge1xuXHQgIHJldHVybiAoXG5cdCAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSB8fFxuXHQgICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcblx0ICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuXHQgICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuXHQgIClcblx0fTtcblxuXHR2YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG5cdHZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcblx0ICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcblx0ICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuXHQgICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuXHQgICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuXHQgICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuXHQgICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuXHQpO1xuXG5cdHZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG5cdHZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG5cdH07XG5cblx0dmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG5cdH07XG5cblx0dmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG5cdCAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcblx0fTtcblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuXHQgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcblx0ICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuXHQgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcblx0ICB3aGlsZSAoY2hpbGROb2RlLmNoaWxkKSB7XG5cdCAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY2hpbGQuX3Zub2RlO1xuXHQgICAgaWYgKGNoaWxkTm9kZS5kYXRhKSB7XG5cdCAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuXHQgICAgaWYgKHBhcmVudE5vZGUuZGF0YSkge1xuXHQgICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIGdlbkNsYXNzRnJvbURhdGEoZGF0YSlcblx0fVxuXG5cdGZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG5cdCAgcmV0dXJuIHtcblx0ICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG5cdCAgICBjbGFzczogY2hpbGQuY2xhc3Ncblx0ICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cblx0ICAgICAgOiBwYXJlbnQuY2xhc3Ncblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBnZW5DbGFzc0Zyb21EYXRhIChkYXRhKSB7XG5cdCAgdmFyIGR5bmFtaWNDbGFzcyA9IGRhdGEuY2xhc3M7XG5cdCAgdmFyIHN0YXRpY0NsYXNzID0gZGF0YS5zdGF0aWNDbGFzcztcblx0ICBpZiAoc3RhdGljQ2xhc3MgfHwgZHluYW1pY0NsYXNzKSB7XG5cdCAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuXHQgIH1cblx0ICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHQgIHJldHVybiAnJ1xuXHR9XG5cblx0ZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG5cdCAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcblx0fVxuXG5cdGZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuXHQgIHZhciByZXMgPSAnJztcblx0ICBpZiAoIXZhbHVlKSB7XG5cdCAgICByZXR1cm4gcmVzXG5cdCAgfVxuXHQgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gdmFsdWVcblx0ICB9XG5cdCAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICB2YXIgc3RyaW5naWZpZWQ7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHQgICAgICBpZiAodmFsdWVbaV0pIHtcblx0ICAgICAgICBpZiAoKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSkge1xuXHQgICAgICAgICAgcmVzICs9IHN0cmluZ2lmaWVkICsgJyAnO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcblx0ICB9XG5cdCAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuXHQgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG5cdCAgICAgIGlmICh2YWx1ZVtrZXldKSB7IHJlcyArPSBrZXkgKyAnICc7IH1cblx0ICAgIH1cblx0ICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG5cdCAgfVxuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdCAgcmV0dXJuIHJlc1xuXHR9XG5cblx0LyogICovXG5cblx0dmFyIG5hbWVzcGFjZU1hcCA9IHtcblx0ICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdCAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG5cdH07XG5cblx0dmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG5cdCAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuXHQgICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG5cdCAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcblx0ICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuXHQgICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcblx0ICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG5cdCAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuXHQgICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuXHQgICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuXHQgICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG5cdCAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUnXG5cdCk7XG5cblx0Ly8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG5cdC8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG5cdHZhciBpc1NWRyA9IG1ha2VNYXAoXG5cdCAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLCcgK1xuXHQgICdmb250LWZhY2UsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuXHQgICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3Jyxcblx0ICB0cnVlXG5cdCk7XG5cblxuXG5cdHZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuXHQgIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG5cdH07XG5cblx0ZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcblx0ICBpZiAoaXNTVkcodGFnKSkge1xuXHQgICAgcmV0dXJuICdzdmcnXG5cdCAgfVxuXHQgIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuXHQgIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcblx0ICBpZiAodGFnID09PSAnbWF0aCcpIHtcblx0ICAgIHJldHVybiAnbWF0aCdcblx0ICB9XG5cdH1cblxuXHR2YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHQgIGlmICghaW5Ccm93c2VyKSB7XG5cdCAgICByZXR1cm4gdHJ1ZVxuXHQgIH1cblx0ICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG5cdCAgICByZXR1cm4gZmFsc2Vcblx0ICB9XG5cdCAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG5cdCAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdCAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG5cdCAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG5cdCAgfVxuXHQgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcblx0ICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG5cdCAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG5cdCAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcblx0ICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcblx0ICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuXHQgICAgKSlcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuXHQgIH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdC8qKlxuXHQgKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cblx0ICovXG5cdGZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuXHQgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG5cdCAgICB2YXIgc2VsZWN0b3IgPSBlbDtcblx0ICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG5cdCAgICBpZiAoIWVsKSB7XG5cdCAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQxKFxuXHQgICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgc2VsZWN0b3Jcblx0ICAgICAgKTtcblx0ICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBlbFxuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuXHQgIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuXHQgIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuXHQgICAgcmV0dXJuIGVsbVxuXHQgIH1cblx0ICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmICdtdWx0aXBsZScgaW4gdm5vZGUuZGF0YS5hdHRycykge1xuXHQgICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcblx0ICB9XG5cdCAgcmV0dXJuIGVsbVxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcblx0ICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcblx0ICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcblx0ICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxuXHR9XG5cblx0ZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG5cdCAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG5cdH1cblxuXHRmdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcblx0ICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuXHQgIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuXHQgIHJldHVybiBub2RlLnBhcmVudE5vZGVcblx0fVxuXG5cdGZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG5cdCAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcblx0fVxuXG5cdGZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcblx0ICByZXR1cm4gbm9kZS50YWdOYW1lXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuXHQgIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0QXR0cmlidXRlIChub2RlLCBrZXksIHZhbCkge1xuXHQgIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcblx0fVxuXG5cblx0dmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0XHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdFx0Y3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG5cdFx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRcdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdFx0aW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG5cdFx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRcdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0XHRwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuXHRcdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0XHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRcdHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblx0XHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZVxuXHR9KTtcblxuXHQvKiAgKi9cblxuXHR2YXIgcmVmID0ge1xuXHQgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuXHQgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuXHQgIH0sXG5cdCAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuXHQgICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuXHQgICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG5cdCAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG5cdCAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG5cdCAgfVxuXHR9O1xuXG5cdGZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG5cdCAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuXHQgIGlmICgha2V5KSB7IHJldHVybiB9XG5cblx0ICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuXHQgIHZhciByZWYgPSB2bm9kZS5jaGlsZCB8fCB2bm9kZS5lbG07XG5cdCAgdmFyIHJlZnMgPSB2bS4kcmVmcztcblx0ICBpZiAoaXNSZW1vdmFsKSB7XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG5cdCAgICAgIHJlbW92ZSQxKHJlZnNba2V5XSwgcmVmKTtcblx0ICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcblx0ICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuXHQgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pICYmIHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG5cdCAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmVmc1trZXldID0gcmVmO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcblx0ICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2Vcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG5cdCAqXG5cdCAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuXHQgKlxuXG5cdC8qXG5cdCAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3Rcblx0ICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG5cdCAqL1xuXG5cdHZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cblx0dmFyIGhvb2tzJDEgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuXHRmdW5jdGlvbiBpc1VuZGVmIChzKSB7XG5cdCAgcmV0dXJuIHMgPT0gbnVsbFxuXHR9XG5cblx0ZnVuY3Rpb24gaXNEZWYgKHMpIHtcblx0ICByZXR1cm4gcyAhPSBudWxsXG5cdH1cblxuXHRmdW5jdGlvbiBzYW1lVm5vZGUgKHZub2RlMSwgdm5vZGUyKSB7XG5cdCAgcmV0dXJuIChcblx0ICAgIHZub2RlMS5rZXkgPT09IHZub2RlMi5rZXkgJiZcblx0ICAgIHZub2RlMS50YWcgPT09IHZub2RlMi50YWcgJiZcblx0ICAgIHZub2RlMS5pc0NvbW1lbnQgPT09IHZub2RlMi5pc0NvbW1lbnQgJiZcblx0ICAgICF2bm9kZTEuZGF0YSA9PT0gIXZub2RlMi5kYXRhXG5cdCAgKVxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG5cdCAgdmFyIGksIGtleTtcblx0ICB2YXIgbWFwID0ge307XG5cdCAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcblx0ICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcblx0ICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuXHQgIH1cblx0ICByZXR1cm4gbWFwXG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG5cdCAgdmFyIGksIGo7XG5cdCAgdmFyIGNicyA9IHt9O1xuXG5cdCAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG5cdCAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cblx0ICBmb3IgKGkgPSAwOyBpIDwgaG9va3MkMS5sZW5ndGg7ICsraSkge1xuXHQgICAgY2JzW2hvb2tzJDFbaV1dID0gW107XG5cdCAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuXHQgICAgICBpZiAobW9kdWxlc1tqXVtob29rcyQxW2ldXSAhPT0gdW5kZWZpbmVkKSB7IGNic1tob29rcyQxW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3MkMVtpXV0pOyB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuXHQgICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcblx0ICAgIGZ1bmN0aW9uIHJlbW92ZSQkMSAoKSB7XG5cdCAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcblx0ICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcblx0ICAgIHJldHVybiByZW1vdmUkJDFcblx0ICB9XG5cblx0ICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuXHQgICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG5cdCAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcblx0ICAgIGlmIChwYXJlbnQpIHtcblx0ICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YXIgaW5QcmUgPSAwO1xuXHQgIGZ1bmN0aW9uIGNyZWF0ZUVsbSAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIG5lc3RlZCkge1xuXHQgICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcblx0ICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG5cdCAgICAgIHJldHVyblxuXHQgICAgfVxuXG5cdCAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG5cdCAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcblx0ICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG5cdCAgICBpZiAoaXNEZWYodGFnKSkge1xuXHQgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge31cblx0ICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcblx0ICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG5cdCAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG5cdCAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuXHQgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgICAge1xuXHQgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcblx0ICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcblx0ICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7fVxuXHQgICAgfSBlbHNlIGlmICh2bm9kZS5pc0NvbW1lbnQpIHtcblx0ICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuXHQgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuXHQgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuXHQgICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuXHQgICAgaWYgKGlzRGVmKGkpKSB7XG5cdCAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY2hpbGQpICYmIGkua2VlcEFsaXZlO1xuXHQgICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcblx0ICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcblx0ICAgICAgfVxuXHQgICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuXHQgICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcblx0ICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG5cdCAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG5cdCAgICAgIGlmIChpc0RlZih2bm9kZS5jaGlsZCkpIHtcblx0ICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXHQgICAgICAgIGlmIChpc1JlYWN0aXZhdGVkKSB7XG5cdCAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRydWVcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG5cdCAgICB2YXIgaTtcblx0ICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cblx0ICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcblx0ICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuXHQgICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cblx0ICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcblx0ICAgIHdoaWxlIChpbm5lck5vZGUuY2hpbGQpIHtcblx0ICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNoaWxkLl92bm9kZTtcblx0ICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuXHQgICAgICAgIGJyZWFrXG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuXHQgICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcblx0ICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYpIHtcblx0ICAgIGlmIChwYXJlbnQpIHtcblx0ICAgICAgaWYgKHJlZikge1xuXHQgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG5cdCAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcblx0ICAgIHdoaWxlICh2bm9kZS5jaGlsZCkge1xuXHQgICAgICB2bm9kZSA9IHZub2RlLmNoaWxkLl92bm9kZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcblx0ICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuXHQgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG5cdCAgICB9XG5cdCAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuXHQgICAgaWYgKGlzRGVmKGkpKSB7XG5cdCAgICAgIGlmIChpLmNyZWF0ZSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuXHQgICAgICBpZiAoaS5pbnNlcnQpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuXHQgICAgaWYgKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkge1xuXHQgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG5cdCAgICB9XG5cdCAgICB2bm9kZS5lbG0gPSB2bm9kZS5jaGlsZC4kZWw7XG5cdCAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG5cdCAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXHQgICAgICBzZXRTY29wZSh2bm9kZSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cblx0ICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuXHQgICAgICByZWdpc3RlclJlZih2bm9kZSk7XG5cdCAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG5cdCAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuXHQgIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG5cdCAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuXHQgIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuXHQgICAgdmFyIGk7XG5cdCAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuXHQgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcblx0ICAgIH1cblx0ICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG5cdCAgICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuXHQgICAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuXHQgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuXHQgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuXHQgICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG5cdCAgICB2YXIgaSwgajtcblx0ICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcblx0ICAgIGlmIChpc0RlZihkYXRhKSkge1xuXHQgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuXHQgICAgfVxuXHQgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcblx0ICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG5cdCAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuXHQgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuXHQgICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuXHQgICAgICBpZiAoaXNEZWYoY2gpKSB7XG5cdCAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcblx0ICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuXHQgICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuXHQgICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuXHQgICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuXHQgICAgaWYgKHJtIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG5cdCAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG5cdCAgICAgIGlmICghcm0pIHtcblx0ICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuXHQgICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG5cdCAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxuXHQgICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcblx0ICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZCkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG5cdCAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG5cdCAgICAgIH1cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcblx0ICAgICAgICBpKHZub2RlLCBybSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcm0oKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG5cdCAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xuXHQgICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcblx0ICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuXHQgICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcblx0ICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG5cdCAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcblx0ICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG5cdCAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuXHQgICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgZWxtVG9Nb3ZlLCByZWZFbG07XG5cblx0ICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuXHQgICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuXHQgICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcblx0ICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cblx0ICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG5cdCAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG5cdCAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG5cdCAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcblx0ICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcblx0ICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcblx0ICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG5cdCAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuXHQgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcblx0ICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuXHQgICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXHQgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuXHQgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuXHQgICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcblx0ICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXHQgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcblx0ICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG5cdCAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG5cdCAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG5cdCAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcblx0ICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG5cdCAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG5cdCAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuXHQgICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldIDogbnVsbDtcblx0ICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcblx0ICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuXHQgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG5cdCAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmICFlbG1Ub01vdmUpIHt9XG5cdCAgICAgICAgICBpZiAoc2FtZVZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcblx0ICAgICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG5cdCAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG5ld1N0YXJ0Vm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG5cdCAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcblx0ICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG5cdCAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuXHQgICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG5cdCAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG5cdCAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG5cdCAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBwYXRjaFZub2RlIChvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuXHQgICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuXHQgICAgICByZXR1cm5cblx0ICAgIH1cblx0ICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cblx0ICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuXHQgICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG5cdCAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuXHQgICAgaWYgKHZub2RlLmlzU3RhdGljICYmXG5cdCAgICAgICAgb2xkVm5vZGUuaXNTdGF0aWMgJiZcblx0ICAgICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuXHQgICAgICAgICh2bm9kZS5pc0Nsb25lZCB8fCB2bm9kZS5pc09uY2UpKSB7XG5cdCAgICAgIHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblx0ICAgICAgdm5vZGUuY2hpbGQgPSBvbGRWbm9kZS5jaGlsZDtcblx0ICAgICAgcmV0dXJuXG5cdCAgICB9XG5cdCAgICB2YXIgaTtcblx0ICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcblx0ICAgIHZhciBoYXNEYXRhID0gaXNEZWYoZGF0YSk7XG5cdCAgICBpZiAoaGFzRGF0YSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcblx0ICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuXHQgICAgfVxuXHQgICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblx0ICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuXHQgICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG5cdCAgICBpZiAoaGFzRGF0YSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcblx0ICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG5cdCAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuXHQgICAgfVxuXHQgICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcblx0ICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcblx0ICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG5cdCAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG5cdCAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cblx0ICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcblx0ICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcblx0ICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG5cdCAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcblx0ICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcblx0ICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuXHQgICAgfVxuXHQgICAgaWYgKGhhc0RhdGEpIHtcblx0ICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG5cdCAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcblx0ICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG5cdCAgICBpZiAoaW5pdGlhbCAmJiB2bm9kZS5wYXJlbnQpIHtcblx0ICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGJhaWxlZCA9IGZhbHNlO1xuXHQgIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG5cdCAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cblx0ICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLHN0eWxlLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG5cdCAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cblx0ICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcblx0ICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7fVxuXHQgICAgdm5vZGUuZWxtID0gZWxtO1xuXHQgICAgdmFyIHRhZyA9IHZub2RlLnRhZztcblx0ICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcblx0ICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuXHQgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG5cdCAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cblx0ICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZCkpIHtcblx0ICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cblx0ICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXHQgICAgICAgIHJldHVybiB0cnVlXG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChpc0RlZih0YWcpKSB7XG5cdCAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcblx0ICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cblx0ICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcblx0ICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuXHQgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuXHQgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuXHQgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcblx0ICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgYnJlYWtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG5cdCAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuXHQgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuXHQgICAgICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuXHQgICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG5cdCAgICAgICAgICAgICAgICAhYmFpbGVkKSB7fVxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2Vcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcblx0ICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG5cdCAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXHQgICAgICAgICAgICBicmVha1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuXHQgICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdHJ1ZVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUpIHtcblx0ICAgIGlmICh2bm9kZS50YWcpIHtcblx0ICAgICAgcmV0dXJuIChcblx0ICAgICAgICB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8XG5cdCAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG5cdCAgICAgIClcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcblx0ICAgIGlmICghdm5vZGUpIHtcblx0ICAgICAgaWYgKG9sZFZub2RlKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuXHQgICAgICByZXR1cm5cblx0ICAgIH1cblxuXHQgICAgdmFyIGVsbSwgcGFyZW50O1xuXHQgICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG5cdCAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cblx0ICAgIGlmICghb2xkVm5vZGUpIHtcblx0ICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuXHQgICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG5cdCAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcblx0ICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG5cdCAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG5cdCAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcblx0ICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG5cdCAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuXHQgICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cblx0ICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoJ3NlcnZlci1yZW5kZXJlZCcpKSB7XG5cdCAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZSgnc2VydmVyLXJlbmRlcmVkJyk7XG5cdCAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBpZiAoaHlkcmF0aW5nKSB7XG5cdCAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuXHQgICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge31cblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuXHQgICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcblx0ICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuXHQgICAgICAgIGVsbSA9IG9sZFZub2RlLmVsbTtcblx0ICAgICAgICBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWxtKTtcblx0ICAgICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50LCBub2RlT3BzLm5leHRTaWJsaW5nKGVsbSkpO1xuXG5cdCAgICAgICAgaWYgKHZub2RlLnBhcmVudCkge1xuXHQgICAgICAgICAgLy8gY29tcG9uZW50IHJvb3QgZWxlbWVudCByZXBsYWNlZC5cblx0ICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuXHQgICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuXHQgICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG5cdCAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcblx0ICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZS5wYXJlbnQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHBhcmVudCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudCwgW29sZFZub2RlXSwgMCwgMCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG5cdCAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuXHQgICAgcmV0dXJuIHZub2RlLmVsbVxuXHQgIH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciBkaXJlY3RpdmVzID0ge1xuXHQgIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcblx0ICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG5cdCAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcblx0ICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG5cdCAgfVxuXHR9O1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuXHQgIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG5cdCAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG5cdCAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcblx0ICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcblx0ICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuXHQgIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cblx0ICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcblx0ICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuXHQgIHZhciBrZXksIG9sZERpciwgZGlyO1xuXHQgIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcblx0ICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcblx0ICAgIGRpciA9IG5ld0RpcnNba2V5XTtcblx0ICAgIGlmICghb2xkRGlyKSB7XG5cdCAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcblx0ICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcblx0ICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuXHQgICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcblx0ICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuXHQgICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG5cdCAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuXHQgICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcblx0ICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcblx0ICAgICAgfVxuXHQgICAgfTtcblx0ICAgIGlmIChpc0NyZWF0ZSkge1xuXHQgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGNhbGxJbnNlcnQsICdkaXItaW5zZXJ0Jyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBjYWxsSW5zZXJ0KCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuXHQgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG5cdCAgICAgIH1cblx0ICAgIH0sICdkaXItcG9zdHBhdGNoJyk7XG5cdCAgfVxuXG5cdCAgaWYgKCFpc0NyZWF0ZSkge1xuXHQgICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuXHQgICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuXHQgICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcblx0ICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdHZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblx0ZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcblx0ICBkaXJzLFxuXHQgIHZtXG5cdCkge1xuXHQgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHQgIGlmICghZGlycykge1xuXHQgICAgcmV0dXJuIHJlc1xuXHQgIH1cblx0ICB2YXIgaSwgZGlyO1xuXHQgIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBkaXIgPSBkaXJzW2ldO1xuXHQgICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG5cdCAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcblx0ICAgIH1cblx0ICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuXHQgICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG5cdCAgfVxuXHQgIHJldHVybiByZXNcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuXHQgIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG5cdH1cblxuXHRmdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG5cdCAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuXHQgIGlmIChmbikge1xuXHQgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcblx0ICB9XG5cdH1cblxuXHR2YXIgYmFzZU1vZHVsZXMgPSBbXG5cdCAgcmVmLFxuXHQgIGRpcmVjdGl2ZXNcblx0XTtcblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG5cdCAgaWYgKCFvbGRWbm9kZS5kYXRhLmF0dHJzICYmICF2bm9kZS5kYXRhLmF0dHJzKSB7XG5cdCAgICByZXR1cm5cblx0ICB9XG5cdCAgdmFyIGtleSwgY3VyLCBvbGQ7XG5cdCAgdmFyIGVsbSA9IHZub2RlLmVsbTtcblx0ICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuXHQgIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG5cdCAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG5cdCAgaWYgKGF0dHJzLl9fb2JfXykge1xuXHQgICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG5cdCAgfVxuXG5cdCAgZm9yIChrZXkgaW4gYXR0cnMpIHtcblx0ICAgIGN1ciA9IGF0dHJzW2tleV07XG5cdCAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuXHQgICAgaWYgKG9sZCAhPT0gY3VyKSB7XG5cdCAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG5cdCAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdCAgaWYgKGlzSUU5ICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuXHQgICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcblx0ICB9XG5cdCAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcblx0ICAgIGlmIChhdHRyc1trZXldID09IG51bGwpIHtcblx0ICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuXHQgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG5cdCAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuXHQgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG5cdCAgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuXHQgICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcblx0ICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG5cdCAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcblx0ICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBrZXkpO1xuXHQgICAgfVxuXHQgIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG5cdCAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdmYWxzZScgOiAndHJ1ZScpO1xuXHQgIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG5cdCAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcblx0ICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuXHQgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHR2YXIgYXR0cnMgPSB7XG5cdCAgY3JlYXRlOiB1cGRhdGVBdHRycyxcblx0ICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG5cdH07XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuXHQgIHZhciBlbCA9IHZub2RlLmVsbTtcblx0ICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG5cdCAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXHQgIGlmICghZGF0YS5zdGF0aWNDbGFzcyAmJiAhZGF0YS5jbGFzcyAmJlxuXHQgICAgICAoIW9sZERhdGEgfHwgKCFvbGREYXRhLnN0YXRpY0NsYXNzICYmICFvbGREYXRhLmNsYXNzKSkpIHtcblx0ICAgIHJldHVyblxuXHQgIH1cblxuXHQgIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuXHQgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcblx0ICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuXHQgIGlmICh0cmFuc2l0aW9uQ2xhc3MpIHtcblx0ICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuXHQgIH1cblxuXHQgIC8vIHNldCB0aGUgY2xhc3Ncblx0ICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG5cdCAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcblx0ICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG5cdCAgfVxuXHR9XG5cblx0dmFyIGtsYXNzID0ge1xuXHQgIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG5cdCAgdXBkYXRlOiB1cGRhdGVDbGFzc1xuXHR9O1xuXG5cdC8qICAqL1xuXG5cdHZhciB0YXJnZXQkMTtcblxuXHRmdW5jdGlvbiBhZGQkMiAoZXZlbnQsIGhhbmRsZXIsIG9uY2UsIGNhcHR1cmUpIHtcblx0ICBpZiAob25jZSkge1xuXHQgICAgdmFyIG9sZEhhbmRsZXIgPSBoYW5kbGVyO1xuXHQgICAgaGFuZGxlciA9IGZ1bmN0aW9uIChldikge1xuXHQgICAgICByZW1vdmUkMyhldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG5cdCAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDFcblx0ICAgICAgICA/IG9sZEhhbmRsZXIoZXYpXG5cdCAgICAgICAgOiBvbGRIYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdCAgICB9O1xuXHQgIH1cblx0ICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlbW92ZSQzIChldmVudCwgaGFuZGxlciwgY2FwdHVyZSkge1xuXHQgIHRhcmdldCQxLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcblx0ICBpZiAoIW9sZFZub2RlLmRhdGEub24gJiYgIXZub2RlLmRhdGEub24pIHtcblx0ICAgIHJldHVyblxuXHQgIH1cblx0ICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuXHQgIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG5cdCAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG5cdCAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDIsIHJlbW92ZSQzLCB2bm9kZS5jb250ZXh0KTtcblx0fVxuXG5cdHZhciBldmVudHMgPSB7XG5cdCAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG5cdCAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcblx0fTtcblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG5cdCAgaWYgKCFvbGRWbm9kZS5kYXRhLmRvbVByb3BzICYmICF2bm9kZS5kYXRhLmRvbVByb3BzKSB7XG5cdCAgICByZXR1cm5cblx0ICB9XG5cdCAgdmFyIGtleSwgY3VyO1xuXHQgIHZhciBlbG0gPSB2bm9kZS5lbG07XG5cdCAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcblx0ICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuXHQgIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuXHQgIGlmIChwcm9wcy5fX29iX18pIHtcblx0ICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuXHQgIH1cblxuXHQgIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG5cdCAgICBpZiAocHJvcHNba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgIGVsbVtrZXldID0gJyc7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGZvciAoa2V5IGluIHByb3BzKSB7XG5cdCAgICBjdXIgPSBwcm9wc1trZXldO1xuXHQgICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG5cdCAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuXHQgICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcblx0ICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuXHQgICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuXHQgICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cblx0ICAgIH1cblx0ICAgIC8vICM0NTIxOiBpZiBhIGNsaWNrIGV2ZW50IHRyaWdnZXJzIHVwZGF0ZSBiZWZvcmUgdGhlIGNoYW5nZSBldmVudCBpc1xuXHQgICAgLy8gZGlzcGF0Y2hlZCBvbiBhIGNoZWNrYm94L3JhZGlvIGlucHV0LCB0aGUgaW5wdXQncyBjaGVja2VkIHN0YXRlIHdpbGxcblx0ICAgIC8vIGJlIHJlc2V0IGFuZCBmYWlsIHRvIHRyaWdnZXIgYW5vdGhlciB1cGRhdGUuXG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHQgICAgaWYgKGtleSA9PT0gJ2NoZWNrZWQnICYmICFpc0RpcnR5KGVsbSwgY3VyKSkge1xuXHQgICAgICBjb250aW51ZVxuXHQgICAgfVxuXHQgICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuXHQgICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuXHQgICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG5cdCAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG5cdCAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuXHQgICAgICB2YXIgc3RyQ3VyID0gY3VyID09IG51bGwgPyAnJyA6IFN0cmluZyhjdXIpO1xuXHQgICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCB2bm9kZSwgc3RyQ3VyKSkge1xuXHQgICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZWxtW2tleV0gPSBjdXI7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0Ly8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuXHRmdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoXG5cdCAgZWxtLFxuXHQgIHZub2RlLFxuXHQgIGNoZWNrVmFsXG5cdCkge1xuXHQgIGlmICghZWxtLmNvbXBvc2luZyAmJiAoXG5cdCAgICB2bm9kZS50YWcgPT09ICdvcHRpb24nIHx8XG5cdCAgICBpc0RpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG5cdCAgICBpc0lucHV0Q2hhbmdlZCh2bm9kZSwgY2hlY2tWYWwpXG5cdCAgKSkge1xuXHQgICAgcmV0dXJuIHRydWVcblx0ICB9XG5cdCAgcmV0dXJuIGZhbHNlXG5cdH1cblxuXHRmdW5jdGlvbiBpc0RpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG5cdCAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbSAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG5cdH1cblxuXHRmdW5jdGlvbiBpc0lucHV0Q2hhbmdlZCAodm5vZGUsIG5ld1ZhbCkge1xuXHQgIHZhciB2YWx1ZSA9IHZub2RlLmVsbS52YWx1ZTtcblx0ICB2YXIgbW9kaWZpZXJzID0gdm5vZGUuZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcblx0ICBpZiAoKG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyKSB8fCB2bm9kZS5lbG0udHlwZSA9PT0gJ251bWJlcicpIHtcblx0ICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcblx0ICB9XG5cdCAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMudHJpbSkge1xuXHQgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuXHQgIH1cblx0ICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxuXHR9XG5cblx0dmFyIGRvbVByb3BzID0ge1xuXHQgIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG5cdCAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xuXHR9O1xuXG5cdC8qICAqL1xuXG5cdHZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuXHQgIHZhciByZXMgPSB7fTtcblx0ICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG5cdCAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcblx0ICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcblx0ICAgIGlmIChpdGVtKSB7XG5cdCAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcblx0ICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHQgIHJldHVybiByZXNcblx0fSk7XG5cblx0Ly8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcblx0ZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG5cdCAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuXHQgIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuXHQgIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG5cdCAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcblx0ICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuXHQgICAgOiBzdHlsZVxuXHR9XG5cblx0Ly8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuXHRmdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuXHQgIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcblx0ICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG5cdCAgfVxuXHQgIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcblx0ICB9XG5cdCAgcmV0dXJuIGJpbmRpbmdTdHlsZVxuXHR9XG5cblx0LyoqXG5cdCAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3Ncblx0ICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcblx0ICovXG5cdGZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuXHQgIHZhciByZXMgPSB7fTtcblx0ICB2YXIgc3R5bGVEYXRhO1xuXG5cdCAgaWYgKGNoZWNrQ2hpbGQpIHtcblx0ICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcblx0ICAgIHdoaWxlIChjaGlsZE5vZGUuY2hpbGQpIHtcblx0ICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNoaWxkLl92bm9kZTtcblx0ICAgICAgaWYgKGNoaWxkTm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xuXHQgICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcblx0ICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG5cdCAgfVxuXG5cdCAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcblx0ICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcblx0ICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuXHQgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzXG5cdH1cblxuXHQvKiAgKi9cblxuXHR2YXIgY3NzVmFyUkUgPSAvXi0tLztcblx0dmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG5cdHZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcblx0ICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuXHQgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcblx0ICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuXHQgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBlbC5zdHlsZVtub3JtYWxpemUobmFtZSldID0gdmFsO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxuXHR2YXIgdGVzdEVsO1xuXHR2YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG5cdCAgdGVzdEVsID0gdGVzdEVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcblx0ICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gdGVzdEVsLnN0eWxlKSkge1xuXHQgICAgcmV0dXJuIHByb3Bcblx0ICB9XG5cdCAgdmFyIHVwcGVyID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyB1cHBlcjtcblx0ICAgIGlmIChwcmVmaXhlZCBpbiB0ZXN0RWwuc3R5bGUpIHtcblx0ICAgICAgcmV0dXJuIHByZWZpeGVkXG5cdCAgICB9XG5cdCAgfVxuXHR9KTtcblxuXHRmdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG5cdCAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuXHQgIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuXHQgIGlmICghZGF0YS5zdGF0aWNTdHlsZSAmJiAhZGF0YS5zdHlsZSAmJlxuXHQgICAgICAhb2xkRGF0YS5zdGF0aWNTdHlsZSAmJiAhb2xkRGF0YS5zdHlsZSkge1xuXHQgICAgcmV0dXJuXG5cdCAgfVxuXG5cdCAgdmFyIGN1ciwgbmFtZTtcblx0ICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cdCAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkVm5vZGUuZGF0YS5zdGF0aWNTdHlsZTtcblx0ICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkVm5vZGUuZGF0YS5zdHlsZSB8fCB7fTtcblxuXHQgIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG5cdCAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG5cdCAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG5cdCAgdm5vZGUuZGF0YS5zdHlsZSA9IHN0eWxlLl9fb2JfXyA/IGV4dGVuZCh7fSwgc3R5bGUpIDogc3R5bGU7XG5cblx0ICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cblx0ICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcblx0ICAgIGlmIChuZXdTdHlsZVtuYW1lXSA9PSBudWxsKSB7XG5cdCAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG5cdCAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcblx0ICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG5cdCAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG5cdCAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdHZhciBzdHlsZSA9IHtcblx0ICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuXHQgIHVwZGF0ZTogdXBkYXRlU3R5bGVcblx0fTtcblxuXHQvKiAgKi9cblxuXHQvKipcblx0ICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG5cdCAqIFNWRyBlbGVtZW50cyBpbiBJRVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcblx0ICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICBpZiAoIWNscyB8fCAhY2xzLnRyaW0oKSkge1xuXHQgICAgcmV0dXJuXG5cdCAgfVxuXG5cdCAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0ICBpZiAoZWwuY2xhc3NMaXN0KSB7XG5cdCAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG5cdCAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgY3VyID0gJyAnICsgZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpICsgJyAnO1xuXHQgICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG5cdCAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cblx0ICogU1ZHIGVsZW1lbnRzIGluIElFXG5cdCAqL1xuXHRmdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHQgIGlmICghY2xzIHx8ICFjbHMudHJpbSgpKSB7XG5cdCAgICByZXR1cm5cblx0ICB9XG5cblx0ICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXHQgIGlmIChlbC5jbGFzc0xpc3QpIHtcblx0ICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcblx0ICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciBjdXIgPSAnICcgKyBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgKyAnICc7XG5cdCAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuXHQgICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuXHQgICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG5cdCAgICB9XG5cdCAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyLnRyaW0oKSk7XG5cdCAgfVxuXHR9XG5cblx0LyogICovXG5cblx0dmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xuXHR2YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcblx0dmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG5cdC8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcblx0dmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xuXHR2YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xuXHR2YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xuXHR2YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcblx0aWYgKGhhc1RyYW5zaXRpb24pIHtcblx0ICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG5cdCAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcblx0ICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuXHQgICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuXHQgIH1cblx0ICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcblx0ICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG5cdCAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuXHQgIH1cblx0fVxuXG5cdHZhciByYWYgPSAoaW5Ccm93c2VyICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHx8IHNldFRpbWVvdXQ7XG5cdGZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcblx0ICByYWYoZnVuY3Rpb24gKCkge1xuXHQgICAgcmFmKGZuKTtcblx0ICB9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuXHQgIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKSkucHVzaChjbHMpO1xuXHQgIGFkZENsYXNzKGVsLCBjbHMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG5cdCAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuXHQgICAgcmVtb3ZlJDEoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuXHQgIH1cblx0ICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG5cdCAgZWwsXG5cdCAgZXhwZWN0ZWRUeXBlLFxuXHQgIGNiXG5cdCkge1xuXHQgIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcblx0ICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuXHQgIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG5cdCAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG5cdCAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cblx0ICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG5cdCAgdmFyIGVuZGVkID0gMDtcblx0ICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuXHQgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuXHQgICAgY2IoKTtcblx0ICB9O1xuXHQgIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG5cdCAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuXHQgICAgICAgIGVuZCgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0ICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuXHQgICAgICBlbmQoKTtcblx0ICAgIH1cblx0ICB9LCB0aW1lb3V0ICsgMSk7XG5cdCAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuXHR9XG5cblx0dmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuXHRmdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuXHQgIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cdCAgdmFyIHRyYW5zaXRpb25lRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG5cdCAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcblx0ICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25lRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcblx0ICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcblx0ICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcblx0ICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG5cdCAgdmFyIHR5cGU7XG5cdCAgdmFyIHRpbWVvdXQgPSAwO1xuXHQgIHZhciBwcm9wQ291bnQgPSAwO1xuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHQgIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcblx0ICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcblx0ICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG5cdCAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcblx0ICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG5cdCAgICB9XG5cdCAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuXHQgICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG5cdCAgICAgIHR5cGUgPSBBTklNQVRJT047XG5cdCAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuXHQgICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuXHQgICAgdHlwZSA9IHRpbWVvdXQgPiAwXG5cdCAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG5cdCAgICAgICAgPyBUUkFOU0lUSU9OXG5cdCAgICAgICAgOiBBTklNQVRJT05cblx0ICAgICAgOiBudWxsO1xuXHQgICAgcHJvcENvdW50ID0gdHlwZVxuXHQgICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cblx0ICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG5cdCAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG5cdCAgICAgIDogMDtcblx0ICB9XG5cdCAgdmFyIGhhc1RyYW5zZm9ybSA9XG5cdCAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG5cdCAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcblx0ICByZXR1cm4ge1xuXHQgICAgdHlwZTogdHlwZSxcblx0ICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG5cdCAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcblx0ICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcblx0ICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHQgIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuXHQgICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuXHQgIH1cblxuXHQgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG5cdCAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuXHQgIH0pKVxuXHR9XG5cblx0ZnVuY3Rpb24gdG9NcyAocykge1xuXHQgIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG5cdCAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG5cdCAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcblx0ICBpZiAoZWwuX2xlYXZlQ2IpIHtcblx0ICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG5cdCAgICBlbC5fbGVhdmVDYigpO1xuXHQgIH1cblxuXHQgIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcblx0ICBpZiAoIWRhdGEpIHtcblx0ICAgIHJldHVyblxuXHQgIH1cblxuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHQgIGlmIChlbC5fZW50ZXJDYiB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuXHQgICAgcmV0dXJuXG5cdCAgfVxuXG5cdCAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuXHQgIHZhciB0eXBlID0gZGF0YS50eXBlO1xuXHQgIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuXHQgIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcblx0ICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcblx0ICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuXHQgIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuXHQgIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG5cdCAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcblx0ICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuXHQgIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuXHQgIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG5cdCAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuXHQgIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcblx0ICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuXHQgIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcblxuXHQgIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcblx0ICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcblx0ICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuXHQgIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuXHQgIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG5cdCAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuXHQgIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcblx0ICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuXHQgICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG5cdCAgfVxuXG5cdCAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG5cdCAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuXHQgICAgcmV0dXJuXG5cdCAgfVxuXG5cdCAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciA/IGFwcGVhckNsYXNzIDogZW50ZXJDbGFzcztcblx0ICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciA/IGFwcGVhckFjdGl2ZUNsYXNzIDogZW50ZXJBY3RpdmVDbGFzcztcblx0ICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcztcblx0ICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXIgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKSA6IGJlZm9yZUVudGVyO1xuXHQgIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhciA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpIDogZW50ZXI7XG5cdCAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXIgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcikgOiBhZnRlckVudGVyO1xuXHQgIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhciA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpIDogZW50ZXJDYW5jZWxsZWQ7XG5cblx0ICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuXHQgIHZhciB1c2VyV2FudHNDb250cm9sID1cblx0ICAgIGVudGVySG9vayAmJlxuXHQgICAgLy8gZW50ZXJIb29rIG1heSBiZSBhIGJvdW5kIG1ldGhvZCB3aGljaCBleHBvc2VzXG5cdCAgICAvLyB0aGUgbGVuZ3RoIG9mIG9yaWdpbmFsIGZuIGFzIF9sZW5ndGhcblx0ICAgIChlbnRlckhvb2suX2xlbmd0aCB8fCBlbnRlckhvb2subGVuZ3RoKSA+IDE7XG5cblx0ICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKGV4cGVjdHNDU1MpIHtcblx0ICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcblx0ICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG5cdCAgICB9XG5cdCAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG5cdCAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG5cdCAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcblx0ICAgICAgfVxuXHQgICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcblx0ICAgIH1cblx0ICAgIGVsLl9lbnRlckNiID0gbnVsbDtcblx0ICB9KTtcblxuXHQgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG5cdCAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuXHQgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuXHQgICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuXHQgICAgICBpZiAocGVuZGluZ05vZGUgJiZcblx0ICAgICAgICAgIHBlbmRpbmdOb2RlLmNvbnRleHQgPT09IHZub2RlLmNvbnRleHQgJiZcblx0ICAgICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG5cdCAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IpIHtcblx0ICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcblx0ICAgICAgfVxuXHQgICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG5cdCAgICB9LCAndHJhbnNpdGlvbi1pbnNlcnQnKTtcblx0ICB9XG5cblx0ICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG5cdCAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG5cdCAgaWYgKGV4cGVjdHNDU1MpIHtcblx0ICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG5cdCAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcblx0ICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG5cdCAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG5cdCAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG5cdCAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcblx0ICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuXHQgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuXHQgIH1cblxuXHQgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuXHQgICAgY2IoKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG5cdCAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG5cdCAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcblx0ICBpZiAoZWwuX2VudGVyQ2IpIHtcblx0ICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG5cdCAgICBlbC5fZW50ZXJDYigpO1xuXHQgIH1cblxuXHQgIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcblx0ICBpZiAoIWRhdGEpIHtcblx0ICAgIHJldHVybiBybSgpXG5cdCAgfVxuXG5cdCAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdCAgaWYgKGVsLl9sZWF2ZUNiIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG5cdCAgICByZXR1cm5cblx0ICB9XG5cblx0ICB2YXIgY3NzID0gZGF0YS5jc3M7XG5cdCAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG5cdCAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG5cdCAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuXHQgIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuXHQgIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG5cdCAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcblx0ICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcblx0ICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuXHQgIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuXG5cdCAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcblx0ICB2YXIgdXNlcldhbnRzQ29udHJvbCA9XG5cdCAgICBsZWF2ZSAmJlxuXHQgICAgLy8gbGVhdmUgaG9vayBtYXkgYmUgYSBib3VuZCBtZXRob2Qgd2hpY2ggZXhwb3Nlc1xuXHQgICAgLy8gdGhlIGxlbmd0aCBvZiBvcmlnaW5hbCBmbiBhcyBfbGVuZ3RoXG5cdCAgICAobGVhdmUuX2xlbmd0aCB8fCBsZWF2ZS5sZW5ndGgpID4gMTtcblxuXHQgIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG5cdCAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG5cdCAgICB9XG5cdCAgICBpZiAoZXhwZWN0c0NTUykge1xuXHQgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG5cdCAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG5cdCAgICB9XG5cdCAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG5cdCAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG5cdCAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcblx0ICAgICAgfVxuXHQgICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBybSgpO1xuXHQgICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuXHQgICAgfVxuXHQgICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuXHQgIH0pO1xuXG5cdCAgaWYgKGRlbGF5TGVhdmUpIHtcblx0ICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgcGVyZm9ybUxlYXZlKCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcblx0ICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcblx0ICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcblx0ICAgICAgcmV0dXJuXG5cdCAgICB9XG5cdCAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG5cdCAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuXHQgICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbdm5vZGUua2V5XSA9IHZub2RlO1xuXHQgICAgfVxuXHQgICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuXHQgICAgaWYgKGV4cGVjdHNDU1MpIHtcblx0ICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcblx0ICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcblx0ICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG5cdCAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcblx0ICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuXHQgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG5cdCAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcblx0ICAgICAgY2IoKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG5cdCAgaWYgKCFkZWYkJDEpIHtcblx0ICAgIHJldHVyblxuXHQgIH1cblx0ICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXHQgIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuXHQgICAgdmFyIHJlcyA9IHt9O1xuXHQgICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG5cdCAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMS5uYW1lIHx8ICd2JykpO1xuXHQgICAgfVxuXHQgICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcblx0ICAgIHJldHVybiByZXNcblx0ICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuXHQgIH1cblx0fVxuXG5cdHZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuXHQgIHJldHVybiB7XG5cdCAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuXHQgICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcblx0ICAgIGFwcGVhckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuXHQgICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuXHQgICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuXHQgICAgYXBwZWFyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcblx0ICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuXHQgICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIiksXG5cdCAgICBhcHBlYXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIilcblx0ICB9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIG9uY2UgKGZuKSB7XG5cdCAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuXHQgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoIWNhbGxlZCkge1xuXHQgICAgICBjYWxsZWQgPSB0cnVlO1xuXHQgICAgICBmbigpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcblx0ICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuXHQgICAgZW50ZXIodm5vZGUpO1xuXHQgIH1cblx0fVxuXG5cdHZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuXHQgIGNyZWF0ZTogX2VudGVyLFxuXHQgIGFjdGl2YXRlOiBfZW50ZXIsXG5cdCAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUgKHZub2RlLCBybSkge1xuXHQgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0ICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG5cdCAgICAgIGxlYXZlKHZub2RlLCBybSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBybSgpO1xuXHQgICAgfVxuXHQgIH1cblx0fSA6IHt9O1xuXG5cdHZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG5cdCAgYXR0cnMsXG5cdCAga2xhc3MsXG5cdCAgZXZlbnRzLFxuXHQgIGRvbVByb3BzLFxuXHQgIHN0eWxlLFxuXHQgIHRyYW5zaXRpb25cblx0XTtcblxuXHQvKiAgKi9cblxuXHQvLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcblx0Ly8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cblx0dmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxuXHR2YXIgcGF0Y2gkMSA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRpZiAoaXNJRTkpIHtcblx0ICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cblx0ICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHQgICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuXHQgICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcblx0ICAgIH1cblx0ICB9KTtcblx0fVxuXG5cdHZhciBtb2RlbCA9IHtcblx0ICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuXHQgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHt9XG5cdCAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuXHQgICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuXHQgICAgICB9O1xuXHQgICAgICBjYigpO1xuXHQgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG5cdCAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGVsLnR5cGUgPT09ICd0ZXh0Jykge1xuXHQgICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuXHQgICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcblx0ICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuXHQgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG5cdCAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgICAgICBpZiAoaXNJRTkpIHtcblx0ICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcblx0ICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG5cdCAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcblx0ICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG5cdCAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cblx0ICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG5cdCAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuXHQgICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcblx0ICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBlbC5vcHRpb25zKTsgfSlcblx0ICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBlbC5vcHRpb25zKTtcblx0ICAgICAgaWYgKG5lZWRSZXNldCkge1xuXHQgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fTtcblxuXHRmdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG5cdCAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcblx0ICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuXHQgIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHQgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDEoXG5cdCAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG5cdCAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuXHQgICAgICB2bVxuXHQgICAgKTtcblx0ICAgIHJldHVyblxuXHQgIH1cblx0ICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdCAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuXHQgICAgaWYgKGlzTXVsdGlwbGUpIHtcblx0ICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG5cdCAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG5cdCAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuXHQgICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG5cdCAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuXG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgaWYgKCFpc011bHRpcGxlKSB7XG5cdCAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IG9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdCAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb25zW2ldKSwgdmFsdWUpKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZVxuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gdHJ1ZVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuXHQgIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cblx0ICAgID8gb3B0aW9uLl92YWx1ZVxuXHQgICAgOiBvcHRpb24udmFsdWVcblx0fVxuXG5cdGZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuXHQgIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG5cdH1cblxuXHRmdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG5cdCAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG5cdCAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG5cdH1cblxuXHRmdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuXHQgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcblx0ICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcblx0ICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xuXHR9XG5cblx0LyogICovXG5cblx0Ly8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuXHRmdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuXHQgIHJldHVybiB2bm9kZS5jaGlsZCAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcblx0ICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jaGlsZC5fdm5vZGUpXG5cdCAgICA6IHZub2RlXG5cdH1cblxuXHR2YXIgc2hvdyA9IHtcblx0ICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuXHQgICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG5cdCAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuXHQgICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcblx0ICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuXHQgICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG5cdCAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiAmJiAhaXNJRTkpIHtcblx0ICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcblx0ICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuXHQgICAgICB9KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcblx0ICAgIH1cblx0ICB9LFxuXG5cdCAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG5cdCAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cdCAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cblx0ICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHQgICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgeyByZXR1cm4gfVxuXHQgICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcblx0ICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG5cdCAgICBpZiAodHJhbnNpdGlvbiAmJiAhaXNJRTkpIHtcblx0ICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcblx0ICAgICAgaWYgKHZhbHVlKSB7XG5cdCAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcblx0ICAgIH1cblx0ICB9LFxuXG5cdCAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuXHQgICAgZWwsXG5cdCAgICBiaW5kaW5nLFxuXHQgICAgdm5vZGUsXG5cdCAgICBvbGRWbm9kZSxcblx0ICAgIGlzRGVzdHJveVxuXHQgICkge1xuXHQgICAgaWYgKCFpc0Rlc3Ryb3kpIHtcblx0ICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0dmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcblx0ICBtb2RlbDogbW9kZWwsXG5cdCAgc2hvdzogc2hvd1xuXHR9O1xuXG5cdC8qICAqL1xuXG5cdC8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG5cdC8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG5cdHZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG5cdCAgbmFtZTogU3RyaW5nLFxuXHQgIGFwcGVhcjogQm9vbGVhbixcblx0ICBjc3M6IEJvb2xlYW4sXG5cdCAgbW9kZTogU3RyaW5nLFxuXHQgIHR5cGU6IFN0cmluZyxcblx0ICBlbnRlckNsYXNzOiBTdHJpbmcsXG5cdCAgbGVhdmVDbGFzczogU3RyaW5nLFxuXHQgIGVudGVyVG9DbGFzczogU3RyaW5nLFxuXHQgIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuXHQgIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcblx0ICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG5cdCAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcblx0ICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuXHQgIGFwcGVhclRvQ2xhc3M6IFN0cmluZ1xuXHR9O1xuXG5cdC8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuXHQvLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuXHRmdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG5cdCAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcblx0ICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG5cdCAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gdm5vZGVcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcblx0ICB2YXIgZGF0YSA9IHt9O1xuXHQgIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcblx0ICAvLyBwcm9wc1xuXHQgIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuXHQgICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuXHQgIH1cblx0ICAvLyBldmVudHMuXG5cdCAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG5cdCAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcblx0ICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcblx0ICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV0uZm47XG5cdCAgfVxuXHQgIHJldHVybiBkYXRhXG5cdH1cblxuXHRmdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcblx0ICByZXR1cm4gL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpXG5cdCAgICA/IGgoJ2tlZXAtYWxpdmUnKVxuXHQgICAgOiBudWxsXG5cdH1cblxuXHRmdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuXHQgIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG5cdCAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG5cdCAgICAgIHJldHVybiB0cnVlXG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuXHQgIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xuXHR9XG5cblx0dmFyIFRyYW5zaXRpb24gPSB7XG5cdCAgbmFtZTogJ3RyYW5zaXRpb24nLFxuXHQgIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG5cdCAgYWJzdHJhY3Q6IHRydWUsXG5cdCAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuXHQgICAgaWYgKCFjaGlsZHJlbikge1xuXHQgICAgICByZXR1cm5cblx0ICAgIH1cblxuXHQgICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcblx0ICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZzsgfSk7XG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdCAgICAgIHJldHVyblxuXHQgICAgfVxuXG5cdCAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG5cdCAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7fVxuXG5cdCAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuXHQgICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcblx0ICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG5cdCAgICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJykge31cblxuXHQgICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cblx0ICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3Ncblx0ICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuXHQgICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG5cdCAgICAgIHJldHVybiByYXdDaGlsZFxuXHQgICAgfVxuXG5cdCAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcblx0ICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcblx0ICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgIGlmICghY2hpbGQpIHtcblx0ICAgICAgcmV0dXJuIHJhd0NoaWxkXG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG5cdCAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcblx0ICAgIH1cblxuXHQgICAgdmFyIGtleSA9IGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsIHx8IGNoaWxkLmlzU3RhdGljXG5cdCAgICAgID8gKFwiX192XCIgKyAoY2hpbGQudGFnICsgdGhpcy5fdWlkKSArIFwiX19cIilcblx0ICAgICAgOiBjaGlsZC5rZXk7XG5cdCAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXHQgICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG5cdCAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG5cdCAgICAvLyBtYXJrIHYtc2hvd1xuXHQgICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG5cdCAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcblx0ICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKG9sZENoaWxkICYmIG9sZENoaWxkLmRhdGEgJiYgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkpIHtcblx0ICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG5cdCAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcblx0ICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZCAmJiAob2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKSk7XG5cdCAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcblx0ICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG5cdCAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG5cdCAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG5cdCAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcblx0ICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcblx0ICAgICAgICB9LCBrZXkpO1xuXHQgICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcblx0ICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuXHQgICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG5cdCAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG5cdCAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUsIGtleSk7XG5cdCAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlLCBrZXkpO1xuXHQgICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7XG5cdCAgICAgICAgICBkZWxheWVkTGVhdmUgPSBsZWF2ZTtcblx0ICAgICAgICB9LCBrZXkpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByYXdDaGlsZFxuXHQgIH1cblx0fTtcblxuXHQvKiAgKi9cblxuXHQvLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXG5cdC8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG5cdC8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cblx0Ly8gaXQgZG9lc24ndCBndWFyYW50ZWUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHJlbW92ZWQgZWxlbWVudHMsXG5cdC8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG5cdC8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuXHQvLyB0cmlnZ2VyaW5nIHRoZWlyIGxlYXZpbmcgdHJhbnNpdGlvbjsgaW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBpbnNlcnQvbW92ZVxuXHQvLyBpbnRvIHRoZSBmaW5hbCBkaXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuXHQvLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxuXHR2YXIgcHJvcHMgPSBleHRlbmQoe1xuXHQgIHRhZzogU3RyaW5nLFxuXHQgIG1vdmVDbGFzczogU3RyaW5nXG5cdH0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cblx0ZGVsZXRlIHByb3BzLm1vZGU7XG5cblx0dmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcblx0ICBwcm9wczogcHJvcHMsXG5cblx0ICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuXHQgICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcblx0ICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHQgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblx0ICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG5cdCAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG5cdCAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcblx0ICAgICAgaWYgKGMudGFnKSB7XG5cdCAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcblx0ICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG5cdCAgICAgICAgICBtYXBbYy5rZXldID0gY1xuXHQgICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge31cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAocHJldkNoaWxkcmVuKSB7XG5cdCAgICAgIHZhciBrZXB0ID0gW107XG5cdCAgICAgIHZhciByZW1vdmVkID0gW107XG5cdCAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG5cdCAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuXHQgICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcblx0ICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHQgICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcblx0ICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuXHQgICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuXHQgIH0sXG5cblx0ICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG5cdCAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG5cdCAgICB0aGlzLl9fcGF0Y2hfXyhcblx0ICAgICAgdGhpcy5fdm5vZGUsXG5cdCAgICAgIHRoaXMua2VwdCxcblx0ICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuXHQgICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3Zlcylcblx0ICAgICk7XG5cdCAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcblx0ICB9LFxuXG5cdCAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG5cdCAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcblx0ICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG5cdCAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuXHQgICAgICByZXR1cm5cblx0ICAgIH1cblxuXHQgICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG5cdCAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cblx0ICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuXHQgICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG5cdCAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG5cdCAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cblx0ICAgIHZhciBmID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXHQgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuXHQgICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG5cdCAgICAgICAgdmFyIGVsID0gYy5lbG07XG5cdCAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcblx0ICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG5cdCAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG5cdCAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuXHQgICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuXHQgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuXHQgICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcblx0ICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9LFxuXG5cdCAgbWV0aG9kczoge1xuXHQgICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuXHQgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlXG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHRoaXMuX2hhc01vdmUgIT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG5cdCAgICAgIH1cblx0ICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuXHQgICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGVsKTtcblx0ICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuXHQgICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0ZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcblx0ICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICBpZiAoYy5lbG0uX21vdmVDYikge1xuXHQgICAgYy5lbG0uX21vdmVDYigpO1xuXHQgIH1cblx0ICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcblx0ICAgIGMuZWxtLl9lbnRlckNiKCk7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcblx0ICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG5cdCAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG5cdCAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG5cdCAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcblx0ICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcblx0ICBpZiAoZHggfHwgZHkpIHtcblx0ICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG5cdCAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuXHQgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuXHQgICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuXHQgIH1cblx0fVxuXG5cdHZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG5cdCAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcblx0ICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxuXHR9O1xuXG5cdC8qICAqL1xuXG5cdC8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblx0VnVlJDIuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXHRWdWUkMi5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5cdFZ1ZSQyLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5cdFZ1ZSQyLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuXG5cdC8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuXHRleHRlbmQoVnVlJDIub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuXHRleHRlbmQoVnVlJDIub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG5cdC8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblx0VnVlJDIucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoJDEgOiBub29wO1xuXG5cdC8vIHdyYXAgbW91bnRcblx0VnVlJDIucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcblx0ICBlbCxcblx0ICBoeWRyYXRpbmdcblx0KSB7XG5cdCAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG5cdCAgcmV0dXJuIHRoaXMuX21vdW50KGVsLCBoeWRyYXRpbmcpXG5cdH07XG5cblx0Ly8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuXHQgICAgaWYgKGRldnRvb2xzKSB7XG5cdCAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMik7XG5cdCAgICB9IGVsc2UgaWYgKFxuXHQgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG5cdCAgICAgIGluQnJvd3NlciAmJiAhaXNFZGdlICYmIC9DaHJvbWVcXC9cXGQrLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxuXHQgICAgKSB7fVxuXHQgIH1cblx0fSwgMCk7XG5cblx0dmFyIHZ1ZV9ydW50aW1lX2NvbW1vbiA9IFZ1ZSQyO1xuXG5cdHZhciBMRUZUX0FSUk9XID0gJ8KrJ1xuXHR2YXIgUklHSFRfQVJST1cgPSAnwrsnXG5cdHZhciBFTExJUFNFUyA9ICfigKYnXG5cblx0dmFyIExpbWl0ZWRMaW5rc0dlbmVyYXRvciA9IGZ1bmN0aW9uIExpbWl0ZWRMaW5rc0dlbmVyYXRvciAobGlzdE9mUGFnZXMsIGN1cnJlbnRQYWdlLCBsaW1pdCkge1xuXHQgIHRoaXMubGlzdE9mUGFnZXMgPSBsaXN0T2ZQYWdlc1xuXHQgIHRoaXMubGFzdFBhZ2UgPSBsaXN0T2ZQYWdlcy5sZW5ndGggLSAxXG5cdCAgdGhpcy5jdXJyZW50UGFnZSA9IGN1cnJlbnRQYWdlID09PSB0aGlzLmxhc3RQYWdlXG5cdCAgICA/IHRoaXMubGFzdFBhZ2UgLSAxXG5cdCAgICA6IGN1cnJlbnRQYWdlXG5cdCAgdGhpcy5saW1pdCA9IGxpbWl0XG5cdH07XG5cblx0TGltaXRlZExpbmtzR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlICgpIHtcblx0ICB2YXIgZmlyc3RIYWxmID0gdGhpcy5fYnVpbGRGaXJzdEhhbGYoKVxuXHQgIHZhciBzZWNvbmRIYWxmID0gdGhpcy5fYnVpbGRTZWNvbmRIYWxmKClcblx0ICByZXR1cm4gZmlyc3RIYWxmLmNvbmNhdCggc2Vjb25kSGFsZilcblx0fTtcblxuXHRMaW1pdGVkTGlua3NHZW5lcmF0b3IucHJvdG90eXBlLl9idWlsZEZpcnN0SGFsZiA9IGZ1bmN0aW9uIF9idWlsZEZpcnN0SGFsZiAoKSB7XG5cdCAgdmFyIGZpcnN0SGFsZiA9IHRoaXMuX2FsbFBhZ2VzQnV0TGFzdCgpXG5cdCAgICAuc2xpY2UoXG5cdCAgICAgIHRoaXMuX2N1cnJlbnRDaHVua0luZGV4KCksXG5cdCAgICAgIHRoaXMuX2N1cnJlbnRDaHVua0luZGV4KCkgKyB0aGlzLmxpbWl0XG5cdCAgICApXG5cdCAgLy8gQWRkIGJhY2t3YXJkIGVsbGlwc2VzIHdpdGggZmlyc3QgcGFnZSBpZiBuZWVkZWRcblx0ICBpZiAodGhpcy5jdXJyZW50UGFnZSA+PSB0aGlzLmxpbWl0KSB7XG5cdCAgICBmaXJzdEhhbGYudW5zaGlmdChFTExJUFNFUylcblx0ICAgIGZpcnN0SGFsZi51bnNoaWZ0KDApXG5cdCAgfVxuXHQgIC8vIEFkZCBlbGxpcHNlcyBpZiBuZWVkZWRcblx0ICBpZiAodGhpcy5sYXN0UGFnZSAtIHRoaXMubGltaXQgPiB0aGlzLl9jdXJyZW50Q2h1bmtJbmRleCgpKSB7XG5cdCAgICBmaXJzdEhhbGYucHVzaChFTExJUFNFUylcblx0ICB9XG5cdCAgcmV0dXJuIGZpcnN0SGFsZlxuXHR9O1xuXG5cdExpbWl0ZWRMaW5rc0dlbmVyYXRvci5wcm90b3R5cGUuX2J1aWxkU2Vjb25kSGFsZiA9IGZ1bmN0aW9uIF9idWlsZFNlY29uZEhhbGYgKCkge1xuXHQgIHZhciBzZWNvbmRIYWxmID0gW3RoaXMubGFzdFBhZ2VdXG5cdCAgcmV0dXJuIHNlY29uZEhhbGZcblx0fTtcblxuXHRMaW1pdGVkTGlua3NHZW5lcmF0b3IucHJvdG90eXBlLl9jdXJyZW50Q2h1bmtJbmRleCA9IGZ1bmN0aW9uIF9jdXJyZW50Q2h1bmtJbmRleCAoKSB7XG5cdCAgdmFyIGN1cnJlbnRDaHVuayA9IE1hdGguZmxvb3IodGhpcy5jdXJyZW50UGFnZSAvIHRoaXMubGltaXQpXG5cdCAgcmV0dXJuIGN1cnJlbnRDaHVuayAqIHRoaXMubGltaXQgXG5cdH07XG5cblx0TGltaXRlZExpbmtzR2VuZXJhdG9yLnByb3RvdHlwZS5fYWxsUGFnZXNCdXRMYXN0ID0gZnVuY3Rpb24gX2FsbFBhZ2VzQnV0TGFzdCAoKSB7XG5cdCAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXHQgIHJldHVybiB0aGlzLmxpc3RPZlBhZ2VzLmZpbHRlcihmdW5jdGlvbiAobikgeyByZXR1cm4gbiAhPT0gdGhpcyQxLmxhc3RQYWdlOyB9KVxuXHR9O1xuXG5cdHZhciBQYWdpbmF0ZUxpbmtzID0ge1xuXHQgIG5hbWU6ICdwYWdpbmF0ZS1saW5rcycsXG5cdCAgcHJvcHM6IHtcblx0ICAgIGZvcjoge1xuXHQgICAgICB0eXBlOiBTdHJpbmcsXG5cdCAgICAgIHJlcXVpcmVkOiB0cnVlXG5cdCAgICB9LFxuXHQgICAgbGltaXQ6IHtcblx0ICAgICAgdHlwZTogTnVtYmVyLFxuXHQgICAgICBkZWZhdWx0OiAwXG5cdCAgICB9LFxuXHQgICAgc2ltcGxlOiB7XG5cdCAgICAgIHR5cGU6IE9iamVjdCxcblx0ICAgICAgZGVmYXVsdDogbnVsbCxcblx0ICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiB2YWxpZGF0b3IgKG9iaikge1xuXHQgICAgICAgIHJldHVybiBvYmoucHJldiAmJiBvYmoubmV4dFxuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgc3RlcExpbmtzOiB7XG5cdCAgICAgIHR5cGU6IE9iamVjdCxcblx0ICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICBwcmV2OiBMRUZUX0FSUk9XLFxuXHQgICAgICAgICAgbmV4dDogUklHSFRfQVJST1dcblx0ICAgICAgICB9XG5cdCAgICAgIH0sXG5cdCAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yJDEgKG9iaikge1xuXHQgICAgICAgIHJldHVybiBvYmoucHJldiAmJiBvYmoubmV4dFxuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgc2hvd1N0ZXBMaW5rczoge1xuXHQgICAgICB0eXBlOiBCb29sZWFuXG5cdCAgICB9LFxuXHQgICAgaGlkZVNpbmdsZVBhZ2U6IHtcblx0ICAgICAgdHlwZTogQm9vbGVhblxuXHQgICAgfSxcblx0ICAgIGNsYXNzZXM6IHtcblx0ICAgICAgdHlwZTogT2JqZWN0LFxuXHQgICAgICBkZWZhdWx0OiBudWxsXG5cdCAgICB9XG5cdCAgfSxcblx0ICBkYXRhOiBmdW5jdGlvbiBkYXRhICgpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIGxpc3RPZlBhZ2VzOiBbXSxcblx0ICAgICAgbnVtYmVyT2ZQYWdlczogMFxuXHQgICAgfVxuXHQgIH0sXG5cdCAgY29tcHV0ZWQ6IHtcblx0ICAgIGN1cnJlbnRQYWdlOiB7XG5cdCAgICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcblx0ICAgICAgICBpZiAodGhpcy4kcGFyZW50LnBhZ2luYXRlW3RoaXMuZm9yXSkge1xuXHQgICAgICAgICAgcmV0dXJuIHRoaXMuJHBhcmVudC5wYWdpbmF0ZVt0aGlzLmZvcl0ucGFnZVxuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHBhZ2UpIHtcblx0ICAgICAgICB0aGlzLiRwYXJlbnQucGFnaW5hdGVbdGhpcy5mb3JdLnBhZ2UgPSBwYWdlXG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIGlmICh0aGlzLnNpbXBsZSAmJiB0aGlzLmxpbWl0KSB7XG5cdCAgICAgIHdhcm4oKFwiPHBhZ2luYXRlLWxpbmtzIGZvcj1cXFwiXCIgKyAodGhpcy5mb3IpICsgXCJcXFwiPiAnc2ltcGxlJyBhbmQgJ2xpbWl0JyBwcm9wcyBjYW4ndCBiZSB1c2VkIGF0IHRoZSBzYW1lIHRpbWUuIEluIHRoaXMgY2FzZSwgJ3NpbXBsZScgd2lsbCB0YWtlIHByZWNlZGVuY2UsIGFuZCAnbGltaXQnIHdpbGwgYmUgaWdub3JlZC5cIiksIHRoaXMuJHBhcmVudCwgJ3dhcm4nKVxuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuc2ltcGxlICYmICF0aGlzLnNpbXBsZS5uZXh0KSB7XG5cdCAgICAgIHdhcm4oKFwiPHBhZ2luYXRlLWxpbmtzIGZvcj1cXFwiXCIgKyAodGhpcy5mb3IpICsgXCJcXFwiPiAnc2ltcGxlJyBwcm9wIGRvZXNuJ3QgY29udGFpbiAnbmV4dCcgdmFsdWUuXCIpLCB0aGlzLiRwYXJlbnQpXG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5zaW1wbGUgJiYgIXRoaXMuc2ltcGxlLnByZXYpIHtcblx0ICAgICAgd2FybigoXCI8cGFnaW5hdGUtbGlua3MgZm9yPVxcXCJcIiArICh0aGlzLmZvcikgKyBcIlxcXCI+ICdzaW1wbGUnIHByb3AgZG9lc24ndCBjb250YWluICdwcmV2JyB2YWx1ZS5cIiksIHRoaXMuJHBhcmVudClcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLnN0ZXBMaW5rcyAmJiAhdGhpcy5zdGVwTGlua3MubmV4dCkge1xuXHQgICAgICB3YXJuKChcIjxwYWdpbmF0ZS1saW5rcyBmb3I9XFxcIlwiICsgKHRoaXMuZm9yKSArIFwiXFxcIj4gJ3N0ZXAtbGlua3MnIHByb3AgZG9lc24ndCBjb250YWluICduZXh0JyB2YWx1ZS5cIiksIHRoaXMuJHBhcmVudClcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLnN0ZXBMaW5rcyAmJiAhdGhpcy5zdGVwTGlua3MucHJldikge1xuXHQgICAgICB3YXJuKChcIjxwYWdpbmF0ZS1saW5rcyBmb3I9XFxcIlwiICsgKHRoaXMuZm9yKSArIFwiXFxcIj4gJ3N0ZXAtbGlua3MnIHByb3AgZG9lc24ndCBjb250YWluICdwcmV2JyB2YWx1ZS5cIiksIHRoaXMuJHBhcmVudClcblx0ICAgIH1cblx0ICAgIHZ1ZV9ydW50aW1lX2NvbW1vbi5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMkMS51cGRhdGVMaXN0T2ZQYWdlcygpXG5cdCAgICB9KVxuXHQgIH0sXG5cdCAgd2F0Y2g6IHtcblx0ICAgICckcGFyZW50LnBhZ2luYXRlJzoge1xuXHQgICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyICgpIHtcblx0ICAgICAgICB0aGlzLnVwZGF0ZUxpc3RPZlBhZ2VzKClcblx0ICAgICAgfSxcblx0ICAgICAgZGVlcDogdHJ1ZVxuXHQgICAgfSxcblx0ICAgIGN1cnJlbnRQYWdlOiBmdW5jdGlvbiBjdXJyZW50UGFnZSAodG9QYWdlLCBmcm9tUGFnZSkge1xuXHQgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0b1BhZ2UgKyAxLCBmcm9tUGFnZSArIDEpXG5cdCAgICB9XG5cdCAgfSxcblx0ICBtZXRob2RzOiB7XG5cdCAgICB1cGRhdGVMaXN0T2ZQYWdlczogZnVuY3Rpb24gdXBkYXRlTGlzdE9mUGFnZXMgKCkge1xuXHQgICAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0UGFnaW5hdGVDb21wb25lbnQodGhpcy4kcGFyZW50LiRjaGlsZHJlbiwgdGhpcy5mb3IpXG5cdCAgICAgIGlmICghdGFyZ2V0KSB7XG5cdCAgICAgICAgd2FybigoXCI8cGFnaW5hdGUtbGlua3MgZm9yPVxcXCJcIiArICh0aGlzLmZvcikgKyBcIlxcXCI+IGNhbid0IGJlIHVzZWQgd2l0aG91dCBpdHMgY29tcGFuaW9uIDxwYWdpbmF0ZSBuYW1lPVxcXCJcIiArICh0aGlzLmZvcikgKyBcIlxcXCI+XCIpLCB0aGlzLiRwYXJlbnQpXG5cdCAgICAgICAgcmV0dXJuXG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5udW1iZXJPZlBhZ2VzID0gTWF0aC5jZWlsKHRhcmdldC5saXN0Lmxlbmd0aCAvIHRhcmdldC5wZXIpXG5cdCAgICAgIHRoaXMubGlzdE9mUGFnZXMgPSBnZXRMaXN0T2ZQYWdlTnVtYmVycyh0aGlzLm51bWJlck9mUGFnZXMpXG5cdCAgICB9XG5cdCAgfSxcblx0ICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIHZhciBsaW5rcyA9IHRoaXMuc2ltcGxlXG5cdCAgICAgID8gZ2V0U2ltcGxlTGlua3ModGhpcywgaClcblx0ICAgICAgOiB0aGlzLmxpbWl0ID4gMVxuXHQgICAgICA/IGdldExpbWl0ZWRMaW5rcyh0aGlzLCBoKVxuXHQgICAgICA6IGdldEZ1bGxMaW5rcyh0aGlzLCBoKVxuXG5cdCAgICBpZiAodGhpcy5oaWRlU2luZ2xlUGFnZSAmJiB0aGlzLm51bWJlck9mUGFnZXMgPD0gMSkge1xuXHQgICAgICByZXR1cm4gbnVsbFxuXHQgICAgfVxuXG5cdCAgICB2YXIgZWwgPSBoKCd1bCcsIHtcblx0ICAgICAgY2xhc3M6IFsncGFnaW5hdGUtbGlua3MnLCB0aGlzLmZvcl1cblx0ICAgIH0sIGxpbmtzKVxuXG5cdCAgICBpZiAodGhpcy5jbGFzc2VzKSB7XG5cdCAgICAgIHZ1ZV9ydW50aW1lX2NvbW1vbi5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgYWRkQWRkaXRpb25hbENsYXNzZXMoZWwuZWxtLCB0aGlzJDEuY2xhc3Nlcylcblx0ICAgICAgfSlcblx0ICAgIH1cblx0ICAgIHJldHVybiBlbFxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEZ1bGxMaW5rcyAodm0sIGgpIHtcblx0ICB2YXIgYWxsTGlua3MgPSB2bS5zaG93U3RlcExpbmtzXG5cdCAgICA/IFt2bS5zdGVwTGlua3MucHJldiBdLmNvbmNhdCggdm0ubGlzdE9mUGFnZXMsIFt2bS5zdGVwTGlua3MubmV4dF0pXG5cdCAgICA6IHZtLmxpc3RPZlBhZ2VzXG5cdCAgcmV0dXJuIGFsbExpbmtzLm1hcChmdW5jdGlvbiAobGluaykge1xuXHQgICAgdmFyIGRhdGEgPSB7XG5cdCAgICAgIG9uOiB7XG5cdCAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcblx0ICAgICAgICAgIHZtLmN1cnJlbnRQYWdlID0gZ2V0VGFyZ2V0UGFnZUZvckxpbmsoXG5cdCAgICAgICAgICAgIGxpbmssXG5cdCAgICAgICAgICAgIHZtLmxpbWl0LFxuXHQgICAgICAgICAgICB2bS5jdXJyZW50UGFnZSxcblx0ICAgICAgICAgICAgdm0ubGlzdE9mUGFnZXMsXG5cdCAgICAgICAgICAgIHZtLnN0ZXBMaW5rc1xuXHQgICAgICAgICAgKVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgdmFyIGxpQ2xhc3NlcyA9IGdldENsYXNzZXNGb3JMaW5rKFxuXHQgICAgICBsaW5rLFxuXHQgICAgICB2bS5jdXJyZW50UGFnZSxcblx0ICAgICAgdm0ubGlzdE9mUGFnZXMubGVuZ3RoIC0gMSxcblx0ICAgICAgdm0uc3RlcExpbmtzXG5cdCAgICApXG5cdCAgICB2YXIgbGlua1RleHQgPSBsaW5rID09PSB2bS5zdGVwTGlua3MubmV4dCB8fCBsaW5rID09PSB2bS5zdGVwTGlua3MucHJldlxuXHQgICAgICA/IGxpbmtcblx0ICAgICAgOiBsaW5rICsgMSAvLyBpdCBtZWFucyBpdCdzIGEgbnVtYmVyXG5cdCAgICByZXR1cm4gaCgnbGknLCB7IGNsYXNzOiBsaUNsYXNzZXMgfSwgW2goJ2EnLCBkYXRhLCBsaW5rVGV4dCldKVxuXHQgIH0pXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRMaW1pdGVkTGlua3MgKHZtLCBoKSB7XG5cdCAgdmFyIGxpbWl0ZWRMaW5rcyA9IG5ldyBMaW1pdGVkTGlua3NHZW5lcmF0b3IoXG5cdCAgICB2bS5saXN0T2ZQYWdlcyxcblx0ICAgIHZtLmN1cnJlbnRQYWdlLFxuXHQgICAgdm0ubGltaXQsXG5cdCAgICB2bS5zdGVwTGlua3Ncblx0ICApLmdlbmVyYXRlKClcblxuXHQgIGxpbWl0ZWRMaW5rcyA9IHZtLnNob3dTdGVwTGlua3Ncblx0ICAgID8gW3ZtLnN0ZXBMaW5rcy5wcmV2IF0uY29uY2F0KCBsaW1pdGVkTGlua3MsIFt2bS5zdGVwTGlua3MubmV4dF0pXG5cdCAgICA6IGxpbWl0ZWRMaW5rc1xuXG5cdCAgdmFyIGxpbWl0ZWRMaW5rc01ldGFkYXRhID0gZ2V0TGltaXRlZExpbmtzTWV0YWRhdGEobGltaXRlZExpbmtzKVxuXG5cdCAgcmV0dXJuIGxpbWl0ZWRMaW5rcy5tYXAoZnVuY3Rpb24gKGxpbmssIGluZGV4KSB7XG5cdCAgICB2YXIgZGF0YSA9IHtcblx0ICAgICAgb246IHtcblx0ICAgICAgICBjbGljazogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuXHQgICAgICAgICAgdm0uY3VycmVudFBhZ2UgPSBnZXRUYXJnZXRQYWdlRm9yTGluayhcblx0ICAgICAgICAgICAgbGluayxcblx0ICAgICAgICAgICAgdm0ubGltaXQsXG5cdCAgICAgICAgICAgIHZtLmN1cnJlbnRQYWdlLFxuXHQgICAgICAgICAgICB2bS5saXN0T2ZQYWdlcyxcblx0ICAgICAgICAgICAgdm0uc3RlcExpbmtzLFxuXHQgICAgICAgICAgICBsaW1pdGVkTGlua3NNZXRhZGF0YVtpbmRleF1cblx0ICAgICAgICAgIClcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHZhciBsaUNsYXNzZXMgPSBnZXRDbGFzc2VzRm9yTGluayhcblx0ICAgICAgbGluayxcblx0ICAgICAgdm0uY3VycmVudFBhZ2UsXG5cdCAgICAgIHZtLmxpc3RPZlBhZ2VzLmxlbmd0aCAtIDEsXG5cdCAgICAgIHZtLnN0ZXBMaW5rc1xuXHQgICAgKVxuXHQgICAgLy8gSWYgdGhlIGxpbmsgaXMgYSBudW1iZXIsXG5cdCAgICAvLyB0aGVuIGluY3JlbWVudGVkIGJ5IDEgKHNpbmNlIGl0J3MgMCBiYXNlZCkuXG5cdCAgICAvLyBvdGhlcndpc2UsIGRvIG5vdGhpbmcgKHNvLCBpdCdzIGEgc3ltYm9sKS4gXG5cdCAgICB2YXIgdGV4dCA9IE51bWJlci5pc0ludGVnZXIobGluaykgPyBsaW5rICsgMSA6IGxpbmtcblx0ICAgIHJldHVybiBoKCdsaScsIHsgY2xhc3M6IGxpQ2xhc3NlcyB9LCBbaCgnYScsIGRhdGEsIHRleHQpXSlcblx0ICB9KVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0U2ltcGxlTGlua3MgKHZtLCBoKSB7XG5cdCAgdmFyIGxhc3RQYWdlID0gdm0ubGlzdE9mUGFnZXMubGVuZ3RoIC0gMVxuXHQgIHZhciBwcmV2RGF0YSA9IHtcblx0ICAgIG9uOiB7XG5cdCAgICAgIGNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuXHQgICAgICAgIGlmICh2bS5jdXJyZW50UGFnZSA+IDApIHsgdm0uY3VycmVudFBhZ2UgLT0gMSB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgdmFyIG5leHREYXRhID0ge1xuXHQgICAgb246IHtcblx0ICAgICAgY2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cdCAgICAgICAgaWYgKHZtLmN1cnJlbnRQYWdlIDwgbGFzdFBhZ2UpIHsgdm0uY3VycmVudFBhZ2UgKz0gMSB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgdmFyIG5leHRMaXN0RGF0YSA9IHsgY2xhc3M6IFsnbmV4dCcsIHZtLmN1cnJlbnRQYWdlID49IGxhc3RQYWdlID8gJ2Rpc2FibGVkJyA6ICcnXSB9XG5cdCAgdmFyIHByZXZMaXN0RGF0YSA9IHsgY2xhc3M6IFsncHJldicsIHZtLmN1cnJlbnRQYWdlIDw9IDAgPyAnZGlzYWJsZWQnIDogJyddIH1cblx0ICB2YXIgcHJldkxpbmsgPSBoKCdsaScsIHByZXZMaXN0RGF0YSwgW2goJ2EnLCBwcmV2RGF0YSwgdm0uc2ltcGxlLnByZXYpXSlcblx0ICB2YXIgbmV4dExpbmsgPSBoKCdsaScsIG5leHRMaXN0RGF0YSwgW2goJ2EnLCBuZXh0RGF0YSwgdm0uc2ltcGxlLm5leHQpXSlcblx0ICByZXR1cm4gW3ByZXZMaW5rLCBuZXh0TGlua11cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFRhcmdldFBhZ2luYXRlQ29tcG9uZW50IChjaGlsZHJlbiwgdGFyZ2V0TmFtZSkge1xuXHQgIHJldHVybiBjaGlsZHJlblxuXHQgICAgLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIChjaGlsZC4kdm5vZGUuY29tcG9uZW50T3B0aW9ucy50YWcgPT09ICdwYWdpbmF0ZScpOyB9KVxuXHQgICAgLmZpbmQoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5uYW1lID09PSB0YXJnZXROYW1lOyB9KVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0TGlzdE9mUGFnZU51bWJlcnMgKG51bWJlck9mUGFnZXMpIHtcblx0ICAvLyBjb252ZXJ0cyBudW1iZXIgb2YgcGFnZXMgaW50byBhbiBhcnJheVxuXHQgIC8vIHRoYXQgY29udGFpbnMgZWFjaCBpbmRpdmlkdWFsIHBhZ2UgbnVtYmVyXG5cdCAgLy8gRm9yIEV4YW1wbGU6IDQgPT4gWzAsIDEsIDIsIDNdXG5cdCAgcmV0dXJuIEFycmF5LmFwcGx5KG51bGwsIHsgbGVuZ3RoOiBudW1iZXJPZlBhZ2VzIH0pXG5cdCAgICAubWFwKGZ1bmN0aW9uICh2YWwsIGluZGV4KSB7IHJldHVybiBpbmRleDsgfSlcblx0fVxuXG5cdGZ1bmN0aW9uIGdldENsYXNzZXNGb3JMaW5rKGxpbmssIGN1cnJlbnRQYWdlLCBsYXN0UGFnZSwgcmVmKSB7XG5cdCAgdmFyIHByZXYgPSByZWYucHJldjtcblx0ICB2YXIgbmV4dCA9IHJlZi5uZXh0O1xuXG5cdCAgdmFyIGxpQ2xhc3MgPSBbXVxuXHQgIGlmIChsaW5rID09PSBwcmV2KSB7XG5cdCAgICBsaUNsYXNzLnB1c2goJ2xlZnQtYXJyb3cnKVxuXHQgIH0gZWxzZSBpZiAobGluayA9PT0gbmV4dCkge1xuXHQgICAgbGlDbGFzcy5wdXNoKCdyaWdodC1hcnJvdycpXG5cdCAgfSBlbHNlIGlmIChsaW5rID09PSBFTExJUFNFUykge1xuXHQgICAgbGlDbGFzcy5wdXNoKCdlbGxpcHNlcycpXG5cdCAgfSBlbHNlIHtcblx0ICAgIGxpQ2xhc3MucHVzaCgnbnVtYmVyJylcblx0ICB9XG5cblx0ICBpZiAobGluayA9PT0gY3VycmVudFBhZ2UpIHtcblx0ICAgIGxpQ2xhc3MucHVzaCgnYWN0aXZlJylcblx0ICB9XG5cblx0ICBpZiAobGluayA9PT0gcHJldiAmJiBjdXJyZW50UGFnZSA8PSAwKSB7XG5cdCAgICBsaUNsYXNzLnB1c2goJ2Rpc2FibGVkJylcblx0ICB9IGVsc2UgaWYgKGxpbmsgPT09IG5leHQgJiYgY3VycmVudFBhZ2UgPj0gbGFzdFBhZ2UpIHtcblx0ICAgIGxpQ2xhc3MucHVzaCgnZGlzYWJsZWQnKVxuXHQgIH1cblx0ICByZXR1cm4gbGlDbGFzc1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VGFyZ2V0UGFnZUZvckxpbmsgKGxpbmssIGxpbWl0LCBjdXJyZW50UGFnZSwgbGlzdE9mUGFnZXMsIHJlZiwgbWV0YURhdGEpIHtcblx0ICB2YXIgcHJldiA9IHJlZi5wcmV2O1xuXHQgIHZhciBuZXh0ID0gcmVmLm5leHQ7XG5cdCAgaWYgKCBtZXRhRGF0YSA9PT0gdm9pZCAwICkgbWV0YURhdGEgPSBudWxsO1xuXG5cdCAgdmFyIGN1cnJlbnRDaHVuayA9IE1hdGguZmxvb3IoY3VycmVudFBhZ2UgLyBsaW1pdClcblx0ICBpZiAobGluayA9PT0gcHJldikge1xuXHQgICAgcmV0dXJuIChjdXJyZW50UGFnZSAtIDEpIDwgMCA/IDAgOiBjdXJyZW50UGFnZSAtIDFcblx0ICB9IGVsc2UgaWYgKGxpbmsgPT09IG5leHQpIHtcblx0ICAgIHJldHVybiAoY3VycmVudFBhZ2UgKyAxID4gbGlzdE9mUGFnZXMubGVuZ3RoIC0gMSlcblx0ICAgICAgPyBsaXN0T2ZQYWdlcy5sZW5ndGggLSAxXG5cdCAgICAgIDogY3VycmVudFBhZ2UgKyAxXG5cdCAgfSBlbHNlIGlmIChtZXRhRGF0YSAmJiBtZXRhRGF0YSA9PT0gJ3JpZ2h0LWVsbGlwc2VzJykge1xuXHQgICAgcmV0dXJuIChjdXJyZW50Q2h1bmsgKyAxKSAqIGxpbWl0XG5cdCAgfSBlbHNlIGlmIChtZXRhRGF0YSAmJiBtZXRhRGF0YSA9PT0gJ2xlZnQtZWxsaXBzZXMnKSB7XG5cdCAgICB2YXIgY2h1bmtDb250ZW50ID0gbGlzdE9mUGFnZXMuc2xpY2UoY3VycmVudENodW5rICogbGltaXQsIGN1cnJlbnRDaHVuayAqIGxpbWl0ICsgbGltaXQpXG5cdCAgICB2YXIgaXNMYXN0UGFnZSA9IGN1cnJlbnRQYWdlID09PSBsaXN0T2ZQYWdlcy5sZW5ndGggLSAxXG5cdCAgICBpZiAoaXNMYXN0UGFnZSAmJiBjaHVua0NvbnRlbnQubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgIGN1cnJlbnRDaHVuay0tXG5cdCAgICB9XG5cdCAgICByZXR1cm4gKGN1cnJlbnRDaHVuayAtIDEpICogbGltaXQgKyBsaW1pdCAtIDFcblx0ICB9XG5cdCAgLy8gd2hpY2ggaXMgbnVtYmVyXG5cdCAgcmV0dXJuIGxpbmtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYWlubHkgdXNlZCBoZXJlIHRvIGNoZWNrIHdoZXRoZXIgdGhlIGRpc3BsYXllZFxuXHQgKiBlbGxpcHNlcyBpcyBmb3Igc2hvd2luZyBwcmV2aW91cyBvciBuZXh0IGxpbmtzXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRMaW1pdGVkTGlua3NNZXRhZGF0YSAobGltaXRlZExpbmtzKSB7XG5cdCAgcmV0dXJuIGxpbWl0ZWRMaW5rcy5tYXAoZnVuY3Rpb24gKGxpbmssIGluZGV4KSB7XG5cdCAgICBpZiAobGluayA9PT0gRUxMSVBTRVMgJiYgbGltaXRlZExpbmtzW2luZGV4IC0gMV0gPT09IDApIHtcblx0ICAgICAgcmV0dXJuICdsZWZ0LWVsbGlwc2VzJ1xuXHQgICAgfSBlbHNlIGlmIChsaW5rID09PSBFTExJUFNFUyAmJiBsaW1pdGVkTGlua3NbaW5kZXggLSAxXSAhPT0gMCkge1xuXHQgICAgICByZXR1cm4gJ3JpZ2h0LWVsbGlwc2VzJ1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpbmtcblx0ICB9KVxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkQWRkaXRpb25hbENsYXNzZXMgKGxpbmtzQ29udGFpbmVyLCBjbGFzc2VzKSB7XG5cdCAgT2JqZWN0LmtleXMoY2xhc3NlcykuZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcblx0ICAgIGlmIChzZWxlY3RvciA9PT0gJ3VsJykge1xuXHQgICAgICB2YXIgc2VsZWN0b3JWYWx1ZSA9IGNsYXNzZXNbJ3VsJ11cblx0ICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0b3JWYWx1ZSkpIHtcblx0ICAgICAgICBzZWxlY3RvclZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGxpbmtzQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoYyk7IH0pXG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgbGlua3NDb250YWluZXIuY2xhc3NMaXN0LmFkZChzZWxlY3RvclZhbHVlKVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBsaW5rc0NvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgIHZhciBzZWxlY3RvclZhbHVlID0gY2xhc3Nlc1tzZWxlY3Rvcl1cblx0ICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0b3JWYWx1ZSkpIHtcblx0ICAgICAgICBzZWxlY3RvclZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5vZGUuY2xhc3NMaXN0LmFkZChjKTsgfSlcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoc2VsZWN0b3JWYWx1ZSlcblx0ICAgICAgfVxuXHQgICAgfSlcblx0ICB9KVxuXHR9XG5cblx0ZnVuY3Rpb24gcGFnaW5hdGVEYXRhR2VuZXJhdG9yIChsaXN0TmFtZXMpIHtcblx0ICBpZiAoIGxpc3ROYW1lcyA9PT0gdm9pZCAwICkgbGlzdE5hbWVzID0gW107XG5cblx0ICByZXR1cm4gbGlzdE5hbWVzLnJlZHVjZShmdW5jdGlvbiAoY3VyciwgbGlzdE5hbWUpIHtcblx0ICAgIGN1cnJbbGlzdE5hbWVdID0ge1xuXHQgICAgICBsaXN0OiBbXSxcblx0ICAgICAgcGFnZTogMFxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGN1cnJcblx0ICB9LCB7fSlcblx0fVxuXG5cdHZhciB2dWVQYWdpbmF0ZSA9IHt9XG5cblx0dnVlUGFnaW5hdGUuaW5zdGFsbCA9IGZ1bmN0aW9uIChWdWUpIHtcblx0ICBWdWUubWl4aW4oe1xuXHQgICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG5cdCAgICAgIGlmICh0aGlzLnBhZ2luYXRlICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLnBhZ2luYXRlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0ICAgICAgICB0aGlzLnBhZ2luYXRlID0gcGFnaW5hdGVEYXRhR2VuZXJhdG9yKHRoaXMucGFnaW5hdGUpXG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBtZXRob2RzOiB7XG5cdCAgICAgIHBhZ2luYXRlZDogZnVuY3Rpb24gcGFnaW5hdGVkIChsaXN0TmFtZSkge1xuXHQgICAgICAgIGlmICghdGhpcy5wYWdpbmF0ZSB8fCAhdGhpcy5wYWdpbmF0ZVtsaXN0TmFtZV0pIHtcblx0ICAgICAgICAgIHdhcm4oKFwiJ1wiICsgbGlzdE5hbWUgKyBcIicgaXMgbm90IHJlZ2lzdGVyZWQgaW4gJ3BhZ2luYXRlJyBhcnJheS5cIiksIHRoaXMpXG5cdCAgICAgICAgICByZXR1cm5cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucGFnaW5hdGVbbGlzdE5hbWVdLmxpc3Rcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0pXG5cdCAgVnVlLmNvbXBvbmVudCgncGFnaW5hdGUnLCBQYWdpbmF0ZSlcblx0ICBWdWUuY29tcG9uZW50KCdwYWdpbmF0ZS1saW5rcycsIFBhZ2luYXRlTGlua3MpXG5cdH1cblxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZ1ZSkge1xuXHQgIHdpbmRvdy5WdWUudXNlKHZ1ZVBhZ2luYXRlKVxuXHR9XG5cblx0cmV0dXJuIHZ1ZVBhZ2luYXRlO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1wYWdpbmF0ZS9kaXN0L3Z1ZS1wYWdpbmF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__main__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utilities_getParam__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__bus__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__factories_file__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__factories_file___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__factories_file__);\n//Dependencies\n\n\n\n\n\n\n//Demo Elements\nvar scratchPad = document.getElementById('scratch-pad')\nvar openButton = document.getElementById('open-btn')\nvar closeButton = document.getElementById('close-btn')\nvar toggleButton = document.getElementById('toggle-btn')\n\n//Demo actions\nvar show = function () { return __WEBPACK_IMPORTED_MODULE_3__bus__[\"a\" /* default */].$emit('manager:show'); }\nvar hide = function () { return __WEBPACK_IMPORTED_MODULE_3__bus__[\"a\" /* default */].$emit('manager:hide'); }\nvar toggle = function () { return __WEBPACK_IMPORTED_MODULE_3__bus__[\"a\" /* default */].$emit('manager:toggle'); }\n\nif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utilities_getParam__[\"a\" /* default */])('on')) {\n    __WEBPACK_IMPORTED_MODULE_3__bus__[\"a\" /* default */].$on(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utilities_getParam__[\"a\" /* default */])('on'), function (component) {\n        scratchPad.className = 'visible'\n        scratchPad.textContent = JSON.stringify(component.input)\n    })\n}\n\n//Demo Listeners\nopenButton.addEventListener('click', show);\ncloseButton.addEventListener('click', hide);\ntoggleButton.addEventListener('click', toggle);\n\n//Init the component in a fresh view instance\nvar initDemo = function(files) {\n    new __WEBPACK_IMPORTED_MODULE_0_vue___default.a({\n        components: {fileManager: __WEBPACK_IMPORTED_MODULE_1__main__[\"a\" /* default */]},\n        data: {\n            files: files\n        }\n    }).$mount('#demo');\n}\n\nvar state = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utilities_getParam__[\"a\" /* default */])('state');\n\nswitch (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utilities_getParam__[\"a\" /* default */])('state')) {\n    case 'no-files':\n        initDemo({})\n        break;\n    default:\n        initDemo(__WEBPACK_IMPORTED_MODULE_4__factories_file___default.a.buildList(100))\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZGVtby9qcy9kZW1vLmpzP2M0ZWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy9EZXBlbmRlbmNpZXNcbmltcG9ydCBWdWUgZnJvbSAndnVlJ1xuaW1wb3J0IGZpbGVNYW5hZ2VyIGZyb20gJy4uLy4uL21haW4nXG5pbXBvcnQgZ2V0UGFyYW0gZnJvbSAnLi4vLi4vdXRpbGl0aWVzL2dldFBhcmFtJ1xuaW1wb3J0IGJ1cyBmcm9tICcuLi8uLi9idXMnXG5pbXBvcnQgZmlsZUZhY3RvcnkgZnJvbSAnLi4vLi4vZmFjdG9yaWVzL2ZpbGUnXG5cbi8vRGVtbyBFbGVtZW50c1xuY29uc3Qgc2NyYXRjaFBhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzY3JhdGNoLXBhZCcpXG5jb25zdCBvcGVuQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ29wZW4tYnRuJylcbmNvbnN0IGNsb3NlQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nsb3NlLWJ0bicpXG5jb25zdCB0b2dnbGVCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndG9nZ2xlLWJ0bicpXG5cbi8vRGVtbyBhY3Rpb25zXG5jb25zdCBzaG93ID0gKCkgPT4gYnVzLiRlbWl0KCdtYW5hZ2VyOnNob3cnKVxuY29uc3QgaGlkZSA9ICgpID0+IGJ1cy4kZW1pdCgnbWFuYWdlcjpoaWRlJylcbmNvbnN0IHRvZ2dsZSA9ICgpID0+IGJ1cy4kZW1pdCgnbWFuYWdlcjp0b2dnbGUnKVxuXG5pZiAoZ2V0UGFyYW0oJ29uJykpIHtcbiAgICBidXMuJG9uKGdldFBhcmFtKCdvbicpLCAoY29tcG9uZW50KSA9PiB7XG4gICAgICAgIHNjcmF0Y2hQYWQuY2xhc3NOYW1lID0gJ3Zpc2libGUnXG4gICAgICAgIHNjcmF0Y2hQYWQudGV4dENvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShjb21wb25lbnQuaW5wdXQpXG4gICAgfSlcbn1cblxuLy9EZW1vIExpc3RlbmVyc1xub3BlbkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNob3cpO1xuY2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoaWRlKTtcbnRvZ2dsZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRvZ2dsZSk7XG5cbi8vSW5pdCB0aGUgY29tcG9uZW50IGluIGEgZnJlc2ggdmlldyBpbnN0YW5jZVxuY29uc3QgaW5pdERlbW8gPSBmdW5jdGlvbihmaWxlcykge1xuICAgIG5ldyBWdWUoe1xuICAgICAgICBjb21wb25lbnRzOiB7ZmlsZU1hbmFnZXJ9LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBmaWxlc1xuICAgICAgICB9XG4gICAgfSkuJG1vdW50KCcjZGVtbycpO1xufVxuXG5sZXQgc3RhdGUgPSBnZXRQYXJhbSgnc3RhdGUnKTtcblxuc3dpdGNoIChnZXRQYXJhbSgnc3RhdGUnKSkge1xuICAgIGNhc2UgJ25vLWZpbGVzJzpcbiAgICAgICAgaW5pdERlbW8oe30pXG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIGluaXREZW1vKGZpbGVGYWN0b3J5LmJ1aWxkTGlzdCgxMDApKVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBkZW1vL2pzL2RlbW8uanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }
/******/ ]);